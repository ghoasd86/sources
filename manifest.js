sprintfWrapper = {
    init: function() {
        if (typeof arguments == "undefined") {
            return null
        }
        if (arguments.length < 1) {
            return null
        }
        if (typeof arguments[0] != "string") {
            return null
        }
        if (typeof RegExp == "undefined") {
            return null
        }
        var K = arguments[0];
        var E = new RegExp(/(%([%]|(\-)?(\+|\x20)?(0)?(\d+)?(\.(\d)?)?([bcdfosxX])))/g);
        var I = new Array();
        var M = new Array();
        var C = 0;
        var J = 0;
        var O = 0;
        var F = 0;
        var L = "";
        var H = null;
        while ((H = E.exec(K))) {
            if (H[9]) {
                C += 1
            }
            J = F;
            O = E.lastIndex - H[0].length;
            M[M.length] = K.substring(J, O);
            F = E.lastIndex;
            I[I.length] = {
                match: H[0],
                left: H[3] ? true : false,
                sign: H[4] || "",
                pad: H[5] || " ",
                min: H[6] || 0,
                precision: H[8],
                code: H[9] || "%",
                negative: (typeof arguments[C] == "number") ? (parseInt(arguments[C]) < 0 ? true : false) : false,
                argument: arguments[C]
            }
        }
        M[M.length] = K.substring(F);
        if (I.length == 0) {
            return K
        }
        if ((arguments.length - 1) < C) {
            return null
        }
        var D = null;
        var H = null;
        var G = null;
        for (G = 0; G < I.length; G++) {
            var N;
            if (I[G].code == "%") {
                N = "%"
            } else {
                if (I[G].code == "b") {
                    I[G].argument = String(Math.abs(parseInt(I[G].argument)).toString(2));
                    N = sprintfWrapper.convert(I[G], true)
                } else {
                    if (I[G].code == "c") {
                        I[G].argument = String(String.fromCharCode(parseInt(Math.abs(parseInt(I[G].argument)))));
                        N = sprintfWrapper.convert(I[G], true)
                    } else {
                        if (I[G].code == "d") {
                            I[G].argument = String(Math.abs(parseInt(I[G].argument)));
                            N = sprintfWrapper.convert(I[G])
                        } else {
                            if (I[G].code == "f") {
                                I[G].argument = String(Math.abs(parseFloat(I[G].argument)).toFixed(I[G].precision ? I[G].precision : 6));
                                N = sprintfWrapper.convert(I[G])
                            } else {
                                if (I[G].code == "o") {
                                    I[G].argument = sprintfWrapper.objectDescription(I[G].argument);
                                    N = sprintfWrapper.convert(I[G], true)
                                } else {
                                    if (I[G].code == "s") {
                                        I[G].argument = "" + I[G].argument;
                                        I[G].argument = I[G].argument.substring(0, I[G].precision ? I[G].precision : I[G].argument.length);
                                        N = sprintfWrapper.convert(I[G], true)
                                    } else {
                                        if (I[G].code == "x") {
                                            I[G].argument = String(Math.abs(parseInt(I[G].argument)).toString(16));
                                            N = sprintfWrapper.convert(I[G])
                                        } else {
                                            if (I[G].code == "X") {
                                                I[G].argument = String(Math.abs(parseInt(I[G].argument)).toString(16));
                                                N = sprintfWrapper.convert(I[G]).toUpperCase()
                                            } else {
                                                N = I[G].match
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            L += M[G];
            L += N
        }
        L += M[G];
        return L
    },
    convert: function(D, F) {
        if (F) {
            D.sign = ""
        } else {
            D.sign = D.negative ? "-" : D.sign
        }
        var C = D.min - D.argument.length + 1 - D.sign.length;
        var E = new Array(C < 0 ? 0 : C).join(D.pad);
        if (!D.left) {
            if (D.pad == "0" || F) {
                return D.sign + E + D.argument
            } else {
                return E + D.sign + D.argument
            }
        } else {
            if (D.pad == "0" || F) {
                return D.sign + D.argument + E.replace(/0/g, " ")
            } else {
                return D.sign + D.argument + E
            }
        }
    },
    objectDescription: function(C) {
        if (!(C instanceof Object)) {
            return "NaO"
        }
        var G = "Object{";
        var D = 0;
        if (C.class_name) {
            G += "class_name='" + C.class_name + "', ";
            D++
        }
        for (var H in C) {
            if (D > 2) {
                break
            }
            try {
                var F = (typeof C[H])
            } catch (E) {
                continue
            }
            if (H == "class_name" || F == "function") {
                continue
            }
            if (F == "string") {
                if (C[H].length > 30) {
                    G += H + "='" + C[H].substr(0, 30) + "...', "
                } else {
                    G += H + "='" + C[H] + "', "
                }
            } else {
                if (F == "array") {
                    G += H + "=[Array], "
                } else {
                    if (F == "number") {
                        G += H + "=" + C[H] + ", "
                    } else {
                        continue
                    }
                }
            }
            D++
        }
        G += "...}";
        return G
    }
};
sprintf = sprintfWrapper.init;
var MD5 = function(T) {
    function q(G, F) {
        return (G << F) | (G >>> (32 - F))
    }

    function p(a, G) {
        var c, F, I, b, H;
        I = (a & 2147483648);
        b = (G & 2147483648);
        c = (a & 1073741824);
        F = (G & 1073741824);
        H = (a & 1073741823) + (G & 1073741823);
        if (c & F) {
            return (H ^ 2147483648 ^ I ^ b)
        }
        if (c | F) {
            if (H & 1073741824) {
                return (H ^ 3221225472 ^ I ^ b)
            } else {
                return (H ^ 1073741824 ^ I ^ b)
            }
        } else {
            return (H ^ I ^ b)
        }
    }

    function S(F, H, G) {
        return (F & H) | ((~F) & G)
    }

    function R(F, H, G) {
        return (F & G) | (H & (~G))
    }

    function Q(F, H, G) {
        return (F ^ H ^ G)
    }

    function O(F, H, G) {
        return (H ^ (F | (~G)))
    }

    function V(H, G, AI, AH, F, I, k) {
        H = p(H, p(p(S(G, AI, AH), F), k));
        return p(q(H, I), G)
    }

    function D(H, G, AI, AH, F, I, k) {
        H = p(H, p(p(R(G, AI, AH), F), k));
        return p(q(H, I), G)
    }

    function j(H, G, AI, AH, F, I, k) {
        H = p(H, p(p(Q(G, AI, AH), F), k));
        return p(q(H, I), G)
    }

    function U(H, G, AI, AH, F, I, k) {
        H = p(H, p(p(O(G, AI, AH), F), k));
        return p(q(H, I), G)
    }

    function C(a) {
        var d;
        var I = a.length;
        var H = I + 8;
        var G = (H - (H % 64)) / 64;
        var c = (G + 1) * 16;
        var k = Array(c - 1);
        var F = 0;
        var b = 0;
        while (b < I) {
            d = (b - (b % 4)) / 4;
            F = (b % 4) * 8;
            k[d] = (k[d] | (a.charCodeAt(b) << F));
            b++
        }
        d = (b - (b % 4)) / 4;
        F = (b % 4) * 8;
        k[d] = k[d] | (128 << F);
        k[c - 2] = I << 3;
        k[c - 1] = I >>> 29;
        return k
    }

    function f(H) {
        var G = "",
            I = "",
            a, F;
        for (F = 0; F <= 3; F++) {
            a = (H >>> (F * 8)) & 255;
            I = "0" + a.toString(16);
            G = G + I.substr(I.length - 2, 2)
        }
        return G
    }

    function o(G) {
        G = G.replace(/\r\n/g, "\n");
        var F = "";
        for (var I = 0; I < G.length; I++) {
            var H = G.charCodeAt(I);
            if (H < 128) {
                F += String.fromCharCode(H)
            } else {
                if ((H > 127) && (H < 2048)) {
                    F += String.fromCharCode((H >> 6) | 192);
                    F += String.fromCharCode((H & 63) | 128)
                } else {
                    F += String.fromCharCode((H >> 12) | 224);
                    F += String.fromCharCode(((H >> 6) & 63) | 128);
                    F += String.fromCharCode((H & 63) | 128)
                }
            }
        }
        return F
    }
    var g = Array();
    var v, J, m, W, E, AG, AF, AE, AD;
    var z = 7,
        w = 12,
        t = 17,
        r = 22;
    var e = 5,
        Z = 9,
        Y = 14,
        X = 20;
    var P = 4,
        N = 11,
        M = 16,
        L = 23;
    var AC = 6,
        AB = 10,
        y = 15,
        u = 21;
    T = o(T);
    g = C(T);
    AG = 1732584193;
    AF = 4023233417;
    AE = 2562383102;
    AD = 271733878;
    for (v = 0; v < g.length; v += 16) {
        J = AG;
        m = AF;
        W = AE;
        E = AD;
        AG = V(AG, AF, AE, AD, g[v + 0], z, 3614090360);
        AD = V(AD, AG, AF, AE, g[v + 1], w, 3905402710);
        AE = V(AE, AD, AG, AF, g[v + 2], t, 606105819);
        AF = V(AF, AE, AD, AG, g[v + 3], r, 3250441966);
        AG = V(AG, AF, AE, AD, g[v + 4], z, 4118548399);
        AD = V(AD, AG, AF, AE, g[v + 5], w, 1200080426);
        AE = V(AE, AD, AG, AF, g[v + 6], t, 2821735955);
        AF = V(AF, AE, AD, AG, g[v + 7], r, 4249261313);
        AG = V(AG, AF, AE, AD, g[v + 8], z, 1770035416);
        AD = V(AD, AG, AF, AE, g[v + 9], w, 2336552879);
        AE = V(AE, AD, AG, AF, g[v + 10], t, 4294925233);
        AF = V(AF, AE, AD, AG, g[v + 11], r, 2304563134);
        AG = V(AG, AF, AE, AD, g[v + 12], z, 1804603682);
        AD = V(AD, AG, AF, AE, g[v + 13], w, 4254626195);
        AE = V(AE, AD, AG, AF, g[v + 14], t, 2792965006);
        AF = V(AF, AE, AD, AG, g[v + 15], r, 1236535329);
        AG = D(AG, AF, AE, AD, g[v + 1], e, 4129170786);
        AD = D(AD, AG, AF, AE, g[v + 6], Z, 3225465664);
        AE = D(AE, AD, AG, AF, g[v + 11], Y, 643717713);
        AF = D(AF, AE, AD, AG, g[v + 0], X, 3921069994);
        AG = D(AG, AF, AE, AD, g[v + 5], e, 3593408605);
        AD = D(AD, AG, AF, AE, g[v + 10], Z, 38016083);
        AE = D(AE, AD, AG, AF, g[v + 15], Y, 3634488961);
        AF = D(AF, AE, AD, AG, g[v + 4], X, 3889429448);
        AG = D(AG, AF, AE, AD, g[v + 9], e, 568446438);
        AD = D(AD, AG, AF, AE, g[v + 14], Z, 3275163606);
        AE = D(AE, AD, AG, AF, g[v + 3], Y, 4107603335);
        AF = D(AF, AE, AD, AG, g[v + 8], X, 1163531501);
        AG = D(AG, AF, AE, AD, g[v + 13], e, 2850285829);
        AD = D(AD, AG, AF, AE, g[v + 2], Z, 4243563512);
        AE = D(AE, AD, AG, AF, g[v + 7], Y, 1735328473);
        AF = D(AF, AE, AD, AG, g[v + 12], X, 2368359562);
        AG = j(AG, AF, AE, AD, g[v + 5], P, 4294588738);
        AD = j(AD, AG, AF, AE, g[v + 8], N, 2272392833);
        AE = j(AE, AD, AG, AF, g[v + 11], M, 1839030562);
        AF = j(AF, AE, AD, AG, g[v + 14], L, 4259657740);
        AG = j(AG, AF, AE, AD, g[v + 1], P, 2763975236);
        AD = j(AD, AG, AF, AE, g[v + 4], N, 1272893353);
        AE = j(AE, AD, AG, AF, g[v + 7], M, 4139469664);
        AF = j(AF, AE, AD, AG, g[v + 10], L, 3200236656);
        AG = j(AG, AF, AE, AD, g[v + 13], P, 681279174);
        AD = j(AD, AG, AF, AE, g[v + 0], N, 3936430074);
        AE = j(AE, AD, AG, AF, g[v + 3], M, 3572445317);
        AF = j(AF, AE, AD, AG, g[v + 6], L, 76029189);
        AG = j(AG, AF, AE, AD, g[v + 9], P, 3654602809);
        AD = j(AD, AG, AF, AE, g[v + 12], N, 3873151461);
        AE = j(AE, AD, AG, AF, g[v + 15], M, 530742520);
        AF = j(AF, AE, AD, AG, g[v + 2], L, 3299628645);
        AG = U(AG, AF, AE, AD, g[v + 0], AC, 4096336452);
        AD = U(AD, AG, AF, AE, g[v + 7], AB, 1126891415);
        AE = U(AE, AD, AG, AF, g[v + 14], y, 2878612391);
        AF = U(AF, AE, AD, AG, g[v + 5], u, 4237533241);
        AG = U(AG, AF, AE, AD, g[v + 12], AC, 1700485571);
        AD = U(AD, AG, AF, AE, g[v + 3], AB, 2399980690);
        AE = U(AE, AD, AG, AF, g[v + 10], y, 4293915773);
        AF = U(AF, AE, AD, AG, g[v + 1], u, 2240044497);
        AG = U(AG, AF, AE, AD, g[v + 8], AC, 1873313359);
        AD = U(AD, AG, AF, AE, g[v + 15], AB, 4264355552);
        AE = U(AE, AD, AG, AF, g[v + 6], y, 2734768916);
        AF = U(AF, AE, AD, AG, g[v + 13], u, 1309151649);
        AG = U(AG, AF, AE, AD, g[v + 4], AC, 4149444226);
        AD = U(AD, AG, AF, AE, g[v + 11], AB, 3174756917);
        AE = U(AE, AD, AG, AF, g[v + 2], y, 718787259);
        AF = U(AF, AE, AD, AG, g[v + 9], u, 3951481745);
        AG = p(AG, J);
        AF = p(AF, m);
        AE = p(AE, W);
        AD = p(AD, E)
    }
    var K = f(AG) + f(AF) + f(AE) + f(AD);
    return K.toLowerCase()
};
jQuery.cookie = function(D, K, N) {
    if (typeof K != "undefined") {
        N = N || {};
        if (K === null) {
            K = "";
            N.expires = -1
        }
        var G = "";
        if (N.expires && (typeof N.expires == "number" || N.expires.toUTCString)) {
            var H;
            if (typeof N.expires == "number") {
                H = new Date();
                H.setTime(H.getTime() + (N.expires * 24 * 60 * 60 * 1000))
            } else {
                H = N.expires
            }
            G = "; expires=" + H.toUTCString()
        }
        var M = N.path ? "; path=" + (N.path) : "";
        var I = N.domain ? "; domain=" + (N.domain) : "";
        var C = N.secure ? "; secure" : "";
        document.cookie = [D, "=", encodeURIComponent(K), G, M, I, C].join("")
    } else {
        var F = null;
        if (document.cookie && document.cookie != "") {
            var L = document.cookie.split(";");
            for (var J = 0; J < L.length; J++) {
                var E = jQuery.trim(L[J]);
                if (E.substring(0, D.length + 1) == (D + "=")) {
                    F = decodeURIComponent(E.substring(D.length + 1));
                    break
                }
            }
        }
        return F
    }
};
if ($) {
    $.extend({
        xmlToJSON: function(G) {
            try {
                if (!G) {
                    return null
                }
                var F = {};
                F.typeOf = "JSXBObject";
                var E = (G.nodeType == 9) ? G.documentElement : G;
                if (G.nodeType == 3 || G.nodeType == 4) {
                    return G.nodeValue
                }

                function I(R, O) {
                    var P;
                    var N;
                    var Q;
                    var L = "";
                    if (!O) {
                        return null
                    }
                    if (!O.hasChildNodes()) {
                        return null
                    }
                    var M = O.childNodes.length - 1;
                    if (O.attributes.length > 0) {
                        D(R, O)
                    }
                    R._children = [];
                    R.Text = "";
                    var S = 0;
                    do {
                        N = O.childNodes[S];
                        switch (N.nodeType) {
                            case 1:
                                P = K(N.tagName);
                                R._children.push(P);
                                if (!R[P]) {
                                    R[P] = []
                                }
                                Q = {};
                                R[P].push(Q);
                                if (N.attributes.length > 0) {
                                    D(Q, N)
                                }
                                if (!R[P].contains) {
                                    J(R[P])
                                }
                                if (N.hasChildNodes()) {
                                    I(Q, N)
                                }
                                break;
                            case 3:
                                R.Text += $.trim(N.nodeValue);
                                break;
                            case 4:
                                R.Text += (N.text) ? $.trim(N.text) : $.trim(N.nodeValue);
                                break
                        }
                    } while (S++ < M)
                }

                function J(L) {
                    L.getNodeByAttribute = function(M, Q) {
                        if (this.length > 0) {
                            var O;
                            var N = this.length - 1;
                            try {
                                do {
                                    O = this[N];
                                    if (O[M] == Q) {
                                        return O
                                    }
                                } while (N--)
                            } catch (P) {
                                return false
                            }
                            return false
                        }
                    };
                    L.contains = function(M, P) {
                        if (this.length > 0) {
                            var N = this.length - 1;
                            try {
                                do {
                                    if (this[N][M] == P) {
                                        return true
                                    }
                                } while (N--)
                            } catch (O) {
                                return false
                            }
                            return false
                        }
                    };
                    L.indexOf = function(M, P) {
                        var Q = -1;
                        if (this.length > 0) {
                            var N = this.length - 1;
                            try {
                                do {
                                    if (this[N][M] == P) {
                                        Q = N
                                    }
                                } while (N--)
                            } catch (O) {
                                return -1
                            }
                            return Q
                        }
                    };
                    L.SortByAttribute = function(O, N) {
                        if (this.length) {
                            function M(S, Q) {
                                var R = S[Q];
                                R = (C(R)) ? parseFloat(R) : R;
                                return R
                            }

                            function P(T, R) {
                                var U = 0;
                                var S, Q;
                                S = M(T, O);
                                Q = M(R, O);
                                if (S < Q) {
                                    U = -1
                                } else {
                                    if (Q < S) {
                                        U = 1
                                    }
                                }
                                if (N) {
                                    U = (N.toUpperCase() == "DESC") ? (0 - U) : U
                                }
                                return U
                            }
                            this.sort(P)
                        }
                    };
                    L.SortByValue = function(N) {
                        if (this.length) {
                            function M(Q) {
                                var P = Q.Text;
                                P = (C(P)) ? parseFloat(P) : P;
                                return P
                            }

                            function O(S, Q) {
                                var T = 0;
                                var R, P;
                                R = M(S);
                                P = M(Q);
                                if (R < P) {
                                    T = -1
                                } else {
                                    if (P < R) {
                                        T = 1
                                    }
                                }
                                if (N) {
                                    T = (N.toUpperCase() == "DESC") ? (0 - T) : T
                                }
                                return T
                            }
                            this.sort(O)
                        }
                    };
                    L.SortByNode = function(O, N) {
                        if (this.length) {
                            function M(S, R) {
                                var Q = S[R][0].Text;
                                Q = (C(Q)) ? parseFloat(Q) : Q;
                                return Q
                            }

                            function P(T, R) {
                                var U = 0;
                                var S, Q;
                                S = M(T, O);
                                Q = M(R, O);
                                if (S < Q) {
                                    U = -1
                                } else {
                                    if (Q < S) {
                                        U = 1
                                    }
                                }
                                if (N) {
                                    U = (N.toUpperCase() == "DESC") ? (0 - U) : U
                                }
                                return U
                            }
                            this.sort(P)
                        }
                    }
                }

                function D(N, M) {
                    if (M.attributes.length > 0) {
                        var L = M.attributes.length - 1;
                        var O;
                        N._attributes = [];
                        do {
                            O = String(K(M.attributes[L].name));
                            N._attributes.push(O);
                            N[O] = $.trim(M.attributes[L].value)
                        } while (L--)
                    }
                }

                function K(M) {
                    var N = /-/g;
                    var L = String(M).replace(N, "_");
                    return L
                }
                var C = function(M) {
                    var L = "";
                    if (M && typeof M == "string") {
                        L = M
                    }
                    var N = /^((-)?([0-9]*)((\.{0,1})([0-9]+))?$)/;
                    return N.test(L)
                };
                I(F, E);
                G = null;
                E = null;
                return F
            } catch (H) {
                return null
            }
        }
    });
    $.extend({
        textToXML: function(F) {
            try {
                var D = new DOMParser();
                D.async = false
            } catch (E) {
                throw new Error("XML Parser could not be instantiated")
            }
            var C;
            try {
                C = D.parseFromString(F, "text/xml")
            } catch (E) {
                throw new Error("Error parsing XML string")
            }
            return C
        }
    })
} else {
    alert("jQuery library is not present")
}
jQuery.fn.disableTextSelect = function() {
    return this.each(function() {
        $(this).css({
            MozUserSelect: "none"
        }).bind("selectstart", function() {
            return false
        }).mousedown(function() {
            return false
        })
    })
};
jQuery.fn.enableTextSelect = function() {
    return this.each(function() {
        $(this).css({
            MozUserSelect: ""
        }).unbind("selectstart").mousedown(function() {
            return true
        })
    })
};
jQuery.format = function(C, D) {
    if (arguments.length == 1) {
        return function() {
            var E = jQuery.makeArray(arguments);
            E.unshift(C);
            return jQuery.format.apply(this, E)
        }
    }
    if (arguments.length > 2 && D.constructor != Array) {
        D = jQuery.makeArray(arguments).slice(1)
    }
    if (D.constructor != Array) {
        D = [D]
    }
    jQuery.each(D, function(E, F) {
        C = C.replace(new RegExp("\\{" + E + "\\}", "g"), F)
    });
    return C
};
(function(C) {
    C.fn.hoverIntent = function(K, J) {
        var L = {
            sensitivity: 7,
            interval: 100,
            timeout: 0,
            selector: null
        };
        L = C.extend(L, J ? {
            over: K,
            out: J
        } : K);
        var N, M, H, F;
        var G = function(O) {
            N = O.pageX;
            M = O.pageY
        };
        var E = function(P, O) {
            O.hoverIntent_t = clearTimeout(O.hoverIntent_t);
            if ((Math.abs(H - N) + Math.abs(F - M)) < L.sensitivity) {
                C(O).unbind("mousemove", G);
                O.hoverIntent_s = 1;
                return L.over.apply(O, [P])
            } else {
                H = N;
                F = M;
                O.hoverIntent_t = setTimeout(function() {
                    E(P, O)
                }, L.interval)
            }
        };
        var I = function(P, O) {
            O.hoverIntent_t = clearTimeout(O.hoverIntent_t);
            O.hoverIntent_s = 0;
            return L.out.apply(O, [P])
        };
        var D = function(Q) {
            var P = jQuery.extend({}, Q);
            var O = this;
            if (O.hoverIntent_t) {
                O.hoverIntent_t = clearTimeout(O.hoverIntent_t)
            }
            if (Q.type == "mouseenter") {
                H = P.pageX;
                F = P.pageY;
                C(O).bind("mousemove", G);
                if (O.hoverIntent_s != 1) {
                    O.hoverIntent_t = setTimeout(function() {
                        E(P, O)
                    }, L.interval)
                }
            } else {
                C(O).unbind("mousemove", G);
                if (O.hoverIntent_s == 1) {
                    O.hoverIntent_t = setTimeout(function() {
                        I(P, O)
                    }, L.timeout)
                }
            }
        };
        if (L.selector !== null) {
            return this.on("mouseenter", L.selector, D).on("mouseleave", L.selector, D)
        } else {
            return this.on("mouseenter", D).on("mouseleave", D)
        }
    }
})(jQuery);
var strings = {
    applicationWelcomeTitle: "Welcome to Application Title",
    applicationTitle: "Application Title",
    applicationTitleAbbrev: "App",
    commandlist: {
        resultSuccessMsg: "Command list completed successfully.",
        canceled: "Execution canceled"
    },
    datasets: {
        advancedSettingsSet: "Advanced Settings",
        chapRecordsSet: "CHAP Records",
        cacheParametersSet: "Cache Parameters",
        controllerStatSet: "Controller Statistics",
        disksSet: "Disk Information",
        diskStatSet: "Disk Statistics",
        emailParametersSet: "Email Settings",
        enclosuresSet: "Hardware Information",
        eventsSet: "Events",
        hostGroupsSet: "Host Information",
        hostnameSet: "Host Information",
        hostPortStatsSet: "Host Port Statistics",
        iscsiParametersSet: "iSCSI Parameters",
        licenseSet: "Feature Licenses",
        mapsSet: "Volume Mapping Information",
        poolsSet: "Pool Information",
        poolStatisticsSet: "Pool Statistics",
        protocolsSet: "Services Information",
        peerConnectionsSet: "Peer Connections",
        refreshCountersSet: "Refresh Counters",
        remoteSystemsSet: "Remote Systems Information",
        replicationSetsSet: "Remote Replication Information",
        schedulesSet: "Schedule Information",
        sessionParametersSet: "Session Parameters",
        snapPoolsSet: "Snap Pool Information",
        snapshotsSet: "Snapshot Information",
        snmpParametersSet: "SNMP Settings",
        storageConfigSet: "Storage Configuration",
        storageUnconfigSet: "Unconfigured Storage Information",
        systemInfoSet: "System Information",
        systemParametersSet: "System Parameters",
        timeSettingsSet: "System Time",
        usersSet: "User Information",
        vdisksSet: "Vdisk Information",
        versionsSet: "Version Information",
        virtualReplicationSets: "Virtual Replication Information",
        volumeCopySet: "Volume Copies",
        volumeGroupsSet: "Volume Information",
        volumesSet: "Volume Information",
        volumeStatSet: "Volume Statistics"
    },
    dateTimeInput: {
        endDateLabel: "Date",
        endLabel: "End",
        endTimeLabel: "Time",
        startDateLabel: "Date",
        startLabel: "Start",
        startTimeLabel: "Time"
    },
    driveSelection: {
        caption1: jQuery.format("Disk Selection Sets, Complete: {0} "),
        caption2: jQuery.format("Disk Sets, Total Space: {0}: "),
        meterAvailTip: "Available",
        meterOverTip: "Overhead",
        meterSparesTip: "Spares",
        meterWasteTip: "Waste (mismatched disks)",
        singlePorted: "Single Ported - data path will not be fault tolerant."
    },
    fileUpload: {
        completedMsg: "File upload is complete.",
        failureMsg: "The file upload failed.",
        processingMsg: "Uploading the file...",
        submitText: "Upload",
        successMsg: "The file uploaded successfully."
    },
    form: {
        errTitle: "Correct the errors below:"
    },
    inputs: {
        optionOrigFlag: ""
    },
    lostComm: {
        confirmMsg: "Communication with the system has been lost. Connection will be automatically restored once communication with the system has been established.",
        title: "Communication Lost"
    },
    segGraph: {
        sizeTip: jQuery.format("{0}: Size = {1}"),
        usedTip: jQuery.format(", Allocated = {0}")
    },
    servicesSetup: {
        activityLabel: "Activity Progress Reporting",
        cliLabel: "Command Line Interface (CLI)",
        commonOffConfirmMsg: jQuery.format("Some common services ({0}) are disabled. Disabling services will prevent future access over those interfaces."),
        confirmQuestion: "Are you sure you want to use these settings?",
        debugLabel: "Service Debug",
        failureMsg: "Failed to set the management interfaces",
        ftpLabel: "File Transfer Protocol (FTP)",
        ftpConfirmMsg: "Enabling the FTP protocol may result in unsecured management operations being sent across the network.",
        httpConfirmMsg: "Enabling the http protocol may result in unsecured management operations being sent across the network.",
        httpLabel: "HTTP",
        httpsLabel: "HTTPS",
        imsText: "In-band Management Services",
        legacyCheckbox: "Legacy Mode",
        legacyInfoTxt: jQuery.format("Enabling legacy mode will enable the use of {0} and uses older terminology, such as vdisk instead of disk group."),
        legacyInfoTxt2: "If you are an experienced user and would like to use this legacy feature, enable legacy mode here.",
        linearRep: "linear replication",
        managementVersionLabel: "Default Management Mode",
        nmsText: "Network Management Services",
        otherIFSLabel: "Other Interfaces",
        port: "Port",
        processingMsg: "Setting the management interfaces",
        sesLabel: "In-band SES Capability",
        sftpLabel: "SSH File Transfer Protocol (SFTP)",
        slpLabel: "Service Location Protocol (SLP)",
        smisLabel: "Storage Management Initiative Specification Interface (SMI-S)",
        smisLabel: "Storage Management Initiative Specification (SMI-S)",
        snmpLabel: "Simple Network Management Protocol (SNMP)",
        snmpConfirmMsg: "This will allow use of SNMPv1, SNMPv2, and SNMPv3. SNMPv1 and SNMPv2 expose the system to inherent security risks. If you want to use SNMPv1 and SNMPv2, you should change the community strings from their default values. The most secure choice is to disable SNMPv1 and SNMPv2 by creating an SNMPv3 user.",
        sshLabel: "SSH",
        successMsg: "Successfully set the management interfaces",
        tabNetwork: "Network Management",
        tabLegacy: "Legacy Services",
        telnetConfirmMsg: "Enabling the telnet protocol may result in unsecured management operations being sent across the network.",
        telnetLabel: "Telnet",
        usmisConfirmMsg: "Enabling the unsecured SMIS protocol may result in unsecured management operations being sent across the network.",
        wbiLabel: "Web Browser Interface (WBI)",
        disableBothWebProtosMsg: "Disabling both HTTP and HTTPS will prevent further access via this interface, and will result in immediate loss of connection for this interface.",
        debugConfirmMsg: "Service debug protocol will enable Telnet debug ports and privileged diagnostic user IDs via remote connections. Enabling the protocol allows remote connection, through incoming ports only, by HPE or HPE's authorized representatives for troubleshooting.",
        disableCurrentProtoMsg: jQuery.format("Disabling the currently used protocol ({0}) will result in immediate loss of connection to this interface."),
        separator: ", "
    },
    sessionTimeout: {
        confirmMsg: "Your session has timed out. You need to sign in again to use the application.",
        title: "Session Timeout"
    },
    sessionWarning: {
        confirmMsg: "Your session will time out within 60 seconds. Click OK to continue to use the application.",
        title: "Session Warning"
    },
    sysDown: {
        confirmMsg: "The system is unavailable at this time.",
        title: "System Unavailable"
    },
    unauthorized: {
        confirmMsg: "You need to sign in again to use the application.",
        title: "Unauthorized Access"
    },
    timeInput: {
        am: "AM",
        military: "24H",
        pm: "PM"
    },
    treeNode: {
        HelpNode: "{text}"
    },
    redirectDialog: {
        header: jQuery.format("Redirecting to {0}"),
        message: jQuery.format("The IP address of the local controller has been changed. Redirecting to its new IP address {0}."),
        title: jQuery.format("IP Address Change")
    },
    scheduleMeta: {
        associated_volume: "Associated Volume",
        associated_volume_serial: "Associated Volume Serial"
    },
    val: {
        accept: "Please enter a value with a valid extension.",
        creditcard: "Please enter a valid credit card number.",
        dateISO: "Please enter a valid date (ISO format).",
        date: "Please enter a valid date.",
        digits: "Please enter only digits.",
        dnsAddress: "Enter a valid IP address or domain name.",
        emailSenderDomain: 'The sender domain cannot contain a space or any of the following characters: \\ " : ; < > ( )',
        emailLocalFormat: 'The sender name cannot contain a space or any of the following characters: \\ " : ; < > ( ) [ ] @',
        email: "Please enter a valid email address.",
        equalTo: "Please enter the same value again.",
        max: jQuery.format("Please enter a value less than or equal to {0}."),
        maxlength: jQuery.format("Please enter no more than {0} characters."),
        min: jQuery.format("Please enter a value greater than or equal to {0}."),
        minlength: jQuery.format("Please enter at least {0} characters."),
        range: jQuery.format("Please enter a value between {0} and {1}."),
        rangelength: jQuery.format("Please enter a value between {0} and {1} characters long."),
        remote: "Please fix this field.",
        required: "This field is required.",
        url: "Please enter a valid URL.",
        chapDoesntExist: "A chap record with selected name does not exist",
        chapSecret: "Secret must be 12 to 16 characters long",
        chapName: "Enter a valid mutual CHAP name that includes only 0-9, lowercase a-z, hyphen, colon, and period ",
        passSecurity: "The password did not pass all of the security rules.  See the help for specific rules.",
        dhHostName: 'The value cannot include any of the following characters: " , . < \\',
        dhName: 'The value cannot include any of the following characters: " , < \\',
        dhNameWithComma: 'The value cannot include any of the following characters: " < > \\',
        dhFdePassword: 'The value cannot include any of the following characters: " < > \\',
        dhRepName: 'The value cannot include leading or trailing spaces or any of the following characters: " , < \\',
        dhLogName: "The value cannot include any of the following characters: \" '`&",
        dhPhoneNumber: "Not a valid phone number. The value must have 10 digits and no other characters.",
        dhsdate: "Enter a valid date (YYYY-MM-DD)",
        dateFormat: "(YYYY-MM-DD)",
        hourFormat: "(HH)",
        minuteFormat: "(MM)",
        dhUserName: 'The value cannot include a space or any of the following characters: " , < \\:',
        diskGroupExists: "The disk group name is in use; choose another.",
        emailFormat: "Enter a valid email address (name@host.domain)",
        groupExists: "The volume group name is in use; choose another.",
        hostDoesntExist: "The specified host does not exist",
        hostExists: "The host name is in use; choose another.",
        hostGroupExists: "The host group name is in use; choose another.",
        hostNickname: 'Enter a host nickname. The value cannot include any of the following characters: " , \\',
        integer: "Enter an integer.",
        ipv4Address: "Enter an IP address (nnn.nnn.nnn.nnn)",
        ipv6Address: "Enter an IP address (0000:0000:0000:0000:0000:0000:0000:0000)",
        NanError: "Enter a number.",
        nicknameAlreadyExists: "The entered nickname already exists. Choose another.",
        noBannedUsers: "Reserved user name. Please choose a different user name.",
        number: "Enter a valid number.",
        password: 'Passwords are case-sensitive. The value cannot include any of the following characters: " , \\',
        peerExists: "A peer with the specified name already exists. Choose an alternate name.",
        remoteSystemExists: "The remote system with this IP address already exists.",
        replicationSetExists: "The replication set with the specified name already exists. Choose an alternate name.",
        rwCommunity: 'The value cannot include a leading or trailing space or any of the following characters: " < >',
        sizeRange: jQuery.format("Enter a size between {0} and {1}."),
        binaryBaseSizeString: "Enter a size in MiB, GiB, or TiB (for example, 35.5GiB).",
        decimalBaseSizeString: "Enter a size in MB, GB, or TB (for example, 35.5GB).",
        userExists: "The user name is in use; choose another.",
        userMustExist: "User name must exist.",
        utf8length: jQuery.format("Input is too long. Maximum length should be  {0} bytes."),
        characterLength: jQuery.format("Input is too long. Maximum length should be {0} characters."),
        validRange: "Enter valid range or comma-separated disk values.",
        validateSystemInfo: 'Enter system information. The value cannot include any of the following characters: " , \\',
        vdiskExists: "The vdisk name is in use; choose another.",
        vdiskName: 'Enter a vdisk name. The value cannot include any of the following characters: " , \\',
        volumeExists: "The volume name is in use; choose another.",
        volumeName: 'Enter a volume name. The value cannot include any of the following characters: " , \\',
        wwniqnError: "Enter a valid Fibre Channel WWN (16 hex digits), or an ISCSI IQN/EUI Address.",
        destAddr: "The destination address is not a recognized format.  Must be WWN or IPv4 address.",
        wwnError: "Enter a valid Fibre Channel WWN (16 hex digits) Address."
    },
    wiz: {
        cancelButtonText: "Cancel",
        confirmCancel: "Are you sure you want to leave the wizard and discard your changes?",
        finishButtonText: "Finish",
        introStep: "Introduction",
        introTitle: "Introduction",
        nextButtonText: "Next",
        prevButtonText: "Previous",
        stepNumMid: " of ",
        stepNumPost: ":",
        stepNumPre: "Step "
    },
    All: "All",
    Allocated: "Allocated",
    allOtherInits: "All Initiators",
    adapt: "ADAPT",
    adapttip: " Stripe virtalization layer",
    and: "and",
    applyAndClose: "Apply and Close",
    applyButtonText: "Apply",
    auto: "Auto",
    Back: "Back",
    BGMS: "Background Media Scan",
    browserNotSupported: "Browser does not support this feature",
    cache: "cache",
    Cancel: "Cancel",
    cancelButtonText: "Cancel",
    Capacity: "Capacity",
    ClickMenu: "Click for menu",
    celsius: "Celsius",
    classStr: "class",
    storageClass: "Class",
    spareCount: "Spare Count",
    clearFilters: "Clear Filters",
    closeButtonText: "Close",
    consistencyGroups: "consistency groups",
    continueMessage: "Do you want to continue?",
    controllerA: "Controller A",
    controllerB: "Controller B",
    Controller: "Controller",
    ControllerId: "Controller ID",
    CPYBK: "Copyback",
    critical: "Critical",
    date: "Date",
    Delete: "Delete",
    deleteButtonText: "Delete",
    Description: "Description",
    Disabled: "Disabled",
    disabled: "disabled",
    discovered: "discovered",
    diskgroup: "disk group",
    diskgroups: "disk groups",
    DiskGroup: "Disk Group",
    DiskGroups: "Disk Groups",
    disks: "disks",
    dotNotation: ".",
    driveLabel: "Disk",
    DRSC: "Disk Scrub",
    emptyTableMessage: "There is no data for your selection.",
    Enable: "Enable",
    Enabled: "Enabled",
    enabled: "enabled",
    enclosureElement: "Enclosure-element",
    Encrypted: "Encrypted",
    enhanceOff: "</b>",
    enhanceOn: "<b>",
    error: "Error",
    EVENT: "EVENT",
    exceededTableSelectionMsg: jQuery.format("You may select a maximum of {0} rows in this table."),
    EXPD: "Expand",
    exportCSVLabel: "Export to CSV",
    fahrenheit: "Fahrenheit",
    firmwareUpdate: "Firmware Update",
    getLogs: "Get Logs",
    generic: "Generic",
    Group: "Group",
    groupedVolumes: "grouped volumes",
    Groups: "Groups",
    helpContentPanelTitle: "Help",
    host: "host",
    hostGroup: "host group",
    HostGroups: "Host Groups",
    hostGroups: "host groups",
    hostLabel: "Host",
    hostNotGrouped: "-nohost-",
    hostUnGrouped: "-ungrouped-",
    Hosts: "Hosts",
    hosts: "hosts",
    ID: "ID",
    informational: "Informational",
    infoResol: "Informational/Resolved",
    INIT: "Initialize",
    initiator: "initiator",
    Initiators: "Initiators",
    initiators: "initiators",
    inLabel: "In ",
    inPort: "In Port",
    iomLabel: "I/O Module",
    IPAddress: "IP Address",
    jobDescription: jQuery.format("{0} ({1}%)"),
    labelTerminator: ":",
    Linear: "Linear",
    LinearPool: "Linear Pool",
    linearSnapshotOrVolume: "linear snapshot or volume",
    linear_disk_group: "linear disk group",
    linearVolume: "linear volume",
    loading: "loading ...",
    loadingData: "Loading data...",
    locPrimVol: "local primary volume",
    locRepVol: "local replication volume",
    loginPanelTitle: "Sign In",
    low: "Low",
    LOWF: "Low-level Format",
    lun: "LUN",
    major: "Error",
    mappableVolumes: "mappable volumes",
    maps: "maps",
    masterVolLabel: "master volume",
    microsec: "\u00B5s",
    minor: "Warning",
    na: "N/A",
    Name: "Name",
    name: "name",
    New: "New",
    No: "No",
    none: "none",
    noInfo: "Snapshot Not Found",
    noResponse: "No response was received from the controller. This is normal if the controller is restarting.",
    noScResponse: "No response was received from the Storage Controller.",
    NotFound: "Not Found",
    no_access: "no-access",
    okButtonText: "OK",
    out: "Out ",
    outPort: "Out Port",
    overcommitMsg: "Action will overcommit the virtual pool. Ensure that event notification is configured to receive warnings before running out of physical storage.",
    Owner: "Owner",
    ownerCombined: jQuery.format("Preferred: {0}, Current: {1}"),
    PRERCON: "Preemptively Reconstructed",
    pageLoadError: "There was a problem loading the page. Click OK to reload. ",
    ParameterTitle: "Parameter",
    Password: "Password",
    peer: "Peer Connection",
    peers: "Peer Connections",
    pleaseConfirmTheFollowing: "Please confirm the following:<br/><br/>",
    Pool: "Pool",
    pool: "pool",
    pools: "pools",
    port: "Port",
    Ports: "Ports",
    ports: "Ports",
    portType: "Port Type",
    preference: "preference",
    progressBarText: jQuery.format("{0}%"),
    progressFinished: jQuery.format("<b>{0}</b> finished."),
    progressOf: "Progress of ",
    progressStarting: jQuery.format("<b>{0}</b> starting."),
    PropertyTitle: "Property",
    PSCD: "Storage-Pool Component Delete",
    Rack: "Rack",
    raid10: "RAID-10",
    raid10tip: "Combination of RAID 0 (data striping) and RAID 1 (mirroring)",
    raid1: "RAID-1",
    raid1tip: "Disk mirroring",
    raid50: "RAID-50",
    raid50tip: "Combination of RAID 0 (data striping) and RAID 5 with distributed parity",
    raid5: "RAID-5",
    raid5tip: "Block-level data striping with distributed parity",
    raid6: "RAID-6",
    raid6tip: "Block-level data striping with double distributed parity",
    RBAL: "Rebalance",
    RCON: "Reconstruct",
    read_only: "read-only",
    read_write: "read-write",
    removeButtonText: "Remove",
    replicationImage: "replication image",
    replicateVolume: "replicate volume",
    replicationSet: "replication set",
    replicationSets: "replication sets",
    repSetLabel: "Replication Set",
    repSetsLabel: "Replication Sets",
    requiredIndicator: "*",
    resolved: "Resolved",
    RTIER: "Volume Restrict Tiers",
    Set: "Set",
    set: "Set",
    setLoading: jQuery.format("Loading {0}"),
    shutdown: "shut down",
    Size: "Size",
    size: "size",
    skip: "Skip",
    snapLabel: "Snapshot",
    snappableVolumes: "snappable volumes",
    snapPoolLabel: "Snap Pool",
    snapshot: "snapshot",
    snapshotOrVolume: "snapshot or volume",
    Spares: "Spares",
    specifyRange: jQuery.format("Specify a range from {0} to {1}"),
    stdSnapshot: "standard snapshot",
    system: "System",
    Tier: "Tier",
    TierAffinity: "Tier Affinity",
    Time: "Time",
    Topic: "Topic",
    topic: "topic",
    topicButtonText: "Action",
    Total: "Total",
    Type: "Type",
    truncatedList: jQuery.format(",... ({0} more)"),
    Unallocated: "Unallocated",
    ungrouped: "ungrouped",
    ungroupedVolumes: "ungrouped volumes",
    unknownVal: "Unknown",
    Update: "Update",
    Username: "Username",
    usingDegradedDisk: "At least one unhealthy disk is selected. Unhealthy disks should be replaced prior to this action to avoid the risk of future failures.",
    ValueTitle: "Value",
    vdiskLabel: "Vdisk",
    Virtual: "Virtual",
    VirtualPool: "Virtual Pool",
    virtual_pool: "virtual pool",
    Volume: "Volume",
    volume: "volume",
    volume: "volume",
    volumeGroup: "volume group",
    VolumeGroups: "Volume Groups",
    volumeGroups: "volume groups",
    volumeLabel: "Volume",
    volumeNotGrouped: "-ungrouped-",
    volumeLabelPlural: "Volumes",
    volumeMapLabel: "Map",
    Volumes: "Volumes",
    volumes: "volumes",
    VolumesAndSnapshots: "Volumes/Snapshots",
    volumesSlashsnapshots: "volumes/snapshots",
    VREMV: "Removing data",
    VRECV: "Recovered",
    VRFY: "Verify",
    VRSC: "Media Scrub",
    VDRAIN: "Draining",
    VPREP: "Preparing",
    warning: "Warning",
    Yes: "Yes",
    mapped: "Mapped",
    menus: {
        abortReplication: "Abort Replication",
        abortVolumeCopy: "Abort Volume Copy",
        addDiskGroup: "Add Disk Group",
        addStorage: "Provision Storage",
        addRemoteSystem: "Add Remote System",
        addToHost: "Add to Host",
        addToHostGroup: "Add to Host Group",
        addToVolumeGroup: "Add to Volume Group",
        applyMaps: "Apply Mapping Changes",
        advancedSettings: "Advanced Settings",
        asyncRep: "Asynchronous Replication",
        certificateInfo: "Show Certificate Info",
        changeSpares: "Manage Spares",
        checkLink: "Check Links",
        clearMetadata: "Clear Metadata",
        configurationWiz: "Configuration Wizard",
        configureChap: "Configure CHAP",
        sysSettings: "System Settings",
        copyVolume: "Copy Volume",
        createConsistency: "Create Consistency Group",
        createHost: "Create Host",
        createInit: "Create Initiator",
        createLinearVolumes: "Create Linear Volumes",
        createPeerConnection: "Create Peer Connection",
        createReplicationSet: "Create Replication Set",
        createReplicationSetVol: "Create Replication Set",
        createRemoteSystem: "Create Remote System",
        createSnapshot: "Create Snapshot",
        createVirtualVolumes: "Create Virtual Volumes",
        createVolumes: "Create Volumes",
        dateTimeSetup: "Set Date and Time",
        deleteInit: "Delete Initiators",
        deletePeerConnection: "Delete Peer Connection",
        deleteRemoteSystem: "Delete Remote System",
        deleteReplicationSet: "Delete Replication Set",
        deleteSnapshot: "Delete Snapshot",
        deleteVolumes: "Delete Volumes",
        delRepSet: "Delete Replication Set",
        detachReplicationVolume: "Detach Replication Volume",
        diskGroupUtilities: "Disk Group Utilities",
        dequarantine: "Dequarantine Disk Group",
        eventList: "Show Event List",
        expandDiskGroups: "Expand Disk Group",
        exportPerf: "Export Historical Statistics",
        exportSnapshot: "Export Snapshot",
        fullDiskEncryption: "Full Disk Encryption",
        home: "Home",
        hostPorts: "Set Up Host Ports",
        hostsAll: "View Hosts",
        hosts: "Hosts",
        hostSetup: "Host Setup",
        hostsWithMaps: "Hosts with maps",
        initiateReplication: "Initiate Replication",
        licenseSetup: "Install License",
        manageSchedules: "Manage Schedules",
        mapDetails: "View Map Details",
        mapInitiators: "Map Initiators",
        map: "Map",
        mapping: "Mapping",
        mapVolumes: "Map Volumes",
        modifyDiskGroup: "Modify Disk Group",
        modifyHost: "Modify Host",
        modifyInit: "Modify Initiator",
        modifyPeerConnection: "Modify Peer Connection",
        modifyReplicationSet: "Modify Replication Set",
        modifyVolume: "Modify Volume",
        networkSetup: "Set Up Network",
        noEntries: "No items",
        noteDisplay: "Notification History",
        notificationSetup: "Set Up Notifications",
        overview: "Overview",
        performance: "Performance",
        poolSettings: "Change Pool Settings",
        pools: "Pools",
        storageSetup: "Storage Setup",
        storageCompleteSetup: "Storage Setup",
        queryPeerConnection: "Query Peer Connection",
        reattachReplicationVolume: "Reattach Replication Volume",
        recoveryManager: "Recovery Manager",
        remoteSnapshotReplication: "Remote Snapshot Replication",
        remoteSystemsManagement: "Remote Systems Management",
        removeDiskGroups: "Remove Disk Groups",
        removeFromHostGroup: "Remove from Host Group",
        removeFromHost: "Remove from Host",
        removeFromVolumeGroup: "Remove from Volume Group",
        removeHostGroup: "Remove Host Group",
        removeHost: "Remove Host",
        removeMap: "Remove Mappings",
        removeAllMaps: "Remove All Mappings",
        removeVolumeGroup: "Remove Volume Group",
        renameHostGroup: "Rename Host Group",
        renameHost: "Rename Host",
        renameVolumeGroup: "Rename Volume Group",
        replicate: "Replicate",
        replicateVol: "Replicate Volume",
        replicateSnapshot: "Replicate Snapshot",
        replications: "Replications",
        replicationWiz: "Replication Wizard",
        rescanDiskChannel: "Rescan Disk Channels",
        resetHostPort: "Reset Host Port",
        resetMappingTopic: "Reset/Clear Mapping Table",
        resetPerf: "Reset All Statistics",
        resetSnapshot: "Reset Snapshot",
        restartSystem: "Restart System",
        resumeReplication: "Resume Replication Set",
        reverseReplication: "Reverse Replication Set",
        rollbackVolume: "Rollback Volume",
        saveLogs: "Save Logs",
        scheduleReplications: "Schedule Replications",
        servicesSetup: "Set Up System Services",
        setPrimaryVolume: "Set Replication Primary Volume",
        setRepExtView: "Set External View",
        setRepPrimVol: "Set Replication Primary Volume",
        ssdActivity: "View I/O Workload",
        startStopDiskGroup: "Stop/Start Disk Group",
        suspendReplication: "Suspend Replication Set",
        sysSettings: "System Settings",
        systemInfoSetup: "Set System Information",
        system: "System",
        systemView: "View System",
        turnOffLeds: "Turn Off LEDs",
        turnOnLeds: "Turn On LEDs",
        updateFirmware: "Update Firmware",
        updatePerf: "Update Historical Statistics",
        userManagement: "Manage Users",
        viewSystem: "View System",
        volumesAll: "View Volumes",
        volumes: "Volumes",
        volumesWithMaps: "Volumes with maps",
        volumesWithSnaps: "Volumes with snapshots"
    },
    activeDialog: {
        applicationTitle: "The application is loading...",
        confirmTitle: "Confirm Operation",
        defaultTitle: "Message",
        errorTitle: "Error",
        failure: "Operation was unsuccessful",
        failureTitle: "Failure",
        messageTitle: "Message",
        processing: "Performing the operation",
        processingTitle: "Processing the request...",
        success: "Completed successfully",
        successTitle: "Success",
        warningTitle: "Warning"
    },
    taskDialog: {
        title: "Action"
    },
    topics: {
        HomeTopic: "HOME",
        HostsTopic: "HOSTS",
        MappingTopic: "MAPPING",
        PerfTopic: "PERFORMANCE",
        PoolsTopic: "POOLS",
        RepsTopic: "REPLICATIONS",
        RsrTopic: "REPLICATIONS",
        SystemTopic: "SYSTEM",
        VolumesTopic: "VOLUMES",
        Replications: "REPLICATIONS"
    },
    actions: {
        AbortReplication: "Abort Replication",
        AbortRsrReplication: "Abort Replication",
        AbortVolumeCopyAction: "Abort Volume Copy",
        CreateDiskGroupAction: "Add Disk Group",
        AddRemoteSystem: "Add Remote System",
        AddStorageAction: "Provision Storage",
        AddToHostAction: "Add to Host",
        AddToHostGroupAction: "Add to Host Group",
        AddToVolumeGroupAction: "Add to Volume Group",
        ApplyMapsAction: "Apply Mapping Changes",
        AdvancedSettingsAction: "Advanced Settings",
        ChangeSparesAction: "Manage Spares",
        CheckLocalLinkAction: "Check Local System Link",
        CheckRemoteLinkAction: "Check Remote Links",
        CheckLinks: "Check Links",
        ClearMetadataAction: "Clear Metadata",
        ConfigurationWizard: "Configuration Wizard",
        ConfigureChapAction: "Configure CHAP",
        CopyVolumeAction: "Copy Volume",
        CreateInitAction: "Create Initiator",
        CreatePeerConnectionAction: "Create Peer Connection",
        CreateLinearVolumesAction: "Create Linear Volumes",
        CreateLinearRepSet: "Create Replication Set",
        CreateRemoteSystemAction: "Add Remote System",
        CreateReplicationSet: "Create Replication Set",
        CreateReplicationSetVol: "Create Replication Set",
        CreateRsrReplicationSet: "Create Replication Set",
        CreateSnapshotAction: "Create Snapshots",
        CreateVirtualVolumesAction: "Create Virtual Volumes",
        createVolumesFactory: "Create Volumes",
        DateTimeSetupAction: "Set Date and Time",
        DateTimeSetupAction: "Set Date and Time",
        DeleteInitAction: "Delete Initiators",
        DeletePeerConnectionAction: "Delete Peer Connection",
        DeleteReplicationSet: "Delete Replication Set",
        DeleteRsrReplicationSet: "Delete Replication Set",
        DeleteRsrSnapshot: "Delete Snapshot",
        DeleteRemoteSystem: "Delete Remote System",
        DeleteVolumesAction: "Delete Volumes",
        DequarantineDiskGroupAction: "Dequarantine Disk Group",
        DetachReplicationVolume: "Detach Replication Volume",
        DisplayMapListAction: "Map Volume/LUNs",
        EventListAction: "Event Log Viewer",
        ExpandDiskGroupAction: "Expand Disk Group",
        ExportPerfAction: "Export Historical Statistics",
        ExportSnapshot: "Export Snapshot",
        FullDiskEncryptionAction: "Full Disk Encryption",
        HostPortsAction: "Host Ports Settings",
        HostSetup: "Host Setup",
        InitiateReplication: "Initiate Replication",
        InitiateRsrReplication: "Initiate Replication",
        LicenseSetupAction: "License Settings",
        ManageSchedulesAction: "Manage Schedules",
        MapAction: "Map",
        MapDetailAction: "Map Details",
        ModifyDiskGroupAction: "Modify Disk Group",
        ModifyInitAction: "Modify Initiator",
        ModifyPeerConnectionAction: "Modify Peer Connection",
        ModifyReplicationSet: "Modify Replication Set",
        ModifyVolumeAction: "Modify Volume",
        NetworkSetupAction: "System IP Network Configuration",
        NoteDisplayAction: "Notification History",
        NotificationSetupAction: "Notification Settings",
        PoolSettingsAction: "Pool Settings",
        QueryPeerConnectionAction: "Query Peer Connection",
        ReattachReplicationVolume: "Reattach Replication Volume",
        RecoveryManager: "Recovery Manager",
        RemoteSystemsManagementAction: "Remote Systems Management",
        RemoveDiskGroupsAction: "Remove Disk Groups",
        RemoveFromHostAction: "Remove from Host",
        RemoveFromHostGroupAction: "Remove from Host Group",
        RemoveFromVolumeGroupAction: "Remove from Volume Group",
        RemoveHostAction: "Remove Host",
        RemoveHostGroupAction: "Remove Host Group",
        RemoveAllMappings: "Remove All Mappings",
        RemoveMappings: "Remove Mappings",
        RemoveVolumeGroupAction: "Remove Volume Group",
        RenameHostAction: "Rename Host",
        RenameHostGroupAction: "Rename Host Group",
        RenameVolumeGroupAction: "Rename Volume Group",
        RsrReplicateAction: "Replicate Volume",
        ReplicateAction: "Replicate",
        ReplicateSnapshot: "Replicate Snapshot",
        ReplicateSnapshotVol: "Replicate Snapshot",
        ReplicateVolumeAction: "Replicate Volume",
        ReplicationWizard: "Replication Setup Wizard",
        RescanDiskChannelAction: "Rescan Disk Channels",
        ResetMappingAction: "Reset/Clear Mappings Table",
        ResetPerfAction: "Reset All Statistics",
        ResetSnapshotAction: "Reset Snapshot",
        RestartSystemAction: "Controller Restart and Shut Down",
        ResumeReplicationSet: "Resume Replication Set",
        ResumeRsrReplication: "Resume Replication Set",
        ReverseReplicationSet: "Reverse Replication Set",
        ResetHostPortAction: "Reset Host Port",
        RollbackVolumeAction: "Rollback Volume",
        SaveLogsAction: "Save Logs",
        ScheduleReplications: "Schedule Replications",
        ScheduleRsrReplication: "Schedule Replication",
        ServicesSetupAction: "System Services",
        SetPrimaryVolume: "Set Replication Primary Volume",
        ShowCertificateInfoAction: "Certificate Information",
        StorageSetup: "Storage Setup",
        StorageCompleteSetup: "Storage Setup",
        SSDActivityDialog: "I/O Workload",
        SuspendReplicationSet: "Suspend Replication Set",
        SuspendRsrReplication: "Suspend Replication Set",
        SystemSettings: "System Settings",
        SystemInfoSetupAction: "Set System Information",
        TestAction: "Test Action",
        startStopDiskGroup: "Start/Stop Disk Group",
        diskGroupUtilities: "Disk Group Utilities",
        UpdateFirmwareAction: "Update Firmware",
        UpdateFirmwareAction: "Update Firmware",
        UpdateFirmwareAction: "Update Firmware",
        UpdatePerfAction: "Update Historical Statistics",
        UserManagementAction: "User Management"
    },
    barPanels: {
        ActivityBarPanel: "System Activity Information",
        CapacityBarPanel: "Capacity Utilization",
        ConnectBarPanel: "Connection Information",
        DateTimeBarPanel: "System Date/Time",
        EventBarPanel: "Event Information",
        HealthBarPanel: "System Health",
        PerfBarPanel: "Host I/O Information",
        SysInfoBarPanel: "System Information",
        TierIoBarPanel: "Tier I/O Information",
        SSDActivityPanel: "I/O Workload",
        UserBarPanel: "User Information"
    },
    capacityBar: {
        diskCapacity: "Total Disk Capacity",
        linearAllocLabel: "Allocated",
        linearDGLabel: "Linear Disk Groups",
        linearReservedLabel: "Reserved",
        linearUnallocLabel: "Unallocated",
        overProvisioned: "is overcommitted by ",
        sparesLabel: "Global Spares",
        uncommittedLabel: "Uncommitted",
        unusedLabel: "Unused",
        virtualAllocLabel: "Allocated",
        virtualDGLabel: "Virtual Disk Groups",
        virtualReservedLabel: "Reserved",
        virtualUnallocLabel: "Unallocated"
    },
    connection: {
        authenticating: "authenticating",
        authorized: "authorized",
        CONNECTED: "Connected",
        DISCONNECTED: "Disconnected",
        SYSDOWN: "Down",
        SYSUP: "Up",
        unauthorized: "unauthorized",
        unknown: "unknown"
    },
    dateTimeBar: {
        ntpLabel: "Network Time Protocol",
        ntpOffsetLabel: "Timezone offset",
        ntpServerLabel: "Server address"
    },
    eventBar: {
        last24Label: "Errors in last 24 hours",
        lastErrorLabel: "Last error occurred at"
    },
    notes: {
        allDataLoaded: "Finished loading configuration data."
    },
    sysInfoBar: {
        contactLabel: "Contact",
        infoLabel: "Information",
        locationLabel: "Location",
        nameLabel: "System name",
        systemLabel: "System: ",
        vendorLabel: "Vendor",
        versionALabel: "Version(A)",
        versionBLabel: "Version(B)",
        versionLabel: "Version: ",
        topLevelSN: "Top Level Serial Number",
        topLevelPN: "Top Level Part Number"
    },
    tierIoBar: {
        tierIoLabel: "Tier<br />IOPS"
    },
    ssdIoBar: {
        label: "I/O Workload"
    },
    userBar: {
        accessLabel: "Access",
        logoutLabel: "Sign Out",
        rolesLabel: "Roles",
        sessionLabel: "Session: ",
        timeoutLabel: "Timeout in",
        userLabel: "User: ",
        userLabelHover: "User"
    },
    hovers: {
        CapacityHover: "Capacity Utilization",
        CompactFlashHover: "CompactFlash Information",
        ConnectHover: "Connection Information",
        ControllersHover: "Controller Information",
        DateTimeHover: "System Date/Time",
        DiskGroupHover: "Disk Group Information",
        DrawersHover: "Drawer Information",
        DrivesHover: "Disk Information",
        EnclosuresHover: "Enclosure Information",
        EventBarHover: "Critical & Error Event Information",
        ExpanderPortsHover: "Expansion Port Information",
        FanHover: "Fan Information",
        HealthHover: "System Health",
        IoModulesHover: "IOM Information",
        NetworkParametersHover: "Network Information",
        ReplicationSetsHover: "Replication Set Information",
        PeerConnectionsHover: "Peer Connection Information",
        PerfHover: "Host I/O Information",
        PoolHover: "Pool Information",
        PortHover: "Port Information",
        PowerSuppliesHover: "Power Supply Information",
        ReplicationImageHover: "Replication Image Information",
        RemoteSystemHover: "Remote System Information",
        RsrReplicationSetHover: "Replication Set Information",
        RepVolumeHover: "Replication Volume Information",
        SnapshotHover: "Snapshot Information",
        ScheduleHover: "Schedule Information",
        SparesHover: "Global Spares Information",
        StorageHover: "Storage Information",
        SystemHover: "System Information",
        TierHover: "Tier Information",
        TierIoHover: "Tier I/O Information",
        UserHover: "User Information",
        VolumeHover: "Volume Information"
    },
    menuTips: {
        belongsToRepSet: "Cannot rename a volume group that is part of a replication set.",
        cannotMapSecondaryVolume: "Secondary volumes cannot be mapped.",
        changeLicense: "Must install a Performance Tier license.",
        dgExpansion: "Disk group not eligible for expansion.",
        faultyPeer: "Cannot delete replication set because peer connection is faulty. Use the CLI command 'delete replication-set' with the 'local-only' parameter.",
        failoverRepSet: "Cannot perform action on replication set while in Failover.",
        hostAlreadyGrouped: "A selected host already belongs to a group.",
        hostGrouped: "A selected host belongs to a group.",
        hostsNotGrouped: "A selected host does not belong to a group.",
        initiatorAlreadyGrouped: "A selected initiator is already assigned to a host.",
        initiatorGrouped: "A selected initiator is assigned to a host. Remove from host before deleting.",
        initiatorNotGrouped: "A selected initiator is not assigned to a host.",
        initiatorNotNamed: "A selected initiator does not have a nickname.",
        linearNotSupported: "Linear operations are not supported.",
        localRepSet: "Cannot change primary volume on local replication sets, use CLI command 'set replication-primary-volume'",
        localRsrDest: "Must select replication set with secondary volume belonging to this system",
        maxPeers: jQuery.format("The system already has the max allowable number ({0}) of peers configured."),
        mustContainMin: jQuery.format("{0} must contain at least {1} {2}."),
        noAvailableDisks: "There are no available disks.",
        noEntries: "There are no enabled items for this menu.",
        noHistoricalUpdate: "Only available for historical statistics.",
        noISCSI: "Cannot create a peer connection because the system has no iSCSI ports.",
        noValidPorts: "Cannot create a peer connection because the system has no iSCSI or FC ports.",
        noItemsConfigured: jQuery.format("There are no {0} configured."),
        noLinearPools: "No linear pools exist.",
        noMapChanges: "There are no mapping changes to apply.",
        noMetadataTip: "There is no disk metadata to clear.",
        noPeers: "No peers found.  At least 1 peer must be available to replicate.",
        noPools: "No storage pools exist.",
        noReplicationRollback: "Cannot rollback secondary volumes in a replication set.",
        noRepSetSelected: "Must select a replication set.",
        noRmtSysSelected: "Must select a remote system",
        noRmtSysTip: "No remote systems have been added to the system.",
        noScheds: "There are no schedules.",
        noScheduleEntries: "There are no Schedules to manage for this menu.",
        noScheduleEntries: "There are no schedules to manage for this menu.",
        noSnapOfLinSnap: "Snapshots can be taken of volumes and virtual snapshots.",
        noSnapPools: "Must select volumes that are not snap pools.",
        noSpareAdapt: "This action not supported for the ADAPT data protection level.",
        noGlobalSpareAdapt: "This action not supported when there are only ADAPT disk groups.",
        noDiskGroups: "This action is not supported when there are no disk groups avaiable.",
        noneOfTheseBelongingToThis: jQuery.format("Must select {0} which do not belong to {1}."),
        notLicensed: "This feature requires a license.",
        nothingToReset: "There is nothing to reset.",
        noVolumesAvailable: "There are no linear volumes available to replicate.",
        offlinePeer: "The system cannot delete the peer connection because there is no connection to the secondary system. Use the CLI command 'delete peer-connection' with the 'local-only' parameter to delete the peer connection locally.",
        oneOrMore: jQuery.format("Must select one or more {0}."),
        only1HostLeftInGroup: "Cannot remove the last host from a host group. Remove group instead.",
        only1InitLeftInHost: "Cannot remove the last initiator from a host. Remove host instead.",
        onlyGroupableVolumes: "Must select only virtual base volumes or snapshots.",
        onlyInSamePool: "Must select volumes from the same pool.",
        partOfRepSet: "Cannot remove from a volume group that belongs to a replication set.",
        pagedNotSupported: "Virtual provisioning operations are not supported.",
        peerConnectionExists: "Must keep at least 1 virtual disk group for existing peer connection.",
        peerHasReplication: "A selected peer has a replication.",
        poolTooSmall: "There is not enough available space in the pool to create a volume",
        replicationsReqRepSet: "Must select a Replication Set primary volume.",
        replicationsReqVirtualVolumes: "Must choose a  virtual volume",
        replicationSetExists: "Cannot delete the last disk group in a pool with a replication set",
        repsWithScheds: "Must select one or more replication sets with schedules.",
        selectMax: jQuery.format("Must select no more than {0} {1}."),
        selectNum: jQuery.format("Must select {0} {1}."),
        selectNumOrMore: jQuery.format("Must select {0} or more {1}."),
        selectRange: jQuery.format("Must select {0} to {1} {2}."),
        selectRangeOfType: jQuery.format("Must select {0} to {1} {2} of the same {3}."),
        selectSingle: jQuery.format("Must select a single {0}."),
        selectSingleWith: jQuery.format("Must select a {0} with {1}."),
        snapsVolsWithScheds: "Must select one or more snapshots or volumes with schedules.",
        snapshotsExceeded: "The licensed maximum number of snapshots is already in use.",
        volAlreadyInRepSet: "Must select volume that is not already in Replication Set.",
        volGrpAlreadyInRepSet: "Must select volume group that is not already in Replication Set.",
        volNotLocal: "Selected volume is not local to the system.",
        volumesWithoutSnapshots: "Must select volumes without snapshots.",
        quarantinedDiskGroup: "Cannot delete a quarantined disk group. Please contact technical support.",
        unDiscoveredButMapped: "Must select initiators which are not mapped.",
        volumeCopyInProgress: "Cannot delete the disk group in a pool while volume copy is in progress",
        linearProvisioningEnable: "Virtual provisioning operations are not supported when a linear disk group exists on the system.",
        virtualProvisioningEnable: "Linear provisioning operations are not supported when a virtual disk group exists on the system."
    },
    dataTables: {
        oPaginate: {
            sFirst: "First",
            sPrevious: "Previous",
            sNext: "Next",
            sLast: "Last"
        },
        sEmptyTable: "No data available in the table",
        sInfoEmpty: "Showing 0 to 0 of 0 entries",
        sInfoFiltered: jQuery.format("(filtered from {0} total entries)"),
        sSelected: jQuery.format("({0} selected)"),
        sInfoPostFix: "",
        sInfo: jQuery.format("Showing {0} to {1} of {2} entries"),
        sInfoThousands: ",",
        sLengthMenu: "Show ",
        sLoadingRecords: "Loading...",
        sProcessing: "Processing...",
        sSearch: "",
        sUrl: "",
        sZeroRecords: "No matching records found"
    },
    healthWidget: {
        more: jQuery.format("... {0} other unhealthy components, see System Topic."),
        reasonLabel: "Reason",
        recommendLabel: "Recommendation",
        unhealthyLabel: "Unhealthy Components"
    },
    rack: {
        alreadyOff: "Some selected component LEDs are already turned off.",
        alreadyOn: "Some selected component LEDs are already turned on.",
        clearLedsFailed: jQuery.format("Failed to turn off all locator LEDs for target: {0}"),
        clearLedsProcessing: jQuery.format("Turning off all locator LEDs for target: {0}"),
        clearLedsSuccess: "Successfully turned off all locator LEDs",
        clearLedsSuccessSelected: "Successfully turned off locator LEDs for selected components.",
        complete: "Complete",
        completeNo: "No",
        completeUnbalanced: "Unbalanced",
        completeYes: "Yes",
        dataTable: "DATA TABLE",
        diskType: "Disk Type",
        display: "Existing",
        DRAWER: "DRAWER",
        drawerInfo: jQuery.format("Drawer {0}"),
        drawerTop: "TOP",
        drawerBottom: "BOTTOM",
        enclosureCol: "Enclosure",
        frontView: "Front View",
        graphical: "Graphical",
        healthCol: "Health",
        health: "Health",
        id: "ID",
        infoCol: "Information",
        locationCol: "Location",
        location: "Location",
        maximum: "Maximum",
        meter: "Disks",
        minimum: "Minimum",
        mixed: "All",
        name: "Name",
        none: "Any",
        parent: "Enclosure",
        rearView: "Rear View",
        resetLedLabel: "Turn Off LEDS",
        resetLedTip: "Turn off locator LEDs for all components.",
        resetLedTipSelected: "Turn off locator LEDs for selected components.",
        SAS: "SAS",
        "SAS-S": "SAS-S",
        SATA: "SATA",
        "SATA-S": "SATA-S",
        selected: "Selected",
        serialNumber: "Serial Number",
        setLedFailed: jQuery.format("Failed to turn on LED for target: {0}, ID: {1}"),
        setLedLabel: "Turn On LEDs",
        setLedProcessing: jQuery.format("Turning on LED for target: {0}, ID: {1}"),
        setLedSuccess: jQuery.format("Successfully turned on {0} locator LEDs"),
        setLedTip: "Turn on locator LEDs for selected components.",
        Size: "Size",
        state: "State",
        statusCol: "Status",
        status: "Status",
        tabular: "Tabular",
        type: {
            compactFlash: "CompactFlash",
            controller: "Controller",
            disk: "Disk",
            drawer: "Drawer",
            enclosure: "Enclosure",
            expander: "Expander",
            expPort: "Expansion Port",
            fan: "Fan",
            iom: "I/O Module",
            netPort: "Network Port",
            port: "Host Port",
            powerSupply: "Power Supply",
            sidePlane: "SidePlane"
        },
        typeCol: "Type"
    },
    easyStart: {
        alert: "<b>ALERT:</b>",
        availStorage: "Available Storage",
        completed: "Completed",
        configComplete: "You have successfully completed the initial setup steps. Click the button below to navigate away from the Welcome screen to the Home Topic view. You can still access the actions above from the Action menu.",
        degraded: "Degraded",
        degradedStateText: "There is something wrong with your system. Use the button below to help diagnose and solve any problems.",
        faulty: "Faulty",
        faultyStateText: "Before continuing, your system must be in good health. Use the button below to navigate to the System topic to help diagnose and solve any problems.",
        good: "Good",
        goToHome: "Go to Home topic",
        hostSetup: "Host Setup",
        intro: "Set up your system using the tools below.",
        mustCompleteConfig: "You need to complete System Settings before continuing to Storage Setup.",
        mustCompleteFirmware: "You need to complete the Upgrade Firmware step before continuing to System Settings.",
        knowWhatDoing: "Know what you're doing?",
        returnLater: "You can return to these actions from the Action menu later.",
        required: "Required",
        skipWelcome: "Skip the Welcome screen",
        storageSetup: "Storage Setup",
        storageCompleteSetup: "Storage Setup",
        sysHealth: "System Health",
        sysInfo: "System Information",
        sysSettings: "System Settings",
        upgradeFirmware: "Upgrade Firmware",
        welcome: "Welcome!"
    },
    homeTopic: {
        cacheTitle: "Cache",
        diskGroupSize: "Disk Group Size",
        diskGroupTitle: "Disk Group Utilization",
        linearLabel: "Linear",
        linearTitle: jQuery.format("{0} Volumes, {1} Snapshots"),
        logicalCapLabel: "Logical:",
        noPool: "No Virtual Pool",
        noVdisk: "No Linear Pools",
        pagedLabel: "Virtual",
        pagedTitle: jQuery.format("{0} Volumes, {1} Snapshots"),
        percentUsed: "% Used",
        physicalCapLabel: "Physical:",
        storageTitle: "Storage",
        vdiskSize: "Disk Group Size",
        vdiskTitle: "Disk Group Utilization"
    },
    hostsTopic: {
        groupCol: "Group",
        hostCol: "Host",
        relatedMaps: "Related Maps",
        hosttype: "Host Type",
        nickname: "Nickname",
        profile: "Profile",
        discovered: "Discovered",
        mapped: "Mapped"
    },
    mappingTopic: {
        accessCol: "Access",
        hostCol: "Group.Host.Nickname",
        lunCol: "LUN",
        portsCol: "Ports",
        volumeCol: "Volume"
    },
    perfTopic: {
        avgIOSize: "Average I/O Size",
        avgRdIOSize: "Average Read I/O Size",
        avgRdRespTime: "Average Read Response Time",
        avgRespTime: "Average Response Time",
        avgWrtIOSize: "Average Write I/O Size",
        avgWrtRespTime: "Average Write Response Time",
        components: "Components",
        controllers: "Controllers",
        count: "Count",
        cpuLoad: "CPU Load",
        current: "Current Data",
        dataRate: "Data Throughput",
        dataRead: "Data Read",
        dataReadRate: "Read Throughput",
        dataWriteRate: "Write Throughput",
        dataTransfer: "Data Transferred",
        dataWrite: "Data Written",
        diskGrps: "Disk Groups",
        disks: "Disks",
        endDate: "End&nbsp;Date",
        exportPerf: "All the historical performance statistics are saved to a file in CSV format. You can specify the time frame of the data to be retrieved. By default all available data, aggregated into 100 samples, will be retrieved.",
        failureMsg: "Failed to collect historical performance data. ",
        historical: "Historical Data",
        histPerfDesc: "The historical graphs show the 100 most recent 15-minute data samples by default. To change the time range of the samples and update displayed data, click Set Time Range.",
        hostPorts: "Host Ports",
        IOPSLabel: "IOPS",
        ioResp: "I/O Response",
        livePerfDescr: "Current data samples show the most recent data samples updated every 30 seconds.",
        noDataFound: "No historical performance data was returned because historical data statistics were recently reset.<br>You must wait 15-30 minutes after resetting statistics to view new data.",
        noteText: "Note: The time range has been adjusted to accommadate 100 samples. Refer to help for more information.",
        novalidData: "No valid data available.",
        numAllocPages: "Number of Allocated Pages",
        numOfdiskErrs: "Number of Disk Errors",
        NumOfDisks: "# Disks",
        numOfInitAlloc: "Number of Initial Allocations",
        numOfIO: "Total I/Os",
        numOfPageReb: "Number of Page Rebalances",
        numOfPagesCopied: "Number of Pages Copied",
        numOfPagesDiscarded: "Number of Pages Discarded",
        numOfReads: "Number of Reads",
        numOfRFCCopies: "Number of RFC Copies",
        numOfZeroPagesReclaimed: "Number of Zero-Pages Reclaimed",
        numOfUnmaps: "Number of Unmaps",
        numOfWrites: "Number of Writes",
        numPageMovesIn: "Number of Page Moves In",
        numPageMovesOut: "Number of Page Moves Out",
        PagesAllocPerMin: "Pages Alloc/Min",
        PagesDeallocPerMin: "Pages Dealloc/Min",
        PageUnmapsPerMin: "Pages Unmapped/Min",
        perfPool: "Pool",
        perfTier: "Tier",
        qdepth: "Queue Depth",
        readCacheRatio: "Read Cache Hit Ratio (%)",
        readIOPS: "Read IOPS",
        readResp: "Read Response",
        resetBtn: "Reset",
        resetConfirm: "Are you sure you want to reset performance statistics?",
        resetDesc: "Reset clears the stored performance statistics for all components. Choose the statistics type to reset.",
        resetFailure: "Failed to reset performance statistics.",
        resetLabel: "Reset Disk Performance Statistics",
        resetProcess: "Resetting performance statistics.",
        resetSuccess: "Succeeded in resetting performance statistics.",
        samplePeriod: "Total Duration of All Data Samples",
        sampleTime: "Sample Time",
        saveFailure: "Failed to save historical performance statistics.",
        saveProcess: "Saving performance statistics data.",
        saveSuccess: "Historical performance data file was created.",
        selectCompText: "Select components from the table and click Show Data, below.",
        setTimeRange: "Set time range",
        showData: "Show Data",
        showIndexLbl: "Show Legend",
        showLabel: "Show",
        startDate: "Start&nbsp;Date",
        statistics: "Statistics",
        statTypeLable: "Statistics Type",
        strgPoolLabel: "Virtual Pools",
        strgTierLabel: "Virtual Tiers",
        timeRange: "Time Range",
        totIOPS: "Total IOPS",
        updateDesc: "Please specify either the count or the time period of samples to display.",
        volumes: "Volumes",
        writeCacheRatio: "Write Cache Hit Ratio (%)",
        writeIOPS: "Write IOPS",
        writeResp: "Write Response"
    },
    poolsTopic: {
        diskGroupsTitle: "Related Disk Groups",
        disksTitle: "Related Disks",
        noPools: "No Pool defined",
        health: "Health",
        totalSize: "TotalSize",
        storagetype: "Class",
        avail: "Avail",
        diskType: "Disk Type",
        free: "Free",
        currentjob: "Current Job",
        status: "Status",
        disks: "Disks",
        usage: "Usage"
    },
    repsTopic: {
        activeReplications: "Active Replications",
        collPolicy: "Collision&nbsp;Policy",
        conStatus: "Status",
        connPorts: "Connected Ports",
        connStatus: "Connection&nbsp;Status",
        connTime: "Connection&nbsp;Time",
        creatDateTime: "Creation&nbsp;Date/Time",
        ctrlrAIP: "Controller&nbsp;A&nbsp;IP",
        ctrlrBIP: "Controller&nbsp;B&nbsp;IP",
        DestinationVol: "Destination Volume",
        directionInbound: "Inbound",
        directionOutbound: "Outbound",
        estCompTime: "Est&nbsp;Completion&nbsp;Time",
        failbackInProgress: "Failback in Progress",
        health: "Connection Health",
        imgSrc: "Image Source",
        imgSerial: "Image Serial Number",
        lastGoodUpdate: "Last Successful Run",
        lastUpdate: "Last&nbsp;Update",
        lastUpdateStatus: "Last Update Status",
        linkType: "Link Type",
        localPorts: "Local Ports",
        localSnapName: "Local Snapshot Name",
        maxQImgs: "Max&nbsp;Queued&nbsp;Images",
        mediaType: "Type",
        monitor: "Monitor",
        namestr: "Name",
        notCurrSupp: "Not currently supported",
        peerConnHealth: "Health",
        peerConnStatus: "Status",
        peerConnections: "Peer Connections",
        peerDestSystemName: "Destination System Name",
        primSnapshot: "Primary Snapshot",
        primaryVol: "Primary Volume",
        primaryVolSnap: "Primary Volume Snapshot",
        priority: "Priority",
        priority: "Priority",
        priorityVal: "Priority&nbsp;Value",
        progress: "Progress",
        remotePorts: "Remote Ports",
        remoteSystems: "Remote Systems",
        remoteSystemName: "Remote System Name",
        repImages: "Replication Images",
        repSets: "Replication Sets",
        repSetSnapHistory: "Replication Snapshot History",
        repSetName: "Replication Set Name",
        repStatus: "Replication&nbsp;Status",
        repVolDeleted: "No Information Available",
        replications: "Replications",
        secSnapshot: "Secondary Snapshot",
        secondaryVol: "Secondary Volume",
        secondaryVolSnap: "Secondary Volume Snapshot",
        serNum: "Serial Number",
        shareddata: "Shared&nbsp;Data",
        size: "size",
        snapData: "Snap&nbsp;Data",
        snapShotName: "Snapshot Name",
        snapshotType: "Snapshot&nbsp;Type",
        snapshotSize: "Snapshot Size",
        status: "Status",
        statusReason: "Status&nbsp;Reason",
        startDateTime: "Start&nbsp;Date/Time",
        strgPool: "Storage Pool",
        strtTime: "Start Time",
        susTime: "Suspended&nbsp;Time",
        suspended: "Suspended",
        time: "Replication Time",
        uniqueData: "Unique&nbsp;Data"
    },
    systemTopic: {
        frontLabel: "Front",
        rearLabel: "Rear",
        tabularLabel: "Table"
    },
    volumesTopic: {
        allocSizeCol: "Allocated",
        groupCol: "Group",
        maps: "Maps",
        noData: "No data for selected volumes.",
        noMaps: "No maps for selected volumes.",
        noReps: "No replication-sets for selected volumes.",
        noScheds: "No schedules for selected volumes.",
        noSnaps: "No snapshots for selected volumes.",
        poolCol: "Pool",
        snaps: "Snapshots",
        schedules: "Schedules",
        size: "Size",
        type: "Type"
    },
    certInfo: {
        controllerA: "A",
        controllerB: "B",
        certStatus: "Status",
        certCreated: "Created",
        certText: "Certificate Contents"
    },
    compactFlashHover: {
        cache: "Cache Flush",
        name: "Name",
        status: "Status"
    },
    controllerHover: {
        descrLabel: "Description",
        hwVersionLabel: "Hardware Version",
        idLabel: "ID",
        ipLabel: "IP Address",
        modelLabel: "Model",
        revLabel: "Revision",
        serialLabel: "Serial Number",
        statusLabel: "Status",
        systemMemorySize: "System Cache Memory (MB)",
        cpldVersion: "CPLD Version",
        storageControllerVersion: "Storage Controller Code Version",
        storageControllerType: "Storage Controller CPU Type",
        partNumber: "Part Number",
        position: "Position",
        hardwareVersion: "Hardware Version",
        mfgDate: "Manufacturing Date",
        mfgLocation: "Manufacturing Location"
    },
    diskGroupHover: {
        adaptActualSpareCapacity: "Adapt Actual Spare Capacity",
        adaptTargetSpareCapacity: "Adapt Target Spare Capacity",
        allocPagesLabel: "Allocated Pages",
        availPagesLabel: "Available Pages",
        chunkSizeLabel: "Chunk Size",
        nameLabel: "Name",
        ownerLabel: "Owner",
        poolLabel: "Pool",
        poolPctLabel: "% of Pool",
        serialLabel: "Serial Number",
        spareCountLabel: "Spares",
        tierLabel: "Tier",
        sectorFormatLabel: "Sector Format",
        created: "Created",
        minDiskSize: "Minimum Disk Size",
        dsdEnable: "Active Drive Spin Down Enable",
        size: "Size",
        free: "Free",
        raid: "RAID",
        disks: "Disks",
        status: "Status",
        currentJob: "Current Job"
    },
    diskHover: {
        fdeLockKeyLabel: "FDE Lock Key",
        fdeStateLabel: "FDE State",
        jobLabel: "Job Running",
        locationLabel: "Location",
        modelLabel: "Model",
        piFormattedLabel: "PI Formatted",
        powerOnHours: "Power On Hours",
        revisionLabel: "Revision",
        rpmLabel: "r/min",
        sectorFormatLabel: "Sector Format",
        serialLabel: "Serial Number",
        sizeLabel: "Size",
        ssdLifeLabel: "SSD Life Left",
        statusLabel: "Status",
        typeLabel: "Type",
        usageLabel: "Usage",
        vendorLabel: "Manufacturer",
        sectorFormatLabel: "Sector Format",
        tranferRateLabel: "Transfer Rate",
        smartLabel: "SMART",
        driveSpinDownLabel: "Drive Spin Down Count"
    },
    drawersHover: {
        drawerDisks: "Number of Disks",
        drawerInfo: "Drawer Information",
        drawerPosition: "Drawer Position",
        expanders: "Expanders",
        expanderName: "Expander Name",
        expanderStatus: "Expander Status",
        id: "ID",
        leftSideplaneInfo: "Left Sideplane Information",
        name: "Name",
        pathID: "Path ID",
        rightSideplaneInfo: "Right Sideplane Information",
        sideplane: "Sideplane",
        sideplaneStatus: "Sideplane Status",
        status: "Status",
        wwn: "WWN"
    },
    enclosureHover: {
        diskCountLabel: "Disk Count",
        idLabel: "ID",
        midSerialLabel: "Midplane Serial",
        modelLabel: "Model",
        revLabel: "Revision",
        statusLabel: "Status",
        vendorLabel: "Vendor",
        wwnLabel: "WWN",
        partNumberLabel: "Part Number",
        manufacturingDateLabel: "Manufacturing Date",
        manufacturingLocationLabel: "Manufacturing Location",
        empARevLabel: "EMP A Revision",
        empBRevLabel: "EMP B Revision",
        empABusLabel: "EMP A Bus ID",
        empBBusLabel: "EMP B Bus ID",
        empATargetLabel: "EMP A Target ID",
        empBTargetLabel: "EMP B Target ID",
        midPlaneLabel: "Midplane Type",
        enclosurePowerLabel: "Enclosure Power(watts)",
        PCIlabel: "PCIe 2-Capable"
    },
    expanderPortHover: {
        controller: "Controller",
        enclosure: "Enclosure",
        name: "Name",
        status: "Status"
    },
    fanHover: {
        internalFansInfo: "Internal Fans Information",
        location: "Location",
        name: "Name",
        speed: "Speed",
        status: "Status"
    },
    iomHover: {
        descrLabel: "Description",
        idLabel: "ID",
        revLabel: "Revision",
        serialLabel: "Serial Number"
    },
    networkHover: {
        gateway: "Gateway",
        ip: "IP Address",
        mask: "Network Mask",
        mode: "Mode",
        name: "Name",
        macAddress: "MAC Address"
    },
    peerConnectionsHover: {
        health: "Health",
        healthReason: "Health Reason",
        localPort: "Local Port",
        name: "Name",
        remotePort: "Remote Port",
        serial: "Serial Number",
        status: "Connection Status",
        type: "Connection Type"
    },
    perfHover: {
        portIopsLabel: "Port&nbsp;IOPS",
        portMbpsLabel: "Port&nbsp;MB/s"
    },
    poolHover: {
        allocPagesLabel: "Allocated Pages",
        availPagesLabel: "Available Pages",
        availSizeLabel: "Available",
        highThreshLabel: "High Threshold",
        lowThreshLabel: "Low Threshold",
        midThreshLabel: "Mid Threshold",
        nameLabel: "Name",
        overcommitLabel: "Overcommit",
        overcommitted: "Pool Overcommitted",
        ownerLabel: "Owner",
        sectorFormatLabel: "Sector Format",
        serialLabel: "Serial Number",
        sizeLabel: "Size",
        snapSize: "Snapshot Size",
        snapPages: "Snapshot Pages"
    },
    portHover: {
        actualSpeed: "Actual Speed",
        configSpeed: "Configured Speed",
        idLabel: "ID",
        ipAddress: "Address",
        ipDefaultRouter: "Default Router",
        ipGateway: "Gateway",
        ipLinkLocal: "Link-Local Address",
        ipNetmask: "Netmask",
        ipVersion: "IP Version",
        mac: "MAC Address",
        name: "Name",
        status: "Status",
        topology: "Topology",
        type: "Type"
    },
    powerSupplyHover: {
        defaultLabel: "Power Supply Unit",
        modelLabel: "Model",
        revLabel: "Revision",
        serialLabel: "Serial Number",
        statusLabel: "Status",
        vendorLabel: "Vendor",
        voltageRegulator: "Voltage Regulator",
        location: "Location",
        partNumber: "Part Number",
        mfgdate: "Manufacturing Date",
        mfglocation: "Manufacturing Location"
    },
    remoteSystemHover: {
        brand: "Product&nbsp;Brand",
        id: "Product&nbsp;ID",
        ipa: "IP&nbsp;Address&nbsp;Controller&nbsp;A",
        ipb: "IP&nbsp;Address&nbsp;Controller&nbsp;B",
        lastConn: "Last&nbsp;Connnected",
        status: "Status",
        sysContact: "System&nbsp;Contact",
        sysInfo: "System&nbsp;Information",
        sysLoc: "System&nbsp;Location",
        sysName: "System&nbsp;Name",
        username: "Username",
        vendor: "Vendor&nbsp;Name"
    },
    replicationImageHover: {
        baseVol: "Base Volume",
        creation: "Creation Date/Time",
        dg: "Disk Group",
        ect: "Estimated Completion Time",
        lastUpdate: "Last Update",
        local: " (local)",
        name: "Name",
        numSnaps: "Number of Snaps",
        numSnapsTree: "Number of Snapshots in Tree",
        noStatus: "(No Information - Secondary snapshot has been deleted)",
        parentVol: "Parent Volume",
        priority: "Priority",
        primaryVolSnap: "Primary Volume Snapshot",
        progress: "Progress",
        repSetStatus: "Replication Image Status",
        secondaryVolSnap: "Secondary Volume Snapshot",
        status: "Status",
        statusReason: "Status-Reason",
        start: "Start Date/Time",
        serial: "Serial Number",
        sharedData: "Shared Data",
        snapData: "Snap Data",
        snapPool: "Snap-Pool Name",
        snapNotCreated: " (Snapshot has not been created yet)",
        snapDeleted: " (Snapshot has been deleted)",
        sourceVol: "Source Volume",
        suspended: "Suspended",
        size: "Total Size",
        time: "Total Replication Time",
        type: "Type",
        uniqueData: "Unique Data",
        userPriority: "User Priority"
    },
    replicationSetsHover: {
        associatedSchedule: "Associated Schedule Name",
        currRunData: "Current Run Transferred Data",
        currRunTimeStart: "Current Run Start Time",
        eTC: "Current Run Estimated Time to Completion",
        lastRunData: "Last Run Transferred Data",
        lastRunEndTime: "Last Run End Time",
        lastRunStartTime: "Last Run Start Time",
        lastRunStatus: "Last Run Status",
        lastRunErrorStatus: "Last Run Error Status",
        lastSuccess: "Last Successful Run",
        name: "Name",
        peerConnection: "Peer Connection",
        primarySnapHist: "Primary Volume Snapshot History",
        primaryVolume: "Primary Volume",
        primaryVolumeGroup: "Primary Volume Group",
        primaryVolumeGroupSerial: "Primary Volume Group Serial",
        primaryVolumeSerial: "Primary Volume Serial",
        progress: "Current Run Progress",
        retentionCount: "Retention Count",
        retentionPriority: "Retention Priority",
        secondarySnapHist: "Secondary Volume Snapshot History",
        secondaryVolume: "Secondary Volume",
        secondaryVolumeGroup: "Secondary Volume Group",
        secondaryVolumeGroupSerial: "Secondary Volume Group Serial",
        secondaryVolumeSerial: "Secondary Volume Serial",
        serial: "Serial Number",
        snapBasename: "Snapshot Basename",
        status: "Status",
        queueCount: "Queue Count",
        queuePolicy: "Queue Policy"
    },
    rsrReplicationSetHover: {
        connStatus: "Connection Status",
        connTime: "Connection Time",
        linkType: "Link Type",
        location: "Location",
        maxRetry: "Maximum Retry Time (Seconds)",
        maxQueue: "Maximum Number of Queued Images",
        monitor: "Monitor",
        monitorInterval: "Monitor Interval",
        onCollision: "On Collision",
        onError: "On Error",
        priority: "Priority",
        repSetName: "Replication Set Name",
        secondaryVol: "Seconary Volume",
        serial: "Serial Number",
        status: "Status",
        statusReason: "Status-Reason",
        volName: "Volume Name",
        primaryVol: "Primary Volume"
    },
    scheduleHover: {
        count: "Retention Count",
        destDg: "Destination Disk Group",
        destDgSerial: "Destination Disk Group Serial",
        errorMessage: "Error Message",
        lastCreated: "Last Created",
        name: "Name",
        nextTime: "Next Time",
        prefix: "Prefix",
        replicationMode: "Replication Mode",
        snapName: "Snapshot Name",
        snapSerial: "Snapshot Serial",
        sourceVol: "Source Volume",
        sourceVolSerial: "Source Volume Serial",
        specification: "Schedule Specification",
        status: "Schedule Status",
        taskName: "Task Name",
        taskState: "Task State",
        taskStatus: "Task Status",
        taskType: "Task Type"
    },
    snapHover: {
        classLabel: "Class",
        nameLabel: "Name",
        priorityLabel: "Priority",
        retentionPriorityLabel: "Retention Priority",
        serialLabel: "Serial Number",
        sharedDataLabel: "Shared Data",
        snapDataLabel: "Snapshot Data",
        statusLabel: "Status",
        statusReasonLabel: "Status Reason",
        storagePool: "Pool",
        uniqueDataLabel: "Unique Data",
        userPriorityLabel: "User Priority",
        numberSnaps: "Number of Snaps",
        numberSnapshots: "Number of Snapshots in Tree",
        sourceVolume: "Source Volume",
        totalSize: "Total Size",
        creationDate: "Creation Date/Time",
        type: "Type",
        parentVolume: "Parent Volume",
        baseVolume: "Base Volume"
    },
    sparesHover: {
        sparesAvailable: "Spares Available",
        usage: "Disk Type",
        warningLabel: "* Minimum of 2 spares are required"
    },
    storageHover: {
        allocRate: "Allocation Rate",
        availSize: "Available Size",
        deallocRate: "Deallocation Rate",
        pagesPerMin: jQuery.format("{0} pages/min"),
        tierAllocLabel: "Allocated",
        tierAvailLabel: "Unallocated",
        tierDisksLabel: "Disks",
        tierPoolPctLabel: "%Pool",
        tiersLabel: "Tiers",
        tierReclaimLabel: "Page Reclaims",
        tierTotalLabel: "Total",
        totalSize: "Total Size",
        usedSize: "Allocated Size",
        snapSize: "Snapshot Size",
        tierAffinitySize: "Affinity Size"
    },
    tierHover: {
        allocRate: "Allocation Rate",
        availSize: "Available Size",
        deallocRate: "Deallocation Rate",
        pagesPerMin: jQuery.format("{0} pages/min"),
        percent: "% of pool",
        tierName: "Tier",
        totalSize: "Total Size",
        usedSize: "Allocated Size"
    },
    volumeHover: {
        allocSizeLabel: "Allocated&nbsp;Size",
        classLabel: "Class",
        freeLabel: "Free",
        freePercentLabel: "Percent Free",
        groupLabel: "Group",
        highThresholdLabel: "Critical",
        lowThresholdLabel: "Warning",
        masterVolumesLabel: "Master Volumes",
        midThresholdLabel: "Error",
        nameLabel: "Name",
        poolLabel: "Pool",
        readAheadSizeLabel: "Read-ahead&nbsp;Size",
        serialLabel: "Serial&nbsp;Number",
        sizeLabel: "Size",
        snapPoolInfo: "Snap Pool Info",
        statusLabel: "Status",
        thresholds: "Snap Pool Threshold settings",
        typeLabel: "Type",
        writePolicyLabel: "Write&nbsp;Policy",
        optimizationLabel: "Optimization",
        owner: "Owner",
        numSnaps: "Number Snapshots",
        numMaps: "Number Maps",
        numSchedules: "Number Scheduled Tasks",
        tierAffinity: "Tier Affinity",
        policyLabel: ", policy: ",
        snapshot: "Snapshots",
        volCopyJob: "Volume Copy Job"
    },
    abortReplication: {
        cannotAbort: "Must abort from the system that owns the primary volume.",
        confirm: "Click OK to abort replicating the volume on this set.",
        failure: "Unable to abort the replication.",
        inProgress: "Must select a replication that is currently running.",
        processing: "Aborting replication",
        selectRepSet: "Must select a single replication set.",
        success: "The replication has stopped."
    },
    abortVolumeCopy: {
        failure: jQuery.format("Unable to abort the volume copy for {0}"),
        noCopyInProgress: "No copy is in progress for this volume",
        panelWarning: jQuery.format("Are you sure you want to stop the volume copy operation for the selected volume?"),
        processing: "Aborting volume copy",
        success: jQuery.format("Volume copy for {0} has stopped.")
    },
    abortRsrReplication: {
        failure: jQuery.format("Unable to abort the replication of volume {0}."),
        infoTxt: "Click OK to abort the current replication being performed on this volume.",
        processing: jQuery.format("<b>Aborting the replication of volume {0}.</b><br>This should take a few seconds."),
        volName: "Secondary Volume",
        success: jQuery.format("Aborting replication of volume {0} was successful.")
    },
    addDiskGroup: {
        chunkLabel: "Chunk size",
        chunkSize: jQuery.format("{0}KB"),
        dataProtectionLabel: "Data Protection",
        disableSelectAll: "If the available disks are of different types, the select all checkbox is disabled",
        diskType: "Disk Type",
        enclosure: "Enclosure",
        failure: jQuery.format("Unable to create disk group {0}."),
        health: "Health",
        instructions: "<I><B>Add disks to the disk group by entering a range of disks or by selecting disks from the table below.</B></I>",
        invalidReadCaheDrive: "Read-Cache disk groups can be created only using SSDs.",
        location: "Location",
        levelLabel: "RAID Level",
        linear: "Linear",
        maxLimitWarning: "User selection exceeds maximum allowed disks for the disk group. Do you want to continue?",
        mixedTypeWarning: "All the disks in a disk group must be of the same type.",
        modeLabel: "Online Initialization",
        nameErr: "Enter a name for the disk group.",
        nameLabel: "Name",
        okButtonText: "Add",
        owner: jQuery.format("Controller {0}"),
        ownerLabel: "Assign to",
        poolLabel: "Pool",
        processing: jQuery.format("<b>Creating disk group {0}.</b><br>This should take a few seconds."),
        range: "Enter Range of Disks",
        rangeTip: "A comma-separated list disks or range of disks (with no spaces) example: 1.4-11,2.6-9 .",
        readCache: "Read Cache",
        subArraysLabel: "Number of Sub-groups",
        success: jQuery.format("Disk group {0} was created successfully."),
        title: "<b>Creating a disk group</b>",
        typeLabel: "Type",
        virtual: "Virtual",
        sectorFormatWarning: "The disk group will include both native and emulated format disks. This may result in lower performance under specific workloads. Where possible it is recommended to utilize the same format of disks in a disk group.<br /><br />Click Yes to continue and No to cancel.",
        selectAll: "Select All",
        defaultStorageTypeTip: "Please consider the following suggestion before provisioning:<br> After selecting a storage type and provisioning that storage, the system won't allow you to provision the other storage type until the selected storage is removed."
    },
    addRemoteSystem: {
        ipLabel: "IP address",
        infoTxt: "Enter a destination IP Address, username, and password to add a remote system.",
        usernameLabel: "User Name",
        passwordLabel: "Password",
        processing: jQuery.format("<b>Creating Remote System.</b><br>This should take a few seconds."),
        failure: jQuery.format("Unable to create Remote System. "),
        success: jQuery.format("Remote System {0} was created successfully."),
        enterIp: "Enter an IP Address.",
        enterUsername: "Enter a User Name.",
        enterPassword: "Enter a Password."
    },
    addStorage: {
        actionDescription: "Provision storage by selecting a storage profile and enclosure.",
        buttonText: "Add Storage",
        profileTable: "Defined profiles",
        enclosuresLabel: "Enclosure",
        processing: jQuery.format("<b>Adding storage for profile, {0}.</b><br>This should take a few seconds."),
        failure: jQuery.format("Unable to add storage for profile, {0}."),
        success: jQuery.format("The storage for profile, {0}, was added successfully.")
    },
    addToHost: {
        actionDescription: "Add the specified initiators to a host.",
        failure: "Unable to add the initiators.",
        hostListLabel: "Host Select",
        initatorNamesLabel: "Initiators to Add",
        processing: "<b>Adding the Initiators.</b><br>This should take a few seconds.",
        successPlural: "The initiators were added successfully.",
        successSingular: "The initiator was added successfully."
    },
    addToHostGroup: {
        actionDescription: "Add one or more hosts to a host group.",
        failure: "Unable to add the hosts.",
        hostGroupListLabel: "Host Group Select",
        hostNamesLabel: "Hosts to Add",
        processing: "<b>Adding the hosts.</b><br>This should take a few seconds.",
        successPlural: "The hosts were added successfully.",
        successSingular: "The host was added successfully."
    },
    addToVolumeGroup: {
        add: {
            failureMsg: jQuery.format("Error adding volumes to group {0}."),
            processingMsg: jQuery.format("Adding volumes to volume group {0}."),
            successMsg: jQuery.format("Successfully added volumes to group {0}.")
        },
        addVolumesAndCreateGroup: jQuery.format("Group <b>{0}</b> will be created and the selected volumes will be added.<br/>"),
        alreadyMember: "Some of the selected volumes are already a members of other groups. Adding these volumes to the designated group will remove these volumes from their original group.<br/>",
        create: {
            failureMsg: jQuery.format("Error creating volume group {0}."),
            processingMsg: jQuery.format("Creating volume group {0}."),
            successMsg: jQuery.format("Successfully created volume group {0}.")
        },
        confirmMsg: "Are you sure you want to change the group membership?<br/>",
        groupComboInfo: "Select a group from the list, or create a new group.",
        remove: {
            failureMsg: jQuery.format("Error removing volumes {0} from existing volume group {1}."),
            processingMsg: jQuery.format("Removing volumes {0} from existing volume group {1}, this will take a few seconds...")
        }
    },
    advSet: {
        advSetFail: "Unable to set the advanced settings.",
        advSetProcessing: "<b>Setting the advanced settings.</b><br>This should take a few seconds.",
        advSettingsText: "Advanced Settings",
        awtTriggerText: "Auto-Write Through Cache Trigger Conditions",
        awtTrCtlrFail: "Controller Failure",
        awtTrCachePower: "Cache Power",
        awtTrFlash: "CompactFlash",
        awtTrPSFail: "Power Supply Failure",
        awtTrFanFail: "Fan Failure",
        awtTrOverTemp: "Overtemperature Failure",
        awtNotifyOther: "Notify Other Controller",
        awtBehaviorText: "Auto-Write Through Cache Behaviors",
        awtRevert: "Revert when Trigger Condition Clears",
        bgScrub: "Disk Group Scrub",
        bgScrubInterval: "Disk Group Scrub Interval (hours)",
        cache: "Cache",
        cachePower: "Cache Power",
        confirmMsg: jQuery.format("Disabling some features ({0}) may prevent the system from detecting or recovering from failures.<br><br>Are you sure you want to proceed?"),
        disk: "Disk",
        diskScrub: "Disk Scrub",
        driveSpinDownEnable: "Available and Spare Drive Spin Down Capability",
        driveSpinDownDelay: "Drive Spin Down Delay (minutes)",
        dsdSuspendStartTime: "Time to Suspend",
        dsdSuspendResumeTime: "Time to Resume",
        dsdSuspendPeriod: "Drive Spin Down Suspend Period",
        dsdSuspendWeekdays: "Exclude Weekend Days from Suspend Period",
        dynamSpare: "Dynamic Spare Capability",
        firmware: "Firmware",
        high: "High",
        hostCtlCache: "Host Control of Write-Back Cache",
        indepCache: "Independent Cache Performance Mode",
        low: "Low",
        managedLogsEnable: "Managed Logs",
        medium: "Medium",
        minute: "minute",
        minutes: "minutes",
        missingLun: "Missing LUN Response",
        missingLunNR: "Not Ready",
        missingLunIR: "Illegal Request",
        pfu: "Partner Firmware Update",
        pollRate: "EMP Polling Rate",
        proceed: "Are you sure you want to proceed?",
        seconds: "seconds",
        separator: ", ",
        smartConfig: "SMART Configuration",
        smartconfig: "SMART configuration",
        smartNoMod: "Don't Modify",
        successMsg: "Successfully set the advanced settings.",
        syncCache: "Sync Cache Mode",
        syncCacheImmed: "Immediate",
        syncCacheFlush: "Flush to Disk",
        utilities: "System Utilities",
        utilPriority: "Utility Priority",
        sysCache: "System Cache",
        piMode: "End-to-End Protection Information Mode",
        cacheBlockSize: "Cache Block Size",
        advSetCacheConfirmMsg: "Disabling some features (CompactFlash, Cache Power) may prevent the system from detecting or recovering from failures. Are you sure you want to proceed?",
        systemCacheConfirmMsg: "Changing cache size or Protection Information (PI) mode will change system configuration, stop I/O, and restart both controllers. Are you sure you want to proceed?",
        cacheSetProcessing: "<b>Setting the system cache settings.</b><br>This should take a few seconds.",
        cacheSetFail: "Unable to set the system cache settings.",
        cacheSetSuccess: "The system cache settings were set successfully.",
        cacheMessage: "Cannot modify End-to-End Protection Information mode when the block size is 512."
    },
    checkRemoteLink: {
        failureMsg: "Remote link verification failed",
        infoMsg: "Click OK to query the remote system and list the remote ports that each local port can access. A port can only link to another port with the same host interface, such as Fibre Channel (FC).",
        processingMsg: jQuery.format("Verifying links to the system {0}.")
    },
    changeDiskGroupSpares: {
        error: "Unable to change the disk group spares.",
        modifying: "<b>Changing the disk group spares.</b><br>This should take a few seconds.",
        success: "The disk group spares were modified successfully.",
        sectorFormatWarning: "Adding the selected spare disks will cause the disk group to include both native and emulated format disks. This may result in lower performance under specific workloads. Where possible it is recommended to utilize the same format of disks in a disk group."
    },
    changeGlobalSparesAction: {
        error: "Unable to change the global spares.",
        modifying: "<b>Changing the global spares.</b><br>This should take a few seconds.",
        success: "The global spares were added successfully."
    },
    clearMetadataAction: {
        confirmMsg: jQuery.format("Are you sure you want to clear metadata from the following disks?<br />{0}<br />Clearing metadata from a disk that is a member of an offline or quarantined disk group could result in unrecoverable data loss."),
        description: "Select one or more disks in the table from which to clear leftover metadata.",
        failure: "Unable to clear the metadata.",
        processing: "<b>Clearing the metadata.</b><br />This should take a few seconds.",
        success: "The metadata was cleared successfully."
    },
    configureChap: {
        create: {
            failure: "Unable to add the new CHAP record.",
            processing: "Adding the new CHAP record.",
            success: "The new CHAP record was added successfully."
        },
        modify: {
            failure: "Unable to modify the CHAP record.",
            processing: "Modifying the CHAP record.",
            success: "The CHAP record was modified successfully."
        },
        remove: {
            confirmMsg: jQuery.format("Are you sure you want to delete CHAP record {0}?<br />Deleting CHAP records may make volumes inaccessible and the data in those volumes unavailable."),
            failure: "Unable to delete the CHAP record.",
            processing: "Deleting the CHAP record.",
            success: "The CHAP record was deleted successfully."
        },
        panelText: {
            actionDescription: "Manage and configure CHAP for iSCSI nodes.",
            caption: "CHAP records",
            deleteLabel: "Delete",
            hostNameLabel: "Node Name (IQN)",
            hostSecretLabel: "Secret",
            initiatorSecret: "Initiator Secret",
            mutualCheckBoxLabel: "Mutual CHAP",
            mutualNameLabel: "Mutual CHAP Name",
            mutualSecretLabel: "Mutual CHAP Secret",
            newLabel: "New",
            tips: {
                buttonDelete: "Delete selected CHAP record",
                buttonNew: "Create a new CHAP record",
                chapRecordTable: "CHAP records table"
            }
        },
        validation: {
            chapAlreadyExists: "A chap record with selected name already exists.",
            hostNameError: "Host Name is required",
            mutualNameError: "Mutual Name is required",
            noEmptySecret: "A password 12-16 character Secret is required."
        }
    },
    connectBar: {
        connectLabel: "Connection State",
        scLabel: "System State"
    },
    copyVolumeAction: {
        cannotMigrate: "Cannot migrate a volume that is mapped.",
        enterPrefix: "Enter a prefix.",
        failure: jQuery.format("Unable to create volume copy {0}."),
        modifiedSnap: "With Modified Data",
        newVolLabel: "New Volume",
        onVdisk: "Residing On Pool",
        prefixLabel: "New Volume Prefix",
        processing: jQuery.format("<b>Copying volume {0}.</b><br>This should take a few seconds."),
        scheduleLabel: "Schedule",
        scheduled: "Schedule?",
        scheduleDataLabel: "Schedule Data",
        scheduleFailure: jQuery.format("Unable to create the schedule for volume copy of {0}."),
        scheduleSuccess: jQuery.format("The schedule for volume copy of {0} was created successfully."),
        srcSnapLabel: "Snapshot",
        srcVolLabel: "Volume",
        success: jQuery.format("Volume copy {0} was created successfully."),
        unmountSourceConfirm: "Before copying the volume, the source volume should be unmounted,<br />or other action taken to ensure that there is no host I/O to it.<br />Proceed?",
        volWithMaps: "Cannot copy a virtual volume that is mapped.",
        withModified: "With Modified Data"
    },
    createInit: {
        failureMsg: jQuery.format("Failed creating initiator {0}"),
        hpux: "HP-UX",
        openVMS: "OpenVMS",
        idLabel: "Initiator ID (WWN/IQN)",
        infoText: "Create an initiator by specifying a WWN or IQN and a nickname.",
        nickLabel: "Initiator Name",
        processingMsg: jQuery.format("Creating initiator {0}"),
        profileLabel: "Profile",
        standard: "Standard",
        successMsg: jQuery.format("Successfully created initiator {0}")
    },
    createLinearVolumes: {
        attachPoolLabel: "Attach Pool",
        failure: jQuery.format("Unable to create volume {0}."),
        nameLabel: "Volume Name",
        nameSetLabel: "Volume Set Base Name",
        numVolumesLabel: "Number of Volumes",
        piSettingLabel: "Enable Protection Information (PI)",
        poolLabel: "Pool",
        prepareLabel: "Replication Prepare",
        processing: jQuery.format("<b>Creating volume {0}.</b><br />This should take a few seconds."),
        setFailure: jQuery.format("Unable to create {0} volumes with base name {1}."),
        setProcessing: jQuery.format("<b>Creating {0} volumes with base name {1}.</b><br />This should take a few seconds."),
        setSuccess: jQuery.format("{0} volumes with base name {1} were created successfully."),
        sizeLabel: "Volume Size",
        sizeTip: "Linear ADAPT volumes allocate disk group space in 8GiB memory chunks.  There must be a minimum of 8GiB remaining in the disk group, and you should expect disk group space to be consumed in multiples of 8GiB regardless of the volume size requested.",
        snappableTitle: "Enable Snapshots",
        snapPoolChoiceLabel: "Snap Pool",
        snapPoolLabel: "Snap Pool Size",
        standardLabel: "Standard Policy",
        success: jQuery.format("Volume {0} was created successfully."),
        freeSpaceUsageMsg: jQuery.format("This action will create a volume using all remaining available space. The size of this new volume will be {0} {1}. Are you sure you want to continue?")
    },
    createPeer: {
        destAddressLabel: "Destination Port Address (FC-WWN or iSCSI-IP)",
        failureMsg: jQuery.format("Failed creating peer {0}"),
        infoText1: "Create a peer by specifying a destination addresss and a name.",
        passwordInvalid: "The password is not valid",
        passwordLabel: "Remote User Password",
        peerNameLabel: "Peer Connection Name",
        processingMsg: jQuery.format("Creating peer connection {0}"),
        successMsg: jQuery.format("Peer connection {0} was created."),
        usernameInvalid: "The username is not valid.",
        usernameLabel: "Remote User Name"
    },
    createRemoteSystem: {
        a1Label: "A1",
        a2Label: "A2",
        a3Label: "A3",
        a4Label: "A4",
        b1Label: "B1",
        b2Label: "B2",
        b3Label: "B3",
        b4Label: "B4",
        confirmMsg: "You are about to create a remote system.  Proceed?",
        connStatus: "Connection Status",
        destId: "Destination Id",
        failureMsg: "There was a problem crating the Remote System.  Please check the help and try again.",
        fcLabel: "FC",
        ioPathLabel: "IO Path",
        ipAddr: "IP Address",
        ipLabel: "IP Address",
        iscsiLabel: "iSCSI",
        localWarning: "Selecting local ports to use is for advanced users.  This may affect which remote ports are reachable.",
        managementPathLabel: "Management Path",
        mediaType: "Media Type",
        nameLabel: "Remote System Name",
        passwordLabel: "Password",
        portLabel: "Label",
        portType: "Media",
        remotePortsLabel: "Reachable Remote Destinations",
        restrictLocalPortsLabel: "Control Local Ports",
        successMsg: "The Remote System was successfully created.",
        usePort: "Enable",
        usernameLabel: "User Name"
    },
    createLinearRepSet: {
        createLabel: "Create new volume on disk group",
        existingLabel: "Use existing replication-prepared volume",
        imageName: "Replication Image Name",
        imagePrefix: "Replication Image Prefix",
        initInfo: "Select the check box above to initiate or schedule replication; clear the check box to create a replication set now and replicate at a later time.",
        schedInfo: "Select the check box above to schedule a replication after the replication set has been created. ",
        schedLabel: "Scheduled (Configure reoccuring replications)",
        infoTxt: "Select a linear volume to use as the primary volume for the replication set",
        linkType: "Link Type",
        lastSnap: "Replicate most recent snapshot",
        local: " (local)",
        localLabel: "local",
        newSnap: "Create new snapshot, then replicate",
        noDgAvailable: jQuery.format("No {0} disk groups available"),
        noVolAvailable: jQuery.format("No {0} volumes available"),
        noVolSelected: "No volume selected",
        now: "Now",
        pairProcessing: jQuery.format("<b>Establishing replication set for volume {0}.</b><br>This should take one or two minutes."),
        pairFailure: jQuery.format("Unable to establish replication set for volume {0}."),
        pairSuccess: jQuery.format("Establishing replication set for volume {0} was successful."),
        remoteLabel: "remote",
        repMode: "Replication Mode",
        retCount: "Replication Images to Retain",
        selSystem: "Select a System",
        scheduled: "Scheduled",
        scheduleProcessing: jQuery.format("<b>Creating the schedule to initiate replication of volume {0}.</b><br>This should take a few seconds."),
        scheduleFailure: jQuery.format("Unable to create the schedule to initiate replication of volume {0}."),
        scheduleSuccess: jQuery.format("The schedule to initiate replication of volume {0} was created successfully."),
        secondarySystem: "Secondary System",
        secondaryVolume: "Secondary Volume",
        taskProcessing: jQuery.format("<b>Creating the task to initiate replication of volume {0}.</b><br>This should take a few seconds."),
        taskFailure: jQuery.format("Unable to create the task to initiate replication of volume {0}."),
        taskSuccess: jQuery.format("The task to initiate replication of volume {0} was created successfully."),
        vdisksProcessing: jQuery.format("<b>Obtaining disk groups information from remote system {0}.</b><br>This should take a few seconds."),
        vdisksFailure: jQuery.format("Unable to obtain disk groups information from remote system {0}."),
        vdisksSuccess: jQuery.format("Disk groups and volumes information from remote system {0} was obtained successfully."),
        volumesProcessing: jQuery.format("<b>Obtaining volumes information from remote system {0}.</b><br>This should take a few seconds."),
        volumesFailure: jQuery.format("Unable to obtain volumes information from remote system {0}."),
        volumesSuccess: jQuery.format("Volumes information from remote system {0} was obtained successfully.")
    },
    createReplicationSet: {
        badConnection: "A peer connection may be faulty. Cannot create a replication set.",
        destinationPoolLabel: "Peer System Pool",
        discard: "Discard",
        failureMsg: "Unable to create replication set",
        high: "high",
        initiateRepMsg: "The replication set was created. The first replication may take awhile. Do you want to begin a replication now?",
        initiateRepSuccess: "The replication has started.",
        initOrScheduleLater: "Once the replication set has been successfully created, you can initiate or schedule a replication using the Replicate action.",
        latest: "Queue Latest",
        low: "low",
        manualRepMsg: "You can initiate a manual replication using the Replicate action.",
        maxRepSets: "The maximum number of replication sets is already in use.",
        medium: "medium",
        neverDelete: "never-delete",
        noVolumes: "No virtual volumes available for replication. ",
        peerConnectionLabel: "Peer Connection",
        primaryVolSnapLabel: "Primary Volume Snapshot History",
        processing: "<b>Creating replication set</b><br>For a large volume group, this could take up to several minutes.",
        repSetNameLabel: "Replication Set Name",
        retentionCountLabel: "Retention Count",
        retentionPriorityLabel: "Retention Priority",
        scheduleLabel: "Scheduled (Configure reoccuring replications)",
        schedulerMsg: "The replication set was created. Click OK to schedule your replications.",
        schedulerSuccess: "The replication set was created. You will be directed to the scheduler.",
        secondaryVolNameLabel: "Secondary Volume Name",
        singleVolume: "Single Volume",
        snapshotBasenameLabel: "Snapshot Basename",
        snapHistLabel: "Secondary Volume Snapshot History",
        volGroupNameCol: "Group",
        volMembersCol: "Volumes",
        volNameCol: "Name",
        volPoolCol: "Pool",
        volSizeCol: "Size",
        volTypeCol: "Type",
        volumeGroup: "Volume Group",
        timeout: "Create replication command timed out",
        queuePolicyLabel: "Queue Policy"
    },
    createReplicationSetVol: {
        continuous: "Continuous (continuous replications)",
        extViewVolumeLable: "external view",
        failure: "Unable to create replication set",
        failureToReplicate: "Unable to replicate the volume.",
        groupMessage: jQuery.format("The selected volume is in Volume Group: <b>{0}</b>.<br />  Currently only the selected volume will be replicated."),
        initiateRepMsg: "The replication set was created. The first replication may take awhile. Do you want to begin a replication now?",
        processReplicate: "Replicating Volume",
        processingRepSet: "<b>Creating replication set</b><br>For a large volume group, this could take up to several minutes.",
        repSetNameLabel: "Replication Set Name",
        scheduleSuccess: "The replication set was created. You will be directed to the scheduler.",
        scheduled: "Scheduled (configure recurring replications)",
        schedulerMsg: "The replication set was created. Click OK to schedule your replications.",
        secondaryPoolLabel: "Secondary Pool",
        secondaryVolumeLabel: "Secondary Volume Name",
        selectPeer: "Select Peer Connection",
        selectVolLabel: "select a volume to replicate",
        sourceLabel: "Source",
        success: "The replication has started.",
        useGroup: "Replicate Volume Group",
        useVolume: "Replicate Volume",
        volMessage: jQuery.format("The selected volume is in Volume Group: <b>{0}</b>.<br /> Currently all volumes in the volume group will be replicated."),
        volumeGroupLabel: "Volume Group",
        volumeLabel: "Volume",
        timeout: "Create replication command timed out"
    },
    createSnapshot: {
        actionDescriptionMulti: "Create snapshots now.",
        actionDescriptionSingle: "Create a snapshot now or schedule snapshot creation.",
        actionDescriptionSingleNoSched: "Create a snapshot now.",
        creatingSnapshotLabel: "Snapshot Name",
        enterName: "Enter a snapshot name.",
        failure: jQuery.format("Unable to create the snapshot{0}."),
        processing: jQuery.format("<b>Creating the snapshot{0}.</b><br>This should take a few seconds."),
        retentionLabel: "Snapshots to Retain",
        scheduledCheckBoxLabel: "Scheduled",
        scheduleFailure: jQuery.format("Unable to create the schedule for snapshots of {0}."),
        scheduleProcessing: jQuery.format("<b>Creating the schedule for snapshots of {0}.</b><br>This should take a few seconds."),
        scheduleSuccess: jQuery.format("The schedule for snapshots of {0} was created successfully."),
        snapshotNameNotUnique: "Snapshot names must be unique.",
        snapshotPrefixLabel: "Snapshot Prefix",
        srcVolLabel: "Volume",
        success: jQuery.format("Snapshot{0} created successfully."),
        taskFailure: jQuery.format("Unable to create the snapshot task for {0}."),
        taskProcessing: jQuery.format("<b>Creating the snapshot task for {0}.</b><br>This should take a few seconds.")
    },
    createVirtualVolumes: {
        addRowLabel: "Add Row",
        badGeneratedName: jQuery.format("The base name {0} will generate at least one conflicting name: {1}."),
        completedMsg: "Volumes created successfully.",
        copiesCol: "Number of Volumes",
        copiesMsg: "&nbsp;Volumes with multiple copies will have a numeric suffix appended to the name shown.",
        createFailedMultMsg: jQuery.format("Failed creating volume set {0}."),
        createFailedOneMsg: jQuery.format("Failed creating volume {0}."),
        creatingMultMsg: jQuery.format("Creating volume set {0}."),
        creatingOneMsg: jQuery.format("Creating volume {0}."),
        exceededMaxVols: jQuery.format("Exceeded maximum number of volumes ({0})."),
        mapLabel: "Go to Mapping after creation",
        mapping: "You will be taken to the Mapping Topic upon successful creation.",
        nameChanged: "Name changed to avoid conflict.",
        newVolsCount1: jQuery.format("One new volume will be created in pool {0} ({1})."),
        newVolsCount1pool: jQuery.format("{0} new volumes will be created in pool {1} ({2})."),
        newVolsCount2pools: jQuery.format("{0} new volumes will be created, {1} in pool A ({2}), {3} in pool B ({4})."),
        newVols: "New Volumes",
        noVols: "There are no volumes specified to create.",
        overcommitted: jQuery.format("Action would overcommit pool {0} and overcommit is disabled."),
        piCol: "PI",
        poolCol: "Pool",
        poolDetails: jQuery.format("{0} volumes, {1} uncommitted, {2} free"),
        qualArchive: "Archive",
        qualityCol: "Preference",
        qualPerf: "Performance",
        qualNoAffinity: "No Affinity",
        removeRowLabel: "Remove Row",
        sizeCol: "Size",
        valError1: "Please correct the error in the table.",
        valErrors: jQuery.format("Please correct the {0} errors in the table."),
        volNameCol: "Volume Name",
        freeSpaceUsageMsg: jQuery.format("This action will create a volume using all remaining available space. The size of this new volume will be {0} {1}. Are you sure you want to continue?")
    },
    dateTimeSetup: {
        DateLabel: "Date",
        noDst: "Daylight Saving Time adjustment is not supported.",
        NtpLabel: "Network Time Protocol (NTP)",
        NtpServerLabel: "NTP Server Address",
        SetDateTimeLabel: "Set Date and Time",
        TimeLabel: "Time",
        TimeSetFail: "Unable to set the time values.",
        TimeSetProcessing: "<b>Setting the time values.</b><br>This should take a few seconds.",
        TimeSetSuccess: "The time values were set successfully.",
        TimeZoneLabel: "NTP Time Zone Offset"
    },
    deleteInit: {
        confirmMsg: "Deleting discovered initiators will delete only the initiator nickname. Discovered initiators will still be visible until they are no longer logged into the system.",
        failureMsg: "Failed deleting initiators",
        itemFailureMsg: jQuery.format("Failed deleting initiator {0}"),
        processingMsg: jQuery.format("Deleting initiator {0}"),
        successMsg: "Successfully deleted initiators.",
        warningText: "Delete the specified initiators?"
    },
    deletePeer: {
        actionDescription: "Delete peer connection.",
        failure: "Failed deleting peer connection.",
        failurePlural: "Failed deleting peer connections.",
        peerName: "Peer Connection",
        peerNamePlural: "Peer Connections",
        processing: "Deleting peer connection.",
        processingPlural: "Deleting peer connections.",
        success: "The peer connection was deleted.",
        successPlural: "The peer connections were deleted.",
        warning: "Are you sure you want to delete the peer connection?",
        warningPlural: "Are you sure you want to delete the peer connections?"
    },
    deleteLinearRepSet: {
        confirmMsg: jQuery.format("Are you sure you want to remove the replication set associated with volume {0}?<br />If you delete the replication set, further replications of the source volume will not be possible."),
        failureMsg: jQuery.format("Unable to remove the replication set associated with volume {0}."),
        infoTxt: "If you no longer want to replicate the primary volume, you can remove its replication set. For details about how replication-set components will be affected, see the online help.",
        processingMsg: jQuery.format("<b>Removing the replication set associated with volume {0}.</b><br>This should take a few seconds."),
        removeFromPrimary: "Must remove replication set from the system that owns the primary volume.",
        repSetName: "Replication set",
        successMsg: jQuery.format("Removing replication set from volume {0} was successful.")
    },
    deleteRemoteSystem: {
        confirmMsg: jQuery.format("Are you sure you want to delete the following remote system?<br />{0}<br />Deleting the remote system will prevent replication operations to or from that remote system."),
        failureMsg: jQuery.format("Failed to delete the Remote System {0}."),
        processingMsg: jQuery.format("Deleting the Remote System {0}..."),
        successMsg: jQuery.format("Successfully deleted the Remote System {0}."),
        sysNameLabel: "System Name",
        warningTxt: "Click OK to remove the remote system."
    },
    deleteReplicationSets: {
        activeSyncJob: "Cannot delete a replication that is currently running. Abort from the system that owns the primary volume, then delete.",
        failure: jQuery.format("Unable to delete the {0}."),
        panelWarning: jQuery.format("Are you sure you want to delete the {0}?<br />If you delete the replication set, further replications of the source volume will not be possible."),
        processing: jQuery.format("<b>Deleting the {0}.</b><br>This should take a few seconds."),
        repSetInProgress: "Cannot delete a replication that is currently running.",
        selectRepSet: "Must select at least 1 replication set.",
        successPlural: jQuery.format("The {0} were deleted successfully."),
        successSingular: jQuery.format("The {0} was deleted."),
        repSetSuspended: "Cannot delete a replication that is currently suspended."
    },
    deleteRsrSnapshot: {
        confirmMsg: jQuery.format("Are you sure you want to delete the snapshot of type {0}?<br><br>When the snapshot is deleted, all data in the snapshot will be lost."),
        failureMsg: "Unable to delete the snapshot.",
        infoTxt: "Click OK to delete the snapshot.",
        processingMsg: "<b>Deleting the snapshot.</b><br />This should take a few seconds.",
        snapAlreadyDeleted: "Local snapshot is already deleted from the replciation image",
        snapLabel: "Snapshot",
        successMsg: "The snapshot was deleted successfully."
    },
    deleteVolumes: {
        buttonText: "Delete",
        failure: jQuery.format("Unable to delete the {0}."),
        panelWarning: jQuery.format("Are you sure you want to delete the {0}?<br />When the volumes are deleted, all data in the volumes will be lost."),
        processing: jQuery.format("<b>Deleting the {0}.</b><br>This should take a few seconds."),
        successPlural: jQuery.format("The {0} were deleted successfully."),
        successSingular: jQuery.format("The {0} was deleted successfully.")
    },
    downloadCSV: {
        all: "All",
        columns: "Columns",
        dataChoiceLabel: "Data to Export",
        dataChoiceText: jQuery.format("Export data for all {0} or only the selected {0}?"),
        downloadStarted: "The CSV file should have started downloading",
        formatLabel: "Data Format",
        formatText: jQuery.format("Display {0} data in rows or columns?"),
        rows: "Rows",
        selected: "Selected",
        title: "Export Data to CSV",
        volumes: "volumes",
        volume: "volume",
        systemInfo: "system information"
    },
    detachReplicationVolume: {
        alreadyDetached: "The secondary volume is detached from the replication set already.",
        cannotDetach: "Must detach from the system that owns the secondary volume",
        confirmText: jQuery.format("Are you sure you want to detach replication volume {0}?"),
        detachProcessing: jQuery.format("<b>Detaching replication volume {0}.</b><br />This should take a few seconds."),
        detachFailure: jQuery.format("Unable to detach replication volume {0}."),
        detachSuccess: jQuery.format("Detaching replication volume {0} was successful."),
        infoTxt: "Click OK to detach this volume from the replication set.",
        secondaryVolLabel: "Secondary Volume"
    },
    diskGroupUtilities: {
        title: "Disk Group Utilities",
        verifyLabel: "Verify Disk Group",
        verify: "Verify Disk Group",
        abortVerify: "Abort Verify",
        scrubLabel: "Media Scrub Disk Group",
        scrub: "Scrub Disk Group",
        abortScrub: "Abort Scrub",
        verifyProcessing: "<b>Verifying the vdisk.</b><br>This utility may run for over an hour.",
        verifyFail: "Unable to verify the vdisk.",
        verifySuccess: "The vdisk verify started successfully.",
        abortVerifyProcessing: "<b>Aborting verify of the vdisk.</b>",
        abortVerifyError: "Unable to abort verify of the vdisk.",
        abortVerifySuccess: "The vdisk verify was aborted successfully.",
        jobRunning: jQuery.format("Job currently running: {0} ({1}%)"),
        needToAbort: "You will need to abort the current job prior to starting a new one.",
        needToWait: "You will need to wait for the current job to finish prior to starting a new one.",
        noJobRunning: "There are no jobs currently running. Click Verify or Scrub to start running the utility.",
        abortScrubProcessing: "<b>Aborting media scrub of the vdisk.</b>",
        abortScrubFail: "Unable to abort media scrub of the vdisk.",
        abortScrubSuccess: "The vdisk media scrub was aborted successfully.",
        scrubProcessing: "<b>Media scrubbing the vdisk.</b><br>This utility may run for over an hour.",
        scrubFail: "Unable to media scrub the vdisk.",
        scrubSuccess: "The vdisk media scrub started successfully."
    },
    dequarantine: {
        dgLabel: "Disk Group",
        processingMsg: "Removing the disk group from quarantine.",
        confirmMsg: "Removing this disk group from quarantine will take the disk group offline and could result in irreversible data loss.<br><br>Are you sure you want to proceed?",
        success: "The disk group was dequarantined successfully.",
        error: "Unable to dequarantine the vdisk.",
        quarantinedDiskGroup: "quarantined disk group",
        infoMsg: "Click OK to remove this disk group from quarantine."
    },
    eventList: {
        aiHeader: "Additional Information:",
        ctrlCol: "Ctrl.",
        eventCodeLabel: "Code",
        messageLabel: "Message",
        idCol: "ID",
        raHeader: "Recommended Action:",
        sevCol: "Sev.",
        timeCol: "Date/Time",
        messageTip: "Click to show or hide additional information."
    },
    exportSnapshot: {
        failureMsg: "Unable to export image as a snapshot.",
        infoTxt: "Click OK to export a replication image to a new, standard snapshot. The exported snapshot will reside in the snap pool. If the snap pool reaches its critical threshold, the snapshot may be deleted, even if it is mapped. To preserve the exported snapshot's data, create a volume copy of the exported snapshot.",
        imageWithSnap: "Must select a replication image with a local snapshot.",
        mustSelectRepImage: "Must select a replication image to export.",
        processingMsg: "<b>Exporting image as a snapshot.</b><br>This should take a few seconds.",
        snapNameLabel: "Snapshot Name",
        successMsg: "Exporting image as a snapshot was successful."
    },
    fde: {
        changePassphraseDescription: "Change Passphrase",
        Clear: "Clear",
        clearKeysConfirm: "Are you sure you want to clear the lock and import keys for this system?",
        clearKeysFailureMsg: "Failed to clear FDE keys",
        ClearKeysLabel: "Clear All FDE Keys",
        clearKeysProcessingMsg: "Clearing Keys",
        clearKeysSuccessMsg: "Successfully cleared FDE keys",
        confirmPassPhraseLabel: "Re-enter Passphrase",
        CurrentPphraseLabel: "Current Passphrase",
        enclID: "EnclosureID",
        FDEStateLabel: "FDE State",
        generalConfigLabel: "FDE General Configuration",
        importDisksLabel: "Set Import Lock Key ID",
        importFail: "Failed to set import lock ID.",
        importFDEDescription: "Import FDE Lock Key",
        importLockKey: "Import Lock Key",
        importProcessing: "<b>Setting import lock ID.</b><br/>This should take a few seconds.",
        importSuccess: "<b>Import lock ID successfully set.</b>",
        instructionsContd: "<br/><em>Enter the current passphrase to enable access to the configurations below</em>.",
        Instructions: "Use this tab to configure general settings for Full Disk Encryption.",
        LockKeyIDLabel: "Lock Key ID",
        messages: {
            clearKeys: "Clears all keys used with Full Disk Encryption.<br/>One use of this command is to temporarily deny access to data on the disks during a period when the system will not be under your physical control.",
            importKey: "Sets or changes the import lock key for the use of Full Disk Encryption.<br/>The import lock key is derived from the passphrase and is used to unlock secured disks that are inserted into the system from a different secure system.",
            passphraseNeedsSet: "<b>NOTE:</b> You must set a passphrase before the system can be secured.",
            repurposeDisks: "Use this tab to repurpose specified disks.<br/>For disks that support Full Disk Encryption, this action performs a secure erase of all data in the disks.",
            repurposeSystem: "Repurposes the system, which secure erases all disks and leaves the system in an unsecured state. Before starting this action, all data (including volumes and disk groups) must be deleted from the system.",
            secureSystem: "Changes the overall state of the system for the use of Full Disk Encryption.<br/>Use this option to secure the system. In a secured system, each disk is secure and inaccessible outside the current system.<br/>",
            setPassphrase: "Sets or changes the lock key for the use of Full Disk Encryption. The lock key is derived from the passphrase and stored within the system. Ensure you record the passphrase and lock key ID returned by the command, as they are not recoverable if forgotten."
        },
        passphraseFail: "<b>Setting the passphrase failed.</b>",
        PassphraseLabel: "Passphrase",
        passphraseProcessing: "<b>Setting the passphrase.</b><br/>This should take a few seconds.",
        passphraseSuccess: "<b>Passphrase changed successfully.</b>",
        setAndSecureSuccessMsg: "<b>System now secured.</b>",
        passVerEqual: "Passphrase and re-entered passphrase do not match.",
        repurposeDisksConfirm: "This will completely erase all data from the selected disks, making the data unrecoverable. Are you certain you want to repurpose the selected disks?",
        repurposeDisksDescription: "Repurpose FDE disks",
        repurposeDisksFail: "<b>Repurposing FDE disks failed.</b>",
        repurposeDisksLabel: "Repurpose Disks",
        repurposeDisksProcessing: "<b>Repurposing FDE disks.</b><br/>This should take a few seconds.",
        repurposeDisksSuccess: "<b>Disks successfully repurposed.</b>",
        Repurpose: "Repurpose",
        repurposeSysConfirm: "Are you sure you want to repurpose all disks in your system?",
        repurposeSystemFail: "<b>Repurposing FDE system failed.</b>",
        repurposeSystemLabel: "Repurpose System",
        repurposeSystemProcessing: "<b>Repurposing FDE system.</b><br/>This should take a few seconds.",
        repurposeSystemSuccess: "<b>System successfully repurposed.</b>",
        secureFdeFail: "<b>Securing the system failed.</b>",
        secureFdeProcessing: "<b>Securing the system with FDE.</b><br/>This should take a few seconds.",
        secureFdeSuccess: "<b>System successfully secured.</b>",
        SecureLabel: "Secure",
        Secure: "Secure",
        secureSystemLabel: "Secure System",
        selectAll: "Select All",
        SetAndSecure: "Set and Secure",
        SetPassphraseLabel: "Set/Create Passphrase",
        Set: "Set"
    },
    help: {
        aboutATS: "About automated tiered storage",
        aboutDiskGroups: "About disk groups",
        aboutDNS: "About configuring DNS settings",
        aboutFDE: "About Full Disk Encryption",
        aboutFirmwareUpdate: "About firmware update",
        aboutHandlingLinearStorage: "About the handling of linear storage",
        aboutHosts: "About hosts",
        aboutLDAP: "About LDAP",
        aboutLogManagement: "About log management",
        aboutMapping: "About volume mapping",
        aboutPerformanceStatistics: "About performance statistics",
        aboutQuickRebuild: "About quick rebuild",
        aboutRAID: "About RAID levels",
        aboutReconstruction: "About disk group reconstruction",
        aboutReplication: "About replication",
        aboutSASCabling: "About SAS Cabling",
        aboutSingleController: "About data protection with a single controller",
        aboutSnapshots: "About snapshots",
        aboutSpares: "About Spares",
        aboutSSDs: "About SSDs",
        aboutSSDReadCache: "About SSD read cache",
        aboutStoragePools: "About pools",
        aboutThinProvisioning: "About thin provisioning",
        aboutVirtualAndLinearStorage: "About virtual and linear storage",
        AboutVirtualStorage: "About virtual storage",
        aboutVolumeCache: "About volume cache options",
        aboutVolumeCopy: "About volume copy",
        aboutVolumes: "About volumes",
        bannerPanels: "Banner panels",
        closeTooltip: "Close help window",
        concepts: "System concepts",
        configLimits: "Configuration limits",
        contentsTitle: "Contents",
        firstTimeConfig: "Configuring and provisoning a new storage system",
        footerPanels: "Footer panels",
        gettingStarted: "Getting started",
        glossary: "Glossary",
        helpTitle: "Help",
        navTooltip: "Show/hide the table of contents",
        nextTooltip: "Go to next help page",
        notFoundMsg: jQuery.format('<link href="../css/helptext.css" rel="stylesheet" type="text/css"><h1 class="topictitle">Help Not Available</h1><p>Sorry, help is not available for {0}.</p>'),
        pinnedTooltip: "Help window is pinned (no context switching)",
        pinTooltip: "Pin help window (prevent context switching)",
        prevTooltip: "Go to previous help page",
        usingWBI: "Using this interface",
        wbiBrowserSetup: "Web browser requirements and setup",
        wbiColorCodes: "Color codes",
        wbiHelpTips: "Tips for using help",
        wbiInterfaceAreas: "Areas of the interface",
        wbiSignInOut: "Signing in and out",
        wbiSizes: "Size representations",
        wbiTableTips: "Tips for using tables",
        wbiTips: "Tips for using the WBI"
    },
    hostPorts: {
        AdvTab: "Advanced Settings",
        iscsiAdvTitle: "These settings apply to all iSCSI ports",
        ibAdvTitle: "These settings apply to all IB ports",
        param: " Param",
        portTab: "Port Settings",
        sasNoSettings: "There are no configurable settings for SAS."
    },
    hostSetup: {
        addToExisting: "Add to existing host group",
        attachedVolumes: "Attached volumes",
        belongsToHostGroup: "Belongs to a host group",
        createNew: "Create a new host group",
        chooseHost: "Choose a Host",
        configureAnother: "You have successfully configured the host. Would you like to configure another host?",
        configureHost: "Configure Host",
        dontGroup: "Do not group this host",
        existingVolumes: jQuery.format("You have chosen to add host {0} to an existing host group {1}. Host group {1} has storage configured already. All hosts within the host group will share the same storage. Below is a summary of the volumes that will be attached to host {0}."),
        fcZoning: "Fibre Channel zoning is required. Server HBAs must be zoned to storage targets, and single initiator to multiple target zoning is supported",
        iSCSI1: "If using iSCSI HBAs, they must be listed in the compatibility matrix",
        iSCSI2: "Install supported drivers and firmware",
        iSCSI3: "Verify IP Addresses are assigned to correct NICs. Assigning IP Addresses to the wrong port can lead to connectivity issues",
        iSCSI4: "If using jumbo frames, they must be enabled on all devices in the data path, NIC ports, switches, and storage system",
        intro: "Introduction",
        introText: "Before continuing, please verify that all prerequisites have been satisfied on the host before continuing.",
        installDrivers: "Install supported HBA drivers and firmware",
        installHBAs: "Install HBAs in the host server",
        initsGrouped: "All discovered initiators have been grouped into hosts. If you expect to see new initiators logged into this system, please return to the <b>Previous</b> screen and make sure you have attached the initiators to the system appropriately.",
        selectHost: "Select Host",
        groupHost: "Group Host",
        groupHostText: jQuery.format("Optional: Group host {0} together with other hosts so that all hosts within the group share the same storage. Host Groups can be used in clustering environments to group hosts together that all need to interact with a single volume or set of volumes."),
        hostDropdown: "Select Host",
        hostInits: "Host Initiators",
        hostName: "Host Name",
        mpio: "MPIO must be installed",
        mustHaveStorage: "Storage must be configured using the Storage Setup wizard first before using the Host Setup wizard.",
        newLinearVols: jQuery.format("{0} new volumes will be created ({1})."),
        noBlankInit: "Cannot have a blank nickname.",
        noInits: "The system has not discovered any initiators on the network. If you expect to see new initiators logged into this system, please return to the <b>Previous</b> screen and make sure you have attached the initiators to the system appropriately.",
        volumes: "Attach Volumes",
        SAS1: "Install supported SAS HBAs in the host servers",
        SAS2: "Install supported HBA drivers and firmware",
        SAS3: "HBAs must be directly connected to the storage system",
        selectHostText: "Create a host you would like to attach to storage. Give the host a name and select the initiators that belong to that host. You can also name the initiators so that you can easily identify them later.<br><br>The following initiators have been discovered by the system. If you expect to see initiators logged into this system that are not in the list below, return to the the <b>Previous</b> screen and make sure you have attached the initiators to the system appropriately.",
        summary: "Summary",
        summaryText: 'Below is a summary of your host configuration. After clicking "Configure Host", you will have the option to configure another host or close this wizard.'
    },
    initiateReplication: {
        cannotSchedule: "Must schedule replication from the system that owns the primary volume.",
        cannotReplicate: "Must replicate from the system that owns the primary volume.",
        confirm: "Click OK to replicate the volume.",
        failure: "Unable to initiate the replication.",
        inProgress: "A replication may already be running.",
        processing: "Initiating replication",
        rsrFailure: jQuery.format("Unable to initiate replication of volume {0}."),
        rsrProcessing: jQuery.format("<b>Initiating replication of volume {0}.</b><br>This should take a few seconds."),
        rsrSuccess: jQuery.format("Replication of volume {0} was initiated successfully."),
        selectRepSet: "Must select a single replication set.",
        success: "The replication has started.",
        queueSuccess: "The replication has been queued."
    },
    licenseMgmt: {
        button: "Install License File",
        completedMsg: "Command completed.",
        confirmTempLicenseBB: "Thank you for choosing to evaluate the advanced features of the storage system. The trial period is 60 days. The trial software was designed so that you can experience the functionality prior to purchase. Contact your sales representative for details on how to protect your data and to purchase a permanent license.",
        confirmTempLicenseHP: "Thank you for choosing to evaluate the advanced features of the storage system. The trial period is 60 days. The trial software was designed so that you can experience the functionality of this product prior to purchase. Contact your HP partner for details on how to protect your data and to purchase a permanent license.",
        EULA: "License agreement text is loading... ",
        expired: "Expired",
        expiredRenewable: "Expired/Renewable",
        expireNever: "Never",
        expiresInDays: jQuery.format("{0} days"),
        expiringIn: jQuery.format("<li>{0} expires in {1} days</li>"),
        expiringSoonIn: jQuery.format('<li class="error">{0} expires in {1} days</li>'),
        expiringTomorrow: jQuery.format('<li class="error">{0} expires TOMORROW</li>'),
        failureMsg: "Unable to load the license file.",
        instructions1noTemp: "Temporary Licensing not available. You may install a permanent license. ",
        instructions2: "You currently have a temporary license. You may install a permanent license.",
        licenseBase: "Base",
        licenseBaseTip: "Included without license",
        licenseExpiration: "Expiration",
        licenseExpirationTip: "Number of days left in temporary license",
        licenseInUse: "In Use",
        licenseInUseTip: "Number in use",
        licenseMax: "Max Licensable",
        licenseMaxTip: "Maximum number that can be licensed",
        licenseName: "Feature",
        licenseNameTip: "Name of licensable feature",
        licenseValue: "License",
        licenseValueTip: "Currently licensed",
        mustHaveManage: "Must have manage role to install a license.",
        okToCommit: "Click Apply button below to register license.",
        permLic: "Permanent License",
        processingMsg: "Uploading the license file",
        selectFileInstructions: "Select a license file for upload:",
        serNumLabel: "Licensing Serial Number",
        successMsg: "The license file was loaded successfully.",
        sysLicenses: "System Licenses",
        tabInstructions: "Use the Temporary License panel to enable features that are not permanently licensed.",
        tempInstructions: "This provides a limited-duration license to temporarily enable features that are not permanently licensed. At the end of the temp license period you may elect to license additional features. This temporary license is a one-time opportunity so cannot be renewed. Request a temporary license by reviewing the End User License Agreement then checking the acceptance checkbox below it.",
        tempLic: "Temporary License",
        tempLicenseError: "Unable to create the temporary license.",
        tempLicenseEULA: "I accept the terms of the license agreement",
        tempLicenseProcessing: "Creating the temporary license.",
        tempLicenseSuccess: "The temporary license was successfully installed.",
        tempPopupMsgPostBB: "You cannot reinstall the software after it expires. To avoid interruption, contact your sales representative for the appropriate software license.",
        tempPopupMsgPostHP: "You cannot reinstall the software after it expires. To avoid interruption, contact your HP partner for the appropriate software license.",
        tempPopupMsgPre: "The following temporary licenses are about to expire:",
        tempPopupTitle: "Temporary License Notice",
        versionLabel: "Licensing Version Number"
    },
    localLinkTask: {
        destPort: "Destination Port",
        infoTxt: "Select the local system to query the local partner controller and list the local host ports and their connections. Select a Remote System to query the remote ports that each local port can access. A port can only link to another port with the same host interface, such as Fibre Channel.",
        linkType: "Link Type",
        sourcePort: "Source Port",
        text: "Click OK to query the local system partner controller and list the local host ports and their connections.",
        processingMsg: "Verifying local system links.",
        failureMsg: "Link verification failed"
    },
    login: {
        authenticating: "<b>Authenticating ...</b>",
        browserIncompatible: "&nbsp;<b>Warning</b><br /><i>This browser version is not supported. Some features of this program may not work correctly. For the best user experience, use one of the supported browsers.<br />Supported browsers include:</i><br /><b>&nbsp;&nbsp;&nbsp;&nbsp;Firefox 10+<br />&nbsp;&nbsp;&nbsp;&nbsp;Internet Explorer 8+<br />&nbsp;&nbsp;&nbsp;&nbsp;Chrome 18+</b>",
        idleTimeout: "Login window timed out, Please refresh the window to reinitialize.",
        clear: "Clear",
        defaultLocale: "user language",
        failure: "<b>Unable to Authenticate Login, Try again.</b>",
        initializing: "<b>Initializing, please wait...</b>",
        language: "Language",
        login: "Sign In",
        password: "Password",
        prevVersion: "Click to launch previous version.",
        success: "<b>Authentication Successful, loading ...</b>",
        systemUnavailable: "&nbsp;<b>Warning</b><br /><i>The system is currently unavailable.</i>",
        user: "User name"
    },
    logoutRequest: {
        confirmMsg: "To proceed with your request to sign out, click Sign Out.",
        okLabel: "Sign Out",
        title: "Sign Out Request"
    },
    manageSchedules: {
        confirmMsg: jQuery.format("Are you sure you want to modify schedule:<br /> {0}"),
        delConfirmMsg: jQuery.format("Are you sure you want to delete schedule {0} and its associated task?"),
        deleteButtonText: "Delete Schedule",
        delScheduleFailure: jQuery.format("Unable to delete schedule {0}."),
        delScheduleProcessing: jQuery.format("<b>Deleting schedule {0}.</b><br>This should take a few seconds."),
        delScheduleSuccess: jQuery.format("Schedule {0} was deleted successfully."),
        navigateAway: "Do you want to navigate away and lose any schedule changes made?",
        scheduleFailure: jQuery.format("Unable to modify schedule {0}."),
        scheduleProcessing: jQuery.format("<b>Modifying schedule {0}.</b><br>This should take a few seconds."),
        scheduleSuccess: jQuery.format("Schedule {0} was modified successfully."),
        taskFailure: jQuery.format("Unable to modify task {0}."),
        taskProcessing: jQuery.format("<b>Modifying task {0}.</b><br>This should take a few seconds."),
        taskSuccess: jQuery.format("Task {0} was modified successfully.")
    },
    mapAction: {
        actions: {
            del: "Delete",
            none: "No Action",
            notMapped: "Not mapped",
            remove: "Remove Row",
            revert: "Revert",
            save: "Save"
        },
        confirmMultHosts: "To avoid multiple hosts mounting the volume and causing corruption, the hosts must be cooperatively managed, which can be accomplished with cluster software. <br /><br />",
        confirmAddOne: jQuery.format("{0} Add"),
        confirmAdds: jQuery.format("{0} Adds"),
        confirmDeleteOne: jQuery.format("{0} Delete"),
        confirmDeletes: jQuery.format("{0} Deletes"),
        confirmModifies: jQuery.format("{0} Changes"),
        confirmModifyOne: jQuery.format("{0} Change"),
        confirmPrefix: "Are you sure you want to perform the following mapping actions? <br />",
        confirmMsgDelete: "When a volume is unmapped from a host, the host will no longer be able to access the volume's data.",
        confirmDeleteMessage: "Removing the host mapping will result in loss of access from the host.  Are you sure you want to remove the host mapping?",
        deleteFailMsg: jQuery.format("Delete failed for host {0}, volume {1}."),
        deleteProcessingMsg: jQuery.format("Deleting map for host {0}, volume {1}."),
        hostGroupCol: "Group",
        hostHostCol: "Host",
        hostIdCol: "ID",
        hostNickCol: "Nickname",
        hostsTopTitle: "Available Host Groups, Hosts, and Initiators",
        infoTxt: "Click OK to remove all the mappings from the system.",
        instructionMsg: "Select one or more entries from Available Hosts and Available Volumes and click Map.",
        lunChanged: "LUN changed to prevent conflict.",
        mapActionCol: "Action",
        mapButtonLabel: "Map",
        mapButtonTip: "Populate table below with maps relating selected hosts and volumes.",
        mapConfirmTitle: "Map Confirmation",
        mapFailMsg: jQuery.format("Mapping failed for host {0} to volume {1}."),
        mapHostCol: "Host",
        mapLunCol: "LUN",
        mapModeCol: "Mode",
        mappingsTitle: jQuery.format("Mappings {0}"),
        mappingSucceeded: "Mapping actions succeeded.",
        mapPortsCol: "Ports",
        mapProcessingMsg: jQuery.format("Mapping host {0} to volume {1}."),
        mapVolCol: "Volume",
        noMaps: "There are no maps on the system.",
        removeAllProcessing: "Removing all mappings on the system.",
        removeAllSuccess: "Succesfully removed all mappings on the system.",
        removeAllFailure: "Failed to remove all mappings.",
        removeInfo: "Click OK to remove the following mappings:",
        resetButtonLabel: "Reset",
        resetButtonTip: "Clear the maps table below and reset.",
        successDelete: "Successfully removed the mappings.",
        volGroupCol: "Group",
        volNameCol: "Name",
        volTypeCol: "Type",
        volumeGroup: "Group",
        volumesTopTitle: "Available Volumes",
        volumesGroupTopTitle: "Available Volume Groups and Volumes",
        lunUsedConfirmMsg: "An existing mapping with the same LUN has been found. The new mapping may override the existing mapping on the same LUN. Changes could cause loss of data.<br />Do you want to continue?"
    },
    mapDetailAction: {
        accessCol: "Access",
        hostCol: "Host",
        hostGroupCol: "Host Group",
        idCol: "Initiator ID",
        lunCol: "LUN",
        nickCol: "Nickname",
        portsCol: "Ports",
        volGroupCol: "Volume Group",
        volumeCol: "Volume"
    },
    modifyDiskGroupAction: {
        confirmExpandMsg: "Depending on several factors, disk group expansion can take a significant amount of time to complete. The size of the physical disks in the original disk group, the amount of capacity being added, and the level of I/O activity during expansion will influence the time of completion.",
        confirmExpandMsgHP: "Depending on several factors, disk group expansion can take a significant amount of time to complete. The size of the physical disks in the original disk group, the amount of capacity being added, and the level of I/O activity during expansion will influence the time of completion.<br/>It is strongly recommended to review the Best Practices white paper before starting a disk group expansion. See the online help to access this white paper.",
        confirmChangeOwner: "Changing ownership of a disk group while any volumes in the disk group are mapped to live hosts is not supported and may cause data loss or unavailability. All volumes in the disk group must be unmapped or attached hosts must be shut down before the ownership of a disk group is changed. Volumes in other disk groups using a snap pool on this disk group may also be affected.",
        sectorFormatWarning: "Expanding the disk group with the selected disks will cause the disk group to include both native and emulated format disks. This may result in lower performance under specific workloads. Where possible it is recommended to utilize the same format of disks in a disk group.",
        dgDelayRangeError: jQuery.format("Please enter a delay for drive spin down between {0} and {1} minutes."),
        doingDataChange: jQuery.format("Modifying disk group: {0}"),
        doingExpand: "Expanding disk group.",
        enableSpinDown: "Enable Drive Spin Down",
        expandLabel: "Expand?",
        failedDataChange: "Failed to modify disk group.",
        failedExpand: "Failed to expand disk group.",
        nameLabel: "Name",
        nameParam: "name",
        newNameLabel: "New Name",
        okButtonText: "Modify",
        ownerLabel: "Owner",
        ownerParam: "owner",
        scrubDuration: "Scrub Duration Goal (hours)",
        scrubRangeError: jQuery.format("Please enter a disk group scrub interval between {0} and {1} hours."),
        spinDownDelay: "Drive Spin Down Delay (minutes)",
        subGroupsLabel: "Additional Sub-groups",
        success: "The disk group was modified successfully."
    },
    modifyInit: {
        failureMsg: jQuery.format("Failed modifying initiator {0}"),
        idLabel: "Initiator ID (WWN/IQN)",
        infoText: "Rename the specified initiator.",
        nickLabel: "Initiator Name",
        processingMsg: jQuery.format("Modifying initiator {0}"),
        successMsg: jQuery.format("Successfully modified initiator {0}")
    },
    modifyPeerConnection: {
        credentialLabel: "Remote System Credentials",
        description: "Enter a new name or a destination address to re-establish a connection.",
        failureMsg: jQuery.format("Could not modify peer connection {0}."),
        newNameLabel: "New Name",
        newAddressLabel: "New Remote Address (FC-WWN or iSCSI-IP)",
        processingMsg: "Modifying the peer connection...",
        remoteAddressLabel: "New Remote Address",
        setPeerName: "New Name",
        successMsg: "The peer connection has been modified successfully.",
        verifyConnection: "Verify Connection"
    },
    modifyReplicationSet: {
        failure: "Failed to modify the replication set.",
        inProgress: "Cannot modify a replication set when a replication sync is in progress.",
        noVolumeGroup: "Must select a replication set that does not contain a volume group.",
        processing: "Modifying the replication set.",
        retentionCountTip: "You will need to delete some snapshots from the replication set in order to reduce retention count to a value lower than the current number of snapshots in the replication set.",
        setRepSetName: "New Name",
        success: "The replication set has successfully been modified."
    },
    modifyVolumeAction: {
        cacheSettings: "Volume Cache Settings",
        CurrentSize: "Current Size",
        Expand: "Expand By",
        failure: jQuery.format("Unable to modify the volume {0}."),
        NewSize: "New Size",
        notInRange: "The value is either too small or would exceed the capacity of the storage pool.",
        ocNotInRange: "There is insufficient free disk space for the operation.",
        processing: jQuery.format("Modifying the volume {0}<br>This should take a few seconds."),
        setVolName: "New Name",
        success: jQuery.format("The volume {0} was modified successfully."),
        writeBack: "Write-back",
        writeOpt: "Write Optimization",
        writePolicy: "Write Policy",
        writeReadAhead: "Read Ahead Size",
        writeThrough: "Write-through",
        writeThroughConfirmMsg: "Enabling write-through cache mode will significantly impact write I/O performance, and should be used only when the system is operating in an environment with low or no fault tolerance.",
        optimizationConfirmMsg: "Changing the cache optimization setting while I/O is active can cause data corruption or loss. Before changing this setting, quiesce I/O from all initiators.",
        no_mirrorOptConfirmMsg: "Enabling no-mirror mode will improve write I/O response time, but at the risk of losing data during a failover.",
        readAheadSizeConfirmMsg: "Change the read-ahead size only if you fully understand how the host operating system, application, and adapter move data so that you can adjust the settings accordingly.",
        continueMsg: "Do you want to continue?"
    },
    networkConfig: {
        auto: "Auto",
        confirmMsg: "Changing the IP settings may disrupt access to this interface.",
        confirmMsg2: "Are you sure you want to apply these network settings?",
        DNSServer: "DNS Servers",
        DHCP: "DHCP",
        Manual: "Manual",
        auto: "Auto",
        nwDHCPLabel: "Addressing Mode",
        nwAtitleText: "Controller A",
        nwBtitleText: "Controller B",
        sourceLabel: "Source",
        nwDHCPValue: "DHCP",
        nwErrorA: "Unable to set the network parameters on Controller A.",
        nwErrorB: "Unable to set the network parameters on Controller B.",
        nwErrorDHCP: "Unable to set the controllers to DHCP.",
        nwIPaddrLabel: "IP address",
        nwIPgatewayLabel: "Gateway",
        nwIPmaskLabel: "IP mask",
        nwManualValue: "manual",
        nwModifyingA: "Setting the network parameters on Controller A.",
        nwModifyingB: "Setting the network parameters on Controller B.",
        nwModifyingDHCP: "Setting the controllers to use DHCP.",
        nwNotPresent: "Not Present",
        nwSuccess: "The network parameters were set successfully.",
        version4: "IPv4",
        version6: "IPv6",
        DNS: "DNS",
        Hostname: "Hostname",
        FQDN: "FQDN Name",
        Mode: "Mode",
        searchDomains: "Search Domains",
        server1: "Server1",
        server2: "Server2",
        server3: "Server3",
        domain1: "Domain1",
        domain2: "Domain2",
        domain3: "Domain3",
        staticLabel: "Static Addresses: ",
        autoLabel: "Auto Addresses: ",
        staticlabel1: "Address1",
        staticlabel2: "Address2",
        staticlabel3: "Address3",
        staticlabel4: "Address4",
        addressLabel: "Address Label",
        warning: jQuery.format("IP {0} already in use")
    },
    noteDisplayAction: {
        noteCol: "Notification"
    },
    notify: {
        confirmMsg: jQuery.format("You are disabling the following notification types: {0}.  Proceed ?"),
        defaultEmailDomain: "mydomain.com",
        clearDNS: "Clear DNS Settings",
        clearDNSSuccess: "DNS settings cleared successfully.",
        clearDnsProcessing: "Clearing the DNS parameters.",
        domainLabel: "Sender Domain",
        domainRequired: "Sender domain is required",
        dnsHeader: "Configure DNS",
        dnsSettings: "DNS Settings",
        dnsProcessing: "Setting the DNS parameters.",
        dnsFailure: "Failed to set the DNS parameters.",
        dnsClearFailure: "Failed to clear the DNS parameters.",
        email1Label: "Email Address 1",
        email2Label: "Email Address 2",
        email3Label: "Email Address 3",
        email4Label: "Email destination address",
        email: "Email",
        emailFailureMsg: "Failed to set the email notification parameters.",
        emailProcessingMsg: "Setting the email notification parameters.",
        emBlurb: "Configure SMTP and email notifications settings. Once SMTP settings are configured, email event notifications may be enabled.",
        emailDNSWarning: "Name server not configured in DNS Settings, system unable to resolve specified SMTP server. This is will result in email notification failure.",
        enableEmailNotif: "Enable Email Notifications",
        enabletls: "Enable TLS",
        eventError: "Unable to send test message.",
        eventProcessingMsg: "<b>Send notification messages.</b>",
        eventSuccess: "Test event sent. If you did not receive an email, look for event 611 in events for more information.",
        healthAlerts: "Enable Health Alerts",
        healthAlertsInfo: "Send a weekly reminder of system health issues (must enable email notifications)",
        host1Label: "Trap Host 1 Address",
        host2Label: "Trap Host 2 Address",
        host3Label: "Trap Host 3 Address",
        includeLogsLabel: "Include logs as an email attachment",
        levelLabel: "Notification Level",
        logsError: "Unable to send managed logs notification.",
        logsHeader: "Logs will be sent when they are ready for transfer to a remote log collection system.",
        logsNeedEmail: "Managed logs email log destination and log attachments requires email server and domain to be set.  Configure email tab and Apply to configure.",
        logsProcessing: "Sending managed logs notification.",
        logsSuccess: "Managed logs notification sent.",
        logTest1: "Notification Validation",
        logTest2: "After configuration is completed, use the button  <br /> on right to send a test event.",
        mlNeedEitherEmailOrSnmp: "Managed logs requires SNMP, Email, or both services to be configured.  Select the SNMP or Email tabs to configure services, then click <b>Apply</b>.",
        mLogsLabel: "Enable Managed Logs",
        mLogs: "Managed Logs",
        nameServers: "Name Servers",
        nameServerMandatory: "Name Server value is required for setting the DNS parameters.",
        searchDomains: "Search Domains",
        readCommLabel: "Read Community",
        portSelect: "Select Port",
        port: "Port",
        protocolTLS: "TLS",
        protocolSSL: "SSL",
        protocolNone: "None",
        securityProtocol: "Security Protocol",
        senderLabel: "Sender Name",
        sendManageLogs: "Test Managed Logs",
        sendSyslog: "Test Syslog",
        sendEmail: "Test Email",
        sendSnmp: "Test SNMP",
        senderPassword: "Sender Password",
        serverLabel: "SMTP Server",
        smtpSettings: "SMTP Settings",
        snmpDisabled: "The SNMP service is currently disabled.  SNMP can be enabled from the System Services available from the System Menu.",
        snmpFailureMsg: "Failed to set the SNMP notification parameters.",
        snmpInst: "Set the parameters to configure SNMP notification of events.",
        snmpProcessingMsg: "Setting the SNMP notification parameters.",
        snmp: "SNMP",
        successMsg: "Successfully set the email, SNMP, syslog, DNS and log notification configuration.",
        syslog: "Syslog",
        syslogProcessing: "Setting the Syslog notification parameters.",
        syslogFailure: "Failed to set the Syslog notification parameters.",
        syslogError: "Unable to send Syslog notification.",
        syslogTestProcessing: "Sending Syslog notification.",
        syslogSuccess: "Syslog notification sent.",
        tips: {
            emSmtpNotify: "SMTP must be configured for email notifications to be enabled.",
            mlDisabled: "SNMP or SMTP must be configured for managed logs to be enabled.",
            mlInclEmDisabled: "SMTP must be configured to include the log as an email attachment."
        },
        writeCommLabel: "Write Community",
        emailWarning: "Email settings are not enabled so a test event will not be sent to the configured email address. Do you want to continue?",
        emailNotConfigured: "No email address configured to send the test email. Do you want to continue?"
    },
    poolSettings: {
        overcommit: "Enable overcommitment of pool?",
        poolFailure: jQuery.format("Failed to set pool {0} parameters."),
        poolFailure: jQuery.format("Failed to set pool {0} parameters."),
        poolHigh: "High Threshold (fixed %)",
        poolLow: "Low Threshold (%)",
        poolMid: "Mid Threshold (%)",
        poolProcessing: jQuery.format("Setting pool {0} parameters."),
        poolToChange: jQuery.format("Change settings for pool {0}."),
        success: "Succeeded in setting pool parameters.",
        success: "Succeeded in setting pool parameters."
    },
    portconfig: {
        activeLanesLabel: "Active lanes",
        auto: "auto",
        auto_gb: "auto",
        both: "FC-and-iSCSI",
        cableTypeLabel: "Cable type",
        confirmHostPortMode: "This  will change host port configuration, stop I/O, and restart both controllers. ",
        confirm2HostPortMode: "The system settings configuration is not complete. After reboot you need to go back and complete the system settings configuration to continue with storage setup.<br>Click OK to continue",
        confirmFCMsg: "Altered FC loop IDs will not take effect until the affected controller is rebooted.<br /><br />Click Yes to continue.",
        defaultRouterLabel: "Default Router",
        defaultRouterErr: jQuery.format("Enter a valid default router for port {0}"),
        disabledLanes: "Disabled lanes",
        eight_gb: "8 Gbit/s",
        expectedLanes: "Expected lanes",
        sixteen_gb: "16 Gbit/s",
        FC: "FC",
        failureHostPortMode: " Failed to change host port mode settings.",
        failureFanoutMsg: "Failed to set fan-out settings on SAS ports.",
        failureFCMsg: "Failed to set the FC parameters.",
        failureIscsiMsg: "Failed to set the iSCSI parameters.",
        failureIBMsg: "Failed to set the IB parameters.",
        failure: jQuery.format("Unable to set the port parameters for: {0}"),
        fanoutCable: "Fan-Out",
        fanoutConfigLabel: "Fan-out Configuration",
        fanoutDescription: "For SAS Controllers, host ports can be configured to use fan-out SAS cables or standard SAS cables.",
        fanoutDisabled: "Disabled",
        fanoutEnabled: "Enabled",
        fanoutLabel: "Use fan-out cables.",
        fcIDrangeErr: "The loop ID must be 255 or between 0 and 125.",
        fcLinkStatusLabel: "Link Status",
        four_gb: "4 Gbit/s",
        gatewayErr: jQuery.format("Enter a valid gateway for port {0}"),
        gatewayLabel: "Gateway",
        guidLabel: "GUID",
        hostPortText: "The system is capable of supporting FC, iSCSI, or a mixed mode where two ports are FC and two ports are iSCSI (FC-iSCSI). Port Settings options above will change when a different Host Port Mode is selected. You will be prompted to accept restart of both controllers as a result of changing the Host Port Mode.",
        hostPortTitle: "Set Host Port Mode: ",
        ipErr: jQuery.format("Enter a valid IP address for port {0}"),
        ipLabel: "IP Address",
        iSCSI: "iSCSI",
        iscsi1g: "1 Gbit/s",
        iscsiChapLabel: "Enable Authentication (CHAP)",
        iscsiIpVersion4: "Version 4",
        iscsiIpVersion6: "Version 6",
        iscsiIpVersionLabel: "iSCSI IP Version",
        ibIpVersionLabel: "IB IP Version",
        iscsiIsnsAddressLabel: "iSNS Address",
        iscsiIsnsAltAddressLabel: "Alternate iSNS Address",
        iscsiIsnsAltIPerr: "Enter a valid alternate IP address for iSNS",
        iscsiIsnsIPerr: "Enter a valid IP address for iSNS",
        iscsiIsnsLabel: "Enable iSNS",
        iscsiJumboLabel: "Enable Jumbo Frames",
        iscsiSpeedLabel: "Link Speed",
        lanesExpectedLabel: "Lanes expected",
        modeLabel: "Connection Mode",
        netmaskErr: jQuery.format("Enter a valid netmask for port {0}"),
        netmaskLabel: "Netmask",
        portModeLabel: "Host Port Mode",
        p2p: "point-to-point",
        processingHostPort: "Changing host port mode settings.",
        processingFanoutMsg: "Setting fan-out settings on SAS ports...",
        processingIscsiMsg: "Setting the iSCSI parameters...",
        processingIBMsg: "Setting the IB parameters...",
        processing: jQuery.format("Setting the port parameters for: {0}"),
        required: "Required parameter",
        speedLabel: "Speed",
        stdCable: "Standard",
        successHostPortMode: "Successfully changed host port mode settings.",
        successFanoutMsg: "Successfully set fan-out settings on SAS ports.",
        successIscsiMsg: "Successfully set the iSCSI parameters.",
        successIBMsg: "Successfully set the IB parameters.",
        success: jQuery.format("Successfully set the port parameters for: {0}"),
        two_gb: "2 Gbit/s",
        primaryLoop: "Primary Loop ID",
        SFPStatus: "SFP status",
        partNumber: "Part Number",
        supportedSpeeds: "Supported Speeds",
        configSpeed: "Configured Speed",
        tenGCompliance: "10G Compliance",
        cableLength: "Cable Length",
        cableTech: "Cable Technology",
        ethernetCompliance: "Ethernet Compliance"
    },
    queryPeer: {
        controllerInfo: jQuery.format("Controller {0} Information"),
        failureMsg: "Failed to query the peer connection.",
        infoTxt: "Click OK to query the specified remote port address.",
        links: "Reachable Local Links",
        port: "Port",
        portHealth: "Port Health",
        portAddr: "Port Address",
        processingMsg: "Querying the specified remote host port peer connection...",
        sysContact: "System Contact",
        sysInfo: "System Information",
        sysLocation: "System Location",
        sysName: "System Name",
        successMsg: "Successfully queried the peer connection.",
        title: "Query Peer Connection",
        type: "Type",
        IPAddress: "IP Address",
        remotePort: "Remote Port Address (FC-WWN or iSCSI-IP)",
        version: "Version"
    },
    reattachReplicationVolume: {
        alreadyAttached: "The secondary volume is already attached to the replication set",
        cannotReattach: "Must reattach from the system that owns the secondary volume",
        confirmTxt: jQuery.format("Are you sure you want to reattach replication volume {0}?"),
        failure: jQuery.format("Unable to reattach replication volume {0}."),
        infoTxt: "Click OK to reattach the secondary volume to the replication set.",
        processing: jQuery.format("<b>Reattaching replication volume {0}.</b><br />This should take a few seconds."),
        secondaryVolLabel: "Secondary Volume",
        success: jQuery.format("Reattaching replication volume {0} was successful.")
    },
    recoveryManager: {
        accept: "Accept",
        alert: "Alert",
        beginFailbackRestore: "Begin Failback Restore",
        beginFailbackNoRestore: "Begin Failback No Restore",
        continueLabel: "Continue",
        confirmLabel: "Confirm Operation",
        completeFailback: "Complete failback restore",
        failbackRestore: "Failback Restore",
        failbackRestoreTxt: "Save and replicate the changes from the secondary volume or volume group to the primary volume or volume group. This will overwrite the data in the primary with the data of the secondary. Mappings on the primary and secondary volume or volume group will be deleted.",
        failbackNoRestore: "Failback No Restore",
        failbackNoRestoreTxt: "Discard any changes that may have been made to the secondary volume or volume group and resume a replication from the primary. Mappings on the secondary volume or volume group will be deleted. Mappings on the primary remain.",
        failoverLabel: "Failover",
        failoverSnapTxt: jQuery.format("Take a snapshot of the secondary volume or volume group. The snapshot will be consistent with the last successful replication run on the replication set {0}. For a single volume, you can set the snapshot name. For a volume group, snapshots need to be taken from the Volumes topic. Upon success, the snapshot(s) will appear in the Volumes topic."),
        failoverStepTxt: "Failover will allow you to access data in the recovery volume. After moving to the secondary, a recovery operation will be available once the peer connection status is Online.",
        failoverStepTxt2: 'By moving to the secondary volume or volume group:<br><ul><li>All active replications will be stopped</li><li>The replication set status changes to "Failed Over"</li><li>The secondary volume or volume group becomes accessible and has the same priviledges as the primary</li><li>A recovery operation will be available once the peer connection to the primary system is Online</li></ul>',
        failoverStepTxt3: 'Select this checkbox to enable the "Failover" button. Once the changes are applied, you will not be able to run a recovery operation until the peer connection status is Online.',
        failoverIntroTxt: "Use of Recovery Manager is a complex operation and is not intended for daily use. If your company has defined a data recovery plan, review it before using this utility. You should be familiar with replication functionality before using this utility.",
        failoverMapTxt: 'If you want to access volume data while the primary volume is down, map the secondary volume or volume group by selecting at least one initiator, host, or host group, then click the "Map" button to view mapping options. If you do not want to allow access or make changes to the data, click "Skip" to see a summary of changes.',
        failoverSummaryTxt: "You may now close the wizard and work with the secondary volume or volume group.",
        failoverSummaryTxt2: "Once the peer connection status is Online again, re-launch this wizard for Part 2 of the Recovery Manager to complete the recovery process.",
        failoverSummaryMap: "The secondary volume has been mapped and is available for access. The system will automatically remove the mapping during Part 2 of the Recovery Manager.",
        failoverSuccessMsg: jQuery.format("Successfully failed over replication set {0}"),
        failoverToSecondary: "Failover to Secondary",
        failoverFailureMsg: jQuery.format("Failed to failover replication set {0}"),
        failoverProcessingMsg: jQuery.format("Initiating failover of replication set {0}"),
        introLabel: "Introduction",
        isMapped: 'The secondary volume or volume group is currently mapped for read-write access. Since it is likely that changes were made to the secondary volume, the "Failback Restore" operation is recommended.',
        isNotMapped: 'The secondary volume or volume group is currently not mapped for read-write access. Since it is likely that no changes were made to the secondary volume, the "Failback No Restore" operation is recommended.',
        legend: "Legend",
        selectRepSet: "Must select a single replication set.",
        secondaryVol: "Secondary Volume",
        secondaryVolName: "Secondary Volume Name",
        secondaryVolInfo: "Secondary Volume Information",
        skip: "Skip",
        snapCreated: "Snapshot created",
        snapGroup: "It is recommended to take snapshots of the secondary volume group members. This can be accomplished in the Volumes topic.",
        snapLocation: "Snapshot location",
        snapName: "Snapshot Name",
        snapTaken: "Snapshot taken",
        stepLabel: jQuery.format("Step {0} of {1}: "),
        summaryLabel: "Summary",
        mapped: "Mapped",
        mapVolLabel: "Map Volume",
        noRestoreAlertText: "Using Failback No Restore will discard any changes made to the secondary volume/volume group. This is the recommended procedure to synchronize data between the primary and secondary using the most recent data saved on the current primary volume/volume group.",
        noRestoreConfirm: "By resuming from primary:",
        noRestoreConfirm1: "Any mappings to the <b>secondary</b> volume or volume group are removed",
        noRestoreConfirm2: "Any mappings to the <b>primary</b> volume or volume group remain",
        noRestoreConfirm3: "Any active replications or scheduled replications will resume on the primary",
        noRestoreConfirmMsg: "Mappings to the secondary volume or volume group will be removed. Any changes made to the secondary volume or volume group will be discarded.<br>Are you sure you want to continue?",
        mustSelectFromSecondary: "Must select replication set from the system that owns the secondary volume.",
        peerName: "Peer Connection Name",
        peerStatus: "Peer Connection Status",
        peerOfflineText: 'The peer connection status to the primary system is offline. Click "Continue" to proceed with Part 1 of the Recovery Manager in order to gain access to the secondary volume or volume group while the primary volume is unavailable.<br><br>Once the peer connection is back online, you can relaunch this wizard to complete Part 2.',
        peerOnlineText: "The peer connection status to the primary system is online. There is nothing to do at this time.",
        primaryVol: "Primary Volume",
        primaryVolName: "Primary Volume Name",
        recommended: "(recommended)",
        recoverLabel: "Recover",
        recovery: "Recovery",
        recoveryConfirm: "Once the replication completes, you will need to log into the primary system and re-launch Recovery Manager to complete failback and remap the primary volume.",
        recoveryIntro: "You have completed Part 1 of Recovery Manager. Since the peer connection status is Online, the replication set can be recovered.<br><br>Part 2 of Recovery Manager will guide you through the process of recovering the replication set back to a normal state. You will need to repair the replication set by selecting a Recovery Operation.",
        recoveryMapTxt: 'As part of the restore operation, any previous mappings to the primary volume have been removed. Re-map the primary volume or volume group by select at least one initiator, host, or host group to map the primary volume to, then click the "Map" button to view mapping options. If you wish to map the primary volume at a later time, click "Close" to exit this wizard.',
        recoverySnapTxt: '<span style="text-decoration: underline;">Take a snapshot of the <b>primary</b> volume or volume group</span><br>Before selecting a recovery operation, it is recommended to log into the primary system and take a snapshot of the primary volume or volume group in this replication set. You may want to save changes in case you select an operation that will overwrite data content.',
        recoverySnapTxt2: '<span style="text-decoration: underline;">Take a snapshot of the <b>secondary</b> volume or volume group</span><br>Take a snapshot to save any changes made to the secondary volume. For a single volume, you can set the snapshot name below. For a volume group, snapshots need to be taken from the Volumes topic. Upon success, the snapshot(s) will appear in the Volumes topic.',
        recoveryTip: "Once the data has been copied to the primary volume, you will need to log in to the primary system and launch Recovery Manager to finalize the failback operation for this replication set.",
        recoveryOpLabel: "Recovery Operation",
        recoverRestoreSummary: "Once the current replication has completed, log-in to the primary system to finalize the recovery process and remap the primary volume or volume group.",
        recoverNoRestoreSummary: "Recovery process has completed.<br><br>Replications will resume from the primary system.<br><br>You may now close out of this wizard.",
        recoverFailureMsg: jQuery.format("Failed to recover replication set {0}"),
        recoverSuccessMsg: jQuery.format("Successfully initiated recovery operation on replication set {0}"),
        recoverProcessingMsg: jQuery.format("Recovering replication set {0}"),
        repSetName: "Replication Set Name",
        repSetStatus: "Replication Set Status",
        restoreAlertText: "Using Failback Restore will overwrite data on the primary volume or volume group. This is the recommended procedure to synchronize data between the primary and secondary using the current data saved on the secondary volume or volume group.",
        restoreTxt: 'As a result from running the <b>failback restore</b> operation, the replication set must complete the failback process.<br><br>To finalize the recovery process, click "Complete failback restore".<br><br>Once completed, Recovery Manager will help you re-map the primary volume or volume group.',
        restoreSummary: "You have successfully completed the recovery process.<br><br>You may now close out of the wizard and resume replications from the primary volume or volume group on the primary system.",
        restoreConfirm: "By restoring from secondary:",
        restoreConfirm1: "Any mappings that exist on the primary and secondary volume or volume group will be removed",
        restoreConfirm2: "Changes will be copied to the primary volume or volume group. Primary volume or volume group data content will be overwritten with content from secondary volume or volume group.",
        restoreConfirm3: 'Once replication begins, the replication set status will show as "Running"',
        restoreConfirm4: "Once the replication completes, you will need to log into the primary system and re-launch Recovery Manager to complete failback and remap the primary volume",
        restoreConfirmMsg: "Data on the primary volume or volume group will be overwritten with data on the secondary volume/volume group. Mappings will be removed on the primary and secondary volume or volume group.<br><br>",
        restoreConfirmAppr: jQuery.format('Please approve this operation by typing "{0}" in the box below:'),
        restoreConfirmCont: "Are you sure you want to continue?",
        takeSnapLabel: "Take snapshots",
        takeSnapButton: "Take Snapshot",
        testRun: "Test run",
        testRunTip: "You can still run this utility for testing purposes. To continue this utility for testing, enable this checkbox.",
        volTopic: "Volumes topic",
        waitForFailover: "Replication set has not yet transitioned to Failover state.",
        whatIs: "What is Recovery Manager?",
        whatIsTip: "Recovery Manager is a disaster recovery utility that will guide you through the process to resume or restore replicated volumes after a replication set's primary system has gone offline. The necessary steps to complete the task are listed in the navigation guide of the wizard."
    },
    remoteSystemsManagement: {
        emptyTable: "Click <b>New</b> to create a new remote system.",
        SystemName: "System Name",
        LinkStatus: "Link Status",
        Check: "Check",
        System: "System",
        Location: "Location",
        Interfaces: "Interfaces",
        Ipa: "IP A",
        Ipb: "IP B",
        Status: "Status",
        Port: "Port",
        Links: "Links",
        Type: "Type",
        NewRow: "NewRow",
        deleteRs: {
            confirmMsg: jQuery.format("Are you sure you want to remove remote system {0}?<br />Deleting the remote system will prevent replication operations to or from that remote system."),
            processingMsg: jQuery.format("Removing remote system {0}."),
            error: jQuery.format("Unable to remove remote system {0}."),
            success: jQuery.format("Remote system {0} was removed successfully.")
        },
        create: {
            processingMsg: jQuery.format("Adding the new remote system {0}."),
            error: jQuery.format("Unable to add the new remote system {0}."),
            success: jQuery.format("The new remote system {0} was added successfully.")
        },
        modify: {
            confirmMsg: jQuery.format("Are you sure you want to modify remote system {0}?"),
            processingMsg: jQuery.format("Modifying the remote system {0}."),
            error: jQuery.format("Unable to modify the remote system {0}."),
            success: jQuery.format("The remote system {0} was modified successfully.")
        },
        checkLinks: {
            processingMsg: jQuery.format("Verifying links to the system {0}.")
        },
        navigateAway: "Do you want to navigate away and lose any changes made?"
    },
    removeDiskGroups: {
        deletePoolsSummary: "<br/><br/>Pools to be removed that contain volumes:<br/><br/>",
        deletePoolWarning: "<b>Removing all disk groups from a pool will remove the pool and all volumes in that pool. All data in the pool will be lost.</b>",
        failure: jQuery.format("Unable to remove the {0}."),
        poolWithVolumes: jQuery.format("{0}: containing {1} {2}<br/>"),
        processing: jQuery.format("<b>Removing {0}.</b><br>This should take a few seconds."),
        standardWarning: jQuery.format("<br/>Are you sure you want to remove the {0}?"),
        success: "The operation was successful."
    },
    removeFromHost: {
        actionDescription: "Remove the specified initiators from their hosts.",
        failure: jQuery.format("Unable to remove the initiators from host {0}."),
        initatorNamesLabel: "Initiators to Remove",
        processing: jQuery.format("<b>Removing the initiators from host {0}.</b><br>This should take a few seconds."),
        successPlural: "The initiators were removed successfully.",
        successSingular: "The initiator was removed successfully."
    },
    removeFromHostGroup: {
        actionDescription: "Remove the specified hosts from their host groups.",
        hostNamesLabel: "Hosts to Remove",
        panelWarning: jQuery.format("<b>Are you sure you want to delete the {0} from {1}?</b><br />If you remove a host from a host group, common configuration settings of the host group will be removed from that host."),
        successPlural: "The hosts were deleted successfully.",
        successSingular: "The host was deleted successfully."
    },
    removeFromVolumeGroup: {
        failureMsg: jQuery.format("Failed removing {0} from {1}."),
        processingMsg: jQuery.format("Removing {0} from {1}..."),
        removeWarning: jQuery.format("<b>Are you sure you want to delete the {0} from {1}?</b><br />If you remove a volume from a volume group, common configuration settings of the volume group will be removed from that volume."),
        successMsg: jQuery.format("Successfully removed {0} from {1}.")
    },
    removeHost: {
        actionDescription: "<b>Remove the specified hosts from the system.</b><br> Removing a host will not remove the initiators it contains.",
        failure: "Unable to remove the hosts.",
        hostNamesLabel: "Hosts to remove",
        processing: "<b>Removing host(s).</b><br>This should take a few seconds.",
        confrimMsg: jQuery.format("<b>Are you sure you want to delete the {0}?</b><br />Deleting a host will prevent you from being able to map volumes to it."),
        successPlural: "The hosts were removed successfully.",
        successSingular: "The host was removed successfully."
    },
    removeHostGroup: {
        confirmMsg: "Deleting all host groups will prevent you from being able to map a volume to a group of hosts in a single action.<br />Do you want to continue?",
        actionDescription: "<b>Remove the specified host groups from the system.</b><br>Removing a host group will not remove the hosts it contains.",
        failure: "Unable to remove the host groups.",
        hostGroupNamesLabel: "Host Groups to Remove",
        processing: "<b>Removing host group(s).</b><br>This should take a few seconds.",
        successPlural: "The host groups were removed successfully.",
        successSingular: "The host group was removed successfully."
    },
    removeVolumeGroup: {
        confirmMsgGroupsAndVols: jQuery.format("Are you sure you want to remove {0} and all the volumes it contains?"),
        confirmMsgGroupsOnly: jQuery.format("Are you sure you want to remove {0}?<br />Deleting volume groups will prevent you from being able to map a volume group to hosts in a single action."),
        DeleteVolumes: "Delete Volumes",
        failureMsg: jQuery.format("Failed removing {0}."),
        processingMsg: jQuery.format("Removing {0}..."),
        removeGroupsWarning: "Clicking OK will remove the selected groups.",
        removeVolsWarning: "<br/><b>This selection will result in all volumes belonging to this group being removed in the process.</b>",
        successMsg: jQuery.format("Successfully removed {0}.")
    },
    renameHost: {
        actionDescription: "Rename the specified host.",
        failure: "Unable to rename the host.",
        newNameLabel: "New Host Name",
        oldNameLabel: "Old Host Name",
        processing: "<b>Renaming host.</b><br>This should take a few seconds.",
        success: "The host was renamed successfully."
    },
    renameHostGroup: {
        actionDescription: "Rename the specified host group.",
        failure: "Unable to rename the host group.",
        newNameLabel: "New Host Group Name",
        oldNameLabel: "Old Host Group Name",
        processing: "<b>Renaming host group.</b><br>This should take a few seconds.",
        success: "The host group was renamed successfully."
    },
    renameVolumeGroup: {
        failureMsg: jQuery.format("Failed renaming {0} to {1}."),
        NewGroupName: "New Group Name",
        processingMsg: jQuery.format("Renaming {0} to {1}..."),
        successMsg: jQuery.format("Successfully renamed {0} to {1}.")
    },
    replicate: {
        cannotReplicate: "Must replicate from the system that owns the primary volume.",
        confirm: "Click OK to initiate or schedule a replication.",
        scheduleLabel: "Scheduled",
        taskName: "Task Name",
        lastSnapshot: "Last Snapshot"
    },
    replicateSnapshot: {
        failureMsg: jQuery.format("Unable to initiate replication of the snapshot {0}."),
        infoTxt: "Select a snapshot of the primary volume to replicate.",
        snapName: "Snapshot Name",
        snapLabel: "Snapshot",
        snapSize: "Snapshot Size",
        snapPool: "Pool",
        repFromPrimary: "Must select a replication set from the primary system.",
        repImageName: "Replication Image Name",
        repWithSnaps: "Must select a replication set that contains a primary volume with standard snapshots.",
        processingMsg: jQuery.format("<b>Initiating replication of the snapshot {0}.</b><br>This should take a few seconds."),
        selectSnap: "Must select a standard snapshot of a Primary Volume in a Replication Set.",
        successMsg: jQuery.format("The replication of snapshot {0} was initiated successfully.")
    },
    rescan: {
        button: "Rescan",
        confirmMsg: "Are you sure you want to rescan disk channels?<br />Performing a rescan will temporarily pause all I/O processes.",
        error: "Unable to rescan the disk channels.",
        instructions: "Click Rescan to start the rescan of disk channels.",
        processingMsg: "<b>Rescanning the disk channels.</b><br />This should take a few seconds.",
        success: "The disk channels were rescanned successfully."
    },
    resetHostPort: {
        title: "Reset Host Port",
        selectPort: "Select a port to reset",
        port: "Port",
        confirmMsg: "This would cause the connection from the host to storage to go down temporarily.<br />Are you sure you want to proceed?",
        processingMsg: "<b>Resetting the host port.</b><br>This should take a few seconds.",
        success: "The host port was reset successfully.",
        error: "Unable to reset the host port."
    },
    resetSnapshotAction: {
        confirmMsg: jQuery.format("To avoid data loss, unmount the snapshot {0} from all hosts before starting the reset operation. All data represented by the snapshot as it exists prior to issuing this command will be lost.<br />Do you want to continue? "),
        failure: jQuery.format("Unable to reset snapshot {0}."),
        processing: jQuery.format("<b>Resetting snapshot {0}.</b><br>This should take a few seconds."),
        scheduleFailure: jQuery.format("Unable to create the schedule for resetting snapshots of {0}."),
        scheduleLabel: "Schedule",
        scheduleProcessing: jQuery.format("<b>Creating the schedule for resetting snapshots of {0}.</b><br>This should take a few seconds."),
        scheduleSuccess: jQuery.format("The schedule for reset snapshot of {0} was created successfully."),
        snapshotLabel: "Snapshot",
        success: jQuery.format("Snapshot {0} was reset successfully."),
        taskFailure: jQuery.format("Unable to create the reset-snapshot task for {0}."),
        taskProcessing: jQuery.format("<b>Creating the reset-snapshot task for {0}.</b><br>This should take a few seconds.")
    },
    restartAction: {
        bothControllers: "A and B",
        confirmBothSCmsg: "Restarting both Storage Controllers will cause loss of access to storage and data availability until complete.<br /><br />This application will be unavailable during restart and will resume after restart is complete.<br /><br />",
        confirmLocalMCmsg: "Restarting the local Management Controller will cause loss of data access through<br /> this application or the CLI and you will need to sign in again when complete.<br /><br />",
        confirmLocalSCmsg: "This application and its data will be unavailable during restart and will resume after restart is complete.<br /><br />",
        confirmLocalShutdownMsg: "Shutting down the local Storage Controller will make this application and its data unavailable.<br /><br />",
        confirmPartnerRestartMsg: "Restarting the partner Storage Controller will cause temporary loss to this application and its data on the partner controller.<br /><br />",
        confirmPartnerShutdownMsg: "Shutting down the partner Storage Controller will make this application and its data unavailable on the partner controller.<br /><br />",
        confirmLastAvailableSystemShutdownMsg: "This operation will cause data to be unavailable from both controllers as the partner controller is currently inactive.<br /><br />Are you sure you want to restart now?",
        confirmMCmsg: jQuery.format("Are you sure you want to restart Management Controller on {0}? <br />"),
        confirmSCmsg: jQuery.format("Are you sure you want to restart Storage Controller on {0}? <br />"),
        confirmShutdownBoth: "Shutting down both Storage Controllers will cause temporary loss of data availability and prevent hosts from accessing data.<br /><br />Are you sure you want to shut down both Storage Controllers? <br /><br />",
        confirmShutdownMsg: jQuery.format("Are you sure you want to shut down Storage Controller on {0}? <br /><br />"),
        controller: jQuery.format("Controller {0}"),
        controllerLabel: "Controller Module",
        descText: "<p>Restarting controller processors may be required by a configuration change or to resolve an operational problem. Shutting down controller processors is recommended before either removing a controller module from its enclosure or powering off its enclosure for maintenance or a move. For details and cautions, see the online help.</p><p>Select the operation to perform and the controller processors and modules to affect.</p>",
        failureRestartMCmsg: jQuery.format("Failed to restart Management Controller on {0}."),
        failureRestartSCmsg: jQuery.format("Failed to restart Storage Controller on {0}."),
        failureShutdownMsg: jQuery.format("Failed to shut down Storage Controller on {0}."),
        mcType: "Management",
        operationLabel: "Operation",
        processingRestartMCmsg: jQuery.format("Restarting Management Controller on {0}.<br /><br />This should take approximately 2 minutes."),
        processingRestartSCmsg: jQuery.format("Restarting Storage Controller on {0}.<br /><br />This should take approximately 2 minutes."),
        processingShutdownMsg: jQuery.format("Shutting down Storage Controller on {0}."),
        restart: "Restart",
        scType: "Storage",
        shutdown: "Shut Down",
        successLocalMsg: "Restart of the local controller was initiated.<br /><br />The sign-in page should appear when complete.<br />This should take approximately 2 minutes.",
        successRemoteMsg: jQuery.format("Partner Management Controller: {0}<br /><br />"),
        successRestartMCmsg: jQuery.format("Restart succeeded for Management Controller on {0}."),
        successRestartSCmsg: jQuery.format("Restart succeeded for Storage Controller on {0}."),
        successShutdownMsg: jQuery.format("Succeeded in shutting down Storage Controller on {0}."),
        typeLabel: "Controller Type"
    },
    resumeReplicationSet: {
        cannotResume: "Must resume from the system that owns the primary volume.",
        confirm: "Click OK to resume volume replication on this set.",
        failure: "Unable to resume the replication set.",
        inProgress: "Must select a replication set that has been stopped.",
        processing: "Resuming replication set",
        selectRepSet: "Must select a single replication set.",
        success: "The replication set has been resumed.",
        suspendedRepSet: "Must select a replication set that is currently suspended."
    },
    resumeRsrReplication: {
        failure: jQuery.format("Unable to resume the replication of volume {0}."),
        infoTxt: "Click OK to resume the replication on this volume.",
        processing: jQuery.format("<b>Resuming the replication of volume {0}.</b><br>This should take a few seconds."),
        success: jQuery.format("Resuming replication of volume {0} was successful.")
    },
    reverseReplication: {
        cannotReverse: "Cannot reverse replication on an unsynchronized replication set.",
        completeViaRM: "Must complete recovery operation through Recovery Manager.",
        deleteMappingsConfirm: "Latest updates to the primary volume or volume group will be discarded in order to match the current contents of the secondary volume or volume group. <br />Mappings to the primary volume or volume group will be removed.<br />The secondary volume or volume group becomes the new primary.<br />Do you want to proceed?",
        failedFailover: "Unable to failover the replication set.",
        failedReverse: "Unable to reverse replication direction.",
        infoText: "Click OK to reverse replication direction for this replication set.",
        mustBeSecondary: "Must reverse replication set from the system that owns the secondary volume",
        peerOnline: "Peer connection must be online to reverse the replication set.",
        processingFailover: "Failing over replication set.",
        processingReverse: "Reversing replication direction",
        singleRepSet: "Must select a single replication set",
        reverseSuccessful: "The replication set has been reversed."
    },
    rollbackVolume: {
        confirmLinear: "To ensure data consistency, the master volume must be unmounted from all hosts, and if the With Modified Data option was specified, the snapshot must also be unmounted. The master volume can be remounted after the rollback has started. The snapshot can be remounted after the rollback is complete (wait for the rollback completion event).<br/>Click Yes if the volumes are unmounted and it is OK to continue, or click No to cancel.",
        confirmVirtual: "To ensure data consistency, the volume and snapshot must be unmounted from all hosts. They can be remounted after the rollback is complete.<br />Click Yes if the volumes are unmounted and it is OK to continue, or click No to cancel.",
        failure: jQuery.format("Unable to rollback volume {0}."),
        forVolLabel: "Volume",
        processing: jQuery.format("<b>Initiating rollback of volume {0}.</b>"),
        successLinear: jQuery.format("Rollback of volume {0} started successfully."),
        successVirtual: jQuery.format("Rollback of volume {0} completed successfully."),
        withModified: "With Modified Data"
    },
    saveLogs: {
        additionalComments: "Comments",
        failed: "Save logs failed.",
        instructions: "Enter information to identify who saved the log data and the problems that the log data relates to, and then click OK.<br>It typically takes several minutes to collect the log data, then you will be prompted to save the log data in a file.",
        processing: "Saving log data...",
        succeeded: "Log file created.",
        yourEmailAddress: "Your Email Address",
        yourName: "Your Name",
        yourPhoneNumber: "Your Phone Number"
    },
    schedule: {
        afterLabel: "After",
        andLabel: "and",
        anyLabel: "Any",
        april: "April",
        atLabel: "at",
        august: "August",
        betweenLabel: "Run schedule between",
        dateConstraintLabel: "Date Constraint",
        day: "Day",
        days: "Days",
        december: "December",
        endLabel: "End",
        editScheduleLabel: "Edit Schedule",
        everyLabel: "every",
        february: "February",
        friday: "Friday",
        hours: "Hours",
        invalidEndTime: "The specified end time must be at least a minute later than the specified start time.",
        invalidRepRecur: "The minimum interval between scheduled replications is 30 minutes.",
        invalidStartTime: "The specified start time must be at least a minute later than the current system time.",
        january: "January",
        july: "July",
        june: "June",
        march: "March",
        may: "May",
        minutes: "Minutes",
        monday: "Monday",
        month: "Month",
        months: "Months",
        november: "November",
        numberLabel: "number",
        occurrencesLabel: "occurrences",
        october: "October",
        ofLabel: "of",
        onLabel: "On",
        repeatLabel: "Repeat",
        saturday: "Saturday",
        scheduleOn: "Run schedule on",
        september: "September",
        sunday: "Sunday",
        thursday: "Thursday",
        timeConstraintLabel: "Time Constraint",
        tuesday: "Tuesday",
        wednesday: "Wednesday",
        weekday: "Weekday",
        weekendday: "Weekend Day",
        weeks: "Weeks",
        years: "Years",
        year: "Year"
    },
    percentValue: jQuery.format("{0}%"),
    spares: "Spares",
    scheduleReplication: {
        cannotSchedule: "Must schedule from the system that owns the primary volume.",
        createSched: {
            scheduleFailure: jQuery.format("Could not set a schedule for task {0}."),
            scheduleProcessing: jQuery.format("Setting the schedule for task {0}")
        },
        createTask: {
            failureMsg: jQuery.format("Failed to create scheduled task for {0}."),
            taskProcessing: jQuery.format("<b>Creating the scheduled task for {0}.</b><br>This should take a few seconds.")
        },
        scheduleSuccess: jQuery.format("The schedule for replication set {0} was created successfully.")
    },
    setPrimaryVolume: {
        confirmMsg: "Make sure that I/O operations are stopped and the primary volume is unmapped before proceeding with this command.<br />Do you want to continue?",
        failureMsg: jQuery.format("Unable to set primary volume to {0}."),
        processingMsg: jQuery.format("<b>Setting primary volume to {0}.</b><br />This should take a few seconds."),
        primaryLabel: "Primary Volume",
        successMsg: jQuery.format("Setting primary volume to {0} was successful.")
    },
    ssdIoWorkload: {
        average: "Average",
        capacity: "Capacity",
        days: "Days",
        failureMsg: "Failed to collect SSD I/O workload data. ",
        ioWorkload: "I/O Workload",
        modesLabel: "Show",
        noDataFound: "No SSD workload data was returned because historical data statistics were recently reset.<br>You must wait 15-30 minutes after resetting statistics to view new data.",
        poolCapacityLabel: "Pool Capacity",
        panelDescription: "Many user workloads can benefit from tiering to SSDs. Use the graph below to compare your I/O workload to your current SSD capacity (shown by the shaded area in the graph). Users often see the greatest performance benefits when 80% or more of their I/O workload is within the shaded area.",
        panelTitle: "I/O Workload Graph",
        peak: "Peak",
        poolsLabel: "Pool",
        reads: "Read I/Os",
        refreshGraph: "Refresh Graph",
        settingsLabel: "Settings",
        ssdCapacityLabel: "Current SSD Capacity",
        totalIos: "Total I/Os",
        unit: "Unit",
        valuesLabel: "Values",
        workloadCustom: "of my I/Os",
        workload80: "80% of my I/Os",
        workload100: "100% of my I/Os",
        workloadLabel: "Workload",
        writes: "Write I/Os"
    },
    startStopDiskGroup: {
        currentlyStopped: "The disk group is currently stopped. Click Start to start the disk group.",
        currentlyRunning: "The disk group is currently running. Click Stop to stop the disk group.",
        title: "Stop/Start Disk Group",
        start: "Start Disk Group",
        stop: "Stop Disk Group",
        stopConfirmMsg: jQuery.format("Are you sure you want to stop disk group {0}?"),
        stopProcessingMsg: jQuery.format("<b>Stopping disk group {0}.</b><br />This should take a few seconds."),
        stopFailMsg: jQuery.format("Unable to stop disk group {0}."),
        stopSuccess: "The disk group was successfully stopped.",
        startConfirmMsg: jQuery.format("Are you sure you want to start disk group {0}?"),
        startProcessingMsg: jQuery.format("<b>Starting disk group {0}.</b><br />This should take a few seconds."),
        startFailMsg: jQuery.format("Unable to start disk group {0}."),
        startSuccess: "The disk group was successfully started."
    },
    storageSetup: {
        adaptExpansionsLabel: "ADAPT Expansions",
        adaptExpansionsText: "The system will expand the available space of the following existing ADAPT disk groups:",
        addStorageProcessing: "Provisioning the storage configuration.<br><br>This may take a few minutes.",
        addStorageSuccess: "Successfully added storage.",
        addStorageFailure: "Failed to provision storage.",
        advancedLink: "Need a specific layout for your environment? ",
        advancedSetup: "Go To Advanced Configuration",
        capacityLabel: "Capacity",
        choosingText: "Choose the storage type that is appropriate for your environment.",
        createAdvPools: "Create Advanced Pools: ",
        createPoolLabel: "Create Pools",
        createPoolDetail: "create two virtual pools, A and B",
        createPoolSingle: jQuery.format("create virtual pool {0}"),
        createVolumeLabel: "Create Volumes",
        configDetailsPlural: jQuery.format('Clicking the "{0}" button will {1}. {2} tier(s) will be created. More details about each tier can be found in the table below.'),
        configDetailsSingle: jQuery.format('Clicking the "{0}" button will {1}. One tier will be created. More details about the tier can be found in the table below.'),
        configDetailsAdapt: 'Clicking the "Expand Pools" button will expand available storage space within existing ADAPT disk groups.',
        configFound: "The system has scanned all available disks and following storage configuration is recommended.",
        configNotFound: "The system could not find a storage configuration.",
        confirmMessage: "You have not configured storage for your system and are about to exit the Storage Setup wizard.<br>Are you sure you want to exit? ",
        confirmCancel: " You are about to exit the storage setup.<br>Are you sure you want to exit? ",
        confirmLeaveVolumes: "You have not configured any volumes on the system yet. You can create volumes later from either the Storage Setup wizard in the Home topic or from the Volumes topic.<br><br>Are you sure you want to exit?",
        confirmLeaveMappings: "You have not configured any mappings on the system yet. You can map volumes later from the Mapping topic.<br><br>Are you sure you want to exit?",
        expandPoolDetail: "expand available storage space in pools A and B",
        expandPoolSingle: jQuery.format("expand available storage space in pool {0}"),
        expandPoolLabel: "Expand Pools",
        fdeState: "FDE State",
        globalSparesLabel: "Global Spares",
        globalSparesText: "The system will use the following disks as global spares:",
        hostLabel: "Hosts",
        hostId: "Initiator ID",
        hostText: 'All connected initiators are listed in the table below.  Verify that all initiators desired to have access to the volumes have been discovered before continuing. This panel will update automatically once new initiators have been discovered. After this wizard has been completed, each of the selected initiators below will have read-write access to each volume created in the previous step. For a more advanced mapping configuration, exit this wizard and navigate to the "Map" action in the Mapping topic.<br><br>Select which initiators you would like mapped to the new volumes.',
        hostType: "Host Type",
        lunTip: "A LUN (Logical Unit Number) is used to expose a volume to a host. Both controllers share a set of LUN IDs, and any unused LUN ID may be used to map a host and volume together. Note that some storage applications reserve specific LUN IDs",
        location: "Location",
        mapAll: "Map to all hosts (including future hosts)",
        mapButton: "Map and Close",
        mapLabel: "Map",
        mapStepLabel: "Map Initiators",
        mapText: 'Specify a unique LUN value for each volume. After the mapping has completed, all volumes listed below will have read-write access to all hosts listed in the previous step. Click the "Map and Close" button to map the volumes and close this wizard.',
        mapTip: "You must map your initators to your volumes in order to establish communication between the two. By unselecting an initator below, you are specifying that you do not want it to read or write data to your volumes. You can revisit your mapping choices and configure details of your maps using the Mapping topic.",
        mapWarn: "This is not a secure mapping because it will allow any host that connects to the network in the future to have unrestricted access to all the volumes.",
        nickname: "Nickname",
        nicknameTip: "You can give initiators a nickname so that you can easily identify it later.",
        noInitiators: "The system has not discovered any initiators connected to the system. Since there are no initiators to map to, you cannot explicitly map to any initiators at this time.<br><br>To troubleshoot, make sure all host port cables are properly plugged into the network. iSCSI ports must be properly configured before initiators can be discovered.<br><br>This page will update automatically if any initiators are discovered. To explicitly map these volumes in a secure manner after completing this wizard, you will need to navigate to the Mapping topic and use the Map action.",
        noProvisionFound: "The system scanned all available disks and was not able to find a valid storage configuration.<br><br>Below are the reason(s) why the system was unable to find a storage configuration.",
        numDisksLabel: "Number of Disks",
        poolLabel: "Pool",
        poolsLabel: "Pools",
        poolsCreated: "Pools Created:",
        poolStepLabel: "Default Pool Storage Configuration",
        poolTableString: "This tool will allow you to set up your storage with a unique configuration for your environment. You will be asked to select disks and group them together according to the data protection (RAID type) they will utilize. It may take several disk groups to build up your entire system, and you will want to have a plan for modeling your storage before continuing.",
        poolTableAddnString: "Would you rather trust the system to suggest an optimal pool configuration based on your installed disks?",
        poolTableGoBack: "Go Back to Suggested Pool Configuration",
        poolTableNext: "Otherwise, proceed to create pools manually by clicking ",
        addDiskGroupLink: "Add Disk Group ",
        below: "below:",
        rescanButton: "Rescan Disks",
        rescanSuccessful: "Successfully rescanned the disks on the system and updated the recommended storage configuration.",
        removeRow: "Remove Row",
        size: "Size",
        spareCreated: "Spares Created: ",
        storageType: "Select Storage Type",
        suggestionText: "Please consider the following suggestions before provisioning:",
        summaryIntro: jQuery.format("You have created {0} of volume storage:"),
        summaryLabel: "Summary",
        summaryMid: "Each of the above volumes is accessible to the following initiators:",
        summaryMid1: "These volumes were mapped to any initiators that may connect to the network in the future. You can change these mapping settings later from the Mapping topic.",
        summaryMid2: "These volumes were not mapped to any initiators. You can map these volumes later from the Mappings topic by using the Map action.",
        summaryFooter1: "Storage Setup is complete!",
        summaryFooter2: " These volumes are now ready to use for storage.",
        summaryFooter3: " Once these volumes are mapped, they will be ready to use for storage.",
        summaryFooter4: " Additional configuration may be necessary on your Operating System in order to begin using your storage.",
        tierLabel: "Tier",
        tierPerf: "Performance",
        tierStand: "Standard",
        tierArch: "Archive",
        tierReadCache: "Read Cache",
        type: "Type",
        unusedDisksLabel: "Unused Disks",
        unusedDisksText: "The system was unable to use the following disks as part of the storage configuration:",
        volNameLabel: "Volume Name",
        volSizeLabel: "Volume Size",
        volSizeTip: "The default volume size is shown as 100GB. You should change this value as needed to fit your environment. If the total size of all the volumes in a pool is greater than the size of the pool, the system will be overcommitted.",
        volumeStepLabel: "Add New Volumes",
        volumeLabel: "Volumes",
        volumeText: 'Volumes are logical subdivisions of pools, and can be mapped to host-based applications to provide storage. Use the table below to manage what volumes to add. By default, 1 volume has been added to each pool. Click the "Next" button to attach the volumes listed in the table to the selected host.',
        warning: "Warning:",
        virtualDescription: "This is the most common selection and is recommended for most environments. Virtual storage allocates space in pages and allows data to be moved to improve system performance of the storage system. Virtual storage can support thin provisioning, tiering, replication, and many other features unavailable to linear configurations.",
        linearDescription: "Linear storage is used in applications where performance and data workloads dictate that data be allocated on disks in a contiguous fashion. Users in streaming media and video editing environments may prefer the performance and raw capacity available to a linear storage configuration. Some features such as thin provisioning, tiering, and replication are not available in a linear storage environment."
    },
    suspendReplicationSet: {
        cannotSuspend: "Must suspend from the system that owns the primary volume.",
        confirm: "Click OK to suspend volume replication on this set.",
        failure: "Unable to suspend the replication set.",
        inProgress: "Must select a replication set that is currently running.",
        processing: "Suspending replication set",
        selectRepSet: "Must select a single replication set.",
        success: "The replication set has been suspended."
    },
    suspendRsrReplication: {
        failure: jQuery.format("Unable to suspend the replication of volume {0}."),
        infoTxt: "Click OK to suspend the current replication being performed on this volume.",
        processing: jQuery.format("<b>Suspending the replication of volume {0}.</b><br>This should take a few seconds."),
        success: jQuery.format("Suspending replication of volume {0} was successful.")
    },
    systeminfo: {
        siContactLabel: "System Contact",
        siInfoLabel: "System Information",
        siLocationLabel: "System Location",
        siNameLabel: "System Name"
    },
    systemInformation: {
        failure: "unable to set the system information.",
        processing: "setting the system information.",
        success: "The system information was set successfully."
    },
    systemports: {
        confirmMsg: "Warning: This change will take effect immediately. Changes may affect access to data.<br />Are you sure you want to apply these settings?",
        confirmIscsiMsg: "Applying new iSCSI parameters may disrupt access from connected hosts.<br />Are you sure you want to apply these settings?",
        fanoutConfirm: "This command will change host port configuration, stop I/O, and restart both controllers. Do you want to continue?",
        fanoutSuccess: "Successfully set SAS port settings.",
        successMsg: "Successfully set the port parameters."
    },
    systemSettings: {
        bypassEasyStartConfirm: "Are you sure you want to skip the Welcome screen?",
        bypassEasyStartFailure: "Failed to skip the Welcome screen.",
        bypassEasyStartProcessing: "Skipping the Welcome screen...",
        bypassEasyStartSuccess: "Successfully skipped the Welcome screen.",
        bypassEmailSuccess: "Successfully updated email notification settings",
        bypassLicenseConfirmLenovo: "Without installing a Performance Tier license, the system will not be able to use all SSDs currently in the system.<br><br>Are you sure you want to skip Performance Tier license install?",
        bypassLicenseConfirmHP: "You are choosing not to install the HPE Advanced Data Services Suite. You may install this license at any time from the Install License tab of the System Settings panel.<br><br>Are you sure you want to continue without this license?",
        bypassLicenseFailure: "Failed to skip required Performance Tier license installation.",
        bypassLicenseProcessing: "Skipping required Performance Tier license installation...",
        bypassLicenseSuccess: "Successfully skipped Performance Tier license installation.",
        bypassLicenseHPE: "Successfully skipped installation of HPE Advanced Data Services Suite.",
        bypassLicenseSuccess: "Successfully skipped required Performance Tier license installation.",
        bypassPortConfirm: "Without configuring iSCSI host ports, the system will not be able to connect storage to any external hosts through these ports.<br><br>Are you sure you want to skip port configuration?",
        bypassPortFailure: "Failed to skip required port configuration.",
        bypassPortProcessing: "Skipping required iSCSI port configuration...",
        bypassPortSuccess: "Successfully skipped iSCSI port configuration.",
        bypassNotifications: "I do not wish to receive notifications for system events at this time.",
        bypassNotificationsProcessing: "Skipping the required notification configuration",
        bypassNotificationsFailure: "Failed to skip required notification configuration.",
        bypassNotificationsSuccess: "Successfully skipped notification configuration.",
        bypassNotificationsConfirm: "If you do not configure notifications for this system, there is a risk of not knowing about any problems that may arise on the system.<br><br>Are you sure you want to skip notification configuration?",
        cannotRemoveManage: "Cannot remove management role from currently logged in user.",
        creatingNewUser: "Creating a new user: ",
        creatingNewUserGroup: "Creating a new user-group:",
        licenseRequiredLenovo: "Your system has more than 4 SSDs. It is highly recommended that you install a Performance Tier license to take full advantage of your SSD capacity.",
        licenseRequiredHP: "You have not installed the HPE Advanced Data Services Suite, which includes support for Performance and Archive Tiering, 512 snapshots, volume copy, and remote snap capability. For more information, visit ",
        licenseRequired: "Your system has more than 4 SSDs. It is highly recommended that you install a Performance Tier license to take full advantage of your SSD capacity.",
        manageUsersRequired: "For security purposes, you must change the default password for all users. Make changes for each user and click Apply. Only one user can be changed at a time.",
        modifyingUser: "Modifying user: ",
        modifyingUserGroup: "Modifying user-group: ",
        notifRequired: "The system will send out notifications of important events that may happen throughout the life of the product. It is highly recommended that you configure at least one notification path so that you can quickly respond to any issues that may arise in the system.",
        portsRequired: "In order for the system to connect to external initiators and map volumes for access to these initiators, you must configure a valid IP Address, Netmask, and Gateway for the iSCSI host ports.",
        skipLicenseRequirementLenovo: "I acknowledge that I cannot utilize all of my SSD capacity, but I do not wish to install a Performance Tier license at this time.",
        skipLicenseRequirementHP: "I acknowledge that I do not intend to install the HPE Advanced Data Services Suite at this time.",
        skipPortsRequirement: "I acknowledge that I cannot map to any hosts without configuring host ports, but I do not wish to configure my host ports at this time.",
        successMsg: "Successfully updated system settings."
    },
    syslogConfig: {
        infoTxt: "Configure remote syslog notification of events.",
        levelLabel: "Notification Level",
        serverIPAddr: "Syslog Server IP Address",
        syslogPortNumber: "Syslog Server Port Number",
        processingMsg: "Setting the Syslog notification parameters.",
        successMsg: "Successfully set the Syslog notification parameters.",
        failureMsg: "Failed to set the Syslog notification parameters.",
        testNotification: "To test notification to the configured destinations, in the menu select <i>Tools > Test Event Notifications and Managed Logs</i>."
    },
    updateFirmware: {
        badFileExtensionError: "The file has an incorrect file extension.",
        busIdCol: "Bus ID",
        bothControllers: "both controllers",
        codeVersionCol: "Code Version",
        componentCol: "Component",
        controllerACol: "Controller A",
        controllerBCol: "Controller B",
        controllerAOnly: "Controller A only",
        controllerBOnly: "Controller B only",
        controllerInstructions: jQuery.format("Select the firmware file to install to controller {0}."),
        ctrlFWLabel: "Bundle or Controller Firmware File",
        diskFWLabel: "Disk Firmware File",
        diskInstructions: "Select one or more disks from table and then select the firmware file to install.",
        empFWLabel: "Expansion Module Firmware File",
        enclosureCol: "Enclosure",
        expanderFirmware: "Expander Firmware",
        health: "Health",
        hpe1: "<b>HPE strongly recommends that you verify that your firmware is up to date.</b> The latest firmware versions include support for new features and the most recent security upgrades.",
        hpe2: "Your current firmware bundle is",
        hpe3Part1: "Use the following link ",
        hp3Part2: " to determine the current released firmware for your MSA model and Expansion (Disk) Enclosures.   If a newer firmware is available, obtain the HPE SmartComponent using the download link and follow the instructions provided to update your firmware.",
        fwUpdateFailedNoReboot: "Firmware update failed.",
        fwUpdateFailedReboot: "Firmware update failed, restarting controller...",
        fwUpdateSucceededNoReboot: "Firmware update succeeded.",
        fwUpdateSucceededReboot: "Firmware update succeeded, restarting controller...",
        instructions12gig: "This table shows all of the expansion modules and drawers in the system and their firmware versions. Update of expansion module and drawer firmware is performed as part of updating controller module firmware.",
        iomInstructions: "Select one or more expansion modules from table and then select the firmware file to install.",
        leftDrawer: "Left Drawer",
        locationCol: "Location",
        midDrawer: "Middle Drawer",
        moduleCol: "Module",
        noManageRole: "Must have manage role to update firmware.",
        ownerCol: "Owner",
        PartnerFirmwareUpgrade: "Partner Firmware Update",
        partNumberCol: "Part Number",
        pfuConfirm: jQuery.format("Are you sure you want to {0} Partner Firmware Update?"),
        pfuEnable: "Click here to enable PFU",
        pfuDisable: "Click here to disable PFU",
        pfuInfo: "Partner Firmware Update (PFU) is a means of synchronizing the firmware between controllers.  If PFU is enabled and a firmware update is initiated on a controller, that firmware revision will become the active revision and will be synchronized to the other controller. If PFU is not enabled the firmware will be installed only on the one controller.",
        pfuStatus: jQuery.format("PFU is currently <b>{0}</b>. {1}"),
        pfuController: jQuery.format("Performing a firmware update will update the firmware on {0}."),
        positionCol: "Position",
        rightDrawer: "Right Drawer",
        revision: "revision",
        serialnumber: "Serial Number",
        setPfuFailureMsg: "Setting PFU failed.",
        setPfuProcessingMsg: "Setting PFU state...",
        setPfuSuccessMsg: "Setting PFU succeeded.",
        slot: "Slot",
        targetIdCol: "Target ID",
        UpdateController: "Update Controller Modules",
        UpdateDiskDriveFirmware: "Update Disk Drives",
        UpdateExpansionModule: "Update Expansion Modules",
        vendor: "Vendor",
        model: "Model"
    },
    userManagement: {
        create: {
            error: "Unable to add the new user.",
            processingMsg: "Adding the new user.",
            success: "The new user was added successfully."
        },
        createGroup: {
            error: "Unable to add the new user-group.",
            processingMsg: "Adding the new user-group.",
            success: "The new user-group was added successfully."
        },
        deleteuser: {
            confirmMsg: jQuery.format("Are you sure you want to remove user {0}?"),
            error: jQuery.format("Unable to remove user {0}."),
            processingMsg: jQuery.format("Removing user {0}."),
            success: jQuery.format("User {0} was removed successfully."),
            message: "Cannot delete the curently logged in user."
        },
        deleteusergroup: {
            confirmMsg: jQuery.format("Are you sure you want to remove user-group {0}?"),
            error: jQuery.format("Unable to remove user-group {0}."),
            processingMsg: jQuery.format("Removing user-group {0}."),
            success: jQuery.format("User-group {0} was removed successfully.")
        },
        modify: {
            confirmMsg: jQuery.format("Are you sure you want to modify user {0}?"),
            error: "Unable to modify the user.",
            processingMsg: "Modifying the user.",
            success: "The user was modified successfully."
        },
        modifyGroup: {
            confirmMsg: jQuery.format("Are you sure you want to modify user-group {0}?"),
            error: "Unable to modify the user-group.",
            processingMsg: "Modifying the user-group.",
            success: "The user-group was modified successfully."
        },
        modifyLdap: {
            confirmMsg: jQuery.format("Are you sure you want to modify LDAP settings?"),
            error: "Unable to modify the LDAP settings.",
            processingMsg: "Modifying the LDAP settings.",
            success: "LDAP settings was modified successfully."
        },
        panelText: {
            base10: "Base 10",
            base2: "Base 2",
            baseLabel: "Base Preference",
            CLI: "CLI",
            ConfirmPassword: "Confirm Password",
            copyLabel: "Copy",
            copyOf: jQuery.format("copy_of_{0}"),
            currentUserGroup: "Current User-Groups:",
            deleteLabel: "Delete",
            Diagnostic: "Diagnostic",
            enableLDAP: "Enable LDAP Configuration",
            FTP: "FTP",
            Interfaces: "Interfaces",
            localeLabel: "Locale",
            localUsersTab: "Local Users",
            ldapUsersTab: "LDAP Users",
            ldapServer: "Server",
            ldapAltServer: "Alt-Server",
            ldapPort: "Port",
            ldapAltPort: "Alt-Port",
            LDAPSettings: "LDAP Settings",
            ldapSearchBase: "User-search-base",
            manage: "manage",
            monitor: "monitor",
            diagnostic: "diagnostic",
            engineering: "engineering",
            Manage: "Manage",
            monitor: "monitor",
            Monitor: "Monitor",
            navigateAway: "Do you want to navigate away and lose any changes made?",
            newLabel: "New",
            newUser: "NewUser",
            newUserGroup: "NewUserGroup",
            password: "Password",
            precisionLabel: "Precision Preference",
            Preferences: "Preferences",
            Roles: "Roles",
            SMIS: "SMI-S",
            SNMPv3: "SNMPv3",
            standard: "standard",
            Standard: "Standard",
            temperatureLabel: "Temperature Preference",
            timeoutMinutes: "Timeout (minutes)",
            tips: {
                btnCopy: "Create a copy of an existing account",
                btnDelete: "Delete an account",
                btnDeleteGroup: "Delete user-group",
                btnNew: "Create a new account from scratch",
                btnNewGroup: "Create a new user-group from scratch",
                maxUsers: "The maximum number of users has been reached.",
                maxUserGroups: "The maximum number of user groups has been reached.",
                requiresManage: "You must have the manage role to perform this action.",
                noStandard: "User with standard role cannot perform this action.",
                noStandardGroup: "User-group with standard role cannot perform this action.",
                snmpAcctNature: "SNMPv3 Account",
                stdAcctNature: "Standard System Account",
                userListTable: "A list of accounts",
                wbiCheckbox: "Access the system via the web"
            },
            unitsLabel: "Unit Preference",
            UserName: "User Name",
            UserGroup: "User Group Name",
            UserType: "User Type",
            WBI: "WBI"
        },
        snmp: {
            authType: "SNMPv3 Authentication Type",
            destination: "Trap Host Address",
            privPasswd: "SNMPv3 Privacy Password",
            privType: "SNMPv3 Privacy Type",
            target: "Trap Target",
            userAccess: "User Access",
            userType: "SNMPv3 Account Type"
        },
        validation: {
            confirmPassword: "Please confirm the password.",
            noEmptyPassword: "A password is required.",
            noEmptyPrivacyPassword: "A privacy password is required when a privacy type is selected.",
            noEmptyPasswordAuth: "A Password is required when a authentication type is selected",
            noEmptyPasswordPrivacy: "A Password is required when a privacy type is selected",
            passwordLength: "Passwords may not exceed 32 characters.",
            trapHostAddressInvalidIp: "A valid IPv4 address is required.",
            trapHostAddressMsg: "An SNMP trap-host destination IP address is required.",
            usernameError: "Enter a unique user name."
        }
    },
    volPreference: {
        Archive: "Archive",
        Performance: "Performance",
        NoAffinity: "No Affinity"
    },
    volumeCache: {
        adaptive: "Adaptive",
        disabled: "Disabled",
        eight_mb: "8MB",
        fivetwelve_kb: "512KB",
        four_mb: "4MB",
        one_mb: "1MB",
        sixteen_mb: "16MB",
        stripe: "Stripe",
        thirtytwo_mb: "32MB",
        two_mb: "2MB",
        standard: "Standard",
        no_mirror: "No-mirror",
        atomic_write: "Atomic write"
    },
    changeSpares: {
        addSpareTitle: "Add New Spares: ",
        addSpareText: " The table below shows available disks that can be used as global spares.",
        addDedSpareText: "If you want to assign a spare disk to a disk group, select the checkbox below, choose the disk group and select the disks from the table.",
        buttonText: "Add Spares",
        compleSetupButtonText: "Manage Spares",
        compleSetupText: "Back to Advanced Pools",
        dedicatedSpare: "Assign dedicated spares to the disk group: ",
        dedicatedType: "Dedicated",
        error: "Unable to remove the spares.",
        existingTitle: "Current Spares:",
        globalType: "Global",
        modifying: "<b>Removing spares.</b><br>This should take a few seconds.",
        notSupported: "This action is not supported when there are only ADAPT disk groups in the system.",
        sectorFormatWarning: "The disk group will include both native and emulated format disks. This may result in lower performance under specific workloads. Where possible it is recommended to use the same format of disks in a disk group.",
        spareType: "Spare Type",
        success: "The spares were removed successfully.",
        title: "Manage Spares"
    },
    configurationWizard: {
        configComplete: "Required configuration is completed",
        configRequired: "Configuration is required",
        confirmMsg2: "<br>Are you sure you would like to apply these system settings?",
        description: "Configure basic settings for system operation.",
        nothingChanged: "Nothing changed. Click <b>Finish</b> to exit the wizard or click <b>Previous</b> to go back and make changes.",
        title: "Configuration Wizard",
        stFail: "Failed to set date/time settings.",
        stInfoText: "Optional. Changes to the date, time, or related properties will result in changes to the system once <b>Next</b> is selected.",
        stProcessing: "Setting date/time settings...",
        stStep: "Date/Time",
        stTitle: "Set Date and Time",
        dateTimeLabel: "Date and Time",
        manageUsersLabel: "Manage Users",
        finishStep: "Confirm",
        finishTitle: "Confirm the configuration changes",
        introText1: "This wizard helps you to initially configure the system, or to later change system settings.  The wizard guides you through these steps:<p><ul><li>Configure system date and time settings</li><li>Change passwords for the default users.</li><li>Configure each controller's network port.</li><li>Enable or disable system-management services.</li><li>Enter information to identify the system.</li><li>Configure event notification.</li><li>Configure host ports (if applicable).</li><li>Confirm changes and apply them.</li></ul></p><p>For each step you can view help by clicking the help icon <img src='images/help/helpIcon.png' title='Help icon' width='18' height='18' align='abscenter'/>.  If you cancel the wizard at any point, no changes are made.</p>",
        introText2: "To continue, click <b>Next</b>",
        nwStep: "Network",
        nwText1: 'Configure Internet Protocol (IP) address settings for each controller\'s network port. You can set static IP values or use Dynamic Host Configuration Protocol (DHCP). In DHCP mode, IP values are obtained from a DHCP server if one is available. If a DHCP server is unavailable, current IP values are unchanged.<p><span class="caution">Caution:</span> Changing IP settings can cause management hosts to lose access to the storage system.',
        nwTitle: "Network configuration",
        notifyStep: "Notifications",
        notifyText1: "Configure up to three email addresses and three SNMP trap hosts to receive notifications of system events.",
        notifyTitle: "Configure event notification",
        manageVerEqual: "The manage password entries do not match.",
        monitorVerEqual: "The monitor password entries do not match.",
        passLabel: "New password",
        passManageHeading: "<b>manage</b> user:",
        passMonitorHeading: "<b>monitor</b> user:",
        passStep: "Passwords",
        passText1: "Optional. Change the passwords for the default users, manage and monitor. The manage user can view system status and change system settings; the monitor user can only view system status and settings. A password is case-sensitive and cannot include a comma, double quote, or backslash.",
        passTitle: "Password Setup",
        passVerifyLabel: "Re-enter password",
        passwordLength: "Passwords may not exceed 32 characters.",
        portStep: "Ports",
        portText1: "If the controllers have FC or iSCSI host ports, configure settings for communication with connected hosts. SAS host ports have no configurable settings. For descriptions of FC and iSCSI settings, see the online help.",
        portTitle: "Port configuration",
        servStep: "Services",
        servTitle: "Enable system-management services",
        servText1: "Enable or disable management-interface services to limit the ways in which users and host-based management applications can access the storage system. Network services operate out-of-band and do not affect host I/O to the system. In-band services operate through the data path and can slightly reduce I/O performance.",
        siStep: "System Info.",
        siText1: "Specify a name to identify the system; the name of the person who administers it; its location; and information about what it's used for or how it's configured. The system name is shown in the browser title bar or tab, and is included in event notification emails. All four values are included in system debug logs for reference by service personnel.",
        siTitle: "System information",
        summary: {
            activity: "Activity Reporting",
            debug: "Debug",
            emTitle: "Email Notification",
            emDomain: "Email Domain",
            emEmail1: "Email Address 1",
            emEmail2: "Email Address 2",
            emEmail3: "Email Address 3",
            emEmail4: "Email Address 4",
            emIncludeLogs: "Include logs as an email attachment",
            emLevel: "Email Notification Level",
            emNotifSettings: "Email Notifications",
            emSender: "Email Sender",
            emServer: "Email Server",
            emHealthAlerts: "Health Alerts",
            fanoutCheckbox: "Use fan-out cables",
            fcId: "id",
            fcSoft: "soft",
            ftp: "FTP",
            https: "WBI HTTPS",
            http: "WBI HTTP",
            IB_chap: "Enable Authentication (CHAP)",
            IB_ip_version: "IB IP Version",
            iscsi_chap: "Auth (CHAP)",
            iscsi_isns_ip: "iSNS Address",
            iscsi_ip_version: "iSCSI IP Version",
            iscsi_isns_alt_ip: "Alt iSNS Address",
            iscsi_isns: "iSNS",
            iscsi_jumbo: "Jumbo Frames",
            iscsi_speed: "Link Speed",
            managedLogs: "Managed Logs",
            managementVersion: "Management Version",
            managePass: "manage password",
            monitorPass: "monitor password",
            nameServer: "Name Server",
            ntp_address: "NTP Server Address",
            ntp_state: "NTP",
            nwConfigMode: "Network Configuration Mode",
            nwDHCP: "DHCP",
            nwIPaddrA: "Controller A IP",
            nwIPaddrB: "Controller B IP",
            nwIPgatewayA: "Controller A Gateway",
            nwIPgatewayB: "Controller B Gateway",
            nwIPmaskA: "Controller A Netmask",
            nwIPmaskB: "Controller B Netmask",
            nwManual: "Manual",
            portMode: "mode",
            portSpeed: "speed",
            senderPasswd: "Sender Password",
            ses: "In-band SES",
            searchDomain: "Search Domain",
            sftp: "SSH File Transfer Protocol (SFTP)",
            sftpPort: "SFTP Port",
            siContact: "System Contact",
            siInfo: "System Info",
            siLocation: "System Location",
            siName: "System Name",
            slp: "Service Location Protocol (SLP)",
            smisEncrypt: "SMI-S Encrypted",
            smisEnable: "SMI-S",
            snmpHost1: "SNMP Host 1",
            snmpHost2: "SNMP Host 2",
            snmpHost3: "SNMP Host 3",
            snmpLevel: "SNMP Notification Level",
            snmpReadComm: "SNMP Read Community",
            snmp: "SNMP",
            snmpWriteComm: "SNMP Write Community",
            ssh: "CLI SSH",
            sshPort: "SSH Port",
            syslogLevel: "Syslog Notification Level",
            syslogIPAddress: "Syslog IP Address",
            syslogPortNumber: "Syslog Port Number",
            telnet: "CLI Telnet",
            time_zone_offset: "NTP Time Zone Offset",
            usmisEnable: "USMI-S"
        },
        confirmMsg: "Confirm the following changes:<br><br>",
        goCDGMsg: "Setup successfully completed.<br />Do you want to create disk groups now?<br />Click No if you want to do this later.",
        passManageFailure: "Failed to set manage user password.",
        passManageProcessing: "Setting manage user password...",
        passManageSuccess: "Successfully set manage user password.",
        passMonitorFailure: "Failed to set monitor user password.",
        passMonitorProcessing: "Setting monitor user password...",
        passMonitorSuccess: "Successfully set monitor user password.",
        servFailure: "Failed to enable/disable services.",
        servProcessing: "Enabling/disabling services...",
        servSuccess: "Successfully enabled/disabled services.",
        siFailure: "Failed to set system info.",
        siProcessing: "Setting system info...",
        siSuccess: "Successfully set system info."
    },
    welcome: {
        getStarted: "Get Started",
        accept: "Accept",
        decline: "Decline",
        eulaLoading: "End-user License Agreement is loading... "
    },
    setupUser: {
        setupNewUserMsg: "Set a new username and password for this system",
        createButtonText: "Apply and Continue",
        error: jQuery.format("Unable to create user {0}, try again."),
        processingMsg: jQuery.format("Creating user {0}"),
        success: jQuery.format("User created successfully, signing in with user {0}...")
    }
};
(function($) {
    $.extend({
        metadata: {
            defaults: {
                type: "class",
                name: "metadata",
                cre: /({.*})/,
                single: "metadata"
            },
            setType: function(type, name) {
                this.defaults.type = type;
                this.defaults.name = name
            },
            get: function(elem, opts) {
                var settings = $.extend({}, this.defaults, opts);
                if (!settings.single.length) {
                    settings.single = "metadata"
                }
                var data = $.data(elem, settings.single);
                if (data) {
                    return data
                }
                data = "{}";
                if (settings.type == "class") {
                    var m = settings.cre.exec(elem.className);
                    if (m) {
                        data = m[1]
                    }
                } else {
                    if (settings.type == "elem") {
                        if (!elem.getElementsByTagName) {
                            return undefined
                        }
                        var e = elem.getElementsByTagName(settings.name);
                        if (e.length) {
                            data = $.trim(e[0].innerHTML)
                        }
                    } else {
                        if (elem.getAttribute != undefined) {
                            var attr = elem.getAttribute(settings.name);
                            if (attr) {
                                data = attr
                            }
                        }
                    }
                }
                if (data.indexOf("{") < 0) {
                    data = "{" + data + "}"
                }
                data = eval("(" + data + ")");
                $.data(elem, settings.single, data);
                return data
            }
        }
    });
    $.fn.metadata = function(opts) {
        return $.metadata.get(this[0], opts)
    }
})(jQuery);
(function(C) {
    C.extend(C.fn, {
        validate: function(D) {
            if (!this.length) {
                D && D.debug && window.console && console.warn("nothing selected, can't validate, returning nothing");
                return
            }
            var E = C.data(this[0], "validator");
            if (E) {
                return E
            }
            E = new C.validator(D, this[0]);
            C.data(this[0], "validator", E);
            if (E.settings.onsubmit) {
                this.find("input, button").filter(".cancel").click(function() {
                    E.cancelSubmit = true
                });
                this.submit(function(F) {
                    if (E.settings.debug) {
                        F.preventDefault()
                    }

                    function G() {
                        if (E.settings.submitHandler) {
                            E.settings.submitHandler.call(E, E.currentForm);
                            return false
                        }
                        return true
                    }
                    if (E.cancelSubmit) {
                        E.cancelSubmit = false;
                        return G()
                    }
                    if (E.form()) {
                        if (E.pendingRequest) {
                            E.formSubmitted = true;
                            return false
                        }
                        return G()
                    } else {
                        E.focusInvalid();
                        return false
                    }
                })
            }
            return E
        },
        valid: function() {
            if (C(this[0]).is("form")) {
                return this.validate().form()
            } else {
                var E = false;
                var D = C(this[0].form).validate();
                this.each(function() {
                    E |= D.element(this)
                });
                return E
            }
        },
        removeAttrs: function(F) {
            var D = {},
                E = this;
            C.each(F.split(/\s/), function(G, H) {
                D[H] = E.attr(H);
                E.removeAttr(H)
            });
            return D
        },
        rules: function(G, D) {
            var I = this[0];
            if (G) {
                var F = C.data(I.form, "validator").settings;
                var K = F.rules;
                var L = C.validator.staticRules(I);
                switch (G) {
                    case "add":
                        C.extend(L, C.validator.normalizeRule(D));
                        K[I.name] = L;
                        if (D.messages) {
                            F.messages[I.name] = C.extend(F.messages[I.name], D.messages)
                        }
                        break;
                    case "remove":
                        if (!D) {
                            delete K[I.name];
                            return L
                        }
                        var J = {};
                        C.each(D.split(/\s/), function(M, N) {
                            J[N] = L[N];
                            delete L[N]
                        });
                        return J
                }
            }
            var H = C.validator.normalizeRules(C.extend({}, C.validator.metadataRules(I), C.validator.classRules(I), C.validator.attributeRules(I), C.validator.staticRules(I)), I);
            if (H.required) {
                var E = H.required;
                delete H.required;
                H = C.extend({
                    required: E
                }, H)
            }
            return H
        }
    });
    C.extend(C.expr[":"], {
        blank: function(D) {
            return !C.trim(D.value)
        },
        filled: function(D) {
            return !!C.trim(D.value)
        },
        unchecked: function(D) {
            return !D.checked
        }
    });
    C.validator = function(D, E) {
        this.settings = C.extend({}, C.validator.defaults, D);
        this.currentForm = E;
        this.init()
    };
    C.extend(C.validator, {
        defaults: {
            docContext: document,
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            errorElement: "label",
            focusInvalid: true,
            errorContainer: C([]),
            errorLabelContainer: C([]),
            onsubmit: true,
            ignore: [],
            ignoreTitle: false,
            onfocusin: function(D) {
                this.lastActive = D;
                if (this.settings.focusCleanup && !this.blockFocusCleanup) {
                    this.settings.unhighlight && this.settings.unhighlight.call(this, D, this.settings.errorClass);
                    this.errorsFor(D).hide()
                }
            },
            onfocusout: function(D, E) {
                if (!this.checkable(D) && (D.name in this.submitted || !this.optional(D))) {
                    this.element(D)
                }
                this.settings.eventHandler.call(D, D, C(D).hasClass(this.settings.errorClass), E)
            },
            onkeyup: function(E, F) {
                if (E.name in this.submitted || E == this.lastElement) {
                    this.element(E);
                    this.settings.eventHandler.call(E, E, C(E).hasClass(this.settings.errorClass), F)
                } else {
                    if (E.className != "sliderText") {
                        var D = this.check(E, true);
                        if (D) {
                            this.element(E);
                            this.settings.eventHandler.call(E, E, C(E).hasClass(this.settings.errorClass), F)
                        }
                    }
                }
            },
            onchange: function(D, E) {
                if (D.name in this.submitted) {
                    this.element(D)
                }
                this.settings.eventHandler.call(D, D, C(D).hasClass(this.settings.errorClass), E)
            },
            onclick: function(D, E) {
                if (D.name in this.submitted) {
                    this.element(D)
                }
                this.settings.eventHandler.call(D, D, C(D).hasClass(this.settings.errorClass), E)
            },
            highlight: function(E, D) {
                C(E).addClass(D)
            },
            unhighlight: function(E, D) {
                C(E).removeClass(D)
            },
            eventHandler: function(D, E) {}
        },
        setDefaults: function(D) {
            C.extend(C.validator.defaults, D)
        },
        messages: strings.val,
        autoCreateRanges: false,
        prototype: {
            init: function() {
                this.labelContainer = C(this.settings.errorLabelContainer, this.settings.docContext);
                this.errorContext = this.labelContainer.length && this.labelContainer || C(this.currentForm);
                this.containers = C(this.settings.errorContainer, this.settings.docContext).add(this.settings.errorLabelContainer);
                this.submitted = {};
                this.valueCache = {};
                this.pendingRequest = 0;
                this.pending = {};
                this.invalid = {};
                this.reset();
                var D = (this.groups = {});
                C.each(this.settings.groups, function(H, I) {
                    C.each(I.split(/\s/), function(K, J) {
                        D[J] = H
                    })
                });
                var G = this.settings.rules;
                C.each(G, function(H, I) {
                    G[H] = C.validator.normalizeRule(I)
                });

                function F(I) {
                    if (!this[0].form) {
                        return
                    }
                    var H = C.data(this[0].form, "validator");
                    if (!H || C(this[0]).is(H.settings.ignore)) {
                        return
                    }
                    H.settings["on" + I.type] && H.settings["on" + I.type].call(H, this[0], I)
                }
                C(this.currentForm).delegate("focusin focusout keyup", ":text, :password, :file, textarea", F).delegate("click", ":radio, :checkbox", F);
                var E = detectBrowser();
                if (jQuery.fn.jquery == "1.3.1" && E.ie && jQuery.browser.version < 9) {
                    C(this.currentForm).delegate("click", "select", F)
                } else {
                    C(this.currentForm).delegate("change", "select", F)
                }
                if (this.settings.invalidHandler) {
                    C(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler)
                }
            },
            form: function() {
                this.checkForm();
                C.extend(this.submitted, this.errorMap);
                this.invalid = C.extend({}, this.errorMap);
                if (!this.valid()) {
                    C(this.currentForm).triggerHandler("invalid-form", [this])
                }
                this.showErrors();
                return this.valid()
            },
            checkForm: function() {
                this.prepareForm();
                for (var D = 0, E = (this.currentElements = this.elements()); E[D]; D++) {
                    this.check(E[D])
                }
                return this.valid()
            },
            element: function(H, G) {
                H = this.clean(H);
                var F = jQuery.data(H, "valRelatedMasters");
                if (F) {
                    for (var E in F) {
                        var I = this.findByName(E)[0];
                        this.element(I, true)
                    }
                }
                this.lastElement = H;
                this.prepareElement(H);
                this.currentElements = C(H);
                var D = this.check(H) !== false;
                if (D) {
                    delete this.invalid[H.name]
                } else {
                    this.invalid[H.name] = true
                }
                if (!this.numberOfInvalids()) {
                    this.toHide = this.toHide.add(this.containers)
                }
                if (!G) {
                    this.showErrors()
                }
                return D
            },
            showErrors: function(L) {
                var F = {};
                if (this.settings.customValidator && C.isFunction(this.settings.customValidator)) {
                    var K = this.settings.customValidator();
                    for (var G in K) {
                        var H = K[G].message;
                        var M = K[G].relatedInputs;
                        F[G] = H;
                        this.submitted[G] = H;
                        for (var I = 0; I < M.length; I++) {
                            this.submitted[M[I]] = H;
                            var J = this.findByName(M[I]);
                            var E = J.data("valRelatedMasters");
                            if (!E) {
                                E = {}
                            }
                            E[G] = true;
                            J.data("valRelatedMasters", E)
                        }
                    }
                }
                if (L) {
                    C.extend(F, L)
                }
                if (F) {
                    C.extend(this.errorMap, F);
                    for (var D in F) {
                        this.errorList.push({
                            message: F[D],
                            element: this.findByName(D)[0]
                        })
                    }
                    this.successList = C.grep(this.successList, function(N) {
                        return !(N.name in F)
                    })
                }
                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
            },
            resetForm: function() {
                if (C.fn.resetForm) {
                    C(this.currentForm).resetForm()
                }
                this.submitted = {};
                this.prepareForm();
                this.hideErrors();
                this.invalid = {};
                var E = this.elements();
                if (this.settings.unhighlight) {
                    for (var F = 0, D = E.length; F < D; F++) {
                        this.settings.unhighlight.call(this, E[F], this.settings.errorClass)
                    }
                } else {
                    this.elements().removeClass(this.settings.errorClass)
                }
            },
            numberOfInvalids: function() {
                return this.objectLength(this.invalid)
            },
            objectLength: function(F) {
                var E = 0;
                for (var D in F) {
                    E++
                }
                return E
            },
            hideErrors: function() {
                this.addWrapper(this.toHide).hide()
            },
            valid: function() {
                return this.size() == 0
            },
            size: function() {
                return this.errorList.length
            },
            focusInvalid: function() {
                if (this.settings.focusInvalid) {
                    try {
                        C(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus()
                    } catch (D) {}
                }
            },
            findLastActive: function() {
                var D = this.lastActive;
                return D && C.grep(this.errorList, function(E) {
                    return E.element.name == D.name
                }).length == 1 && D
            },
            elements: function() {
                var F = this,
                    D = {};
                var E = C(this.currentForm).find("input, select, textarea");
                if (E.length < 1) {
                    E = C([]).add(this.currentForm.elements).find("input, select, textarea")
                }
                return E.not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function() {
                    !this.name && F.settings.debug && window.console && console.error("%o has no name assigned", this);
                    if (this.name in D || !F.objectLength(C(this).rules())) {
                        return false
                    }
                    D[this.name] = true;
                    return true
                })
            },
            clean: function(D) {
                return C(D)[0]
            },
            errors: function() {
                return C(this.settings.errorElement + "." + this.settings.errorClass, this.errorContext)
            },
            reset: function() {
                this.successList = [];
                this.errorList = [];
                this.errorMap = {};
                this.toShow = C([]);
                this.toHide = C([]);
                this.lastElement = {};
                this.formSubmitted = false;
                this.currentElements = C([]);
                var D = C([]).add(this.currentForm.elements).filter("input, select, textarea").filter("[disabled]");
                for (var E = 0; E < D.length; E++) {
                    this.settings.unhighlight.call(this, D[E], this.settings.errorClass)
                }
            },
            prepareForm: function() {
                this.reset();
                this.toHide = this.errors().add(this.containers)
            },
            prepareElement: function(D) {
                this.reset();
                this.toHide = this.errorsFor(D)
            },
            check: function(E, G) {
                E = this.clean(E);
                if (this.checkable(E)) {
                    E = this.findByName(E.name)[0]
                }
                var J = C(E).rules();
                var F = false;
                for (method in J) {
                    var I = {
                        method: method,
                        parameters: J[method]
                    };
                    try {
                        var D = C.validator.methods[method].call(this, E.value, E, I.parameters);
                        if (D == "dependency-mismatch") {
                            F = true;
                            continue
                        }
                        F = false;
                        if (D == "pending") {
                            this.toHide = this.toHide.not(this.errorsFor(E));
                            return
                        }
                        if (!D) {
                            if (!G) {
                                this.formatAndAdd(E, I)
                            }
                            return false
                        }
                    } catch (H) {
                        this.settings.debug && window.console && console.log("exception occured when checking element " + E.id + ", check the '" + I.method + "' method");
                        throw H
                    }
                }
                if (F) {
                    return
                }
                if (this.objectLength(J)) {
                    this.successList.push(E)
                }
                return true
            },
            customMetaMessage: function(D, F) {
                if (!C.metadata) {
                    return
                }
                var E = this.settings.meta ? C(D).metadata()[this.settings.meta] : C(D).metadata();
                return E && E.messages && E.messages[F]
            },
            customMessage: function(E, F) {
                var D = this.settings.messages[E];
                return D && (D.constructor == String ? D : D[F])
            },
            findDefined: function() {
                for (var D = 0; D < arguments.length; D++) {
                    if (arguments[D] !== undefined) {
                        return arguments[D]
                    }
                }
                return undefined
            },
            defaultMessage: function(D, E) {
                return this.findDefined(this.customMessage(D.name, E), this.customMetaMessage(D, E), !this.settings.ignoreTitle && D.title || undefined, C.validator.messages[E], "<strong>Warning: No message defined for " + D.name + "</strong>")
            },
            formatAndAdd: function(D, F) {
                var E = this.defaultMessage(D, F.method);
                if (typeof E == "function") {
                    E = E.call(this, F.parameters, D)
                }
                this.errorList.push({
                    message: E,
                    element: D
                });
                this.errorMap[D.name] = E;
                this.submitted[D.name] = E
            },
            addWrapper: function(D) {
                if (this.settings.wrapper) {
                    D = D.add(D.parent(this.settings.wrapper))
                }
                return D
            },
            defaultShowErrors: function() {
                var G = [];
                for (var F = 0; this.errorList[F]; F++) {
                    var E = this.errorList[F];
                    this.settings.highlight && this.settings.highlight.call(this, E.element, this.settings.errorClass);
                    var I = true;
                    for (var D = 0; D < G.length; D++) {
                        if (G[D] == E.message) {
                            I = false
                        }
                    }
                    if (I) {
                        G.push(E.message);
                        this.showLabel(E.element, E.message)
                    }
                }
                if (this.errorList.length) {
                    this.toShow = this.toShow.add(this.containers)
                }
                if (this.settings.success) {
                    for (var F = 0; this.successList[F]; F++) {
                        this.showLabel(this.successList[F])
                    }
                }
                if (this.settings.unhighlight) {
                    for (var F = 0, H = this.validElements(); H[F]; F++) {
                        this.settings.unhighlight.call(this, H[F], this.settings.errorClass)
                    }
                }
                this.toHide = this.toHide.not(this.toShow);
                this.hideErrors();
                this.addWrapper(this.toShow).show()
            },
            validElements: function() {
                return this.currentElements.not(this.invalidElements())
            },
            invalidElements: function() {
                return C(this.errorList).map(function() {
                    return this.element
                })
            },
            showLabel: function(E, F) {
                var D = this.errorsFor(E);
                if (D.length) {
                    D.removeClass().addClass(this.settings.errorClass);
                    D.attr("generated") && D.html(F)
                } else {
                    D = C("<" + this.settings.errorElement + "/>").attr({
                        "for": this.idOrName(E),
                        generated: true
                    }).addClass(this.settings.errorClass).html(F || "");
                    if (this.settings.wrapper) {
                        D = D.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()
                    }
                    if (!this.labelContainer.append(D).length) {
                        this.settings.errorPlacement ? this.settings.errorPlacement(D, C(E)) : D.insertAfter(E)
                    }
                }
                if (!F && this.settings.success) {
                    D.text("");
                    typeof this.settings.success == "string" ? D.addClass(this.settings.success) : this.settings.success(D)
                }
                this.toShow = this.toShow.add(D)
            },
            errorsFor: function(D) {
                return this.errors().filter("[for='" + this.idOrName(D) + "']")
            },
            idOrName: function(D) {
                return this.groups[D.name] || (this.checkable(D) ? D.name : D.id || D.name)
            },
            checkable: function(D) {
                return /radio|checkbox/i.test(D.type)
            },
            findByName: function(D) {
                return C("[name='" + D + "']", this.currentForm)
            },
            getLength: function(E, D) {
                switch (D.nodeName.toLowerCase()) {
                    case "select":
                        return C("option:selected", D).length;
                    case "input":
                        if (this.checkable(D)) {
                            return this.findByName(D.name).filter(":checked").length
                        }
                }
                return E.length
            },
            depend: function(E, D) {
                return this.dependTypes[typeof E] ? this.dependTypes[typeof E](E, D) : true
            },
            dependTypes: {
                "boolean": function(E, D) {
                    return E
                },
                string: function(E, D) {
                    return !!C(E, D.form).length
                },
                "function": function(E, D) {
                    return E(D)
                }
            },
            optional: function(D) {
                return !C.validator.methods.required.call(this, C.trim(D.value), D) && "dependency-mismatch"
            },
            startRequest: function(D) {
                if (!this.pending[D.name]) {
                    this.pendingRequest++;
                    this.pending[D.name] = true
                }
            },
            stopRequest: function(D, E) {
                this.pendingRequest--;
                if (this.pendingRequest < 0) {
                    this.pendingRequest = 0
                }
                delete this.pending[D.name];
                if (E && this.pendingRequest == 0 && this.formSubmitted && this.form()) {
                    C(this.currentForm).submit()
                } else {
                    if (!E && this.pendingRequest == 0 && this.formSubmitted) {
                        C(this.currentForm).triggerHandler("invalid-form", [this])
                    }
                }
            },
            previousValue: function(D) {
                return C.data(D, "previousValue") || C.data(D, "previousValue", previous = {
                    old: null,
                    valid: true,
                    message: this.defaultMessage(D, "remote")
                })
            }
        },
        classRuleSettings: {
            required: {
                required: true
            },
            email: {
                email: true
            },
            url: {
                url: true
            },
            date: {
                date: true
            },
            dateISO: {
                dateISO: true
            },
            dateDE: {
                dateDE: true
            },
            number: {
                number: true
            },
            numberDE: {
                numberDE: true
            },
            digits: {
                digits: true
            },
            creditcard: {
                creditcard: true
            }
        },
        addClassRules: function(D, E) {
            D.constructor == String ? this.classRuleSettings[D] = E : C.extend(this.classRuleSettings, D)
        },
        classRules: function(E) {
            var F = {};
            var D = C(E).attr("class");
            D && C.each(D.split(" "), function() {
                if (this in C.validator.classRuleSettings) {
                    C.extend(F, C.validator.classRuleSettings[this])
                }
            });
            return F
        },
        attributeRules: function(E) {
            var G = {};
            var D = C(E);
            for (method in C.validator.methods) {
                var F = D.attr(method);
                if (F) {
                    G[method] = F
                }
            }
            if (G.maxlength && /-1|2147483647|524288/.test(G.maxlength)) {
                delete G.maxlength
            }
            return G
        },
        metadataRules: function(D) {
            if (!C.metadata) {
                return {}
            }
            var E = C.data(D.form, "validator").settings.meta;
            return E ? C(D).metadata()[E] : C(D).metadata()
        },
        staticRules: function(E) {
            var F = {};
            var D = C.data(E.form, "validator");
            if (D.settings.rules) {
                F = C.validator.normalizeRule(D.settings.rules[E.name]) || {}
            }
            return F
        },
        normalizeRules: function(E, D) {
            C.each(E, function(H, G) {
                if (G === false) {
                    delete E[H];
                    return
                }
                if (G.param || G.depends) {
                    var F = true;
                    switch (typeof G.depends) {
                        case "string":
                            F = !!C(G.depends, D.form).length;
                            break;
                        case "function":
                            F = G.depends.call(D, D);
                            break
                    }
                    if (F) {
                        E[H] = G.param !== undefined ? G.param : true
                    } else {
                        delete E[H]
                    }
                }
            });
            C.each(E, function(F, G) {
                E[F] = C.isFunction(G) ? G(D) : G
            });
            C.each(["minlength", "maxlength", "min", "max"], function() {
                if (E[this]) {
                    E[this] = Number(E[this])
                }
            });
            C.each(["rangelength", "range"], function() {
                if (E[this]) {
                    E[this] = [Number(E[this][0]), Number(E[this][1])]
                }
            });
            if (C.validator.autoCreateRanges) {
                if (E.min && E.max) {
                    E.range = [E.min, E.max];
                    delete E.min;
                    delete E.max
                }
                if (E.minlength && E.maxlength) {
                    E.rangelength = [E.minlength, E.maxlength];
                    delete E.minlength;
                    delete E.maxlength
                }
            }
            if (E.messages) {
                delete E.messages
            }
            return E
        },
        normalizeRule: function(E) {
            if (typeof E == "string") {
                var D = {};
                C.each(E.split(/\s/), function() {
                    D[this] = true
                });
                E = D
            }
            return E
        },
        addMethod: function(D, F, E) {
            C.validator.methods[D] = F;
            C.validator.messages[D] = E;
            if (F.length < 3) {
                C.validator.addClassRules(D, C.validator.normalizeRule(D))
            }
        },
        methods: {
            required: function(G, F, H) {
                if (!this.depend(H, F)) {
                    return "dependency-mismatch"
                }
                switch (F.nodeName.toLowerCase()) {
                    case "select":
                        var E = C("option:selected", F);
                        var D = detectBrowser();
                        return E.length > 0 && (F.type == "select-multiple" || (D.ie && !(E[0].attributes.value.specified) ? E[0].text : E[0].value).length > 0);
                    case "input":
                        if (this.checkable(F)) {
                            return this.getLength(G, F) > 0
                        }
                        default:
                            return C.trim(G).length > 0
                }
            },
            remote: function(H, E, I) {
                if (this.optional(E)) {
                    return "dependency-mismatch"
                }
                var F = this.previousValue(E);
                if (!this.settings.messages[E.name]) {
                    this.settings.messages[E.name] = {}
                }
                this.settings.messages[E.name].remote = typeof F.message == "function" ? F.message(H) : F.message;
                I = typeof I == "string" && {
                    url: I
                } || I;
                if (F.old !== H) {
                    F.old = H;
                    var D = this;
                    this.startRequest(E);
                    var G = {};
                    G[E.name] = H;
                    C.ajax(C.extend(true, {
                        url: I,
                        mode: "abort",
                        port: "validate" + E.name,
                        dataType: "json",
                        data: G,
                        success: function(K) {
                            if (K) {
                                var J = D.formSubmitted;
                                D.prepareElement(E);
                                D.formSubmitted = J;
                                D.successList.push(E);
                                D.showErrors()
                            } else {
                                var L = {};
                                L[E.name] = K || D.defaultMessage(E, "remote");
                                D.showErrors(L)
                            }
                            F.valid = K;
                            D.stopRequest(E, K)
                        }
                    }, I));
                    return "pending"
                } else {
                    if (this.pending[E.name]) {
                        return "pending"
                    }
                }
                return F.valid
            },
            minlength: function(E, D, F) {
                return this.optional(D) || this.getLength(C.trim(E), D) >= F
            },
            maxlength: function(E, D, F) {
                return this.optional(D) || this.getLength(C.trim(E), D) <= F
            },
            rangelength: function(F, D, G) {
                var E = this.getLength(C.trim(F), D);
                return this.optional(D) || (E >= G[0] && E <= G[1])
            },
            min: function(E, D, F) {
                return this.optional(D) || E >= F
            },
            max: function(E, D, F) {
                return this.optional(D) || E <= F
            },
            range: function(E, D, F) {
                return this.optional(D) || (E >= F[0] && E <= F[1])
            },
            email: function(E, D) {
                return this.optional(D) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(E)
            },
            url: function(E, D) {
                return this.optional(D) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(E)
            },
            date: function(E, D) {
                return this.optional(D) || !/Invalid|NaN/.test(new Date(E))
            },
            dateISO: function(E, D) {
                return this.optional(D) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(E)
            },
            dateDE: function(E, D) {
                return this.optional(D) || /^\d\d?\.\d\d?\.\d\d\d?\d?$/.test(E)
            },
            number: function(E, D) {
                return this.optional(D) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(E)
            },
            numberDE: function(E, D) {
                return this.optional(D) || /^-?(?:\d+|\d{1,3}(?:\.\d{3})+)(?:,\d+)?$/.test(E)
            },
            digits: function(E, D) {
                return this.optional(D) || /^\d+$/.test(E)
            },
            creditcard: function(H, E) {
                if (this.optional(E)) {
                    return "dependency-mismatch"
                }
                if (/[^0-9-]+/.test(H)) {
                    return false
                }
                var I = 0,
                    G = 0,
                    D = false;
                H = H.replace(/\D/g, "");
                for (n = H.length - 1; n >= 0; n--) {
                    var F = H.charAt(n);
                    var G = parseInt(F, 10);
                    if (D) {
                        if ((G *= 2) > 9) {
                            G -= 9
                        }
                    }
                    I += G;
                    D = !D
                }
                return (I % 10) == 0
            },
            accept: function(E, D, F) {
                F = typeof F == "string" ? F : "png|jpe?g|gif";
                return this.optional(D) || E.match(new RegExp(".(" + F + ")$", "i"))
            },
            equalTo: function(E, D, F) {
                return E == C(F).val()
            }
        }
    })
})(jQuery);
(function(E) {
    var D = E.ajax;
    var C = {};
    E.ajax = function(G) {
        G = E.extend(G, E.extend({}, E.ajaxSettings, G));
        var F = G.port;
        if (G.mode == "abort") {
            if (C[F]) {
                C[F].abort()
            }
            return (C[F] = D.apply(this, arguments))
        }
        return D.apply(this, arguments)
    }
})(jQuery);
(function(C) {
    C.each({
        focus: "focusin",
        blur: "focusout"
    }, function(E, D) {
        C.event.special[D] = {
            setup: function() {
                var F = detectBrowser();
                if (F.ie) {
                    return false
                }
                this.addEventListener(E, C.event.special[D].handler, true)
            },
            teardown: function() {
                var F = detectBrowser();
                if (F.ie) {
                    return false
                }
                this.removeEventListener(E, C.event.special[D].handler, true)
            },
            handler: function(F) {
                arguments[0] = C.event.fix(F);
                arguments[0].type = D;
                return C.event.dispatch.apply(this, arguments)
            }
        }
    });
    C.extend(C.fn, {
        delegate: function(F, E, D) {
            return this.bind(F, function(G) {
                var H = C(G.target);
                if (H.is(E)) {
                    return D.apply(H, arguments)
                }
            })
        },
        triggerEvent: function(D, E) {
            return this.triggerHandler(D, [C.event.fix({
                type: D,
                target: E
            })])
        }
    })
})(jQuery);
(function(D) {
    D.ui = D.ui || {};
    D.fn.extend({
        dialog: function(F, G) {
            var E = Array.prototype.slice.call(arguments, 1);
            return this.each(function() {
                if (typeof F == "string") {
                    var H = D.data(this, "ui-dialog") || D.data(D(this).parents(".ui-dialog:first").find(".ui-dialog-content")[0], "ui-dialog");
                    H[F].apply(H, E)
                } else {
                    if (!D(this).is(".ui-dialog-content")) {
                        new D.ui.dialog(this, F)
                    }
                }
            })
        }
    });
    D.ui.dialog = function(G, O) {
        this.options = O = D.extend({}, D.ui.dialog.defaults, O && O.modal ? {
            resizable: false
        } : {}, O);
        this.element = G;
        var N = this;
        this.isOpen = false;
        D.data(this.element, "ui-dialog", this);
        D(G).bind("setData.dialog", function(Q, P, R) {
            O[P] = R
        }).bind("getData.dialog", function(Q, P) {
            return O[P]
        });
        var H = D(G).addClass("ui-dialog-content");
        if (!H.parent().length) {
            H.appendTo("body")
        }
        H.wrap(document.createElement("div")).wrap(document.createElement("div"));
        var K = H.parent().addClass("ui-dialog-container").css({
            position: "relative"
        });
        var M = this.uiDialog = K.parent().hide().addClass("ui-dialog").css({
            position: "absolute",
            width: O.width,
            height: O.height,
            overflow: "visible"
        });
        M.prepend('<div class="shadowbox1"></div>').prepend('<div class="shadowbox2"></div>').prepend('<div class="shadowbox3"></div>');
        var E = H.attr("class").split(" ");
        D.each(E, function(P, Q) {
            if (Q != "ui-dialog-content") {
                M.addClass(Q)
            }
        });
        if (O.resizable && D.fn.resizable) {
            M.append('<div class="ui-resizable-n ui-resizable-handle"></div>').append('<div class="ui-resizable-s ui-resizable-handle"></div>').append('<div class="ui-resizable-e ui-resizable-handle"></div>').append('<div class="ui-resizable-w ui-resizable-handle"></div>').append('<div class="ui-resizable-ne ui-resizable-handle"></div>').append('<div class="ui-resizable-se ui-resizable-handle"></div>').append('<div class="ui-resizable-sw ui-resizable-handle"></div>').append('<div class="ui-resizable-nw ui-resizable-handle"></div>');
            M.resizable({
                maxWidth: O.maxWidth,
                maxHeight: O.maxHeight,
                minWidth: O.minWidth,
                minHeight: O.minHeight
            })
        }
        K.prepend('<div class="ui-dialog-titlebar"></div>');
        var F = D(".ui-dialog-titlebar", K);
        var L = (O.title) ? O.title : (H.attr("title")) ? H.attr("title") : "";
        F.append('<span class="ui-dialog-title">' + L + "</span>");
        if (O.decorations) {
            F.append('<a href="#" class="ui-dialog-titlebar-close"></a>');
            this.uiDialogTitlebarClose = D(".ui-dialog-titlebar-close", F).hover(function() {
                D(this).addClass("ui-dialog-titlebar-close-hover")
            }, function() {
                D(this).removeClass("ui-dialog-titlebar-close-hover")
            }).mousedown(function(P) {
                P.stopPropagation()
            }).click(function() {
                N.close();
                return false
            }).keydown(function(P) {
                var Q = 27;
                P.keyCode && P.keyCode == Q && N.close()
            })
        }
        var I = 0;
        D.each(O.buttons, function() {
            I = 1;
            return false
        });
        if (I == 1) {
            M.append('<div class="ui-dialog-buttonpane"></div>');
            var J = D(".ui-dialog-buttonpane", M);
            D.each(O.buttons, function(P, R) {
                var Q = D(document.createElement("button")).text(P).click(R);
                J.append(Q)
            })
        }
        if (O.draggable && D.fn.draggable) {
            M.draggable({
                handle: ".ui-dialog-titlebar",
                start: function() {
                    N.activate()
                }
            })
        }
        O.bgiframe && D.fn.bgiframe && M.bgiframe();
        this.open = function() {
            if (this.isOpen) {
                return
            }
            if (O.modal) {
                this.overlay = new C(N, O.overlay);
                this.overlay.show()
            }
            M.appendTo("body");
            this.position();
            M.show();
            N.activate();
            var P = null;
            var Q = {
                options: O
            };
            if (this.uiDialogTitlebarClose) {
                this.uiDialogTitlebarClose.focus()
            }
            this.isOpen = true;
            D(this.element).triggerHandler("dialogopen", [P, Q], O.open)
        };
        this.activate = function() {
            var P = 0;
            D(".ui-dialog:visible").each(function() {
                var Q = D(this).css("z-index");
                if (Q == undefined) {
                    Q = 0
                } else {
                    Q = parseInt(Q, 10)
                }
                P = Math.max(P, Q)
            });
            if (this.overlay) {
                this.overlay.setZindex(++P)
            }
            M.css("z-index", ++P)
        };
        this.close = function() {
            if (O.modal && this.overlay) {
                this.overlay.hide();
                delete this.overlay
            }
            M.hide();
            var Q = null;
            var P = {
                options: O
            };
            this.isOpen = false;
            D(this.element).triggerHandler("dialogclose", [Q, P], O.close)
        };
        this.position = function() {
            var P = D(window),
                S = D(document),
                R = S.scrollTop(),
                Q = S.scrollLeft();
            if (O.position.constructor == Array) {
                R += O.position[1];
                Q += O.position[0]
            } else {
                switch (O.position) {
                    case "center":
                        R += (P.height() / 2) - (M.height() / 2);
                        Q += (P.width() / 2) - (M.width() / 2);
                        break;
                    case "top":
                        R += 0;
                        Q += (P.width() / 2) - (M.width() / 2);
                        break;
                    case "right":
                        R += (P.height() / 2) - (M.height() / 2);
                        Q += (P.width()) - (M.width());
                        break;
                    case "bottom":
                        R += (P.height()) - (M.height());
                        Q += (P.width() / 2) - (M.width() / 2);
                        break;
                    case "left":
                        R += (P.height() / 2) - (M.height() / 2);
                        Q += 0;
                        break;
                    default:
                        R += (P.height() / 2) - (M.height() / 2);
                        Q += (P.width() / 2) - (M.width() / 2)
                }
            }
            R = R < S.scrollTop() ? S.scrollTop() : R;
            M.css({
                top: R,
                left: Q
            })
        };
        if (O.autoOpen) {
            this.open()
        }
    };
    D.extend(D.ui.dialog, {
        defaults: {
            autoOpen: true,
            bgiframe: false,
            buttons: [],
            draggable: true,
            height: 200,
            minHeight: 100,
            minWidth: 150,
            modal: false,
            overlay: {},
            position: "center",
            resizable: true,
            decorations: true,
            width: 300
        }
    });

    function C(F, E) {
        this.dialog = F;
        this.css = E;
        this.$el = null;
        this.events = D.map("focus,mousedown,mouseup,keydown,keypress,click".split(","), function(G) {
            return G + ".ui-dialog-overlay"
        }).join(" ")
    }
    C.prototype.show = function() {
        if (this.$el) {
            return
        }
        var G = C.width();
        var E = C.height();
        this.$el = D("<div/>").appendTo(document.body).addClass("ui-dialog-overlay").css(D.extend({
            borderWidth: 0,
            margin: 0,
            padding: 0,
            position: "absolute",
            top: 0,
            left: 0,
            width: G,
            height: E
        }, this.css));
        D("a, :input").bind(this.events, function() {
            if (D(this).parents(".ui-dialog").length == 0) {
                if (this.dialog && this.dialog.uiDialogTitlebarClose) {
                    this.dialog.uiDialogTitlebarClose.focus()
                }
                return false
            }
        });
        D(document).bind("keydown.ui-dialog-overlay", function(H) {
            var I = 27;
            H.keyCode && H.keyCode == I && this.dialog && this.dialog.close && this.dialog.close()
        });
        $overlay = this.$el;

        function F() {
            $overlay.css({
                width: G,
                height: E
            }).css({
                width: C.width(),
                height: C.height()
            })
        }
        D(window).bind("resize.ui-dialog-overlay", F);
        this.dialog.uiDialog.is(".ui-draggable") && this.dialog.uiDialog.data("stop.draggable", F);
        this.dialog.uiDialog.is(".ui-resizable") && this.dialog.uiDialog.data("stop.resizable", F)
    };
    C.prototype.hide = function() {
        D("a, :input").add([document, window]).unbind(".ui-dialog-overlay");
        if (this.$el) {
            this.$el.remove()
        }
        this.$el = null
    };
    C.prototype.setZindex = function(E) {
        if (this.$el) {
            this.$el.css("z-index", E)
        }
    };
    C.height = function() {
        var E;
        E = D(document).height();
        return E + "px"
    };
    C.width = function() {
        var E;
        E = D(document).width();
        return E + "px"
    }
})(jQuery);
(function(C) {
    C.ui = C.ui || {};
    C.extend(C.ui, {
        plugin: {
            add: function(E, F, H) {
                var G = C.ui[E].prototype;
                for (var D in H) {
                    G.plugins[D] = G.plugins[D] || [];
                    G.plugins[D].push([F, H[D]])
                }
            },
            call: function(D, E, G) {
                var H = D.plugins[E];
                if (!H) {
                    return
                }
                for (var F = 0; F < H.length; F++) {
                    if (D.options[H[F][0]]) {
                        H[F][1].apply(D.element, G)
                    }
                }
            }
        },
        cssCache: {},
        css: function(D) {
            if (C.ui.cssCache[D]) {
                return C.ui.cssCache[D]
            }
            var E = C('<div class="ui-resizable-gen">').addClass(D).css({
                position: "absolute",
                top: "-5000px",
                left: "-5000px",
                display: "block"
            }).appendTo("body");
            C.ui.cssCache[D] = !!(((/^[1-9]/).test(E.css("height")) || (/^[1-9]/).test(E.css("width")) || !(/none/).test(E.css("backgroundImage")) || !(/transparent|rgba\(0, 0, 0, 0\)/).test(E.css("backgroundColor"))));
            try {
                C("body").get(0).removeChild(E.get(0))
            } catch (F) {}
            return C.ui.cssCache[D]
        },
        disableSelection: function(D) {
            if (!D) {
                return
            }
            D.unselectable = "on";
            D.onselectstart = function() {
                return false
            };
            if (D.style) {
                D.style.MozUserSelect = "none"
            }
        },
        enableSelection: function(D) {
            if (!D) {
                return
            }
            D.unselectable = "off";
            D.onselectstart = function() {
                return true
            };
            if (D.style) {
                D.style.MozUserSelect = ""
            }
        }
    });
    C.fn.extend({
        mouseInteraction: function(D) {
            return this.each(function() {
                new C.ui.mouseInteraction(this, D)
            })
        },
        removeMouseInteraction: function(D) {
            return this.each(function() {
                if (C.data(this, "ui-mouse")) {
                    C.data(this, "ui-mouse").destroy()
                }
            })
        }
    });
    C.ui.mouseInteraction = function(F, E) {
        var D = this;
        this.element = F;
        C.data(this.element, "ui-mouse", this);
        this.options = C.extend({}, E);
        C(F).bind("mousedown.draggable", function() {
            return D.click.apply(D, arguments)
        })
    };
    C.extend(C.ui.mouseInteraction.prototype, {
        destroy: function() {
            C(this.element).unbind("mousedown.draggable")
        },
        trigger: function() {
            return this.click.apply(this, arguments)
        },
        click: function(F) {
            if (F.which != 1 || C.inArray(F.target.nodeName.toLowerCase(), this.options.dragPrevention) != -1 || (this.options.condition && !this.options.condition.apply(this.options.executor || this, [F, this.element]))) {
                return true
            }
            var E = this;
            var D = function() {
                E._MP = {
                    left: F.pageX,
                    top: F.pageY
                };
                C(document).bind("mouseup.draggable", function() {
                    return E.stop.apply(E, arguments)
                });
                C(document).bind("mousemove.draggable", function() {
                    return E.drag.apply(E, arguments)
                })
            };
            if (this.options.delay) {
                if (this.timer) {
                    clearInterval(this.timer)
                }
                this.timer = setTimeout(D, this.options.delay)
            } else {
                D()
            }
            return false
        },
        stop: function(D) {
            var E = this.options;
            if (!this.initialized) {
                return C(document).unbind("mouseup.draggable").unbind("mousemove.draggable")
            }
            if (this.options.stop) {
                this.options.stop.call(this.options.executor || this, D, this.element)
            }
            C(document).unbind("mouseup.draggable").unbind("mousemove.draggable");
            this.initialized = false;
            return false
        },
        drag: function(D) {
            var E = this.options;
            if (!this.initialized && (Math.abs(this._MP.left - D.pageX) >= E.distance || Math.abs(this._MP.top - D.pageY) >= E.distance)) {
                if (this.options.start) {
                    this.options.start.call(this.options.executor || this, D, this.element)
                }
                this.initialized = true
            } else {
                if (!this.initialized) {
                    return false
                }
            }
            if (E.drag) {
                E.drag.call(this.options.executor || this, D, this.element)
            }
            return false
        }
    })
})(jQuery);
(function(C) {
    C.fn.extend({
        draggable: function(E) {
            var D = Array.prototype.slice.call(arguments, 1);
            return this.each(function() {
                if (typeof E == "string") {
                    var F = C.data(this, "ui-draggable");
                    F[E].apply(F, D)
                } else {
                    if (!C.data(this, "ui-draggable")) {
                        new C.ui.draggable(this, E)
                    }
                }
            })
        }
    });
    C.ui.draggable = function(F, E) {
        var D = this;
        this.element = C(F);
        C.data(F, "ui-draggable", this);
        this.element.addClass("ui-draggable");
        this.options = C.extend({}, E);
        var G = this.options;
        C.extend(G, {
            helper: G.ghosting == true ? "clone" : (G.helper || "original"),
            handle: G.handle ? (C(G.handle, F)[0] ? C(G.handle, F) : this.element) : this.element,
            appendTo: G.appendTo || "parent"
        });
        C(F).bind("setData.draggable", function(I, H, J) {
            D.options[H] = J
        }).bind("getData.draggable", function(I, H) {
            return D.options[H]
        });
        C(G.handle).mouseInteraction({
            executor: this,
            delay: G.delay,
            distance: G.distance || 0,
            dragPrevention: G.prevention ? G.prevention.toLowerCase().split(",") : ["input", "textarea", "button", "select", "option"],
            start: this.start,
            stop: this.stop,
            drag: this.drag,
            condition: function(H) {
                return !(H.target.className.indexOf("ui-resizable-handle") != -1 || this.disabled)
            }
        });
        if (G.helper == "original" && (this.element.css("position") == "static" || this.element.css("position") == "")) {
            this.element.css("position", "relative")
        }
    };
    C.extend(C.ui.draggable.prototype, {
        plugins: {},
        ui: function(D) {
            return {
                helper: this.helper,
                position: this.position,
                absolutePosition: this.positionAbs,
                instance: this,
                options: this.options
            }
        },
        propagate: function(E, D) {
            C.ui.plugin.call(this, E, [D, this.ui()]);
            return this.element.triggerHandler(E == "drag" ? E : "drag" + E, [D, this.ui()], this.options[E])
        },
        destroy: function() {
            this.handle.removeMouseInteraction();
            this.element.removeClass("ui-draggable ui-draggable-disabled").removeData("ui-draggable").unbind(".draggable")
        },
        enable: function() {
            this.element.removeClass("ui-draggable-disabled");
            this.disabled = false
        },
        disable: function() {
            this.element.addClass("ui-draggable-disabled");
            this.disabled = true
        },
        recallOffset: function(F) {
            var E = {
                left: this.elementOffset.left - this.offsetParentOffset.left,
                top: this.elementOffset.top - this.offsetParentOffset.top
            };
            var D = this.helper.css("position") == "relative";
            this.originalPosition = {
                left: (D ? parseInt(this.helper.css("left"), 10) || 0 : E.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft)),
                top: (D ? parseInt(this.helper.css("top"), 10) || 0 : E.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop))
            };
            this.offset = {
                left: this._pageX - this.originalPosition.left,
                top: this._pageY - this.originalPosition.top
            }
        },
        start: function(F) {
            var G = this.options;
            if (C.ui.ddmanager) {
                C.ui.ddmanager.current = this
            }
            this.helper = typeof G.helper == "function" ? C(G.helper.apply(this.element[0], [F])) : (G.helper == "clone" ? this.element.clone().appendTo((G.appendTo == "parent" ? this.element[0].parentNode : G.appendTo)) : this.element);
            if (this.helper[0] != this.element[0]) {
                this.helper.css("position", "absolute")
            }
            if (!this.helper.parents("body").length) {
                this.helper.appendTo((G.appendTo == "parent" ? this.element[0].parentNode : G.appendTo))
            }
            this.helper.addClass("dragging");
            this.offsetParent = (function(H) {
                while (H) {
                    if (H.style && (/(absolute|relative|fixed)/).test(C.css(H, "position"))) {
                        return C(H)
                    }
                    H = H.parentNode ? H.parentNode : null
                }
                return C("body")
            })(this.helper[0].parentNode);
            this.elementOffset = this.element.offset();
            this.offsetParentOffset = this.offsetParent.offset();
            var E = {
                left: this.elementOffset.left - this.offsetParentOffset.left,
                top: this.elementOffset.top - this.offsetParentOffset.top
            };
            this._pageX = F.pageX;
            this._pageY = F.pageY;
            this.clickOffset = {
                left: F.pageX - this.elementOffset.left,
                top: F.pageY - this.elementOffset.top
            };
            var D = this.helper.css("position") == "relative";
            this.originalPosition = {
                left: (D ? parseInt(this.helper.css("left"), 10) || 0 : E.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft)),
                top: (D ? parseInt(this.helper.css("top"), 10) || 0 : E.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop))
            };
            if (this.element.css("position") == "fixed") {
                this.originalPosition.top -= this.offsetParent[0] == document.body ? C(document).scrollTop() : this.offsetParent[0].scrollTop;
                this.originalPosition.left -= this.offsetParent[0] == document.body ? C(document).scrollLeft() : this.offsetParent[0].scrollLeft
            }
            this.offset = {
                left: F.pageX - this.originalPosition.left,
                top: F.pageY - this.originalPosition.top
            };
            this.propagate("start", F);
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
            if (C.ui.ddmanager && !G.dropBehaviour) {
                C.ui.ddmanager.prepareOffsets(this, F)
            }
            if (G.cursorAt) {
                if (G.cursorAt.top != undefined || G.cursorAt.bottom != undefined) {
                    this.offset.top -= this.clickOffset.top - (G.cursorAt.top != undefined ? G.cursorAt.top : (this.helperProportions.height - G.cursorAt.bottom));
                    this.clickOffset.top = (G.cursorAt.top != undefined ? G.cursorAt.top : (this.helperProportions.height - G.cursorAt.bottom))
                }
                if (G.cursorAt.left != undefined || G.cursorAt.right != undefined) {
                    this.offset.left -= this.clickOffset.left - (G.cursorAt.left != undefined ? G.cursorAt.left : (this.helperProportions.width - G.cursorAt.right));
                    this.clickOffset.left = (G.cursorAt.left != undefined ? G.cursorAt.left : (this.helperProportions.width - G.cursorAt.right))
                }
            }
            return false
        },
        clear: function() {
            if (C.ui.ddmanager) {
                C.ui.ddmanager.current = null
            }
            this.helper = null
        },
        stop: function(D) {
            if (C.ui.ddmanager && !this.options.dropBehaviour) {
                C.ui.ddmanager.drop(this, D)
            }
            this.propagate("stop", D);
            if (this.cancelHelperRemoval) {
                return false
            }
            if (this.options.helper != "original") {
                this.helper.remove()
            }
            this.clear();
            return false
        },
        drag: function(D) {
            this.position = {
                top: D.pageY - this.offset.top,
                left: D.pageX - this.offset.left
            };
            this.positionAbs = {
                left: D.pageX - this.clickOffset.left,
                top: D.pageY - this.clickOffset.top
            };
            this.position = this.propagate("drag", D) || this.position;
            this.helper.css({
                left: this.position.left + "px",
                top: this.position.top + "px"
            });
            if (C.ui.ddmanager) {
                C.ui.ddmanager.drag(this, D)
            }
            return false
        }
    })
})(jQuery);
(function(C) {
    C.fn.resizable = function(D) {
        return this.each(function() {
            var F = Array.prototype.slice.call(arguments, 1);
            if (typeof D == "string") {
                var E = C.data(this, "ui-resizable");
                E[D].apply(E, F)
            } else {
                if (!C(this).is(".ui-resizable")) {
                    new C.ui.resizable(this, D)
                }
            }
        })
    };
    C.ui.resizable = function(M, T) {
        var S = this;
        this.element = C(M);
        C.data(M, "ui-resizable", this);
        this.element.addClass("ui-resizable");
        this.options = C.extend({
            preventDefault: true,
            transparent: false,
            minWidth: 10,
            minHeight: 10,
            aspectRatio: false,
            disableSelection: true,
            preserveCursor: true,
            autohide: false
        }, T);
        this.options._aspectRatio = !!(this.options.aspectRatio);
        C(M).bind("setData.resizable", function(V, U, W) {
            S.options[U] = W
        }).bind("getData.resizable", function(V, U) {
            return S.options[U]
        });
        var E = this.options;
        var G = "1px solid #DEDEDE";
        E.defaultTheme = {
            "ui-resizable": {
                display: "block"
            },
            "ui-resizable-handle": {
                position: "absolute",
                background: "#F5F5F5"
            },
            "ui-resizable-n": {
                cursor: "n-resize",
                height: "4px",
                left: "0px",
                right: "0px",
                borderTop: G
            },
            "ui-resizable-s": {
                cursor: "s-resize",
                height: "4px",
                left: "0px",
                right: "0px",
                borderBottom: G
            },
            "ui-resizable-e": {
                cursor: "e-resize",
                width: "4px",
                top: "0px",
                bottom: "0px",
                borderRight: G
            },
            "ui-resizable-w": {
                cursor: "w-resize",
                width: "4px",
                top: "0px",
                bottom: "0px",
                borderLeft: G
            },
            "ui-resizable-se": {
                cursor: "se-resize",
                width: "4px",
                height: "4px",
                borderRight: G,
                borderBottom: G
            },
            "ui-resizable-sw": {
                cursor: "sw-resize",
                width: "4px",
                height: "4px",
                borderBottom: G,
                borderLeft: G
            },
            "ui-resizable-ne": {
                cursor: "ne-resize",
                width: "4px",
                height: "4px",
                borderRight: G,
                borderTop: G
            },
            "ui-resizable-nw": {
                cursor: "nw-resize",
                width: "4px",
                height: "4px",
                borderLeft: G,
                borderTop: G
            }
        };
        if (!E.proxy && (this.element.css("position") == "static" || this.element.css("position") == "")) {
            this.element.css("position", "relative")
        }
        var Q = M.nodeName;
        if (Q.match(/textarea|input|select|button|img/i)) {
            this.element.wrap('<div class="ui-wrapper"  style="overflow: hidden; position: relative; width: ' + this.element.outerWidth() + "px; height: " + this.element.outerHeight() + ';"></div>');
            var K = this.element;
            M = M.parentNode;
            this.element = C(M);
            this.element.css({
                marginLeft: K.css("marginLeft"),
                marginTop: K.css("marginTop"),
                marginRight: K.css("marginRight"),
                marginBottom: K.css("marginBottom")
            });
            K.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            });
            if (C.browser.safari && E.preventDefault) {
                K.css("resize", "none")
            }
            E.proportionallyResize = K.css("position", "static");
            this._proportionallyResize()
        }
        if (!E.handles) {
            E.handles = !C(".ui-resizable-handle", M).length ? "e,s,se" : {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            }
        }
        if (E.handles.constructor == String) {
            if (E.handles == "all") {
                E.handles = "n,e,s,w,se,sw,ne,nw"
            }
            var F = E.handles.split(",");
            E.handles = {};
            E.zIndex = E.zIndex || 1000;
            var J = {
                handle: "overflow:hidden; position:absolute;",
                n: "top: 0pt; width:100%;",
                e: "right: 0pt; height:100%;",
                s: "bottom: 0pt; width:100%;",
                w: "left: 0pt; height:100%;",
                se: "bottom: 0pt; right: 0px;",
                sw: "bottom: 0pt; left: 0px;",
                ne: "top: 0pt; right: 0px;",
                nw: "top: 0pt; left: 0px;"
            };
            for (var L = 0; L < F.length; L++) {
                var O = jQuery.trim(F[L]),
                    R = E.defaultTheme,
                    D = "ui-resizable-" + O;
                var P = C.extend(R[D], R["ui-resizable-handle"]),
                    I = C(['<div class="', D, ' ui-resizable-handle" style="', J[O], J.handle, '"></div>'].join("")).css(/sw|se|ne|nw/.test(O) ? {
                        zIndex: ++E.zIndex
                    } : {});
                E.handles[O] = ".ui-resizable-" + O;
                this.element.append(I.css(!C.ui.css(D) ? P : {}))
            }
        }
        this._renderAxis = function(Y) {
            Y = Y || this.element;
            for (var V in E.handles) {
                if (E.handles[V].constructor == String) {
                    E.handles[V] = C(E.handles[V], M).show()
                }
                if (E.transparent) {
                    E.handles[V].css({
                        opacity: 0
                    })
                }
                if (this.element.is(".ui-wrapper") && Q.match(/textarea|input|select|button/i)) {
                    var W = C(E.handles[V], M),
                        X = 0;
                    X = /sw|ne|nw|se|n|s/.test(V) ? W.outerHeight() : W.outerWidth();
                    var U = ["padding", /ne|nw|n/.test(V) ? "Top" : /se|sw|s/.test(V) ? "Bottom" : /^e$/.test(V) ? "Right" : "Left"].join("");
                    if (!E.transparent) {
                        Y.css(U, X)
                    }
                }
                if (!C(E.handles[V]).length) {
                    continue
                }
            }
        };
        this._renderAxis(this.element);
        var H = C(".ui-resizable-handle", S.element);
        if (E.disableSelection) {
            H.each(function(U, V) {
                C.ui.disableSelection(V)
            })
        }
        H.mouseover(function() {
            if (!E.resizing) {
                if (this.className) {
                    var U = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)
                }
                E.axis = U && U[1] ? U[1] : "se"
            }
        });
        if (E.autohide) {
            var N = C.ui.css("ui-resizable-s") || C.ui.css("ui-resizable-e");
            if (!N) {
                H.hide()
            }
            C(S.element).addClass("ui-resizable-autohide").hover(function() {
                if (!N) {
                    H.show()
                }
                C(this).removeClass("ui-resizable-autohide")
            }, function() {
                if (!E.resizing) {
                    if (!N) {
                        H.hide()
                    }
                    C(this).addClass("ui-resizable-autohide")
                }
            })
        }
        this.element.mouseInteraction({
            executor: this,
            delay: 0,
            distance: 0,
            dragPrevention: ["input", "textarea", "button", "select", "option"],
            start: this.start,
            stop: this.stop,
            drag: this.drag,
            condition: function(V) {
                if (this.disabled) {
                    return false
                }
                for (var U in this.options.handles) {
                    if (C(this.options.handles[U])[0] == V.target) {
                        return true
                    }
                }
                return false
            }
        })
    };
    C.extend(C.ui.resizable.prototype, {
        plugins: {},
        ui: function() {
            return {
                instance: this,
                axis: this.options.axis,
                options: this.options
            }
        },
        _proportionallyResize: function() {
            var G = this.options;
            if (!G.proportionallyResize) {
                return
            }
            var E = G.proportionallyResize;
            var D = [E.css("borderTopWidth"), E.css("borderRightWidth"), E.css("borderBottomWidth"), E.css("borderLeftWidth")];
            var F = [E.css("paddingTop"), E.css("paddingRight"), E.css("paddingBottom"), E.css("paddingLeft")];
            G.borderDif = G.borderDif || C.map(D, function(H, J) {
                var I = parseInt(H, 10) || 0,
                    K = parseInt(F[J], 10) || 0;
                return I + K
            });
            E.css({
                display: "block",
                height: (this.element.height() - G.borderDif[0] - G.borderDif[2]) + "px",
                width: (this.element.width() - G.borderDif[1] - G.borderDif[3]) + "px"
            })
        },
        _renderProxy: function() {
            var D = this.element,
                F = this.options;
            this.offset = D.offset();
            if (F.proxy) {
                this.helper = this.helper || C('<div style="overflow:hidden;"></div>');
                var E = (C.browser.msie && C.browser.version < 7 ? 3 : 0);
                this.helper.addClass(F.proxy).css({
                    width: D.outerWidth(),
                    height: D.outerHeight(),
                    position: "absolute",
                    left: this.offset.left - E + "px",
                    top: this.offset.top - E + "px",
                    zIndex: ++F.zIndex
                });
                this.helper.appendTo("body");
                if (F.disableSelection) {
                    C.ui.disableSelection(this.helper.get(0))
                }
            } else {
                this.helper = D
            }
        },
        propagate: function(E, D) {
            C.ui.plugin.call(this, E, [D, this.ui()]);
            this.element.triggerHandler(E == "resize" ? E : "resize" + E, [D, this.ui()], this.options[E])
        },
        destroy: function() {
            this.element.removeClass("ui-resizable ui-resizable-disabled").removeMouseInteraction().removeData("ui-resizable").unbind(".resizable")
        },
        enable: function() {
            this.element.removeClass("ui-resizable-disabled");
            this.disabled = false
        },
        disable: function() {
            this.element.addClass("ui-resizable-disabled");
            this.disabled = true
        },
        start: function(N) {
            var I = this.options,
                E = this.element.position(),
                J = this.element;
            I.resizing = true;
            I.documentScroll = {
                top: C(document).scrollTop(),
                left: C(document).scrollLeft()
            };
            if (J.is(".ui-draggable") || (/absolute/).test(J.css("position"))) {
                var Q = C.browser.msie && !I.containment && (/absolute/).test(J.css("position")) && !(/relative/).test(J.parent().css("position"));
                var R = Q ? I.documentScroll.top : 0,
                    L = Q ? I.documentScroll.left : 0;
                J.css({
                    position: "absolute",
                    top: (E.top + R),
                    left: (E.left + L)
                })
            }
            if (/relative/.test(J.css("position")) && C.browser.opera) {
                J.css({
                    position: "relative",
                    top: "auto",
                    left: "auto"
                })
            }
            this._renderProxy();
            var S = parseInt(this.helper.css("left"), 10) || 0,
                K = parseInt(this.helper.css("top"), 10) || 0;
            C.extend(I, {
                currentSize: {
                    width: J.outerWidth(),
                    height: J.outerHeight()
                },
                currentSizeDiff: {
                    width: J.outerWidth() - J.width(),
                    height: J.outerHeight() - J.height()
                },
                startMousePosition: {
                    left: N.pageX,
                    top: N.pageY
                },
                startPosition: {
                    left: S,
                    top: K
                },
                currentPosition: {
                    left: S,
                    top: K
                }
            });
            var G = I.currentSize.width < I.currentSize.height;
            I.aspectRatio = (typeof I.aspectRatio == "number") ? I.aspectRatio : Math.pow(I.currentSize.width / I.currentSize.height, G ? 1 : -1);
            I.aspectRatioTarget = G ? "width" : "height";
            if (I.preserveCursor) {
                C("body").css("cursor", I.axis + "-resize")
            }
            if (I.containment) {
                var F = I.containment,
                    H = (F instanceof jQuery) ? F.get(0) : (/parent/.test(F)) ? J.parent().get(0) : null;
                if (H) {
                    var P = function(W, U) {
                        var T = /top/.test(U || "top") ? "scrollTop" : "scrollLeft",
                            V = false;
                        if (W[T] > 0) {
                            return true
                        }
                        W[T] = 1;
                        V = W[T] > 0 ? true : false;
                        W[T] = 0;
                        return V
                    };
                    var O = C(H).offset(),
                        D = C(H).innerHeight(),
                        M = C(H).innerWidth();
                    I.cdata = {
                        e: H,
                        l: O.left,
                        t: O.top,
                        w: (P(H, "left") ? H.scrollWidth : M),
                        h: (P(H) ? H.scrollHeight : D)
                    }
                }
                if (/document/.test(F) || F == document) {
                    I.cdata = {
                        e: document,
                        l: 0,
                        t: 0,
                        w: C(document).width(),
                        h: C(document).height()
                    }
                }
            }
            this.propagate("start", N);
            return false
        },
        stop: function(E) {
            this.options.resizing = false;
            var F = this.options;
            if (F.proxy) {
                var D = {
                    width: (this.helper.width() - F.currentSizeDiff.width) + "px",
                    height: (this.helper.height() - F.currentSizeDiff.height) + "px",
                    top: ((parseInt(this.element.css("top"), 10) || 0) + ((parseInt(this.helper.css("top"), 10) - this.offset.top) || 0)),
                    left: ((parseInt(this.element.css("left"), 10) || 0) + ((parseInt(this.helper.css("left"), 10) - this.offset.left) || 0))
                };
                this.element.css(D);
                if (F.proxy) {
                    this._proportionallyResize()
                }
                this.helper.remove()
            }
            if (F.preserveCursor) {
                C("body").css("cursor", "auto")
            }
            this.propagate("stop", E);
            return false
        },
        drag: function(G) {
            var E = this.helper,
                D = this.options,
                I = {},
                Q = this,
                M = D._aspectRatio || G.shiftKey;
            var J = function(X, W) {
                var V = (X == "top" || X == "height"),
                    S = (X == "width" || X == "height"),
                    Z = (D.axis == "se" || D.axis == "s" || D.axis == "e");
                var U = (G[V ? "pageY" : "pageX"] - D.startMousePosition[V ? "top" : "left"]) * (W ? -1 : 1);
                var R = D[S ? "currentSize" : "startPosition"][X] - U - (!D.proxy && Z ? D.currentSizeDiff.width : 0);
                if (M) {
                    var Y = R * Math.pow(D.aspectRatio, (V ? -1 : 1) * (D.aspectRatioTarget == "height" ? 1 : -1)),
                        T = false;
                    if (V && Y >= D.maxWidth || !V && Y >= D.maxHeight) {
                        T = true
                    }
                    if (V && Y <= D.minWidth || !V && Y <= D.minHeight) {
                        T = true
                    }
                    if (S && !T) {
                        E.css(V ? "width" : "height", Y)
                    }
                    if (X == "top" && (D.axis == "ne" || D.axis == "nw")) {
                        return
                    }
                }
                E.css(X, R)
            };
            var L = D.axis,
                K = 0,
                O;
            if (L == "n" || L == "ne" || L == "nw") {
                J("height")
            }
            if (L == "s" || L == "se" || L == "sw") {
                J("height", 1)
            }
            var H = parseInt(E.css("height"), 10) || 0;
            if (D.minHeight && H <= D.minHeight) {
                E.css("height", D.minHeight)
            }
            if (D.maxHeight && H >= D.maxHeight) {
                E.css("height", D.maxHeight)
            }
            if (L == "n" || L == "ne" || L == "nw") {
                J("top", 1)
            }
            var F = parseInt(E.css("top"), 10) || 0;
            K = (D.startPosition.top + (D.currentSize.height - D.minHeight));
            O = (D.startPosition.top + (D.currentSize.height - D.maxHeight));
            if (D.minHeight && F >= K) {
                E.css("top", K)
            }
            if (D.maxHeight && F <= O) {
                E.css("top", O)
            }
            if (L == "e" || L == "se" || L == "ne") {
                J("width", 1)
            }
            if (L == "sw" || L == "w" || L == "nw") {
                J("width")
            }
            var N = parseInt(E.css("width"), 10) || 0;
            if (D.minWidth && N <= D.minWidth) {
                E.css("width", D.minWidth)
            }
            if (D.maxWidth && N >= D.maxWidth) {
                E.css("width", D.maxWidth)
            }
            if (L == "sw" || L == "w" || L == "nw") {
                J("left", 1)
            }
            var P = parseInt(E.css("left"), 10) || 0;
            K = (D.startPosition.left + (D.currentSize.width - D.minWidth));
            O = (D.startPosition.left + (D.currentSize.width - D.maxWidth));
            if (D.minWidth && P >= K) {
                E.css("left", K)
            }
            if (D.maxWidth && P <= O) {
                E.css("left", O)
            }
            if (D.containment && D.cdata.e) {
                if (P < 0) {
                    E.css("left", 0);
                    E.css("width", N + P)
                }
                if (F < 0) {
                    E.css("top", 0);
                    E.css("height", H + F)
                }
                if (N + D.currentSizeDiff.width + P >= D.cdata.w) {
                    E.css("width", D.cdata.w - D.currentSizeDiff.width - (P < 0 ? 0 : P))
                }
                if (H + D.currentSizeDiff.height + F >= D.cdata.h) {
                    E.css("height", D.cdata.h - D.currentSizeDiff.height - (F < 0 ? 0 : F))
                }
            }
            D.currentPosition = {
                left: P,
                top: F
            };
            if (!D.proxy) {
                this._proportionallyResize()
            }
            this.propagate("resize", G);
            return false
        }
    })
})(jQuery);
(function(C) {
    C.ui = C.ui || {};
    C.fn.tabs = function() {
        var E = typeof arguments[0] == "string" && arguments[0];
        var D = E && Array.prototype.slice.call(arguments, 1) || arguments;
        return this.each(function() {
            if (E) {
                var F = C.data(this, "ui-tabs");
                F[E].apply(F, D)
            } else {
                new C.ui.tabs(this, D[0] || {})
            }
        })
    };
    C.ui.tabs = function(F, E) {
        var D = this;
        this.element = F;
        this.options = C.extend({
            selected: 0,
            unselect: E.selected === null,
            event: "click",
            disabled: [],
            cookie: null,
            spinner: "Loading&#8230;",
            cache: false,
            idPrefix: "ui-tabs-",
            ajaxOptions: {},
            fx: null,
            tabTemplate: '<li><a href="#{href}"><span>#{label}</span></a></li>',
            panelTemplate: "<div></div>",
            navClass: "ui-tabs-nav",
            selectedClass: "ui-tabs-selected",
            unselectClass: "ui-tabs-unselect",
            disabledClass: "ui-tabs-disabled",
            panelClass: "ui-tabs-panel",
            hideClass: "ui-tabs-hide",
            loadingClass: "ui-tabs-loading",
            hide: function() {},
            show: function() {}
        }, E);
        this.options.event += ".ui-tabs";
        this.options.cookie = C.cookie && C.cookie.constructor == Function && this.options.cookie;
        C(F).bind("setData.ui-tabs", function(H, G, I) {
            D.options[G] = I;
            this.tabify()
        }).bind("getData.ui-tabs", function(H, G) {
            return D.options[G]
        });
        C.data(F, "ui-tabs", this);
        this.tabify(true)
    };
    C.extend(C.ui.tabs.prototype, {
        tabId: function(D) {
            return D.title && D.title.replace(/\s/g, "_").replace(/[^A-Za-z0-9\-_:\.]/g, "") || this.options.idPrefix + C.data(D)
        },
        ui: function(E, D) {
            return {
                instance: this,
                options: this.options,
                tab: E,
                panel: D
            }
        },
        tabify: function(Q) {
            this.$lis = C("li:has(a[href])", this.element);
            this.$tabs = this.$lis.map(function() {
                return C("a", this)[0]
            });
            this.$panels = C([]);
            var R = this,
                G = this.options;
            this.$tabs.each(function(T, S) {
                if (S.hash && S.hash.replace("#", "")) {
                    R.$panels = R.$panels.add(S.hash)
                } else {
                    if (C(S).attr("href") != "#") {
                        C.data(S, "href.ui-tabs", S.href);
                        C.data(S, "load.ui-tabs", S.href);
                        var V = R.tabId(S);
                        S.href = "#" + V;
                        var U = C("#" + V);
                        if (!U.length) {
                            U = C(G.panelTemplate).attr("id", V).addClass(G.panelClass).insertAfter(R.$panels[T - 1] || R.element);
                            U.data("destroy.ui-tabs", true)
                        }
                        R.$panels = R.$panels.add(U)
                    } else {
                        G.disabled.push(T + 1)
                    }
                }
            });
            if (Q) {
                C(this.element).hasClass(G.navClass) || C(this.element).addClass(G.navClass);
                this.$panels.each(function() {
                    var S = C(this);
                    S.hasClass(G.panelClass) || S.addClass(G.panelClass)
                });
                for (var K = 0, N; N = G.disabled[K]; K++) {
                    this.disable(N)
                }
                this.$tabs.each(function(U, S) {
                    if (location.hash) {
                        if (S.hash == location.hash) {
                            G.selected = U;
                            scrollTo(0, 0);
                            return false
                        }
                    } else {
                        if (G.cookie) {
                            var T = parseInt(C.cookie("ui-tabs" + C.data(R.element)), 10);
                            if (T && R.$tabs[T]) {
                                G.selected = T;
                                return false
                            }
                        } else {
                            if (R.$lis.eq(U).hasClass(G.selectedClass)) {
                                G.selected = U;
                                return false
                            }
                        }
                    }
                });
                var H = this.$lis.length;
                while (this.$lis.eq(G.selected).hasClass(G.disabledClass) && H) {
                    G.selected = ++G.selected < this.$lis.length ? G.selected : 0;
                    H--
                }
                if (!H) {
                    G.unselect = true
                }
                this.$panels.addClass(G.hideClass);
                this.$lis.removeClass(G.selectedClass);
                if (!G.unselect) {
                    this.$panels.eq(G.selected).show().removeClass(G.hideClass);
                    this.$lis.eq(G.selected).addClass(G.selectedClass)
                }
                var F = !G.unselect && C.data(this.$tabs[G.selected], "load.ui-tabs");
                if (F) {
                    this.load(G.selected, F)
                }
                if (!(/^click/).test(G.event)) {
                    this.$tabs.bind("click", function(S) {
                        S.preventDefault()
                    })
                }
            }
            var E, M, D = {
                    "min-width": 0,
                    duration: 1
                },
                I = "normal";
            if (G.fx && G.fx.constructor == Array) {
                E = G.fx[0] || D, M = G.fx[1] || D
            } else {
                E = M = G.fx || D
            }
            var L = {
                display: "",
                overflow: "",
                height: ""
            };
            L.opacity = "";

            function P(T, S, U) {
                S.animate(E, E.duration || I, function() {
                    S.addClass(G.hideClass).css(L);
                    G.hide(T, S[0], U && U[0] || null);
                    if (U) {
                        O(T, U, S)
                    }
                })
            }

            function O(T, U, S) {
                if (M === D) {
                    U.css("display", "block")
                }
                U.animate(M, M.duration || I, function() {
                    U.removeClass(G.hideClass).css(L);
                    G.show(T, U[0], S && S[0] || null);
                    C(R.element).triggerHandler("show.ui-tabs", [R.ui(T, U[0])])
                })
            }

            function J(T, V, S, U) {
                V.addClass(G.selectedClass).siblings().removeClass(G.selectedClass);
                P(T, S, U)
            }
            this.$tabs.unbind(G.event).bind(G.event, function() {
                var V = C(this).parents("li:eq(0)"),
                    S = R.$panels.filter(":visible"),
                    U = C(this.hash);
                if ((V.hasClass(G.selectedClass) && !G.unselect) || V.hasClass(G.disabledClass) || C(R.element).triggerHandler("select.ui-tabs", [R.ui(this, U[0])]) === false) {
                    this.blur();
                    return false
                }
                R.options.selected = R.$tabs.index(this);
                if (G.unselect) {
                    if (V.hasClass(G.selectedClass)) {
                        R.options.selected = null;
                        V.removeClass(G.selectedClass);
                        R.$panels.stop();
                        P(this, S);
                        this.blur();
                        return false
                    } else {
                        if (!S.length) {
                            R.$panels.stop();
                            var T = this;
                            R.load(R.$tabs.index(this), function() {
                                V.addClass(G.selectedClass).addClass(G.unselectClass);
                                O(T, U)
                            });
                            this.blur();
                            return false
                        }
                    }
                }
                if (G.cookie) {
                    C.cookie("ui-tabs" + C.data(R.element), R.options.selected, G.cookie)
                }
                R.$panels.stop();
                if (U.length) {
                    var T = this;
                    R.load(R.$tabs.index(this), function() {
                        J(T, V, S, U)
                    })
                } else {
                    throw "jQuery UI Tabs: Mismatching fragment identifier."
                }
                return false
            })
        },
        add: function(G, F, E) {
            if (G && F) {
                E = E || this.$tabs.length;
                var I = this.options;
                var K = C(I.tabTemplate.replace(/#\{href\}/, G).replace(/#\{label\}/, F));
                K.data("destroy.ui-tabs", true);
                var J = G.indexOf("#") == 0 ? G.replace("#", "") : this.tabId(C("a:first-child", K)[0]);
                var H = C("#" + J);
                if (!H.length) {
                    H = C(I.panelTemplate).attr("id", J).addClass(I.panelClass).addClass(I.hideClass);
                    H.data("destroy.ui-tabs", true)
                }
                if (E >= this.$lis.length) {
                    K.appendTo(this.element);
                    H.appendTo(this.element.parentNode)
                } else {
                    K.insertBefore(this.$lis[E]);
                    H.insertBefore(this.$panels[E])
                }
                this.tabify();
                if (this.$tabs.length == 1) {
                    K.addClass(I.selectedClass);
                    H.removeClass(I.hideClass);
                    var D = C.data(this.$tabs[0], "load.ui-tabs");
                    if (D) {
                        this.load(E, D)
                    }
                }
                C(this.element).triggerHandler("add.ui-tabs", [this.ui(this.$tabs[E], this.$panels[E])])
            } else {
                throw "jQuery UI Tabs: Not enough arguments to add tab."
            }
        },
        remove: function(D) {
            if (D && D.constructor == Number) {
                var F = this.options,
                    G = this.$lis.eq(D).remove(),
                    E = this.$panels.eq(D).remove();
                if (G.hasClass(F.selectedClass) && this.$tabs.length > 1) {
                    this.click(D + (D < this.$tabs.length ? 1 : -1))
                }
                this.tabify();
                C(this.element).triggerHandler("remove.ui-tabs", [this.ui(G.find("a")[0], E[0])])
            }
        },
        enable: function(E) {
            var D = this,
                F = this.options,
                G = this.$lis.eq(E);
            G.removeClass(F.disabledClass);
            F.disabled = C.map(this.$lis.filter("." + F.disabledClass), function(I, H) {
                return D.$lis.index(I)
            });
            C(this.element).triggerHandler("enable.ui-tabs", [this.ui(this.$tabs[E], this.$panels[E])])
        },
        disable: function(E) {
            var D = this,
                F = this.options;
            this.$lis.eq(E).addClass(F.disabledClass);
            F.disabled = C.map(this.$lis.filter("." + F.disabledClass), function(H, G) {
                return D.$lis.index(H)
            });
            C(this.element).triggerHandler("disable.ui-tabs", [this.ui(this.$tabs[E], this.$panels[E])])
        },
        select: function(D) {
            if (typeof D == "string") {
                D = this.$tabs.index(this.$tabs.filter("[href$=" + D + "]")[0])
            }
            this.$tabs.eq(D).trigger(this.options.event)
        },
        load: function(H, M) {
            var N = this,
                E = this.options,
                F = this.$tabs.eq(H),
                L = F[0];
            var D = F.data("load.ui-tabs");
            if (!D) {
                typeof M == "function" && M();
                return
            }
            if (E.spinner) {
                var I = C("span", L),
                    K = I.html();
                I.html("<em>" + E.spinner + "</em>")
            }
            var J = function() {
                N.$tabs.filter("." + E.loadingClass).each(function() {
                    C(this).removeClass(E.loadingClass);
                    if (E.spinner) {
                        C("span", this).html(K)
                    }
                });
                N.xhr = null
            };
            var G = C.extend({}, E.ajaxOptions, {
                url: D,
                success: function(P, O) {
                    C(L.hash).html(P);
                    J();
                    typeof M == "function" && M();
                    if (E.cache) {
                        C.removeData(L, "load.ui-tabs")
                    }
                    C(N.element).triggerHandler("load.ui-tabs", [N.ui(N.$tabs[H], N.$panels[H])]);
                    E.ajaxOptions.success && E.ajaxOptions.success(P, O)
                }
            });
            if (this.xhr) {
                this.xhr.abort();
                J()
            }
            F.addClass(E.loadingClass);
            setTimeout(function() {
                N.xhr = C.ajax(G)
            }, 0)
        },
        url: function(E, D) {
            this.$tabs.eq(E).data("load.ui-tabs", D)
        },
        destroy: function() {
            var D = this.options;
            C(this.element).unbind(".ui-tabs").removeClass(D.navClass).removeData("ui-tabs");
            this.$tabs.each(function() {
                var E = C.data(this, "href.ui-tabs");
                if (E) {
                    this.href = E
                }
                C(this).unbind(".ui-tabs").removeData("href.ui-tabs").removeData("load.ui-tabs")
            });
            this.$lis.add(this.$panels).each(function() {
                if (C.data(this, "destroy.ui-tabs")) {
                    C(this).remove()
                } else {
                    C(this).removeClass([D.selectedClass, D.unselectClass, D.disabledClass, D.panelClass, D.hideClass].join(" "))
                }
            })
        }
    })
})(jQuery);
(function(G) {
    G.ui = G.ui || {};
    G.fn.extend({
        accordion: function(J, K) {
            var I = Array.prototype.slice.call(arguments, 1);
            return this.each(function() {
                if (typeof J == "string") {
                    var L = G.data(this, "ui-accordion");
                    L[J].apply(L, I)
                } else {
                    if (!G(this).is(".ui-accordion")) {
                        G.data(this, "ui-accordion", new G.ui.accordion(this, J))
                    }
                }
            })
        },
        activate: function(I) {
            return this.accordion("activate", I)
        }
    });
    G.ui.accordion = function(I, J) {
        this.options = J = G.extend({}, G.ui.accordion.defaults, J);
        this.element = I;
        G(I).addClass("ui-accordion");
        if (J.navigation) {
            var M = G(I).find("a").filter(J.navigationFilter);
            if (M.length) {
                if (M.filter(J.header).length) {
                    J.active = M
                } else {
                    J.active = M.parent().parent().prev();
                    M.addClass("current")
                }
            }
        }
        J.headers = G(I).find(J.header);
        J.active = E(J.headers, J.active);
        if (J.fillSpace) {
            var L = G(I).parent().height();
            J.headers.each(function() {
                L -= G(this).outerHeight()
            });
            var K = 0;
            J.headers.next().each(function() {
                K = Math.max(K, G(this).innerHeight() - G(this).height())
            }).height(L - K)
        } else {
            if (J.autoheight) {
                var L = 0;
                J.headers.next().each(function() {
                    L = Math.max(L, G(this).outerHeight())
                }).height(L)
            }
        }
        J.headers.not(J.active || "").next().hide();
        J.active.parent().andSelf().addClass(J.selectedClass);
        if (J.event) {
            G(I).bind((J.event || "") + ".ui-accordion", H)
        }
    };
    G.ui.accordion.prototype = {
        activate: function(I) {
            H.call(this.element, {
                target: E(this.options.headers, I)[0]
            })
        },
        enable: function() {
            this.options.disabled = false
        },
        disable: function() {
            this.options.disabled = true
        },
        destroy: function() {
            this.options.headers.next().css("display", "");
            if (this.options.fillSpace || this.options.autoheight) {
                this.options.headers.next().css("height", "")
            }
            G.removeData(this.element, "ui-accordion");
            G(this.element).removeClass("ui-accordion").unbind(".ui-accordion")
        }
    };

    function D(J, I) {
        return function() {
            return J.apply(I, arguments)
        }
    }

    function F(K) {
        if (!G.data(this, "ui-accordion")) {
            return
        }
        var I = G.data(this, "ui-accordion");
        var J = I.options;
        J.running = K ? 0 : --J.running;
        if (J.running) {
            return
        }
        if (J.clearStyle) {
            J.toShow.add(J.toHide).css({
                height: "",
                overflow: ""
            })
        }
        G(this).triggerHandler("change-ui-accordion", [J.data], J.change)
    }

    function C(I, M, N, L, O) {
        var K = G.data(this, "ui-accordion").options;
        K.toShow = I;
        K.toHide = M;
        K.data = N;
        var J = D(F, this);
        K.running = M.size() == 0 ? I.size() : M.size();
        if (K.animated) {
            if (!K.alwaysOpen && L) {
                G.ui.accordion.animations[K.animated]({
                    toShow: jQuery([]),
                    toHide: M,
                    complete: J,
                    down: O,
                    autoheight: K.autoheight
                })
            } else {
                G.ui.accordion.animations[K.animated]({
                    toShow: I,
                    toHide: M,
                    complete: J,
                    down: O,
                    autoheight: K.autoheight
                })
            }
        } else {
            if (!K.alwaysOpen && L) {
                I.toggle()
            } else {
                M.hide();
                I.show()
            }
            J(true)
        }
    }

    function H(N) {
        var L = G.data(this, "ui-accordion").options;
        if (L.disabled) {
            return false
        }
        if (!N.target && !L.alwaysOpen) {
            L.active.parent().andSelf().toggleClass(L.selectedClass);
            var K = L.active.next(),
                O = {
                    instance: this,
                    options: L,
                    newHeader: jQuery([]),
                    oldHeader: L.active,
                    newContent: jQuery([]),
                    oldContent: K
                },
                I = L.active = G([]);
            C.call(this, I, K, O);
            return false
        }
        var M = G(N.target);
        if (M.parents(L.header).length) {
            while (!M.is(L.header)) {
                M = M.parent()
            }
        }
        var J = M[0] == L.active[0];
        if (L.running || (L.alwaysOpen && J)) {
            return false
        }
        if (!M.is(L.header)) {
            return
        }
        L.active.parent().andSelf().toggleClass(L.selectedClass);
        if (!J) {
            M.parent().andSelf().addClass(L.selectedClass)
        }
        var I = M.next(),
            K = L.active.next(),
            O = {
                instance: this,
                options: L,
                newHeader: M,
                oldHeader: L.active,
                newContent: I,
                oldContent: K
            },
            P = L.headers.index(L.active[0]) > L.headers.index(M[0]);
        L.active = J ? G([]) : M;
        C.call(this, I, K, O, J, P);
        return false
    }

    function E(J, I) {
        return I != undefined ? typeof I == "number" ? J.filter(":eq(" + I + ")") : J.not(J.not(I)) : I === false ? G([]) : J.filter(":eq(0)")
    }
    G.extend(G.ui.accordion, {
        defaults: {
            selectedClass: "selected",
            alwaysOpen: true,
            animated: "slide",
            event: "click",
            header: "a",
            autoheight: true,
            running: 0,
            navigationFilter: function() {
                return this.href.toLowerCase() == location.href.toLowerCase()
            }
        },
        animations: {
            slide: function(I, K) {
                I = G.extend({
                    easing: "swing",
                    duration: 300
                }, I, K);
                if (!I.toHide.size()) {
                    I.toShow.animate({
                        height: "show"
                    }, I);
                    return
                }
                var J = I.toHide.height(),
                    L = I.toShow.height(),
                    M = L / J;
                I.toShow.css({
                    height: 0,
                    overflow: "hidden"
                }).show();
                I.toHide.filter(":hidden").each(I.complete).end().filter(":visible").animate({
                    height: "hide"
                }, {
                    step: function(N) {
                        var O = (J - N) * M;
                        if (G.browser.msie || G.browser.opera) {
                            O = Math.ceil(O)
                        }
                        I.toShow.height(O)
                    },
                    duration: I.duration,
                    easing: I.easing,
                    complete: function() {
                        if (!I.autoheight) {
                            I.toShow.css("height", "auto")
                        }
                        I.complete()
                    }
                })
            },
            bounceslide: function(I) {
                this.slide(I, {
                    easing: I.down ? "bounceout" : "swing",
                    duration: I.down ? 1000 : 200
                })
            },
            easeslide: function(I) {
                this.slide(I, {
                    easing: "easeinout",
                    duration: 700
                })
            }
        }
    })
})(jQuery);
(function(C) {
    C.fn.extend({
        slider: function(E) {
            var D = Array.prototype.slice.call(arguments, 1);
            if (E == "value") {
                return C.data(this[0], "ui-slider").value(arguments[1])
            }
            return this.each(function() {
                if (typeof E == "string") {
                    var F = C.data(this, "ui-slider");
                    F[E].apply(F, D)
                } else {
                    if (!C.data(this, "ui-slider")) {
                        new C.ui.slider(this, E)
                    }
                }
            })
        }
    });
    C.ui.slider = function(F, L) {
        var K = this;
        this.element = C(F);
        C.data(F, "ui-slider", this);
        this.element.addClass("ui-slider");
        this.options = C.extend({}, L);
        var D = this.options;
        C.extend(D, {
            axis: D.axis || (F.offsetWidth < F.offsetHeight ? "vertical" : "horizontal"),
            maxValue: !isNaN(parseInt(D.maxValue, 10)) ? parseInt(D.maxValue, 10) : 100,
            minValue: parseInt(D.minValue, 10) || 0,
            startValue: parseInt(D.startValue, 10) || "none"
        });
        D.realMaxValue = D.maxValue - D.minValue;
        D.stepping = parseInt(D.stepping, 10) || (D.steps ? D.realMaxValue / D.steps : 0);
        C(F).bind("setData.slider", function(N, M, O) {
            K.options[M] = O
        }).bind("getData.slider", function(N, M) {
            return K.options[M]
        });
        this.handle = D.handle ? C(D.handle, F) : C("> *", F);
        C(this.handle).mouseInteraction({
            executor: this,
            delay: D.delay,
            distance: D.distance || 0,
            dragPrevention: D.prevention ? D.prevention.toLowerCase().split(",") : ["input", "textarea", "button", "select", "option"],
            start: this.start,
            stop: this.stop,
            drag: this.drag,
            condition: function(N, M) {
                if (!this.disabled) {
                    if (this.currentHandle) {
                        this.blur(this.currentHandle)
                    }
                    this.focus(M, 1);
                    return !this.disabled
                }
            }
        }).wrap('<a href="javascript:void(0)"></a>').parent().bind("focus", function(M) {
            K.focus(this.firstChild)
        }).bind("blur", function(M) {
            K.blur(this.firstChild)
        }).bind("keydown", function(M) {
            if (/(37|39)/.test(M.keyCode)) {
                K.moveTo((M.keyCode == 37 ? "-" : "+") + "=" + (K.options.stepping ? K.options.stepping : (K.options.realMaxValue / K.size) * 5), this.firstChild)
            }
        });
        if (D.helper == "original" && (this.element.css("position") == "static" || this.element.css("position") == "")) {
            this.element.css("position", "relative")
        }
        if (D.axis == "horizontal") {
            this.size = this.element.outerWidth();
            this.properties = ["left", "width"]
        } else {
            this.size = this.element.outerHeight();
            this.properties = ["top", "height"]
        }
        if (D.ticking && (typeof D.ticking) == "boolean") {
            D.ticking = D.stepping
        }
        if (D.ticking && this.size && D.realMaxValue > 0) {
            this.currentHandle = this.handle[0];
            var J = "";
            var H = 0;
            var E;
            do {
                H += D.ticking;
                E = D.minValue + H
            } while (parseInt(this.translateValue(E)) < 5);
            for (var G = D.minValue; G <= D.maxValue; G += H) {
                var I = parseInt(this.translateValue(G) + this.handleSize(0) / 2);
                J += ('<div class="slider-tick" style="' + this.properties[0] + ": " + I + 'px; "></div>')
            }
            this.element.append(J)
        }
        this.element.bind("click", function(M) {
            K.click.apply(K, [M])
        });
        if (!isNaN(D.startValue)) {
            this.moveTo(D.startValue, 0)
        }
        if (this.handle.length == 1) {
            this.previousHandle = this.handle
        }
        if (this.handle.length == 2 && D.range) {
            this.createRange()
        }
    };
    C.extend(C.ui.slider.prototype, {
        plugins: {},
        createRange: function() {
            this.rangeElement = C("<div></div>").addClass("ui-slider-range").css({
                position: "absolute"
            }).css(this.properties[0], parseInt(C(this.handle[0]).css(this.properties[0]), 10) + this.handleSize(0) / 2).css(this.properties[1], parseInt(C(this.handle[1]).css(this.properties[0]), 10) - parseInt(C(this.handle[0]).css(this.properties[0]), 10)).appendTo(this.element)
        },
        updateRange: function() {
            this.rangeElement.css(this.properties[0], parseInt(C(this.handle[0]).css(this.properties[0]), 10) + this.handleSize(0) / 2);
            this.rangeElement.css(this.properties[1], parseInt(C(this.handle[1]).css(this.properties[0]), 10) - parseInt(C(this.handle[0]).css(this.properties[0]), 10))
        },
        getRange: function() {
            return this.rangeElement ? this.convertValue(parseInt(this.rangeElement.css(this.properties[1]), 10)) : null
        },
        ui: function(D) {
            return {
                instance: this,
                options: this.options,
                handle: this.currentHandle,
                value: this.value(),
                range: this.getRange()
            }
        },
        propagate: function(E, D) {
            C.ui.plugin.call(this, E, [D, this.ui()]);
            if (C.isFunction(this.options[E])) {
                this.options[E](D, this.ui())
            }
        },
        destroy: function() {
            this.element.children(".slider-tick").remove();
            this.element.removeClass("ui-slider ui-slider-disabled").unbind(".slider");
            this.handle.removeMouseInteraction();
            var D = this.handle;
            D.each(function(E) {
                C(this).parent("a").after(this).remove()
            });
            C.removeData(this.element.get(0), "ui-slider")
        },
        enable: function() {
            this.element.removeClass("ui-slider-disabled");
            this.disabled = false
        },
        disable: function() {
            this.element.addClass("ui-slider-disabled");
            this.disabled = true
        },
        focus: function(D, E) {
            this.currentHandle = C(D).addClass("ui-slider-handle-active");
            if (E) {
                this.currentHandle.parent()[0].focus()
            }
        },
        blur: function(D) {
            C(D).removeClass("ui-slider-handle-active");
            if (this.currentHandle && this.currentHandle[0] == D) {
                this.previousHandle = this.currentHandle;
                this.currentHandle = null
            }
        },
        value: function(D) {
            if (this.handle.length == 1) {
                this.currentHandle = this.handle
            }
            var E = ((parseInt(C(D != undefined ? this.handle[D] || D : this.currentHandle).css(this.properties[0]), 10) / (this.size - this.handleSize())) * this.options.realMaxValue) + this.options.minValue;
            if (this.options.stepping) {
                E = Math.round(E / this.options.stepping) * this.options.stepping
            }
            if (E < this.options.minValue) {
                E = this.options.minValue
            } else {
                if (E > this.options.maxValue) {
                    E = this.options.maxValue
                }
            }
            return E
        },
        convertValue: function(D) {
            return (D / (this.size - this.handleSize())) * this.options.realMaxValue + this.options.minValue
        },
        translateValue: function(D) {
            if (this.options.realMaxValue == 0) {
                return 0
            }
            return ((D - this.options.minValue) / this.options.realMaxValue) * (this.size - this.handleSize())
        },
        handleSize: function(D) {
            return C(D != undefined ? this.handle[D] : this.currentHandle)["outer" + this.properties[1].substr(0, 1).toUpperCase() + this.properties[1].substr(1)]()
        },
        click: function(E) {
            var F = [E.pageX, E.pageY];
            var D = false;
            this.handle.each(function() {
                if (this == E.target) {
                    D = true
                }
            });
            if (D || this.disabled || !(this.currentHandle || this.previousHandle)) {
                return
            }
            if (this.previousHandle) {
                this.focus(this.previousHandle, 1)
            }
            this.offset = this.element.offset();
            this.moveTo(this.convertValue(E[this.properties[0] == "top" ? "pageY" : "pageX"] - this.offset[this.properties[0]] - this.handleSize() / 2))
        },
        start: function(E, D) {
            var F = this.options;
            this.offset = this.element.offset();
            this.handleOffset = this.currentHandle.offset();
            this.clickOffset = {
                top: E.pageY - this.handleOffset.top,
                left: E.pageX - this.handleOffset.left
            };
            this.firstValue = this.value();
            this.propagate("start", E);
            return false
        },
        stop: function(D) {
            this.propagate("stop", D);
            if (this.firstValue != this.value()) {
                this.propagate("change", D)
            }
            return false
        },
        drag: function(H, G) {
            var I = this.options;
            var E = {
                top: H.pageY - this.offset.top - this.clickOffset.top,
                left: H.pageX - this.offset.left - this.clickOffset.left
            };
            var D = E[this.properties[0]];
            if (D >= this.size - this.handleSize()) {
                D = this.size - this.handleSize()
            }
            if (D <= 0) {
                D = 0
            }
            if (I.stepping) {
                var F = this.convertValue(D);
                F = Math.round(F / I.stepping) * I.stepping;
                D = this.translateValue(F)
            }
            if (this.rangeElement) {
                if (this.currentHandle[0] == this.handle[0] && D >= this.translateValue(this.value(1))) {
                    D = this.translateValue(this.value(1))
                }
                if (this.currentHandle[0] == this.handle[1] && D <= this.translateValue(this.value(0))) {
                    D = this.translateValue(this.value(0))
                }
            }
            this.currentHandle.css(this.properties[0], D);
            if (this.rangeElement) {
                this.updateRange()
            }
            this.propagate("slide", H);
            return false
        },
        moveTo: function(E, D) {
            var F = this.options;
            if (D == undefined && !this.currentHandle && this.handle.length != 1) {
                return false
            }
            if (D == undefined && !this.currentHandle) {
                D = 0
            }
            if (D != undefined) {
                this.currentHandle = this.previousHandle = C(this.handle[D] || D)
            }
            if (E.constructor == String) {
                if (E.indexOf("=") == -1) {
                    E = parseInt(E, 10)
                } else {
                    E = /\-\=/.test(E) ? this.value() - parseInt(E.replace("-=", ""), 10) : this.value() + parseInt(E.replace("+=", ""), 10)
                }
            }
            if (F.stepping) {
                E = Math.round(E / F.stepping) * F.stepping
            }
            E = this.translateValue(E);
            if (E >= this.size - this.handleSize()) {
                E = this.size - this.handleSize()
            }
            if (E <= 0) {
                E = 0
            }
            if (this.rangeElement) {
                if (this.currentHandle[0] == this.handle[0] && E >= this.translateValue(this.value(1))) {
                    E = this.translateValue(this.value(1))
                }
                if (this.currentHandle[0] == this.handle[1] && E <= this.translateValue(this.value(0))) {
                    E = this.translateValue(this.value(0))
                }
            }
            this.currentHandle.css(this.properties[0], E);
            if (this.rangeElement) {
                this.updateRange()
            }
            this.propagate("start", null);
            this.propagate("stop", null);
            this.propagate("change", null)
        }
    })
})(jQuery);
(function($) {
    function Datepicker() {
        this.debug = false;
        this._nextId = 0;
        this._inst = [];
        this._curInst = null;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this.regional = [];
        this.regional[""] = {
            clearText: "Clear",
            clearStatus: "Erase the current date",
            closeText: "Close",
            closeStatus: "Close without change",
            prevText: "&#x3c;Prev",
            prevStatus: "Show the previous month",
            nextText: "Next&#x3e;",
            nextStatus: "Show the next month",
            currentText: "Today",
            currentStatus: "Show the current month",
            monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            monthStatus: "Show a different month",
            yearStatus: "Show a different year",
            weekHeader: "Wk",
            weekStatus: "Week of the year",
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
            dayStatus: "Set DD as first week day",
            dateStatus: "Select DD, M d",
            dateFormat: "mm/dd/yy",
            firstDay: 0,
            initStatus: "Select a date",
            isRTL: false
        };
        this._defaults = {
            showOn: "focus",
            showAnim: "show",
            defaultDate: null,
            appendText: "",
            buttonText: "...",
            buttonImage: "",
            buttonImageOnly: false,
            closeAtTop: true,
            mandatory: false,
            hideIfNoPrevNext: false,
            changeMonth: true,
            changeYear: true,
            yearRange: "-10:+10",
            changeFirstDay: true,
            showOtherMonths: false,
            showWeeks: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: "+10",
            showStatus: false,
            statusForDate: this.dateStatus,
            minDate: null,
            maxDate: null,
            speed: "normal",
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onClose: null,
            numberOfMonths: 1,
            stepMonths: 1,
            rangeSelect: false,
            rangeSeparator: " - "
        };
        $.extend(this._defaults, this.regional[""]);
        this._datepickerDiv = $('<div id="datepicker_div"></div>')
    }
    $.extend(Datepicker.prototype, {
        markerClassName: "hasDatepicker",
        log: function() {
            if (this.debug && window.console) {
                console.log.apply("", arguments)
            }
        },
        _register: function(inst) {
            var id = this._nextId++;
            this._inst[id] = inst;
            return id
        },
        _getInst: function(id) {
            return this._inst[id] || id
        },
        setDefaults: function(settings) {
            extendRemove(this._defaults, settings || {});
            return this
        },
        _attachDatepicker: function(target, settings) {
            var inlineSettings = null;
            for (attrName in this._defaults) {
                var attrValue = target.getAttribute("date:" + attrName);
                if (attrValue) {
                    inlineSettings = inlineSettings || {};
                    try {
                        inlineSettings[attrName] = eval(attrValue)
                    } catch (err) {
                        inlineSettings[attrName] = attrValue
                    }
                }
            }
            var nodeName = target.nodeName.toLowerCase();
            var instSettings = (inlineSettings ? $.extend(settings || {}, inlineSettings || {}) : settings);
            if (nodeName == "input") {
                var inst = (inst && !inlineSettings ? inst : new DatepickerInstance(instSettings, false));
                this._connectDatepicker(target, inst)
            } else {
                if (nodeName == "div" || nodeName == "span") {
                    var inst = new DatepickerInstance(instSettings, true);
                    this._inlineDatepicker(target, inst)
                }
            }
        },
        _destroyDatepicker: function(target) {
            var nodeName = target.nodeName.toLowerCase();
            var calId = target._calId;
            target._calId = null;
            var $target = $(target);
            if (nodeName == "input") {
                $target.siblings(".datepicker_append").replaceWith("").end().siblings(".datepicker_trigger").replaceWith("").end().removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress);
                var wrapper = $target.parents(".datepicker_wrap");
                if (wrapper) {
                    wrapper.replaceWith(wrapper.html())
                }
            } else {
                if (nodeName == "div" || nodeName == "span") {
                    $target.removeClass(this.markerClassName).empty()
                }
            }
            if ($("input[_calId=" + calId + "]").length == 0) {
                this._inst[calId] = null
            }
        },
        _enableDatepicker: function(target) {
            target.disabled = false;
            $(target).siblings("button.datepicker_trigger").each(function() {
                this.disabled = false
            }).end().siblings("img.datepicker_trigger").css({
                opacity: "1.0",
                cursor: ""
            });
            this._disabledInputs = $.map(this._disabledInputs, function(value) {
                return (value == target ? null : value)
            })
        },
        _disableDatepicker: function(target) {
            target.disabled = true;
            $(target).siblings("button.datepicker_trigger").each(function() {
                this.disabled = true
            }).end().siblings("img.datepicker_trigger").css({
                opacity: "0.5",
                cursor: "default"
            });
            this._disabledInputs = $.map($.datepicker._disabledInputs, function(value) {
                return (value == target ? null : value)
            });
            this._disabledInputs[$.datepicker._disabledInputs.length] = target
        },
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] == target) {
                    return true
                }
            }
            return false
        },
        _changeDatepicker: function(target, name, value) {
            var settings = name || {};
            if (typeof name == "string") {
                settings = {};
                settings[name] = value
            }
            if (inst = this._getInst(target._calId)) {
                extendRemove(inst._settings, settings);
                this._updateDatepicker(inst)
            }
        },
        _setDateDatepicker: function(target, date, endDate) {
            if (inst = this._getInst(target._calId)) {
                inst._setDate(date, endDate);
                this._updateDatepicker(inst)
            }
        },
        _getDateDatepicker: function(target) {
            var inst = this._getInst(target._calId);
            return (inst ? inst._getDate() : null)
        },
        _doKeyDown: function(e) {
            var inst = $.datepicker._getInst(this._calId);
            if ($.datepicker._datepickerShowing) {
                switch (e.keyCode) {
                    case 9:
                        $.datepicker._hideDatepicker(null, "");
                        break;
                    case 13:
                        $.datepicker._selectDay(inst, inst._selectedMonth, inst._selectedYear, $("td.datepicker_daysCellOver", inst._datepickerDiv)[0]);
                        return false;
                        break;
                    case 27:
                        $.datepicker._hideDatepicker(null, inst._get("speed"));
                        break;
                    case 33:
                        $.datepicker._adjustDate(inst, (e.ctrlKey ? -1 : -inst._get("stepMonths")), (e.ctrlKey ? "Y" : "M"));
                        break;
                    case 34:
                        $.datepicker._adjustDate(inst, (e.ctrlKey ? +1 : +inst._get("stepMonths")), (e.ctrlKey ? "Y" : "M"));
                        break;
                    case 35:
                        if (e.ctrlKey) {
                            $.datepicker._clearDate(inst)
                        }
                        break;
                    case 36:
                        if (e.ctrlKey) {
                            $.datepicker._gotoToday(inst)
                        }
                        break;
                    case 37:
                        if (e.ctrlKey) {
                            $.datepicker._adjustDate(inst, -1, "D")
                        }
                        break;
                    case 38:
                        if (e.ctrlKey) {
                            $.datepicker._adjustDate(inst, -7, "D")
                        }
                        break;
                    case 39:
                        if (e.ctrlKey) {
                            $.datepicker._adjustDate(inst, +1, "D")
                        }
                        break;
                    case 40:
                        if (e.ctrlKey) {
                            $.datepicker._adjustDate(inst, +7, "D")
                        }
                        break
                }
            } else {
                if (e.keyCode == 36 && e.ctrlKey) {
                    $.datepicker._showDatepicker(this)
                }
            }
        },
        _doKeyPress: function(e) {
            var inst = $.datepicker._getInst(this._calId);
            var chars = $.datepicker._possibleChars(inst._get("dateFormat"));
            var chr = String.fromCharCode(e.charCode == undefined ? e.keyCode : e.charCode);
            return e.ctrlKey || (chr < " " || !chars || chars.indexOf(chr) > -1)
        },
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            if (input.is("." + this.markerClassName)) {
                return
            }
            var appendText = inst._get("appendText");
            var isRTL = inst._get("isRTL");
            if (appendText) {
                if (isRTL) {
                    input.before('<span class="datepicker_append">' + appendText)
                } else {
                    input.after('<span class="datepicker_append">' + appendText)
                }
            }
            var showOn = inst._get("showOn");
            if (showOn == "focus" || showOn == "both") {
                input.focus(this._showDatepicker)
            }
            if (showOn == "button" || showOn == "both") {
                input.wrap('<span class="datepicker_wrap">');
                var buttonText = inst._get("buttonText");
                var buttonImage = inst._get("buttonImage");
                var trigger = $(inst._get("buttonImageOnly") ? $("<img>").addClass("datepicker_trigger").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $("<button>").addClass("datepicker_trigger").attr({
                    type: "button"
                }).html(buttonImage != "" ? $("<img>").attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : buttonText));
                if (isRTL) {
                    input.before(trigger)
                } else {
                    input.after(trigger)
                }
                trigger.click(function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput == target) {
                        $.datepicker._hideDatepicker()
                    } else {
                        $.datepicker._showDatepicker(target)
                    }
                })
            }
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).bind("setData.datepicker", function(event, key, value) {
                inst._settings[key] = value
            }).bind("getData.datepicker", function(event, key) {
                return inst._get(key)
            });
            input[0]._calId = inst._id
        },
        _inlineDatepicker: function(target, inst) {
            var input = $(target);
            if (input.is("." + this.markerClassName)) {
                return
            }
            input.addClass(this.markerClassName).append(inst._datepickerDiv).bind("setData.datepicker", function(event, key, value) {
                inst._settings[key] = value
            }).bind("getData.datepicker", function(event, key) {
                return inst._get(key)
            });
            input[0]._calId = inst._id;
            this._updateDatepicker(inst)
        },
        _inlineShow: function(inst) {
            var numMonths = inst._getNumberOfMonths();
            inst._datepickerDiv.width(numMonths[1] * $(".datepicker", inst._datepickerDiv[0]).width())
        },
        _dialogDatepicker: function(input, dateText, onSelect, settings, pos) {
            var inst = this._dialogInst;
            if (!inst) {
                inst = this._dialogInst = new DatepickerInstance({}, false);
                this._dialogInput = $('<input type="text" size="1" style="position: absolute; top: -100px;"/>');
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                this._dialogInput[0]._calId = inst._id
            }
            extendRemove(inst._settings, settings || {});
            this._dialogInput.val(dateText);
            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                var browserWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                var browserHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY]
            }
            this._dialogInput.css("left", this._pos[0] + "px").css("top", this._pos[1] + "px");
            inst._settings.onSelect = onSelect;
            this._inDialog = true;
            this._datepickerDiv.addClass("datepicker_dialog");
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this._datepickerDiv)
            }
            return this
        },
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() != "input") {
                input = $("input", input.parentNode)[0]
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) {
                return
            }
            var inst = $.datepicker._getInst(input._calId);
            var beforeShow = inst._get("beforeShow");
            extendRemove(inst._settings, (beforeShow ? beforeShow.apply(input, [input, inst]) : {}));
            $.datepicker._hideDatepicker(null, "");
            $.datepicker._lastInput = input;
            inst._setDateFromField(input);
            if ($.datepicker._inDialog) {
                input.value = ""
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight
            }
            var isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") == "fixed"
            });
            inst._datepickerDiv.css("position", ($.datepicker._inDialog && $.blockUI ? "static" : (isFixed ? "fixed" : "absolute"))).css({
                left: $.datepicker._pos[0] + "px",
                top: $.datepicker._pos[1] + "px"
            });
            $.datepicker._pos = null;
            inst._rangeStart = null;
            $.datepicker._updateDatepicker(inst);
            if (!inst._inline) {
                var speed = inst._get("speed");
                var postProcess = function() {
                    $.datepicker._datepickerShowing = true;
                    $.datepicker._afterShow(inst)
                };
                var showAnim = inst._get("showAnim") || "show";
                inst._datepickerDiv[showAnim](speed, postProcess);
                if (speed == "") {
                    postProcess()
                }
                if (inst._input[0].type != "hidden") {
                    inst._input[0].focus()
                }
                $.datepicker._curInst = inst
            }
        },
        _updateDatepicker: function(inst) {
            inst._datepickerDiv.empty().append(inst._generateDatepicker());
            var numMonths = inst._getNumberOfMonths();
            if (numMonths[0] != 1 || numMonths[1] != 1) {
                inst._datepickerDiv.addClass("datepicker_multi")
            } else {
                inst._datepickerDiv.removeClass("datepicker_multi")
            }
            if (inst._get("isRTL")) {
                inst._datepickerDiv.addClass("datepicker_rtl")
            } else {
                inst._datepickerDiv.removeClass("datepicker_rtl")
            }
            if (inst._input && inst._input[0].type != "hidden") {
                $(inst._input[0]).focus()
            }
        },
        _afterShow: function(inst) {
            var numMonths = inst._getNumberOfMonths();
            inst._datepickerDiv.width(numMonths[1] * $(".datepicker", inst._datepickerDiv[0])[0].offsetWidth);
            var isFixed = inst._datepickerDiv.css("position") == "fixed";
            var pos = inst._input ? $.datepicker._findPos(inst._input[0]) : null;
            var browserWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            var browserHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            var scrollX = (isFixed ? 0 : document.documentElement.scrollLeft || document.body.scrollLeft);
            var scrollY = (isFixed ? 0 : document.documentElement.scrollTop || document.body.scrollTop);
            if ((inst._datepickerDiv.offset().left + inst._datepickerDiv.width()) > (browserWidth + scrollX)) {
                inst._datepickerDiv.css("left", Math.max(scrollX, pos[0] + (inst._input ? $(inst._input[0]).width() : null) - inst._datepickerDiv.width()) + "px")
            }
            if ((inst._datepickerDiv.offset().top + inst._datepickerDiv.height()) > (browserHeight + scrollY)) {
                inst._datepickerDiv.css("top", Math.max(scrollY, pos[1] - (this._inDialog ? 0 : inst._datepickerDiv.height())) + "px")
            }
        },
        _findPos: function(obj) {
            while (obj && (obj.type == "hidden" || obj.nodeType != 1)) {
                obj = obj.nextSibling
            }
            var position = $(obj).offset();
            return [position.left, position.top]
        },
        _hideDatepicker: function(input, speed) {
            var inst = this._curInst;
            if (!inst) {
                return
            }
            var rangeSelect = inst._get("rangeSelect");
            if (rangeSelect && this._stayOpen) {
                this._selectDate(inst, inst._formatDate(inst._currentDay, inst._currentMonth, inst._currentYear))
            }
            this._stayOpen = false;
            if (this._datepickerShowing) {
                speed = (speed != null ? speed : inst._get("speed"));
                var showAnim = inst._get("showAnim");
                inst._datepickerDiv[(showAnim == "slideDown" ? "slideUp" : (showAnim == "fadeIn" ? "fadeOut" : "hide"))](speed, function() {
                    $.datepicker._tidyDialog(inst)
                });
                if (speed == "") {
                    this._tidyDialog(inst)
                }
                var onClose = inst._get("onClose");
                if (onClose) {
                    onClose.apply((inst._input ? inst._input[0] : null), [inst._getDate(), inst])
                }
                this._datepickerShowing = false;
                this._lastInput = null;
                inst._settings.prompt = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this._datepickerDiv)
                    }
                }
                this._inDialog = false
            }
            this._curInst = null
        },
        _tidyDialog: function(inst) {
            inst._datepickerDiv.removeClass("datepicker_dialog").unbind(".datepicker");
            $(".datepicker_prompt", inst._datepickerDiv).remove()
        },
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return
            }
            var $target = $(event.target);
            if (($target.parents("#datepicker_div").length == 0) && ($target.attr("class") != "datepicker_trigger") && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI)) {
                $.datepicker._hideDatepicker(null, "")
            }
        },
        _adjustDate: function(id, offset, period) {
            var inst = this._getInst(id);
            inst._adjustDate(offset, period);
            this._updateDatepicker(inst)
        },
        _gotoToday: function(id) {
            var date = new Date();
            var inst = this._getInst(id);
            inst._selectedDay = date.getDate();
            inst._drawMonth = inst._selectedMonth = date.getMonth();
            inst._drawYear = inst._selectedYear = date.getFullYear();
            this._adjustDate(inst)
        },
        _selectMonthYear: function(id, select, period) {
            var inst = this._getInst(id);
            inst._selectingMonthYear = false;
            inst[period == "M" ? "_drawMonth" : "_drawYear"] = select.options[select.selectedIndex].value - 0;
            this._adjustDate(inst)
        },
        _clickMonthYear: function(id) {
            var inst = this._getInst(id);
            inst._selectingMonthYear = !inst._selectingMonthYear
        },
        _changeFirstDay: function(id, day) {
            var inst = this._getInst(id);
            inst._settings.firstDay = day;
            this._updateDatepicker(inst)
        },
        _selectDay: function(id, month, year, td) {
            if ($(td).is(".datepicker_unselectable")) {
                return
            }
            var inst = this._getInst(id);
            var rangeSelect = inst._get("rangeSelect");
            if (rangeSelect) {
                if (!this._stayOpen) {
                    $(".datepicker td").removeClass("datepicker_currentDay");
                    $(td).addClass("datepicker_currentDay")
                }
                this._stayOpen = !this._stayOpen
            }
            inst._selectedDay = inst._currentDay = $("a", td).html();
            inst._selectedMonth = inst._currentMonth = month;
            inst._selectedYear = inst._currentYear = year;
            this._selectDate(id, inst._formatDate(inst._currentDay, inst._currentMonth, inst._currentYear));
            if (this._stayOpen) {
                inst._endDay = inst._endMonth = inst._endYear = null;
                inst._rangeStart = new Date(inst._currentYear, inst._currentMonth, inst._currentDay);
                this._updateDatepicker(inst)
            } else {
                if (rangeSelect) {
                    inst._endDay = inst._currentDay;
                    inst._endMonth = inst._currentMonth;
                    inst._endYear = inst._currentYear;
                    inst._selectedDay = inst._currentDay = inst._rangeStart.getDate();
                    inst._selectedMonth = inst._currentMonth = inst._rangeStart.getMonth();
                    inst._selectedYear = inst._currentYear = inst._rangeStart.getFullYear();
                    inst._rangeStart = null;
                    if (inst._inline) {
                        this._updateDatepicker(inst)
                    }
                }
            }
        },
        _clearDate: function(id) {
            var inst = this._getInst(id);
            if (inst._get("mandatory")) {
                return
            }
            this._stayOpen = false;
            inst._endDay = inst._endMonth = inst._endYear = inst._rangeStart = null;
            this._selectDate(inst, "")
        },
        _selectDate: function(id, dateStr) {
            var inst = this._getInst(id);
            dateStr = (dateStr != null ? dateStr : inst._formatDate());
            if (inst._rangeStart) {
                dateStr = inst._formatDate(inst._rangeStart) + inst._get("rangeSeparator") + dateStr
            }
            if (inst._input) {
                inst._input.val(dateStr)
            }
            var onSelect = inst._get("onSelect");
            if (onSelect) {
                onSelect.apply((inst._input ? inst._input[0] : null), [dateStr, inst])
            } else {
                if (inst._input) {
                    inst._input.trigger("change")
                }
            }
            if (inst._inline) {
                this._updateDatepicker(inst)
            } else {
                if (!this._stayOpen) {
                    this._hideDatepicker(null, inst._get("speed"));
                    this._lastInput = inst._input[0];
                    if (typeof(inst._input[0]) != "object") {
                        inst._input[0].focus()
                    }
                    this._lastInput = null
                }
            }
        },
        noWeekends: function(date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ""]
        },
        iso8601Week: function(date) {
            var checkDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), (date.getTimezoneOffset() / -60));
            var firstMon = new Date(checkDate.getFullYear(), 1 - 1, 4);
            var firstDay = firstMon.getDay() || 7;
            firstMon.setDate(firstMon.getDate() + 1 - firstDay);
            if (firstDay < 4 && checkDate < firstMon) {
                checkDate.setDate(checkDate.getDate() - 3);
                return $.datepicker.iso8601Week(checkDate)
            } else {
                if (checkDate > new Date(checkDate.getFullYear(), 12 - 1, 28)) {
                    firstDay = new Date(checkDate.getFullYear() + 1, 1 - 1, 4).getDay() || 7;
                    if (firstDay > 4 && (checkDate.getDay() || 7) < firstDay - 3) {
                        checkDate.setDate(checkDate.getDate() + 3);
                        return $.datepicker.iso8601Week(checkDate)
                    }
                }
            }
            return Math.floor(((checkDate - firstMon) / 86400000) / 7) + 1
        },
        dateStatus: function(date, inst) {
            return $.datepicker.formatDate(inst._get("dateStatus"), date, inst._getFormatConfig())
        },
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments"
            }
            value = (typeof value == "object" ? value.toString() : value + "");
            if (value == "") {
                return null
            }
            var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
            var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
            var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
            var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
            var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
            var year = -1;
            var month = -1;
            var day = -1;
            var literal = false;
            var lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches) {
                    iFormat++
                }
                return matches
            };
            var getNumber = function(match) {
                lookAhead(match);
                var size = (match == "y" ? 4 : 2);
                var num = 0;
                while (size > 0 && iValue < value.length && value.charAt(iValue) >= "0" && value.charAt(iValue) <= "9") {
                    num = num * 10 + (value.charAt(iValue++) - 0);
                    size--
                }
                if (size == (match == "y" ? 4 : 2)) {
                    throw "Missing number at position " + iValue
                }
                return num
            };
            var getName = function(match, shortNames, longNames) {
                var names = (lookAhead(match) ? longNames : shortNames);
                var size = 0;
                for (var j = 0; j < names.length; j++) {
                    size = Math.max(size, names[j].length)
                }
                var name = "";
                var iInit = iValue;
                while (size > 0 && iValue < value.length) {
                    name += value.charAt(iValue++);
                    for (var i = 0; i < names.length; i++) {
                        if (name == names[i]) {
                            return i + 1
                        }
                    }
                    size--
                }
                throw "Unknown name at position " + iInit
            };
            var checkLiteral = function() {
                if (value.charAt(iValue) != format.charAt(iFormat)) {
                    throw "Unexpected literal at position " + iValue
                }
                iValue++
            };
            var iValue = 0;
            for (var iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
                        literal = false
                    } else {
                        checkLiteral()
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral()
                            } else {
                                literal = true
                            }
                            break;
                        default:
                            checkLiteral()
                    }
                }
            }
            if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100)
            }
            var date = new Date(year, month - 1, day);
            if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day) {
                throw "Invalid date"
            }
            return date
        },
        formatDate: function(format, date, settings) {
            if (!date) {
                return ""
            }
            var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
            var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
            var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
            var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
            var lookAhead = function(match) {
                var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
                if (matches) {
                    iFormat++
                }
                return matches
            };
            var formatNumber = function(match, value) {
                return (lookAhead(match) && value < 10 ? "0" : "") + value
            };
            var formatName = function(match, value, shortNames, longNames) {
                return (lookAhead(match) ? longNames[value] : shortNames[value])
            };
            var output = "";
            var literal = false;
            if (date) {
                for (var iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
                            literal = false
                        } else {
                            output += format.charAt(iFormat)
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate());
                                break;
                            case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;
                            case "m":
                                output += formatNumber("m", date.getMonth() + 1);
                                break;
                            case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case "y":
                                output += (lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'"
                                } else {
                                    literal = true
                                }
                                break;
                            default:
                                output += format.charAt(iFormat)
                        }
                    }
                }
            }
            return output
        },
        _possibleChars: function(format) {
            var chars = "";
            var literal = false;
            for (var iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) == "'" && !lookAhead("'")) {
                        literal = false
                    } else {
                        chars += format.charAt(iFormat)
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d" || "m" || "y":
                            chars += "0123456789";
                            break;
                        case "D" || "M":
                            return null;
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'"
                            } else {
                                literal = true
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat)
                    }
                }
            }
            return chars
        }
    });

    function DatepickerInstance(settings, inline) {
        this._id = $.datepicker._register(this);
        this._selectedDay = 0;
        this._selectedMonth = 0;
        this._selectedYear = 0;
        this._drawMonth = 0;
        this._drawYear = 0;
        this._input = null;
        this._inline = inline;
        this._datepickerDiv = (!inline ? $.datepicker._datepickerDiv : $('<div id="datepicker_div_' + this._id + '" class="datepicker_inline">'));
        this._settings = extendRemove(settings || {});
        if (inline) {
            this._setDate(this._getDefaultDate())
        }
    }
    $.extend(DatepickerInstance.prototype, {
        _get: function(name) {
            return this._settings[name] !== undefined ? this._settings[name] : $.datepicker._defaults[name]
        },
        _setDateFromField: function(input) {
            this._input = $(input);
            var dateFormat = this._get("dateFormat");
            var dates = this._input ? this._input.val().split(this._get("rangeSeparator")) : null;
            this._endDay = this._endMonth = this._endYear = null;
            var date = defaultDate = this._getDefaultDate();
            if (dates.length > 0) {
                var settings = this._getFormatConfig();
                if (dates.length > 1) {
                    date = $.datepicker.parseDate(dateFormat, dates[1], settings) || defaultDate;
                    this._endDay = date.getDate();
                    this._endMonth = date.getMonth();
                    this._endYear = date.getFullYear()
                }
                try {
                    date = $.datepicker.parseDate(dateFormat, dates[0], settings) || defaultDate
                } catch (e) {
                    $.datepicker.log(e);
                    date = defaultDate
                }
            }
            this._selectedDay = date.getDate();
            this._drawMonth = this._selectedMonth = date.getMonth();
            this._drawYear = this._selectedYear = date.getFullYear();
            this._currentDay = (dates[0] ? date.getDate() : 0);
            this._currentMonth = (dates[0] ? date.getMonth() : 0);
            this._currentYear = (dates[0] ? date.getFullYear() : 0);
            this._adjustDate()
        },
        _getDefaultDate: function() {
            var date = this._determineDate("defaultDate", new Date());
            var minDate = this._getMinMaxDate("min", true);
            var maxDate = this._getMinMaxDate("max");
            date = (minDate && date < minDate ? minDate : date);
            date = (maxDate && date > maxDate ? maxDate : date);
            return date
        },
        _determineDate: function(name, defaultDate) {
            var offsetNumeric = function(offset) {
                var date = new Date();
                date.setDate(date.getDate() + offset);
                return date
            };
            var offsetString = function(offset, getDaysInMonth) {
                var date = new Date();
                var matches = /^([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?$/.exec(offset);
                if (matches) {
                    var year = date.getFullYear();
                    var month = date.getMonth();
                    var day = date.getDate();
                    switch (matches[2] || "d") {
                        case "d":
                        case "D":
                            day += (matches[1] - 0);
                            break;
                        case "w":
                        case "W":
                            day += (matches[1] * 7);
                            break;
                        case "m":
                        case "M":
                            month += (matches[1] - 0);
                            day = Math.min(day, getDaysInMonth(year, month));
                            break;
                        case "y":
                        case "Y":
                            year += (matches[1] - 0);
                            day = Math.min(day, getDaysInMonth(year, month));
                            break
                    }
                    date = new Date(year, month, day)
                }
                return date
            };
            var date = this._get(name);
            return (date == null ? defaultDate : (typeof date == "string" ? offsetString(date, this._getDaysInMonth) : (typeof date == "number" ? offsetNumeric(date) : date)))
        },
        _setDate: function(date, endDate) {
            this._selectedDay = this._currentDay = date.getDate();
            this._drawMonth = this._selectedMonth = this._currentMonth = date.getMonth();
            this._drawYear = this._selectedYear = this._currentYear = date.getFullYear();
            if (this._get("rangeSelect")) {
                if (endDate) {
                    this._endDay = endDate.getDate();
                    this._endMonth = endDate.getMonth();
                    this._endYear = endDate.getFullYear()
                } else {
                    this._endDay = this._currentDay;
                    this._endMonth = this._currentMonth;
                    this._endYear = this._currentYear
                }
            }
            this._adjustDate()
        },
        _getDate: function() {
            var startDate = (!this._currentYear || (this._input && this._input.val() == "") ? null : new Date(this._currentYear, this._currentMonth, this._currentDay));
            if (this._get("rangeSelect")) {
                return [startDate, (!this._endYear ? null : new Date(this._endYear, this._endMonth, this._endDay))]
            } else {
                return startDate
            }
        },
        _generateDatepicker: function() {
            var today = new Date();
            today = new Date(today.getFullYear(), today.getMonth(), today.getDate());
            var showStatus = this._get("showStatus");
            var isRTL = this._get("isRTL");
            var clear = (this._get("mandatory") ? "" : '<div class="datepicker_clear"><a onclick="jQuery.datepicker._clearDate(' + this._id + ');"' + (showStatus ? this._addStatus(this._get("clearStatus") || "&#xa0;") : "") + ">" + this._get("clearText") + "</a></div>");
            var controls = '<div class="datepicker_control">' + (isRTL ? "" : clear) + '<div class="datepicker_close"><a onclick="jQuery.datepicker._hideDatepicker();"' + (showStatus ? this._addStatus(this._get("closeStatus") || "&#xa0;") : "") + ">" + this._get("closeText") + "</a></div>" + (isRTL ? clear : "") + "</div>";
            var prompt = this._get("prompt");
            var closeAtTop = this._get("closeAtTop");
            var hideIfNoPrevNext = this._get("hideIfNoPrevNext");
            var numMonths = this._getNumberOfMonths();
            var stepMonths = this._get("stepMonths");
            var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
            var minDate = this._getMinMaxDate("min", true);
            var maxDate = this._getMinMaxDate("max");
            var drawMonth = this._drawMonth;
            var drawYear = this._drawYear;
            if (maxDate) {
                var maxDraw = new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[1] + 1, maxDate.getDate());
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (new Date(drawYear, drawMonth, 1) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--
                    }
                }
            }
            var prev = '<div class="datepicker_prev">' + (this._canAdjustMonth(-1, drawYear, drawMonth) ? '<a onclick="jQuery.datepicker._adjustDate(' + this._id + ", -" + stepMonths + ", 'M');\"" + (showStatus ? this._addStatus(this._get("prevStatus") || "&#xa0;") : "") + ">" + this._get("prevText") + "</a>" : (hideIfNoPrevNext ? "" : "<label>" + this._get("prevText") + "</label>")) + "</div>";
            var next = '<div class="datepicker_next">' + (this._canAdjustMonth(+1, drawYear, drawMonth) ? '<a onclick="jQuery.datepicker._adjustDate(' + this._id + ", +" + stepMonths + ", 'M');\"" + (showStatus ? this._addStatus(this._get("nextStatus") || "&#xa0;") : "") + ">" + this._get("nextText") + "</a>" : (hideIfNoPrevNext ? ">" : "<label>" + this._get("nextText") + "</label>")) + "</div>";
            var html = (prompt ? '<div class="datepicker_prompt">' + prompt + "</div>" : "") + (closeAtTop && !this._inline ? controls : "") + '<div class="datepicker_links">' + (isRTL ? next : prev) + (this._isInRange(today) ? '<div class="datepicker_current"><a onclick="jQuery.datepicker._gotoToday(' + this._id + ');"' + (showStatus ? this._addStatus(this._get("currentStatus") || "&#xa0;") : "") + ">" + this._get("currentText") + "</a></div>" : "") + (isRTL ? prev : next) + "</div>";
            var showWeeks = this._get("showWeeks");
            for (var row = 0; row < numMonths[0]; row++) {
                for (var col = 0; col < numMonths[1]; col++) {
                    var selectedDate = new Date(drawYear, drawMonth, this._selectedDay);
                    html += '<div class="datepicker_oneMonth' + (col == 0 ? " datepicker_newRow" : "") + '">' + this._generateMonthYearHeader(drawMonth, drawYear, minDate, maxDate, selectedDate, row > 0 || col > 0) + '<table class="datepicker" cellpadding="0" cellspacing="0"><thead><tr class="datepicker_titleRow">' + (showWeeks ? "<td>" + this._get("weekHeader") + "</td>" : "");
                    var firstDay = this._get("firstDay");
                    var changeFirstDay = this._get("changeFirstDay");
                    var dayNames = this._get("dayNames");
                    var dayNamesShort = this._get("dayNamesShort");
                    var dayNamesMin = this._get("dayNamesMin");
                    for (var dow = 0; dow < 7; dow++) {
                        var day = (dow + firstDay) % 7;
                        var status = this._get("dayStatus") || "&#xa0;";
                        status = (status.indexOf("DD") > -1 ? status.replace(/DD/, dayNames[day]) : status.replace(/D/, dayNamesShort[day]));
                        html += "<td" + ((dow + firstDay + 6) % 7 >= 5 ? ' class="datepicker_weekEndCell"' : "") + ">" + (!changeFirstDay ? "<span" : '<a onclick="jQuery.datepicker._changeFirstDay(' + this._id + ", " + day + ');"') + (showStatus ? this._addStatus(status) : "") + ' title="' + dayNames[day] + '">' + dayNamesMin[day] + (changeFirstDay ? "</a>" : "</span>") + "</td>"
                    }
                    html += "</tr></thead><tbody>";
                    var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear == this._selectedYear && drawMonth == this._selectedMonth) {
                        this._selectedDay = Math.min(this._selectedDay, daysInMonth)
                    }
                    var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    var currentDate = (!this._currentDay ? new Date(9999, 9, 9) : new Date(this._currentYear, this._currentMonth, this._currentDay));
                    var endDate = this._endDay ? new Date(this._endYear, this._endMonth, this._endDay) : currentDate;
                    var printDate = new Date(drawYear, drawMonth, 1 - leadDays);
                    var numRows = (isMultiMonth ? 6 : Math.ceil((leadDays + daysInMonth) / 7));
                    var beforeShowDay = this._get("beforeShowDay");
                    var showOtherMonths = this._get("showOtherMonths");
                    var calculateWeek = this._get("calculateWeek") || $.datepicker.iso8601Week;
                    var dateStatus = this._get("statusForDate") || $.datepicker.dateStatus;
                    for (var dRow = 0; dRow < numRows; dRow++) {
                        html += '<tr class="datepicker_daysRow">' + (showWeeks ? '<td class="datepicker_weekCol">' + calculateWeek(printDate) + "</td>" : "");
                        for (var dow = 0; dow < 7; dow++) {
                            var daySettings = (beforeShowDay ? beforeShowDay.apply((this._input ? this._input[0] : null), [printDate]) : [true, ""]);
                            var otherMonth = (printDate.getMonth() != drawMonth);
                            var unselectable = otherMonth || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            html += '<td class="datepicker_daysCell' + ((dow + firstDay + 6) % 7 >= 5 ? " datepicker_weekEndCell" : "") + (otherMonth ? " datepicker_otherMonth" : "") + (printDate.getTime() == selectedDate.getTime() && drawMonth == this._selectedMonth ? " datepicker_daysCellOver" : "") + (unselectable ? " datepicker_unselectable" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() >= currentDate.getTime() && printDate.getTime() <= endDate.getTime() ? " datepicker_currentDay" : "") + (printDate.getTime() == today.getTime() ? " datepicker_today" : "")) + '"' + (unselectable ? "" : " onmouseover=\"jQuery(this).addClass('datepicker_daysCellOver');" + (!showStatus || (otherMonth && !showOtherMonths) ? "" : "jQuery('#datepicker_status_" + this._id + "').html('" + (dateStatus.apply((this._input ? this._input[0] : null), [printDate, this]) || "&#xa0;") + "');") + "\" onmouseout=\"jQuery(this).removeClass('datepicker_daysCellOver');" + (!showStatus || (otherMonth && !showOtherMonths) ? "" : "jQuery('#datepicker_status_" + this._id + "').html('&#xa0;');") + '" onclick="jQuery.datepicker._selectDay(' + this._id + "," + drawMonth + "," + drawYear + ', this);"') + ">" + (otherMonth ? (showOtherMonths ? printDate.getDate() : "&#xa0;") : (unselectable ? printDate.getDate() : "<a>" + printDate.getDate() + "</a>")) + "</td>";
                            printDate.setDate(printDate.getDate() + 1)
                        }
                        html += "</tr>"
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++
                    }
                    html += "</tbody></table></div>"
                }
            }
            html += (showStatus ? '<div style="clear: both;"></div><div id="datepicker_status_' + this._id + '" class="datepicker_status">' + (this._get("initStatus") || "&#xa0;") + "</div>" : "") + (!closeAtTop && !this._inline ? controls : "") + '<div style="clear: both;"></div>';
            return html
        },
        _generateMonthYearHeader: function(drawMonth, drawYear, minDate, maxDate, selectedDate, secondary) {
            minDate = (this._rangeStart && minDate && selectedDate < minDate ? selectedDate : minDate);
            var showStatus = this._get("showStatus");
            var html = '<div class="datepicker_header">';
            var monthNames = this._get("monthNames");
            if (secondary || !this._get("changeMonth")) {
                html += monthNames[drawMonth] + "&#xa0;"
            } else {
                var inMinYear = (minDate && minDate.getFullYear() == drawYear);
                var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
                html += '<select class="datepicker_newMonth" onchange="jQuery.datepicker._selectMonthYear(' + this._id + ", this, 'M');\" onclick=\"jQuery.datepicker._clickMonthYear(" + this._id + ');"' + (showStatus ? this._addStatus(this._get("monthStatus") || "&#xa0;") : "") + ">";
                for (var month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        html += '<option value="' + month + '"' + (month == drawMonth ? ' selected="selected"' : "") + ">" + monthNames[month] + "</option>"
                    }
                }
                html += "</select>"
            }
            if (secondary || !this._get("changeYear")) {
                html += drawYear
            } else {
                var years = this._get("yearRange").split(":");
                var year = 0;
                var endYear = 0;
                if (years.length != 2) {
                    year = drawYear - 10;
                    endYear = drawYear + 10
                } else {
                    if (years[0].charAt(0) == "+" || years[0].charAt(0) == "-") {
                        year = drawYear + parseInt(years[0], 10);
                        endYear = drawYear + parseInt(years[1], 10)
                    } else {
                        year = parseInt(years[0], 10);
                        endYear = parseInt(years[1], 10)
                    }
                }
                year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                html += '<select class="datepicker_newYear" onchange="jQuery.datepicker._selectMonthYear(' + this._id + ", this, 'Y');\" onclick=\"jQuery.datepicker._clickMonthYear(" + this._id + ');"' + (showStatus ? this._addStatus(this._get("yearStatus") || "&#xa0;") : "") + ">";
                for (; year <= endYear; year++) {
                    html += '<option value="' + year + '"' + (year == drawYear ? ' selected="selected"' : "") + ">" + year + "</option>"
                }
                html += "</select>"
            }
            html += "</div>";
            return html
        },
        _addStatus: function(text) {
            return " onmouseover=\"jQuery('#datepicker_status_" + this._id + "').html('" + text + "');\" onmouseout=\"jQuery('#datepicker_status_" + this._id + "').html('&#xa0;');\""
        },
        _adjustDate: function(offset, period) {
            var year = this._drawYear + (period == "Y" ? offset : 0);
            var month = this._drawMonth + (period == "M" ? offset : 0);
            var day = Math.min(this._selectedDay, this._getDaysInMonth(year, month)) + (period == "D" ? offset : 0);
            var date = new Date(year, month, day);
            var minDate = this._getMinMaxDate("min", true);
            var maxDate = this._getMinMaxDate("max");
            date = (minDate && date < minDate ? minDate : date);
            date = (maxDate && date > maxDate ? maxDate : date);
            this._selectedDay = date.getDate();
            this._drawMonth = this._selectedMonth = date.getMonth();
            this._drawYear = this._selectedYear = date.getFullYear()
        },
        _getNumberOfMonths: function() {
            var numMonths = this._get("numberOfMonths");
            return (numMonths == null ? [1, 1] : (typeof numMonths == "number" ? [1, numMonths] : numMonths))
        },
        _getMinMaxDate: function(minMax, checkRange) {
            var date = this._determineDate(minMax + "Date", null);
            if (date) {
                date.setHours(0);
                date.setMinutes(0);
                date.setSeconds(0);
                date.setMilliseconds(0)
            }
            return date || (checkRange ? this._rangeStart : null)
        },
        _getDaysInMonth: function(year, month) {
            return 32 - new Date(year, month, 32).getDate()
        },
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay()
        },
        _canAdjustMonth: function(offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths();
            var date = new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[1]), 1);
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()))
            }
            return this._isInRange(date)
        },
        _isInRange: function(date) {
            var newMinDate = (!this._rangeStart ? null : new Date(this._selectedYear, this._selectedMonth, this._selectedDay));
            newMinDate = (newMinDate && this._rangeStart < newMinDate ? this._rangeStart : newMinDate);
            var minDate = newMinDate || this._getMinMaxDate("min");
            var maxDate = this._getMinMaxDate("max");
            return ((!minDate || date >= minDate) && (!maxDate || date <= maxDate))
        },
        _getFormatConfig: function() {
            var shortYearCutoff = this._get("shortYearCutoff");
            shortYearCutoff = (typeof shortYearCutoff != "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get("dayNamesShort"),
                dayNames: this._get("dayNames"),
                monthNamesShort: this._get("monthNamesShort"),
                monthNames: this._get("monthNames")
            }
        },
        _formatDate: function(day, month, year) {
            if (!day) {
                this._currentDay = this._selectedDay;
                this._currentMonth = this._selectedMonth;
                this._currentYear = this._selectedYear
            }
            var date = (day ? (typeof day == "object" ? day : new Date(year, month, day)) : new Date(this._currentYear, this._currentMonth, this._currentDay));
            return $.datepicker.formatDate(this._get("dateFormat"), date, this._getFormatConfig())
        }
    });

    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = null
            }
        }
        return target
    }
    $.fn.datepicker = function(options) {
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options == "string" && (options == "isDisabled" || options == "getDate")) {
            return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs))
        }
        return this.each(function() {
            typeof options == "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options)
        })
    };
    $.datepicker = new Datepicker();
    $(document).ready(function() {
        $(document.body).append($.datepicker._datepickerDiv).mousedown($.datepicker._checkExternalClick)
    })
})(jQuery);
(function(D) {
    D.color = {};
    D.color.make = function(H, G, E, F) {
        var I = {};
        I.r = H || 0;
        I.g = G || 0;
        I.b = E || 0;
        I.a = F != null ? F : 1;
        I.add = function(L, K) {
            for (var J = 0; J < L.length; ++J) {
                I[L.charAt(J)] += K
            }
            return I.normalize()
        };
        I.scale = function(L, K) {
            for (var J = 0; J < L.length; ++J) {
                I[L.charAt(J)] *= K
            }
            return I.normalize()
        };
        I.toString = function() {
            if (I.a >= 1) {
                return "rgb(" + [I.r, I.g, I.b].join(",") + ")"
            } else {
                return "rgba(" + [I.r, I.g, I.b, I.a].join(",") + ")"
            }
        };
        I.normalize = function() {
            function J(L, M, K) {
                return M < L ? L : M > K ? K : M
            }
            I.r = J(0, parseInt(I.r), 255);
            I.g = J(0, parseInt(I.g), 255);
            I.b = J(0, parseInt(I.b), 255);
            I.a = J(0, I.a, 1);
            return I
        };
        I.clone = function() {
            return D.color.make(I.r, I.b, I.g, I.a)
        };
        return I.normalize()
    };
    D.color.extract = function(F, E) {
        var G;
        do {
            G = F.css(E).toLowerCase();
            if (G != "" && G != "transparent") {
                break
            }
            F = F.parent()
        } while (F.length && !D.nodeName(F.get(0), "body"));
        if (G == "rgba(0, 0, 0, 0)") {
            G = "transparent"
        }
        return D.color.parse(G)
    };
    D.color.parse = function(H) {
        var G, E = D.color.make;
        if (G = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(H)) {
            return E(parseInt(G[1], 10), parseInt(G[2], 10), parseInt(G[3], 10))
        }
        if (G = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(H)) {
            return E(parseInt(G[1], 10), parseInt(G[2], 10), parseInt(G[3], 10), parseFloat(G[4]))
        }
        if (G = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(H)) {
            return E(parseFloat(G[1]) * 2.55, parseFloat(G[2]) * 2.55, parseFloat(G[3]) * 2.55)
        }
        if (G = /rgba\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\s*\)/.exec(H)) {
            return E(parseFloat(G[1]) * 2.55, parseFloat(G[2]) * 2.55, parseFloat(G[3]) * 2.55, parseFloat(G[4]))
        }
        if (G = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(H)) {
            return E(parseInt(G[1], 16), parseInt(G[2], 16), parseInt(G[3], 16))
        }
        if (G = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(H)) {
            return E(parseInt(G[1] + G[1], 16), parseInt(G[2] + G[2], 16), parseInt(G[3] + G[3], 16))
        }
        var F = D.trim(H).toLowerCase();
        if (F == "transparent") {
            return E(255, 255, 255, 0)
        } else {
            G = C[F] || [0, 0, 0];
            return E(G[0], G[1], G[2])
        }
    };
    var C = {
        aqua: [0, 255, 255],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        black: [0, 0, 0],
        blue: [0, 0, 255],
        brown: [165, 42, 42],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgrey: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkviolet: [148, 0, 211],
        fuchsia: [255, 0, 255],
        gold: [255, 215, 0],
        green: [0, 128, 0],
        indigo: [75, 0, 130],
        khaki: [240, 230, 140],
        lightblue: [173, 216, 230],
        lightcyan: [224, 255, 255],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        navy: [0, 0, 128],
        olive: [128, 128, 0],
        orange: [255, 165, 0],
        pink: [255, 192, 203],
        purple: [128, 0, 128],
        violet: [128, 0, 128],
        red: [255, 0, 0],
        silver: [192, 192, 192],
        white: [255, 255, 255],
        yellow: [255, 255, 0]
    }
})(jQuery);
(function(G) {
    var F = Object.prototype.hasOwnProperty;
    if (!G.fn.detach) {
        G.fn.detach = function() {
            return this.each(function() {
                if (this.parentNode) {
                    this.parentNode.removeChild(this)
                }
            })
        }
    }

    function C(J, I) {
        var L = I.children("." + J)[0];
        if (L == null) {
            L = document.createElement("canvas");
            L.className = J;
            G(L).css({
                direction: "ltr",
                position: "absolute",
                left: 0,
                top: 0
            }).appendTo(I);
            if (!L.getContext) {
                if (window.G_vmlCanvasManager) {
                    L = window.G_vmlCanvasManager.initElement(L)
                } else {
                    throw new Error("Canvas is not available. If you're using IE with a fall-back such as Excanvas, then there's either a mistake in your conditional include, or the page has no DOCTYPE and is rendering in Quirks Mode.")
                }
            }
        }
        this.element = L;
        var K = this.context = L.getContext("2d");
        var H = window.devicePixelRatio || 1,
            M = K.webkitBackingStorePixelRatio || K.mozBackingStorePixelRatio || K.msBackingStorePixelRatio || K.oBackingStorePixelRatio || K.backingStorePixelRatio || 1;
        this.pixelRatio = H / M;
        this.resize(I.width(), I.height());
        this.textContainer = null;
        this.text = {};
        this._textCache = {}
    }
    C.prototype.resize = function(K, H) {
        if (K <= 0 || H <= 0) {
            throw new Error("Invalid dimensions for plot, width = " + K + ", height = " + H)
        }
        var J = this.element,
            I = this.context,
            L = this.pixelRatio;
        if (this.width != K) {
            J.width = K * L;
            J.style.width = K + "px";
            this.width = K
        }
        if (this.height != H) {
            J.height = H * L;
            J.style.height = H + "px";
            this.height = H
        }
        I.restore();
        I.save();
        I.scale(L, L)
    };
    C.prototype.clear = function() {
        this.context.clearRect(0, 0, this.width, this.height)
    };
    C.prototype.render = function() {
        var H = this._textCache;
        for (var P in H) {
            if (F.call(H, P)) {
                var O = this.getTextLayer(P),
                    I = H[P];
                O.hide();
                for (var N in I) {
                    if (F.call(I, N)) {
                        var J = I[N];
                        for (var Q in J) {
                            if (F.call(J, Q)) {
                                var L = J[Q].positions;
                                for (var K = 0, M; M = L[K]; K++) {
                                    if (M.active) {
                                        if (!M.rendered) {
                                            O.append(M.element);
                                            M.rendered = true
                                        }
                                    } else {
                                        L.splice(K--, 1);
                                        if (M.rendered) {
                                            M.element.detach()
                                        }
                                    }
                                }
                                if (L.length == 0) {
                                    delete J[Q]
                                }
                            }
                        }
                    }
                }
                O.show()
            }
        }
    };
    C.prototype.getTextLayer = function(I) {
        var H = this.text[I];
        if (H == null) {
            if (this.textContainer == null) {
                this.textContainer = G("<div class='flot-text' id='graphTickColor'></div>").insertAfter(this.element)
            }
            H = this.text[I] = G("<div></div>").addClass(I).css({
                position: "absolute",
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }).appendTo(this.textContainer)
        }
        return H
    };
    C.prototype.getTextInfo = function(O, Q, L, M, I) {
        var P, H, K, J;
        Q = "" + Q;
        if (typeof L === "object") {
            P = L.style + " " + L.variant + " " + L.weight + " " + L.size + "px/" + L.lineHeight + "px " + L.family
        } else {
            P = L
        }
        H = this._textCache[O];
        if (H == null) {
            H = this._textCache[O] = {}
        }
        K = H[P];
        if (K == null) {
            K = H[P] = {}
        }
        J = K[Q];
        if (J == null) {
            var N = G("<div></div>").html(Q).css({
                position: "absolute",
                "max-width": I,
                top: -9999
            }).appendTo(this.getTextLayer(O));
            if (typeof L === "object") {
                N.css({
                    font: P,
                    color: L.color
                })
            } else {
                if (typeof L === "string") {
                    N.addClass(L)
                }
            }
            J = K[Q] = {
                width: N.outerWidth(true),
                height: N.outerHeight(true),
                element: N,
                positions: []
            };
            N.detach()
        }
        return J
    };
    C.prototype.addText = function(P, S, Q, T, J, K, H, O, R) {
        var I = this.getTextInfo(P, T, J, K, H),
            M = I.positions;
        if (O == "center") {
            S -= I.width / 2
        } else {
            if (O == "right") {
                S -= I.width
            }
        }
        if (R == "middle") {
            Q -= I.height / 2
        } else {
            if (R == "bottom") {
                Q -= I.height
            }
        }
        for (var L = 0, N; N = M[L]; L++) {
            if (N.x == S && N.y == Q) {
                N.active = true;
                return
            }
        }
        N = {
            active: true,
            rendered: false,
            element: M.length ? I.element.clone() : I.element,
            x: S,
            y: Q
        };
        M.push(N);
        N.element.css({
            top: Math.round(Q),
            left: Math.round(S),
            "text-align": O
        })
    };
    C.prototype.removeText = function(P, R, Q, T, J, K) {
        if (T == null) {
            var H = this._textCache[P];
            if (H != null) {
                for (var O in H) {
                    if (F.call(H, O)) {
                        var I = H[O];
                        for (var S in I) {
                            if (F.call(I, S)) {
                                var M = I[S].positions;
                                for (var L = 0, N; N = M[L]; L++) {
                                    N.active = false
                                }
                            }
                        }
                    }
                }
            }
        } else {
            var M = this.getTextInfo(P, T, J, K).positions;
            for (var L = 0, N; N = M[L]; L++) {
                if (N.x == R && N.y == Q) {
                    N.active = false
                }
            }
        }
    };

    function E(x, c, e, I) {
        var V = [],
            r = {
                colors: ["#edc240", "#afd8f8", "#cb4b4b", "#4da74d", "#9440ed"],
                legend: {
                    show: true,
                    noColumns: 1,
                    labelFormatter: null,
                    labelBoxBorderColor: "#ccc",
                    container: null,
                    position: "ne",
                    margin: 5,
                    backgroundColor: null,
                    backgroundOpacity: 0.85,
                    sorted: null
                },
                xaxis: {
                    show: null,
                    position: "bottom",
                    mode: null,
                    font: null,
                    color: null,
                    tickColor: null,
                    transform: null,
                    inverseTransform: null,
                    min: null,
                    max: null,
                    autoscaleMargin: null,
                    ticks: null,
                    tickFormatter: null,
                    labelWidth: null,
                    labelHeight: null,
                    reserveSpace: null,
                    tickLength: null,
                    alignTicksWithAxis: null,
                    tickDecimals: null,
                    tickSize: null,
                    minTickSize: null
                },
                yaxis: {
                    autoscaleMargin: 0.02,
                    position: "left"
                },
                xaxes: [],
                yaxes: [],
                series: {
                    points: {
                        show: false,
                        radius: 3,
                        lineWidth: 2,
                        fill: true,
                        fillColor: "#FFF",
                        symbol: "circle"
                    },
                    lines: {
                        lineWidth: 2,
                        fill: false,
                        fillColor: null,
                        steps: false
                    },
                    bars: {
                        show: false,
                        lineWidth: 2,
                        barWidth: 1,
                        fill: true,
                        fillColor: null,
                        align: "left",
                        horizontal: false,
                        zero: true
                    },
                    shadowSize: 3,
                    highlightColor: null
                },
                grid: {
                    show: true,
                    aboveData: false,
                    color: "#545454",
                    backgroundColor: null,
                    borderColor: null,
                    tickColor: null,
                    margin: 0,
                    labelMargin: 10,
                    axisMargin: 8,
                    borderWidth: 1,
                    minBorderMargin: null,
                    markings: null,
                    markingsColor: "#f4f4f4",
                    markingsLineWidth: 2,
                    clickable: false,
                    hoverable: false,
                    autoHighlight: true,
                    mouseActiveRadius: 10
                },
                interaction: {
                    redrawOverlayInterval: 1000 / 60
                },
                hooks: {}
            },
            AK = null,
            AT = null,
            AU = null,
            f = null,
            Ad = null,
            AW = [],
            AE = [],
            p = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            M = 0,
            AL = 0,
            R = {
                processOptions: [],
                processRawData: [],
                processDatapoints: [],
                processOffset: [],
                drawBackground: [],
                drawSeries: [],
                draw: [],
                bindEvents: [],
                drawOverlay: [],
                shutdown: []
            },
            J = this;
        J.setData = q;
        J.setupGrid = v;
        J.draw = Ab;
        J.getPlaceholder = function() {
            return x
        };
        J.getCanvas = function() {
            return AK.element
        };
        J.getPlotOffset = function() {
            return p
        };
        J.width = function() {
            return M
        };
        J.height = function() {
            return AL
        };
        J.offset = function() {
            var Af = AU.offset();
            Af.left += p.left;
            Af.top += p.top;
            return Af
        };
        J.getData = function() {
            return V
        };
        J.getAxes = function() {
            var Ag = {},
                Af;
            G.each(AW.concat(AE), function(Ah, Ai) {
                if (Ai) {
                    Ag[Ai.direction + (Ai.n != 1 ? Ai.n : "") + "axis"] = Ai
                }
            });
            return Ag
        };
        J.getXAxes = function() {
            return AW
        };
        J.getYAxes = function() {
            return AE
        };
        J.c2p = AG;
        J.p2c = y;
        J.getOptions = function() {
            return r
        };
        J.highlight = AV;
        J.unhighlight = AP;
        J.triggerRedrawOverlay = AF;
        J.pointOffset = function(Af) {
            return {
                left: parseInt(AW[Z(Af, "x") - 1].p2c(+Af.x) + p.left, 10),
                top: parseInt(AE[Z(Af, "y") - 1].p2c(+Af.y) + p.top, 10)
            }
        };
        J.shutdown = Q;
        J.destroy = function() {
            Q();
            x.removeData("plot").empty();
            V = [];
            r = null;
            AK = null;
            AT = null;
            AU = null;
            f = null;
            Ad = null;
            AW = [];
            AE = [];
            R = null;
            AO = [];
            J = null
        };
        J.resize = function() {
            var Ag = x.width(),
                Af = x.height();
            AK.resize(Ag, Af);
            AT.resize(Ag, Af)
        };
        J.hooks = R;
        m(J);
        AI(e);
        Ae();
        q(c);
        v();
        Ab();
        AZ();

        function j(Ah, Af) {
            Af = [J].concat(Af);
            for (var Ag = 0; Ag < Ah.length; ++Ag) {
                Ah[Ag].apply(this, Af)
            }
        }

        function m() {
            var Ag = {
                Canvas: C
            };
            for (var Af = 0; Af < I.length; ++Af) {
                var Ah = I[Af];
                Ah.init(J, Ag);
                if (Ah.options) {
                    G.extend(true, r, Ah.options)
                }
            }
        }

        function AI(Ah) {
            G.extend(true, r, Ah);
            if (Ah && Ah.colors) {
                r.colors = Ah.colors
            }
            if (r.xaxis.color == null) {
                r.xaxis.color = G.color.parse(r.grid.color).scale("a", 0.22).toString()
            }
            if (r.yaxis.color == null) {
                r.yaxis.color = G.color.parse(r.grid.color).scale("a", 0.22).toString()
            }
            if (r.xaxis.tickColor == null) {
                r.xaxis.tickColor = r.grid.tickColor || r.xaxis.color
            }
            if (r.yaxis.tickColor == null) {
                r.yaxis.tickColor = r.grid.tickColor || r.yaxis.color
            }
            if (r.grid.borderColor == null) {
                r.grid.borderColor = r.grid.color
            }
            if (r.grid.tickColor == null) {
                r.grid.tickColor = G.color.parse(r.grid.color).scale("a", 0.22).toString()
            }
            var Af, Am, Ak, Aj = x.css("font-size"),
                Ai = Aj ? +Aj.replace("px", "") : 13,
                Ag = {
                    style: x.css("font-style"),
                    size: Math.round(0.8 * Ai),
                    variant: x.css("font-variant"),
                    weight: x.css("font-weight"),
                    family: x.css("font-family")
                };
            Ak = r.xaxes.length || 1;
            for (Af = 0; Af < Ak; ++Af) {
                Am = r.xaxes[Af];
                if (Am && !Am.tickColor) {
                    Am.tickColor = Am.color
                }
                Am = G.extend(true, {}, r.xaxis, Am);
                r.xaxes[Af] = Am;
                if (Am.font) {
                    Am.font = G.extend({}, Ag, Am.font);
                    if (!Am.font.color) {
                        Am.font.color = Am.color
                    }
                    if (!Am.font.lineHeight) {
                        Am.font.lineHeight = Math.round(Am.font.size * 1.15)
                    }
                }
            }
            Ak = r.yaxes.length || 1;
            for (Af = 0; Af < Ak; ++Af) {
                Am = r.yaxes[Af];
                if (Am && !Am.tickColor) {
                    Am.tickColor = Am.color
                }
                Am = G.extend(true, {}, r.yaxis, Am);
                r.yaxes[Af] = Am;
                if (Am.font) {
                    Am.font = G.extend({}, Ag, Am.font);
                    if (!Am.font.color) {
                        Am.font.color = Am.color
                    }
                    if (!Am.font.lineHeight) {
                        Am.font.lineHeight = Math.round(Am.font.size * 1.15)
                    }
                }
            }
            if (r.xaxis.noTicks && r.xaxis.ticks == null) {
                r.xaxis.ticks = r.xaxis.noTicks
            }
            if (r.yaxis.noTicks && r.yaxis.ticks == null) {
                r.yaxis.ticks = r.yaxis.noTicks
            }
            if (r.x2axis) {
                r.xaxes[1] = G.extend(true, {}, r.xaxis, r.x2axis);
                r.xaxes[1].position = "top";
                if (r.x2axis.min == null) {
                    r.xaxes[1].min = null
                }
                if (r.x2axis.max == null) {
                    r.xaxes[1].max = null
                }
            }
            if (r.y2axis) {
                r.yaxes[1] = G.extend(true, {}, r.yaxis, r.y2axis);
                r.yaxes[1].position = "right";
                if (r.y2axis.min == null) {
                    r.yaxes[1].min = null
                }
                if (r.y2axis.max == null) {
                    r.yaxes[1].max = null
                }
            }
            if (r.grid.coloredAreas) {
                r.grid.markings = r.grid.coloredAreas
            }
            if (r.grid.coloredAreasColor) {
                r.grid.markingsColor = r.grid.coloredAreasColor
            }
            if (r.lines) {
                G.extend(true, r.series.lines, r.lines)
            }
            if (r.points) {
                G.extend(true, r.series.points, r.points)
            }
            if (r.bars) {
                G.extend(true, r.series.bars, r.bars)
            }
            if (r.shadowSize != null) {
                r.series.shadowSize = r.shadowSize
            }
            if (r.highlightColor != null) {
                r.series.highlightColor = r.highlightColor
            }
            for (Af = 0; Af < r.xaxes.length; ++Af) {
                t(AW, Af + 1).options = r.xaxes[Af]
            }
            for (Af = 0; Af < r.yaxes.length; ++Af) {
                t(AE, Af + 1).options = r.yaxes[Af]
            }
            for (var Al in R) {
                if (r.hooks[Al] && r.hooks[Al].length) {
                    R[Al] = R[Al].concat(r.hooks[Al])
                }
            }
            j(R.processOptions, [r])
        }

        function q(Af) {
            V = S(Af);
            a();
            z()
        }

        function S(Ai) {
            var Ag = [];
            for (var Af = 0; Af < Ai.length; ++Af) {
                var Ah = G.extend(true, {}, r.series);
                if (Ai[Af].data != null) {
                    Ah.data = Ai[Af].data;
                    delete Ai[Af].data;
                    G.extend(true, Ah, Ai[Af]);
                    Ai[Af].data = Ah.data
                } else {
                    Ah.data = Ai[Af]
                }
                Ag.push(Ah)
            }
            return Ag
        }

        function Z(Ag, Ah) {
            var Af = Ag[Ah + "axis"];
            if (typeof Af == "object") {
                Af = Af.n
            }
            if (typeof Af != "number") {
                Af = 1
            }
            return Af
        }

        function L() {
            return G.grep(AW.concat(AE), function(Af) {
                return Af
            })
        }

        function AG(Ai) {
            var Ag = {},
                Af, Ah;
            for (Af = 0; Af < AW.length; ++Af) {
                Ah = AW[Af];
                if (Ah && Ah.used) {
                    Ag["x" + Ah.n] = Ah.c2p(Ai.left)
                }
            }
            for (Af = 0; Af < AE.length; ++Af) {
                Ah = AE[Af];
                if (Ah && Ah.used) {
                    Ag["y" + Ah.n] = Ah.c2p(Ai.top)
                }
            }
            if (Ag.x1 !== undefined) {
                Ag.x = Ag.x1
            }
            if (Ag.y1 !== undefined) {
                Ag.y = Ag.y1
            }
            return Ag
        }

        function y(Aj) {
            var Ah = {},
                Ag, Ai, Af;
            for (Ag = 0; Ag < AW.length; ++Ag) {
                Ai = AW[Ag];
                if (Ai && Ai.used) {
                    Af = "x" + Ai.n;
                    if (Aj[Af] == null && Ai.n == 1) {
                        Af = "x"
                    }
                    if (Aj[Af] != null) {
                        Ah.left = Ai.p2c(Aj[Af]);
                        break
                    }
                }
            }
            for (Ag = 0; Ag < AE.length; ++Ag) {
                Ai = AE[Ag];
                if (Ai && Ai.used) {
                    Af = "y" + Ai.n;
                    if (Aj[Af] == null && Ai.n == 1) {
                        Af = "y"
                    }
                    if (Aj[Af] != null) {
                        Ah.top = Ai.p2c(Aj[Af]);
                        break
                    }
                }
            }
            return Ah
        }

        function t(Ag, Af) {
            if (!Ag[Af - 1]) {
                Ag[Af - 1] = {
                    n: Af,
                    direction: Ag == AW ? "x" : "y",
                    options: G.extend(true, {}, Ag == AW ? r.xaxis : r.yaxis)
                }
            }
            return Ag[Af - 1]
        }

        function a() {
            var Aq = V.length,
                Ah = -1,
                Ai;
            for (Ai = 0; Ai < V.length; ++Ai) {
                var An = V[Ai].color;
                if (An != null) {
                    Aq--;
                    if (typeof An == "number" && An > Ah) {
                        Ah = An
                    }
                }
            }
            if (Aq <= Ah) {
                Aq = Ah + 1
            }
            var Am, Af = [],
                Al = r.colors,
                Ak = Al.length,
                Ag = 0;
            for (Ai = 0; Ai < Aq; Ai++) {
                Am = G.color.parse(Al[Ai % Ak] || "#666");
                if (Ai % Ak == 0 && Ai) {
                    if (Ag >= 0) {
                        if (Ag < 0.5) {
                            Ag = -Ag - 0.2
                        } else {
                            Ag = 0
                        }
                    } else {
                        Ag = -Ag
                    }
                }
                Af[Ai] = Am.scale("rgb", 1 + Ag)
            }
            var Aj = 0,
                Ar;
            for (Ai = 0; Ai < V.length; ++Ai) {
                Ar = V[Ai];
                if (Ar.color == null) {
                    Ar.color = Af[Aj].toString();
                    ++Aj
                } else {
                    if (typeof Ar.color == "number") {
                        Ar.color = Af[Ar.color].toString()
                    }
                }
                if (Ar.lines.show == null) {
                    var Ap, Ao = true;
                    for (Ap in Ar) {
                        if (Ar[Ap] && Ar[Ap].show) {
                            Ao = false;
                            break
                        }
                    }
                    if (Ao) {
                        Ar.lines.show = true
                    }
                }
                if (Ar.lines.zero == null) {
                    Ar.lines.zero = !!Ar.lines.fill
                }
                Ar.xaxis = t(AW, Z(Ar, "x"));
                Ar.yaxis = t(AE, Z(Ar, "y"))
            }
        }

        function z() {
            var At = Number.POSITIVE_INFINITY,
                An = Number.NEGATIVE_INFINITY,
                Af = Number.MAX_VALUE,
                A0, Ay, Ax, As, Ah, Ao, Az, Au, Am, Al, Ag, A6, A3, Aq, A5, A2;

            function Aj(A9, A8, A7) {
                if (A8 < A9.datamin && A8 != -Af) {
                    A9.datamin = A8
                }
                if (A7 > A9.datamax && A7 != Af) {
                    A9.datamax = A7
                }
            }
            G.each(L(), function(A7, A8) {
                A8.datamin = At;
                A8.datamax = An;
                A8.used = false
            });
            for (A0 = 0; A0 < V.length; ++A0) {
                Ao = V[A0];
                Ao.datapoints = {
                    points: []
                };
                j(R.processRawData, [Ao, Ao.data, Ao.datapoints])
            }
            for (A0 = 0; A0 < V.length; ++A0) {
                Ao = V[A0];
                A5 = Ao.data;
                A2 = Ao.datapoints.format;
                if (!A2) {
                    A2 = [];
                    A2.push({
                        x: true,
                        number: true,
                        required: true
                    });
                    A2.push({
                        y: true,
                        number: true,
                        required: true
                    });
                    if (Ao.bars.show || (Ao.lines.show && Ao.lines.fill)) {
                        var Av = !!((Ao.bars.show && Ao.bars.zero) || (Ao.lines.show && Ao.lines.zero));
                        A2.push({
                            y: true,
                            number: true,
                            required: false,
                            defaultValue: 0,
                            autoscale: Av
                        });
                        if (Ao.bars.horizontal) {
                            delete A2[A2.length - 1].y;
                            A2[A2.length - 1].x = true
                        }
                    }
                    Ao.datapoints.format = A2
                }
                if (Ao.datapoints.pointsize != null) {
                    continue
                }
                Ao.datapoints.pointsize = A2.length;
                Au = Ao.datapoints.pointsize;
                Az = Ao.datapoints.points;
                var Ak = Ao.lines.show && Ao.lines.steps;
                Ao.xaxis.used = Ao.yaxis.used = true;
                for (Ay = Ax = 0; Ay < A5.length; ++Ay, Ax += Au) {
                    Aq = A5[Ay];
                    var Ai = Aq == null;
                    if (!Ai) {
                        for (As = 0; As < Au; ++As) {
                            A6 = Aq[As];
                            A3 = A2[As];
                            if (A3) {
                                if (A3.number && A6 != null) {
                                    A6 = +A6;
                                    if (isNaN(A6)) {
                                        A6 = null
                                    } else {
                                        if (A6 == Infinity) {
                                            A6 = Af
                                        } else {
                                            if (A6 == -Infinity) {
                                                A6 = -Af
                                            }
                                        }
                                    }
                                }
                                if (A6 == null) {
                                    if (A3.required) {
                                        Ai = true
                                    }
                                    if (A3.defaultValue != null) {
                                        A6 = A3.defaultValue
                                    }
                                }
                            }
                            Az[Ax + As] = A6
                        }
                    }
                    if (Ai) {
                        for (As = 0; As < Au; ++As) {
                            A6 = Az[Ax + As];
                            if (A6 != null) {
                                A3 = A2[As];
                                if (A3.autoscale !== false) {
                                    if (A3.x) {
                                        Aj(Ao.xaxis, A6, A6)
                                    }
                                    if (A3.y) {
                                        Aj(Ao.yaxis, A6, A6)
                                    }
                                }
                            }
                            Az[Ax + As] = null
                        }
                    } else {
                        if (Ak && Ax > 0 && Az[Ax - Au] != null && Az[Ax - Au] != Az[Ax] && Az[Ax - Au + 1] != Az[Ax + 1]) {
                            for (As = 0; As < Au; ++As) {
                                Az[Ax + Au + As] = Az[Ax + As]
                            }
                            Az[Ax + 1] = Az[Ax - Au + 1];
                            Ax += Au
                        }
                    }
                }
            }
            for (A0 = 0; A0 < V.length; ++A0) {
                Ao = V[A0];
                j(R.processDatapoints, [Ao, Ao.datapoints])
            }
            for (A0 = 0; A0 < V.length; ++A0) {
                Ao = V[A0];
                Az = Ao.datapoints.points;
                Au = Ao.datapoints.pointsize;
                A2 = Ao.datapoints.format;
                var Ap = At,
                    Aw = At,
                    Ar = An,
                    A1 = An;
                for (Ay = 0; Ay < Az.length; Ay += Au) {
                    if (Az[Ay] == null) {
                        continue
                    }
                    for (As = 0; As < Au; ++As) {
                        A6 = Az[Ay + As];
                        A3 = A2[As];
                        if (!A3 || A3.autoscale === false || A6 == Af || A6 == -Af) {
                            continue
                        }
                        if (A3.x) {
                            if (A6 < Ap) {
                                Ap = A6
                            }
                            if (A6 > Ar) {
                                Ar = A6
                            }
                        }
                        if (A3.y) {
                            if (A6 < Aw) {
                                Aw = A6
                            }
                            if (A6 > A1) {
                                A1 = A6
                            }
                        }
                    }
                }
                if (Ao.bars.show) {
                    var A4;
                    switch (Ao.bars.align) {
                        case "left":
                            A4 = 0;
                            break;
                        case "right":
                            A4 = -Ao.bars.barWidth;
                            break;
                        default:
                            A4 = -Ao.bars.barWidth / 2
                    }
                    if (Ao.bars.horizontal) {
                        Aw += A4;
                        A1 += A4 + Ao.bars.barWidth
                    } else {
                        Ap += A4;
                        Ar += A4 + Ao.bars.barWidth
                    }
                }
                Aj(Ao.xaxis, Ap, Ar);
                Aj(Ao.yaxis, Aw, A1)
            }
            G.each(L(), function(A7, A8) {
                if (A8.datamin == At) {
                    A8.datamin = null
                }
                if (A8.datamax == An) {
                    A8.datamax = null
                }
            })
        }

        function Ae() {
            x.css("padding", 0).children().filter(function() {
                return !G(this).hasClass("flot-overlay") && !G(this).hasClass("flot-base")
            }).remove();
            if (x.css("position") == "static") {
                x.css("position", "relative")
            }
            AK = new C("flot-base", x);
            AT = new C("flot-overlay", x);
            f = AK.context;
            Ad = AT.context;
            AU = G(AT.element).unbind();
            var Af = x.data("plot");
            if (Af) {
                Af.shutdown();
                AT.clear()
            }
            x.data("plot", J)
        }

        function AZ() {
            if (r.grid.hoverable) {
                AU.mousemove(H);
                AU.bind("mouseleave", w)
            }
            if (r.grid.clickable) {
                AU.click(o)
            }
            j(R.bindEvents, [AU])
        }

        function Q() {
            if (N) {
                clearTimeout(N)
            }
            AU.unbind("mousemove", H);
            AU.unbind("mouseleave", w);
            AU.unbind("click", o);
            j(R.shutdown, [AU])
        }

        function P(Ak) {
            function Ag(Al) {
                return Al
            }
            var Aj, Af, Ah = Ak.options.transform || Ag,
                Ai = Ak.options.inverseTransform;
            if (Ak.direction == "x") {
                Aj = Ak.scale = M / Math.abs(Ah(Ak.max) - Ah(Ak.min));
                Af = Math.min(Ah(Ak.max), Ah(Ak.min))
            } else {
                Aj = Ak.scale = AL / Math.abs(Ah(Ak.max) - Ah(Ak.min));
                Aj = -Aj;
                Af = Math.max(Ah(Ak.max), Ah(Ak.min))
            }
            if (Ah == Ag) {
                Ak.p2c = function(Al) {
                    return (Al - Af) * Aj
                }
            } else {
                Ak.p2c = function(Al) {
                    return (Ah(Al) - Af) * Aj
                }
            }
            if (!Ai) {
                Ak.c2p = function(Al) {
                    return Af + Al / Aj
                }
            } else {
                Ak.c2p = function(Al) {
                    return Ai(Af + Al / Aj)
                }
            }
        }

        function AH(Ai) {
            var Af = Ai.options,
                Ao = Ai.ticks || [],
                An = Af.labelWidth || 0,
                Aj = Af.labelHeight || 0,
                Ap = An || (Ai.direction == "x" ? Math.floor(AK.width / (Ao.length || 1)) : null),
                Al = Ai.direction + "Axis " + Ai.direction + Ai.n + "Axis",
                Am = "flot-" + Ai.direction + "-axis flot-" + Ai.direction + Ai.n + "-axis " + Al,
                Ah = Af.font || "flot-tick-label tickLabel";
            for (var Ak = 0; Ak < Ao.length; ++Ak) {
                var Aq = Ao[Ak];
                if (!Aq.label) {
                    continue
                }
                var Ag = AK.getTextInfo(Am, Aq.label, Ah, null, Ap);
                An = Math.max(An, Ag.width);
                Aj = Math.max(Aj, Ag.height)
            }
            Ai.labelWidth = Af.labelWidth || An;
            Ai.labelHeight = Af.labelHeight || Aj
        }

        function g(Ah) {
            var Ag = Ah.labelWidth,
                Ao = Ah.labelHeight,
                Am = Ah.options.position,
                Af = Ah.direction === "x",
                Ak = Ah.options.tickLength,
                Al = r.grid.axisMargin,
                An = r.grid.labelMargin,
                Aq = true,
                Aj = true,
                Ai = true,
                Ap = false;
            G.each(Af ? AW : AE, function(As, Ar) {
                if (Ar && (Ar.show || Ar.reserveSpace)) {
                    if (Ar === Ah) {
                        Ap = true
                    } else {
                        if (Ar.options.position === Am) {
                            if (Ap) {
                                Aj = false
                            } else {
                                Aq = false
                            }
                        }
                    }
                    if (!Ap) {
                        Ai = false
                    }
                }
            });
            if (Aj) {
                Al = 0
            }
            if (Ak == null) {
                Ak = Ai ? "full" : 5
            }
            if (!isNaN(+Ak)) {
                An += +Ak
            }
            if (Af) {
                Ao += An;
                if (Am == "bottom") {
                    p.bottom += Ao + Al;
                    Ah.box = {
                        top: AK.height - p.bottom,
                        height: Ao
                    }
                } else {
                    Ah.box = {
                        top: p.top + Al,
                        height: Ao
                    };
                    p.top += Ao + Al
                }
            } else {
                Ag += An;
                if (Am == "left") {
                    Ah.box = {
                        left: p.left + Al,
                        width: Ag
                    };
                    p.left += Ag + Al
                } else {
                    p.right += Ag + Al;
                    Ah.box = {
                        left: AK.width - p.right,
                        width: Ag
                    }
                }
            }
            Ah.position = Am;
            Ah.tickLength = Ak;
            Ah.box.padding = An;
            Ah.innermost = Aq
        }

        function AJ(Af) {
            if (Af.direction == "x") {
                Af.box.left = p.left - Af.labelWidth / 2;
                Af.box.width = AK.width - p.left - p.right + Af.labelWidth
            } else {
                Af.box.top = p.top - Af.labelHeight / 2;
                Af.box.height = AK.height - p.bottom - p.top + Af.labelHeight
            }
        }

        function d() {
            var Ah = r.grid.minBorderMargin,
                Ag, Af;
            if (Ah == null) {
                Ah = 0;
                for (Af = 0; Af < V.length; ++Af) {
                    Ah = Math.max(Ah, 2 * (V[Af].points.radius + V[Af].points.lineWidth / 2))
                }
            }
            var Ai = {
                left: Ah,
                right: Ah,
                top: Ah,
                bottom: Ah
            };
            G.each(L(), function(Aj, Ak) {
                if (Ak.reserveSpace && Ak.ticks && Ak.ticks.length) {
                    if (Ak.direction === "x") {
                        Ai.left = Math.max(Ai.left, Ak.labelWidth / 2);
                        Ai.right = Math.max(Ai.right, Ak.labelWidth / 2)
                    } else {
                        Ai.bottom = Math.max(Ai.bottom, Ak.labelHeight / 2);
                        Ai.top = Math.max(Ai.top, Ak.labelHeight / 2)
                    }
                }
            });
            p.left = Math.ceil(Math.max(Ai.left, p.left));
            p.right = Math.ceil(Math.max(Ai.right, p.right));
            p.top = Math.ceil(Math.max(Ai.top, p.top));
            p.bottom = Math.ceil(Math.max(Ai.bottom, p.bottom))
        }

        function v() {
            var Ah, Aj = L(),
                Ak = r.grid.show;
            for (var Ag in p) {
                var Ai = r.grid.margin || 0;
                p[Ag] = typeof Ai == "number" ? Ai : Ai[Ag] || 0
            }
            j(R.processOffset, [p]);
            for (var Ag in p) {
                if (typeof(r.grid.borderWidth) == "object") {
                    p[Ag] += Ak ? r.grid.borderWidth[Ag] : 0
                } else {
                    p[Ag] += Ak ? r.grid.borderWidth : 0
                }
            }
            G.each(Aj, function(Am, An) {
                var Al = An.options;
                An.show = Al.show == null ? An.used : Al.show;
                An.reserveSpace = Al.reserveSpace == null ? An.show : Al.reserveSpace;
                O(An)
            });
            if (Ak) {
                var Af = G.grep(Aj, function(Al) {
                    return Al.show || Al.reserveSpace
                });
                G.each(Af, function(Al, Am) {
                    AY(Am);
                    AD(Am);
                    W(Am, Am.ticks);
                    AH(Am)
                });
                for (Ah = Af.length - 1; Ah >= 0; --Ah) {
                    g(Af[Ah])
                }
                d();
                G.each(Af, function(Al, Am) {
                    AJ(Am)
                })
            }
            M = AK.width - p.left - p.right;
            AL = AK.height - p.bottom - p.top;
            G.each(Aj, function(Al, Am) {
                P(Am)
            });
            if (Ak) {
                Aa()
            }
            Ac()
        }

        function O(Ai) {
            var Aj = Ai.options,
                Ah = +(Aj.min != null ? Aj.min : Ai.datamin),
                Af = +(Aj.max != null ? Aj.max : Ai.datamax),
                Al = Af - Ah;
            if (Al == 0) {
                var Ag = Af == 0 ? 1 : 0.01;
                if (Aj.min == null) {
                    Ah -= Ag
                }
                if (Aj.max == null || Aj.min != null) {
                    Af += Ag
                }
            } else {
                var Ak = Aj.autoscaleMargin;
                if (Ak != null) {
                    if (Aj.min == null) {
                        Ah -= Al * Ak;
                        if (Ah < 0 && Ai.datamin != null && Ai.datamin >= 0) {
                            Ah = 0
                        }
                    }
                    if (Aj.max == null) {
                        Af += Al * Ak;
                        if (Af > 0 && Ai.datamax != null && Ai.datamax <= 0) {
                            Af = 0
                        }
                    }
                }
            }
            Ai.min = Ah;
            Ai.max = Af
        }

        function AY(Ak) {
            var Ag = Ak.options;
            var Aj;
            if (typeof Ag.ticks == "number" && Ag.ticks > 0) {
                Aj = Ag.ticks
            } else {
                Aj = 0.3 * Math.sqrt(Ak.direction == "x" ? AK.width : AK.height)
            }
            var Ap = (Ak.max - Ak.min) / Aj,
                Al = -Math.floor(Math.log(Ap) / Math.LN10),
                Ai = Ag.tickDecimals;
            if (Ai != null && Al > Ai) {
                Al = Ai
            }
            var Af = Math.pow(10, -Al),
                Ah = Ap / Af,
                Ar;
            if (Ah < 1.5) {
                Ar = 1
            } else {
                if (Ah < 3) {
                    Ar = 2;
                    if (Ah > 2.25 && (Ai == null || Al + 1 <= Ai)) {
                        Ar = 2.5;
                        ++Al
                    }
                } else {
                    if (Ah < 7.5) {
                        Ar = 5
                    } else {
                        Ar = 10
                    }
                }
            }
            Ar *= Af;
            if (Ag.minTickSize != null && Ar < Ag.minTickSize) {
                Ar = Ag.minTickSize
            }
            Ak.delta = Ap;
            Ak.tickDecimals = Math.max(0, Ai != null ? Ai : Al);
            Ak.tickSize = Ag.tickSize || Ar;
            if (Ag.mode == "time" && !Ak.tickGenerator) {
                throw new Error("Time mode requires the flot.time plugin.")
            }
            if (!Ak.tickGenerator) {
                Ak.tickGenerator = function(Au) {
                    var Aw = [],
                        Ax = D(Au.min, Au.tickSize),
                        At = 0,
                        As = Number.NaN,
                        Av;
                    do {
                        Av = As;
                        As = (Ax + At * Au.tickSize).toFixed(10);
                        Aw.push(As);
                        ++At
                    } while (As < Au.max && As != Av);
                    return Aw
                };
                Ak.tickFormatter = function(Ax, Av) {
                    var Au = Av.tickDecimals ? Math.pow(10, Av.tickDecimals) : 1;
                    var Aw = "" + Math.round(Ax * Au) / Au;
                    if (Av.tickDecimals != null) {
                        var At = Aw.indexOf(".");
                        var As = At == -1 ? 0 : Aw.length - At - 1;
                        if (As < Av.tickDecimals) {
                            return (As ? Aw : Aw + ".") + ("" + Au).substr(1, Av.tickDecimals - As)
                        }
                    }
                    return Aw
                }
            }
            if (G.isFunction(Ag.tickFormatter)) {
                Ak.tickFormatter = function(As, At) {
                    return "" + Ag.tickFormatter(As, At)
                }
            }
            if (Ag.alignTicksWithAxis != null) {
                var Am = (Ak.direction == "x" ? AW : AE)[Ag.alignTicksWithAxis - 1];
                if (Am && Am.used && Am != Ak) {
                    var Aq = Ak.tickGenerator(Ak);
                    if (Aq.length > 0) {
                        if (Ag.min == null) {
                            Ak.min = Math.min(Ak.min, Aq[0])
                        }
                        if (Ag.max == null && Aq.length > 1) {
                            Ak.max = Math.max(Ak.max, Aq[Aq.length - 1])
                        }
                    }
                    Ak.tickGenerator = function(Au) {
                        var Av = [],
                            As, At;
                        for (At = 0; At < Am.ticks.length; ++At) {
                            As = (Am.ticks[At].v - Am.min) / (Am.max - Am.min);
                            As = Au.min + As * (Au.max - Au.min);
                            Av.push(As)
                        }
                        return Av
                    };
                    if (!Ak.mode && Ag.tickDecimals == null) {
                        var Ao = Math.max(0, -Math.floor(Math.log(Ak.delta) / Math.LN10) + 1),
                            An = Ak.tickGenerator(Ak);
                        if (!(An.length > 1 && /\..*0$/.test((An[1] - An[0]).toFixed(Ao)))) {
                            Ak.tickDecimals = Ao
                        }
                    }
                }
            }
        }

        function AD(Aj) {
            var Al = Aj.options.ticks,
                Ak = [];
            if (Al == null || (typeof Al == "number" && Al > 0)) {
                Ak = Aj.tickGenerator(Aj)
            } else {
                if (Al) {
                    if (G.isFunction(Al)) {
                        Ak = Al(Aj)
                    } else {
                        Ak = Al
                    }
                }
            }
            var Ai, Af;
            Aj.ticks = [];
            for (Ai = 0; Ai < Ak.length; ++Ai) {
                var Ag = null;
                var Ah = Ak[Ai];
                if (typeof Ah == "object") {
                    Af = +Ah[0];
                    if (Ah.length > 1) {
                        Ag = Ah[1]
                    }
                } else {
                    Af = +Ah
                }
                if (Ag == null) {
                    Ag = Aj.tickFormatter(Af, Aj)
                }
                if (!isNaN(Af)) {
                    Aj.ticks.push({
                        v: Af,
                        label: Ag
                    })
                }
            }
        }

        function W(Af, Ag) {
            if (Af.options.autoscaleMargin && Ag.length > 0) {
                if (Af.options.min == null) {
                    Af.min = Math.min(Af.min, Ag[0].v)
                }
                if (Af.options.max == null && Ag.length > 1) {
                    Af.max = Math.max(Af.max, Ag[Ag.length - 1].v)
                }
            }
        }

        function Ab() {
            AK.clear();
            j(R.drawBackground, [f]);
            var Ag = r.grid;
            if (Ag.show && Ag.backgroundColor) {
                T()
            }
            if (Ag.show && !Ag.aboveData) {
                Y()
            }
            for (var Af = 0; Af < V.length; ++Af) {
                j(R.drawSeries, [f, V[Af]]);
                AR(V[Af])
            }
            j(R.draw, [f]);
            if (Ag.show && Ag.aboveData) {
                Y()
            }
            AK.render();
            AF()
        }

        function U(Af, Aj) {
            var Ag, Al, Am, An, Ak = L();
            for (var Ai = 0; Ai < Ak.length; ++Ai) {
                Ag = Ak[Ai];
                if (Ag.direction == Aj) {
                    An = Aj + Ag.n + "axis";
                    if (!Af[An] && Ag.n == 1) {
                        An = Aj + "axis"
                    }
                    if (Af[An]) {
                        Al = Af[An].from;
                        Am = Af[An].to;
                        break
                    }
                }
            }
            if (!Af[An]) {
                Ag = Aj == "x" ? AW[0] : AE[0];
                Al = Af[Aj + "1"];
                Am = Af[Aj + "2"]
            }
            if (Al != null && Am != null && Al > Am) {
                var Ah = Al;
                Al = Am;
                Am = Ah
            }
            return {
                from: Al,
                to: Am,
                axis: Ag
            }
        }

        function T() {
            f.save();
            f.translate(p.left, p.top);
            f.fillStyle = X(r.grid.backgroundColor, AL, 0, "rgba(255, 255, 255, 0)");
            f.fillRect(0, 0, M, AL);
            f.restore()
        }

        function Y() {
            var Av, Au, Ay, Ah;
            f.save();
            f.translate(p.left, p.top);
            var Ai = r.grid.markings;
            if (Ai) {
                if (G.isFunction(Ai)) {
                    Au = J.getAxes();
                    Au.xmin = Au.xaxis.min;
                    Au.xmax = Au.xaxis.max;
                    Au.ymin = Au.yaxis.min;
                    Au.ymax = Au.yaxis.max;
                    Ai = Ai(Au)
                }
                for (Av = 0; Av < Ai.length; ++Av) {
                    var As = Ai[Av],
                        Aj = U(As, "x"),
                        An = U(As, "y");
                    if (Aj.from == null) {
                        Aj.from = Aj.axis.min
                    }
                    if (Aj.to == null) {
                        Aj.to = Aj.axis.max
                    }
                    if (An.from == null) {
                        An.from = An.axis.min
                    }
                    if (An.to == null) {
                        An.to = An.axis.max
                    }
                    if (Aj.to < Aj.axis.min || Aj.from > Aj.axis.max || An.to < An.axis.min || An.from > An.axis.max) {
                        continue
                    }
                    Aj.from = Math.max(Aj.from, Aj.axis.min);
                    Aj.to = Math.min(Aj.to, Aj.axis.max);
                    An.from = Math.max(An.from, An.axis.min);
                    An.to = Math.min(An.to, An.axis.max);
                    var Ak = Aj.from === Aj.to,
                        Aq = An.from === An.to;
                    if (Ak && Aq) {
                        continue
                    }
                    Aj.from = Math.floor(Aj.axis.p2c(Aj.from));
                    Aj.to = Math.floor(Aj.axis.p2c(Aj.to));
                    An.from = Math.floor(An.axis.p2c(An.from));
                    An.to = Math.floor(An.axis.p2c(An.to));
                    if (Ak || Aq) {
                        var Af = As.lineWidth || r.grid.markingsLineWidth,
                            Aw = Af % 2 ? 0.5 : 0;
                        f.beginPath();
                        f.strokeStyle = As.color || r.grid.markingsColor;
                        f.lineWidth = Af;
                        if (Ak) {
                            f.moveTo(Aj.to + Aw, An.from);
                            f.lineTo(Aj.to + Aw, An.to)
                        } else {
                            f.moveTo(Aj.from, An.to + Aw);
                            f.lineTo(Aj.to, An.to + Aw)
                        }
                        f.stroke()
                    } else {
                        f.fillStyle = As.color || r.grid.markingsColor;
                        f.fillRect(Aj.from, An.to, Aj.to - Aj.from, An.from - An.to)
                    }
                }
            }
            Au = L();
            Ay = r.grid.borderWidth;
            for (var At = 0; At < Au.length; ++At) {
                var Ag = Au[At],
                    Ao = Ag.box,
                    Ar = Ag.tickLength,
                    Am, Al, Ax, Az;
                if (!Ag.show || Ag.ticks.length == 0) {
                    continue
                }
                f.lineWidth = 1;
                if (Ag.direction == "x") {
                    Am = 0;
                    if (Ar == "full") {
                        Al = (Ag.position == "top" ? 0 : AL)
                    } else {
                        Al = Ao.top - p.top + (Ag.position == "top" ? Ao.height : 0)
                    }
                } else {
                    Al = 0;
                    if (Ar == "full") {
                        Am = (Ag.position == "left" ? 0 : M)
                    } else {
                        Am = Ao.left - p.left + (Ag.position == "left" ? Ao.width : 0)
                    }
                }
                if (!Ag.innermost) {
                    f.strokeStyle = Ag.options.color;
                    f.beginPath();
                    Ax = Az = 0;
                    if (Ag.direction == "x") {
                        Ax = M + 1
                    } else {
                        Az = AL + 1
                    }
                    if (f.lineWidth == 1) {
                        if (Ag.direction == "x") {
                            Al = Math.floor(Al) + 0.5
                        } else {
                            Am = Math.floor(Am) + 0.5
                        }
                    }
                    f.moveTo(Am, Al);
                    f.lineTo(Am + Ax, Al + Az);
                    f.stroke()
                }
                f.strokeStyle = Ag.options.tickColor;
                f.beginPath();
                for (Av = 0; Av < Ag.ticks.length; ++Av) {
                    var Ap = Ag.ticks[Av].v;
                    Ax = Az = 0;
                    if (isNaN(Ap) || Ap < Ag.min || Ap > Ag.max || (Ar == "full" && ((typeof Ay == "object" && Ay[Ag.position] > 0) || Ay > 0) && (Ap == Ag.min || Ap == Ag.max))) {
                        continue
                    }
                    if (Ag.direction == "x") {
                        Am = Ag.p2c(Ap);
                        Az = Ar == "full" ? -AL : Ar;
                        if (Ag.position == "top") {
                            Az = -Az
                        }
                    } else {
                        Al = Ag.p2c(Ap);
                        Ax = Ar == "full" ? -M : Ar;
                        if (Ag.position == "left") {
                            Ax = -Ax
                        }
                    }
                    if (f.lineWidth == 1) {
                        if (Ag.direction == "x") {
                            Am = Math.floor(Am) + 0.5
                        } else {
                            Al = Math.floor(Al) + 0.5
                        }
                    }
                    f.moveTo(Am, Al);
                    f.lineTo(Am + Ax, Al + Az)
                }
                f.stroke()
            }
            if (Ay) {
                Ah = r.grid.borderColor;
                if (typeof Ay == "object" || typeof Ah == "object") {
                    if (typeof Ay !== "object") {
                        Ay = {
                            top: Ay,
                            right: Ay,
                            bottom: Ay,
                            left: Ay
                        }
                    }
                    if (typeof Ah !== "object") {
                        Ah = {
                            top: Ah,
                            right: Ah,
                            bottom: Ah,
                            left: Ah
                        }
                    }
                    if (Ay.top > 0) {
                        f.strokeStyle = Ah.top;
                        f.lineWidth = Ay.top;
                        f.beginPath();
                        f.moveTo(0 - Ay.left, 0 - Ay.top / 2);
                        f.lineTo(M, 0 - Ay.top / 2);
                        f.stroke()
                    }
                    if (Ay.right > 0) {
                        f.strokeStyle = Ah.right;
                        f.lineWidth = Ay.right;
                        f.beginPath();
                        f.moveTo(M + Ay.right / 2, 0 - Ay.top);
                        f.lineTo(M + Ay.right / 2, AL);
                        f.stroke()
                    }
                    if (Ay.bottom > 0) {
                        f.strokeStyle = Ah.bottom;
                        f.lineWidth = Ay.bottom;
                        f.beginPath();
                        f.moveTo(M + Ay.right, AL + Ay.bottom / 2);
                        f.lineTo(0, AL + Ay.bottom / 2);
                        f.stroke()
                    }
                    if (Ay.left > 0) {
                        f.strokeStyle = Ah.left;
                        f.lineWidth = Ay.left;
                        f.beginPath();
                        f.moveTo(0 - Ay.left / 2, AL + Ay.bottom);
                        f.lineTo(0 - Ay.left / 2, 0);
                        f.stroke()
                    }
                } else {
                    f.lineWidth = Ay;
                    f.strokeStyle = r.grid.borderColor;
                    f.strokeRect(-Ay / 2, -Ay / 2, M + Ay, AL + Ay)
                }
            }
            f.restore()
        }

        function Aa() {
            G.each(L(), function(Aq, Ag) {
                var Aj = Ag.box,
                    Ai = Ag.direction + "Axis " + Ag.direction + Ag.n + "Axis",
                    Am = "flot-" + Ag.direction + "-axis flot-" + Ag.direction + Ag.n + "-axis " + Ai,
                    Af = Ag.options.font || "flot-tick-label tickLabel",
                    Ak, Ap, An, Al, Ao;
                AK.removeText(Am);
                if (!Ag.show || Ag.ticks.length == 0) {
                    return
                }
                for (var Ah = 0; Ah < Ag.ticks.length; ++Ah) {
                    Ak = Ag.ticks[Ah];
                    if (!Ak.label || Ak.v < Ag.min || Ak.v > Ag.max) {
                        continue
                    }
                    if (Ag.direction == "x") {
                        Al = "center";
                        Ap = p.left + Ag.p2c(Ak.v);
                        if (Ag.position == "bottom") {
                            An = Aj.top + Aj.padding
                        } else {
                            An = Aj.top + Aj.height - Aj.padding;
                            Ao = "bottom"
                        }
                    } else {
                        Ao = "middle";
                        An = p.top + Ag.p2c(Ak.v);
                        if (Ag.position == "left") {
                            Ap = Aj.left + Aj.width - Aj.padding;
                            Al = "right"
                        } else {
                            Ap = Aj.left + Aj.padding
                        }
                    }
                    AK.addText(Am, Ap, An, Ak.label, Af, null, null, Al, Ao)
                }
            })
        }

        function AR(Af) {
            if (Af.lines.show) {
                k(Af)
            }
            if (Af.bars.show) {
                AB(Af)
            }
            if (Af.points.show) {
                AC(Af)
            }
        }

        function k(Ai) {
            function Ah(At, Au, Am, Ay, Ax) {
                var Az = At.points,
                    An = At.pointsize,
                    Ar = null,
                    Aq = null;
                f.beginPath();
                for (var As = An; As < Az.length; As += An) {
                    var Ap = Az[As - An],
                        Aw = Az[As - An + 1],
                        Ao = Az[As],
                        Av = Az[As + 1];
                    if (Ap == null || Ao == null) {
                        continue
                    }
                    if (Aw <= Av && Aw < Ax.min) {
                        if (Av < Ax.min) {
                            continue
                        }
                        Ap = (Ax.min - Aw) / (Av - Aw) * (Ao - Ap) + Ap;
                        Aw = Ax.min
                    } else {
                        if (Av <= Aw && Av < Ax.min) {
                            if (Aw < Ax.min) {
                                continue
                            }
                            Ao = (Ax.min - Aw) / (Av - Aw) * (Ao - Ap) + Ap;
                            Av = Ax.min
                        }
                    }
                    if (Aw >= Av && Aw > Ax.max) {
                        if (Av > Ax.max) {
                            continue
                        }
                        Ap = (Ax.max - Aw) / (Av - Aw) * (Ao - Ap) + Ap;
                        Aw = Ax.max
                    } else {
                        if (Av >= Aw && Av > Ax.max) {
                            if (Aw > Ax.max) {
                                continue
                            }
                            Ao = (Ax.max - Aw) / (Av - Aw) * (Ao - Ap) + Ap;
                            Av = Ax.max
                        }
                    }
                    if (Ap <= Ao && Ap < Ay.min) {
                        if (Ao < Ay.min) {
                            continue
                        }
                        Aw = (Ay.min - Ap) / (Ao - Ap) * (Av - Aw) + Aw;
                        Ap = Ay.min
                    } else {
                        if (Ao <= Ap && Ao < Ay.min) {
                            if (Ap < Ay.min) {
                                continue
                            }
                            Av = (Ay.min - Ap) / (Ao - Ap) * (Av - Aw) + Aw;
                            Ao = Ay.min
                        }
                    }
                    if (Ap >= Ao && Ap > Ay.max) {
                        if (Ao > Ay.max) {
                            continue
                        }
                        Aw = (Ay.max - Ap) / (Ao - Ap) * (Av - Aw) + Aw;
                        Ap = Ay.max
                    } else {
                        if (Ao >= Ap && Ao > Ay.max) {
                            if (Ap > Ay.max) {
                                continue
                            }
                            Av = (Ay.max - Ap) / (Ao - Ap) * (Av - Aw) + Aw;
                            Ao = Ay.max
                        }
                    }
                    if (Ap != Ar || Aw != Aq) {
                        f.moveTo(Ay.p2c(Ap) + Au, Ax.p2c(Aw) + Am)
                    }
                    Ar = Ao;
                    Aq = Av;
                    f.lineTo(Ay.p2c(Ao) + Au, Ax.p2c(Av) + Am)
                }
                f.stroke()
            }

            function Aj(Am, Au, At) {
                var A0 = Am.points,
                    Az = Am.pointsize,
                    Ar = Math.min(Math.max(0, At.min), At.max),
                    A1 = 0,
                    Ay, Ax = false,
                    Aq = 1,
                    Ap = 0,
                    Av = 0;
                while (true) {
                    if (Az > 0 && A1 > A0.length + Az) {
                        break
                    }
                    A1 += Az;
                    var A3 = A0[A1 - Az],
                        Ao = A0[A1 - Az + Aq],
                        A2 = A0[A1],
                        An = A0[A1 + Aq];
                    if (Ax) {
                        if (Az > 0 && A3 != null && A2 == null) {
                            Av = A1;
                            Az = -Az;
                            Aq = 2;
                            continue
                        }
                        if (Az < 0 && A1 == Ap + Az) {
                            f.fill();
                            Ax = false;
                            Az = -Az;
                            Aq = 1;
                            A1 = Ap = Av + Az;
                            continue
                        }
                    }
                    if (A3 == null || A2 == null) {
                        continue
                    }
                    if (A3 <= A2 && A3 < Au.min) {
                        if (A2 < Au.min) {
                            continue
                        }
                        Ao = (Au.min - A3) / (A2 - A3) * (An - Ao) + Ao;
                        A3 = Au.min
                    } else {
                        if (A2 <= A3 && A2 < Au.min) {
                            if (A3 < Au.min) {
                                continue
                            }
                            An = (Au.min - A3) / (A2 - A3) * (An - Ao) + Ao;
                            A2 = Au.min
                        }
                    }
                    if (A3 >= A2 && A3 > Au.max) {
                        if (A2 > Au.max) {
                            continue
                        }
                        Ao = (Au.max - A3) / (A2 - A3) * (An - Ao) + Ao;
                        A3 = Au.max
                    } else {
                        if (A2 >= A3 && A2 > Au.max) {
                            if (A3 > Au.max) {
                                continue
                            }
                            An = (Au.max - A3) / (A2 - A3) * (An - Ao) + Ao;
                            A2 = Au.max
                        }
                    }
                    if (!Ax) {
                        f.beginPath();
                        f.moveTo(Au.p2c(A3), At.p2c(Ar));
                        Ax = true
                    }
                    if (Ao >= At.max && An >= At.max) {
                        f.lineTo(Au.p2c(A3), At.p2c(At.max));
                        f.lineTo(Au.p2c(A2), At.p2c(At.max));
                        continue
                    } else {
                        if (Ao <= At.min && An <= At.min) {
                            f.lineTo(Au.p2c(A3), At.p2c(At.min));
                            f.lineTo(Au.p2c(A2), At.p2c(At.min));
                            continue
                        }
                    }
                    var As = A3,
                        Aw = A2;
                    if (Ao <= An && Ao < At.min && An >= At.min) {
                        A3 = (At.min - Ao) / (An - Ao) * (A2 - A3) + A3;
                        Ao = At.min
                    } else {
                        if (An <= Ao && An < At.min && Ao >= At.min) {
                            A2 = (At.min - Ao) / (An - Ao) * (A2 - A3) + A3;
                            An = At.min
                        }
                    }
                    if (Ao >= An && Ao > At.max && An <= At.max) {
                        A3 = (At.max - Ao) / (An - Ao) * (A2 - A3) + A3;
                        Ao = At.max
                    } else {
                        if (An >= Ao && An > At.max && Ao <= At.max) {
                            A2 = (At.max - Ao) / (An - Ao) * (A2 - A3) + A3;
                            An = At.max
                        }
                    }
                    if (A3 != As) {
                        f.lineTo(Au.p2c(As), At.p2c(Ao))
                    }
                    f.lineTo(Au.p2c(A3), At.p2c(Ao));
                    f.lineTo(Au.p2c(A2), At.p2c(An));
                    if (A2 != Aw) {
                        f.lineTo(Au.p2c(A2), At.p2c(An));
                        f.lineTo(Au.p2c(Aw), At.p2c(An))
                    }
                }
            }
            f.save();
            f.translate(p.left, p.top);
            f.lineJoin = "round";
            var Ak = Ai.lines.lineWidth,
                Af = Ai.shadowSize;
            if (Ak > 0 && Af > 0) {
                f.lineWidth = Af;
                f.strokeStyle = "rgba(0,0,0,0.1)";
                var Al = Math.PI / 18;
                Ah(Ai.datapoints, Math.sin(Al) * (Ak / 2 + Af / 2), Math.cos(Al) * (Ak / 2 + Af / 2), Ai.xaxis, Ai.yaxis);
                f.lineWidth = Af / 2;
                Ah(Ai.datapoints, Math.sin(Al) * (Ak / 2 + Af / 4), Math.cos(Al) * (Ak / 2 + Af / 4), Ai.xaxis, Ai.yaxis)
            }
            f.lineWidth = Ak;
            f.strokeStyle = Ai.color;
            var Ag = b(Ai.lines, Ai.color, 0, AL);
            if (Ag) {
                f.fillStyle = Ag;
                Aj(Ai.datapoints, Ai.xaxis, Ai.yaxis)
            }
            if (Ak > 0) {
                Ah(Ai.datapoints, 0, 0, Ai.xaxis, Ai.yaxis)
            }
            f.restore()
        }

        function AC(Ai) {
            function Al(Ar, Aq, Ay, Ao, Aw, Ax, Au, An) {
                var Av = Ar.points,
                    Am = Ar.pointsize;
                for (var Ap = 0; Ap < Av.length; Ap += Am) {
                    var At = Av[Ap],
                        As = Av[Ap + 1];
                    if (At == null || At < Ax.min || At > Ax.max || As < Au.min || As > Au.max) {
                        continue
                    }
                    f.beginPath();
                    At = Ax.p2c(At);
                    As = Au.p2c(As) + Ao;
                    if (An == "circle") {
                        f.arc(At, As, Aq, 0, Aw ? Math.PI : Math.PI * 2, false)
                    } else {
                        An(f, At, As, Aq, Aw)
                    }
                    f.closePath();
                    if (Ay) {
                        f.fillStyle = Ay;
                        f.fill()
                    }
                    f.stroke()
                }
            }
            f.save();
            f.translate(p.left, p.top);
            var Ak = Ai.points.lineWidth,
                Ag = Ai.shadowSize,
                Af = Ai.points.radius,
                Aj = Ai.points.symbol;
            if (Ak == 0) {
                Ak = 0.0001
            }
            if (Ak > 0 && Ag > 0) {
                var Ah = Ag / 2;
                f.lineWidth = Ah;
                f.strokeStyle = "rgba(0,0,0,0.1)";
                Al(Ai.datapoints, Af, null, Ah + Ah / 2, true, Ai.xaxis, Ai.yaxis, Aj);
                f.strokeStyle = "rgba(0,0,0,0.2)";
                Al(Ai.datapoints, Af, null, Ah / 2, true, Ai.xaxis, Ai.yaxis, Aj)
            }
            f.lineWidth = Ak;
            f.strokeStyle = Ai.color;
            Al(Ai.datapoints, Af, b(Ai.points, Ai.color), 0, false, Ai.xaxis, Ai.yaxis, Aj);
            f.restore()
        }

        function AS(Aq, Ap, Ay, Al, At, Ah, Ao, An, Ax, Au, Ag) {
            var Ai, Aw, Am, As, Aj, Af, Ar, Ak, Av;
            if (Au) {
                Ak = Af = Ar = true;
                Aj = false;
                Ai = Ay;
                Aw = Aq;
                As = Ap + Al;
                Am = Ap + At;
                if (Aw < Ai) {
                    Av = Aw;
                    Aw = Ai;
                    Ai = Av;
                    Aj = true;
                    Af = false
                }
            } else {
                Aj = Af = Ar = true;
                Ak = false;
                Ai = Aq + Al;
                Aw = Aq + At;
                Am = Ay;
                As = Ap;
                if (As < Am) {
                    Av = As;
                    As = Am;
                    Am = Av;
                    Ak = true;
                    Ar = false
                }
            }
            if (Aw < Ao.min || Ai > Ao.max || As < An.min || Am > An.max) {
                return
            }
            if (Ai < Ao.min) {
                Ai = Ao.min;
                Aj = false
            }
            if (Aw > Ao.max) {
                Aw = Ao.max;
                Af = false
            }
            if (Am < An.min) {
                Am = An.min;
                Ak = false
            }
            if (As > An.max) {
                As = An.max;
                Ar = false
            }
            Ai = Ao.p2c(Ai);
            Am = An.p2c(Am);
            Aw = Ao.p2c(Aw);
            As = An.p2c(As);
            if (Ah) {
                Ax.fillStyle = Ah(Am, As);
                Ax.fillRect(Ai, As, Aw - Ai, Am - As)
            }
            if (Ag > 0 && (Aj || Af || Ar || Ak)) {
                Ax.beginPath();
                Ax.moveTo(Ai, Am);
                if (Aj) {
                    Ax.lineTo(Ai, As)
                } else {
                    Ax.moveTo(Ai, As)
                }
                if (Ar) {
                    Ax.lineTo(Aw, As)
                } else {
                    Ax.moveTo(Aw, As)
                }
                if (Af) {
                    Ax.lineTo(Aw, Am)
                } else {
                    Ax.moveTo(Aw, Am)
                }
                if (Ak) {
                    Ax.lineTo(Ai, Am)
                } else {
                    Ax.moveTo(Ai, Am)
                }
                Ax.stroke()
            }
        }

        function AB(Ah) {
            function Ag(Am, Al, Ao, An, Aq, Ap) {
                var Ar = Am.points,
                    Aj = Am.pointsize;
                for (var Ak = 0; Ak < Ar.length; Ak += Aj) {
                    if (Ar[Ak] == null) {
                        continue
                    }
                    AS(Ar[Ak], Ar[Ak + 1], Ar[Ak + 2], Al, Ao, An, Aq, Ap, f, Ah.bars.horizontal, Ah.bars.lineWidth)
                }
            }
            f.save();
            f.translate(p.left, p.top);
            f.lineWidth = Ah.bars.lineWidth;
            f.strokeStyle = Ah.color;
            var Af;
            switch (Ah.bars.align) {
                case "left":
                    Af = 0;
                    break;
                case "right":
                    Af = -Ah.bars.barWidth;
                    break;
                default:
                    Af = -Ah.bars.barWidth / 2
            }
            var Ai = Ah.bars.fill ? function(Aj, Ak) {
                return b(Ah.bars, Ah.color, Aj, Ak)
            } : null;
            Ag(Ah.datapoints, Af, Af + Ah.bars.barWidth, Ai, Ah.xaxis, Ah.yaxis);
            f.restore()
        }

        function b(Ah, Af, Ag, Aj) {
            var Ai = Ah.fill;
            if (!Ai) {
                return null
            }
            if (Ah.fillColor) {
                return X(Ah.fillColor, Ag, Aj, Af)
            }
            var Ak = G.color.parse(Af);
            Ak.a = typeof Ai == "number" ? Ai : 0.4;
            Ak.normalize();
            return Ak.toString()
        }

        function Ac() {
            if (r.legend.container != null) {
                G(r.legend.container).html("")
            } else {
                x.find(".legend").remove()
            }
            if (!r.legend.show) {
                return
            }
            var An = [],
                Ak = [],
                Al = false,
                Au = r.legend.labelFormatter,
                At, Ap;
            for (var Aj = 0; Aj < V.length; ++Aj) {
                At = V[Aj];
                if (At.label) {
                    Ap = Au ? Au(At.label, At) : At.label;
                    if (Ap) {
                        Ak.push({
                            label: Ap,
                            color: At.color
                        })
                    }
                }
            }
            if (r.legend.sorted) {
                if (G.isFunction(r.legend.sorted)) {
                    Ak.sort(r.legend.sorted)
                } else {
                    if (r.legend.sorted == "reverse") {
                        Ak.reverse()
                    } else {
                        var Ai = r.legend.sorted != "descending";
                        Ak.sort(function(Aw, Av) {
                            return Aw.label == Av.label ? 0 : ((Aw.label < Av.label) != Ai ? 1 : -1)
                        })
                    }
                }
            }
            for (var Aj = 0; Aj < Ak.length; ++Aj) {
                var Ar = Ak[Aj];
                if (Aj % r.legend.noColumns == 0) {
                    if (Al) {
                        An.push("</tr>")
                    }
                    An.push("<tr>");
                    Al = true
                }
                An.push('<td class="legendColorBox"><div style="border:1px solid ' + r.legend.labelBoxBorderColor + ';padding:1px"><div style="width:4px;height:0;border:5px solid ' + Ar.color + ';overflow:hidden"></div></div></td><td class="legendLabel">' + Ar.label + "</td></div>")
            }
            if (Al) {
                An.push("</tr>")
            }
            if (An.length == 0) {
                return
            }
            var As = '<table style="font-size:smaller;color:' + r.grid.color + '">' + An.join("") + "</table>";
            if (r.legend.container != null) {
                G(r.legend.container).html(As)
            } else {
                var Ao = "",
                    Ag = r.legend.position,
                    Ah = r.legend.margin;
                if (Ah[0] == null) {
                    Ah = [Ah, Ah]
                }
                if (Ag.charAt(0) == "n") {
                    Ao += "top:" + (Ah[1] + p.top) + "px;"
                } else {
                    if (Ag.charAt(0) == "s") {
                        Ao += "bottom:" + (Ah[1] + p.bottom) + "px;"
                    }
                }
                if (Ag.charAt(1) == "e") {
                    Ao += "right:" + (Ah[0] + p.right) + "px;"
                } else {
                    if (Ag.charAt(1) == "w") {
                        Ao += "left:" + (Ah[0] + p.left) + "px;"
                    }
                }
                var Aq = G('<div class="legend">' + As.replace('style="', 'style="position:absolute;' + Ao + ";") + "</div>").appendTo(x);
                if (r.legend.backgroundOpacity != 0) {
                    var Am = r.legend.backgroundColor;
                    if (Am == null) {
                        Am = r.grid.backgroundColor;
                        if (Am && typeof Am == "string") {
                            Am = G.color.parse(Am)
                        } else {
                            Am = G.color.extract(Aq, "background-color")
                        }
                        Am.a = 1;
                        Am = Am.toString()
                    }
                    var Af = Aq.children();
                    G('<div style="position:absolute;width:' + Af.width() + "px;height:" + Af.height() + "px;" + Ao + "background-color:" + Am + ';"> </div>').prependTo(Aq).css("opacity", r.legend.backgroundOpacity)
                }
            }
        }
        var AO = [],
            N = null;

        function AX(Am, Ak, Ah) {
            var As = r.grid.mouseActiveRadius,
                A5 = As * As + 1,
                A3 = null,
                Aw = false,
                A1, Az, Ay;
            for (A1 = V.length - 1; A1 >= 0; --A1) {
                if (!Ah(V[A1])) {
                    continue
                }
                var Au = V[A1],
                    Al = Au.xaxis,
                    Aj = Au.yaxis,
                    A0 = Au.datapoints.points,
                    Av = Al.c2p(Am),
                    Ar = Aj.c2p(Ak),
                    Ag = As / Al.scale,
                    Af = As / Aj.scale,
                    At = Au.unit ? Au.unit : null;
                Ay = Au.datapoints.pointsize;
                if (Al.options.inverseTransform) {
                    Ag = Number.MAX_VALUE
                }
                if (Aj.options.inverseTransform) {
                    Af = Number.MAX_VALUE
                }
                if (Au.lines.show || Au.points.show) {
                    for (Az = 0; Az < A0.length; Az += Ay) {
                        var Ao = A0[Az],
                            An = A0[Az + 1];
                        if (Ao == null) {
                            continue
                        }
                        if (Ao - Av > Ag || Ao - Av < -Ag || An - Ar > Af || An - Ar < -Af) {
                            continue
                        }
                        var Aq = Math.abs(Al.p2c(Ao) - Am),
                            Ap = Math.abs(Aj.p2c(An) - Ak),
                            Ax = Aq * Aq + Ap * Ap;
                        if (Ax < A5) {
                            A5 = Ax;
                            A3 = [A1, Az / Ay]
                        }
                    }
                }
                if (Au.bars.show && !A3) {
                    var Ai, A2;
                    switch (Au.bars.align) {
                        case "left":
                            Ai = 0;
                            break;
                        case "right":
                            Ai = -Au.bars.barWidth;
                            break;
                        default:
                            Ai = -Au.bars.barWidth / 2
                    }
                    A2 = Ai + Au.bars.barWidth;
                    for (Az = 0; Az < A0.length; Az += Ay) {
                        var Ao = A0[Az],
                            An = A0[Az + 1],
                            A4 = A0[Az + 2];
                        if (Ao == null) {
                            continue
                        }
                        if (V[A1].bars.horizontal ? (Av <= Math.max(A4, Ao) && Av >= Math.min(A4, Ao) && Ar >= An + Ai && Ar <= An + A2) : (Av >= Ao + Ai && Av <= Ao + A2 && Ar >= Math.min(A4, An) && Ar <= Math.max(A4, An))) {
                            A3 = [A1, Az / Ay]
                        }
                    }
                }
            }
            if (A3) {
                A1 = A3[0];
                Az = A3[1];
                Ay = V[A1].datapoints.pointsize;
                At = V[A1].unit;
                return {
                    datapoint: V[A1].datapoints.points.slice(Az * Ay, (Az + 1) * Ay),
                    dataIndex: Az,
                    series: V[A1],
                    unit: V[A1].unit,
                    seriesIndex: A1
                }
            }
            return null
        }

        function H(Af) {
            if (r.grid.hoverable) {
                K("plothover", Af, function(Ag) {
                    return Ag.hoverable != false
                })
            }
        }

        function w(Af) {
            if (r.grid.hoverable) {
                K("plothover", Af, function(Ag) {
                    return false
                })
            }
        }

        function o(Af) {
            K("plotclick", Af, function(Ag) {
                return Ag.clickable != false
            })
        }

        function K(Ag, Af, Ah) {
            var Ai = AU.offset(),
                Al = Af.pageX - Ai.left - p.left,
                Aj = Af.pageY - Ai.top - p.top,
                An = AG({
                    left: Al,
                    top: Aj
                });
            An.pageX = Af.pageX;
            An.pageY = Af.pageY;
            var Ao = AX(Al, Aj, Ah);
            if (Ao) {
                Ao.pageX = parseInt(Ao.series.xaxis.p2c(Ao.datapoint[0]) + Ai.left + p.left, 10);
                Ao.pageY = parseInt(Ao.series.yaxis.p2c(Ao.datapoint[1]) + Ai.top + p.top, 10)
            }
            if (r.grid.autoHighlight) {
                for (var Ak = 0; Ak < AO.length; ++Ak) {
                    var Am = AO[Ak];
                    if (Am.auto == Ag && !(Ao && Am.series == Ao.series && Am.point[0] == Ao.datapoint[0] && Am.point[1] == Ao.datapoint[1])) {
                        AP(Am.series, Am.point)
                    }
                }
                if (Ao) {
                    AV(Ao.series, Ao.datapoint, Ag)
                }
            }
            x.trigger(Ag, [An, Ao])
        }

        function AF() {
            var Af = r.interaction.redrawOverlayInterval;
            if (Af == -1) {
                AN();
                return
            }
            if (!N) {
                N = setTimeout(AN, Af)
            }
        }

        function AN() {
            N = null;
            Ad.save();
            AT.clear();
            Ad.translate(p.left, p.top);
            var Ag, Af;
            for (Ag = 0; Ag < AO.length; ++Ag) {
                Af = AO[Ag];
                if (Af.series.bars.show) {
                    AQ(Af.series, Af.point)
                } else {
                    AM(Af.series, Af.point)
                }
            }
            Ad.restore();
            j(R.drawOverlay, [Ad])
        }

        function AV(Ah, Af, Aj) {
            if (typeof Ah == "number") {
                Ah = V[Ah]
            }
            if (typeof Af == "number") {
                var Ai = Ah.datapoints.pointsize;
                Af = Ah.datapoints.points.slice(Ai * Af, Ai * (Af + 1))
            }
            var Ag = u(Ah, Af);
            if (Ag == -1) {
                AO.push({
                    series: Ah,
                    point: Af,
                    auto: Aj
                });
                AF()
            } else {
                if (!Aj) {
                    AO[Ag].auto = false
                }
            }
        }

        function AP(Ah, Af) {
            if (Ah == null && Af == null) {
                AO = [];
                AF();
                return
            }
            if (typeof Ah == "number") {
                Ah = V[Ah]
            }
            if (typeof Af == "number") {
                var Ai = Ah.datapoints.pointsize;
                Af = Ah.datapoints.points.slice(Ai * Af, Ai * (Af + 1))
            }
            var Ag = u(Ah, Af);
            if (Ag != -1) {
                AO.splice(Ag, 1);
                AF()
            }
        }

        function u(Ah, Ai) {
            for (var Af = 0; Af < AO.length; ++Af) {
                var Ag = AO[Af];
                if (Ag.series == Ah && Ag.point[0] == Ai[0] && Ag.point[1] == Ai[1]) {
                    return Af
                }
            }
            return -1
        }

        function AM(Af, Al) {
            var Aj = Al[0],
                Ah = Al[1],
                Am = Af.xaxis,
                Ak = Af.yaxis,
                An = (typeof Af.highlightColor === "string") ? Af.highlightColor : G.color.parse(Af.color).scale("a", 0.5).toString();
            if (Aj < Am.min || Aj > Am.max || Ah < Ak.min || Ah > Ak.max) {
                return
            }
            var Ai = Af.points.radius + Af.points.lineWidth / 2;
            Ad.lineWidth = Ai;
            Ad.strokeStyle = An;
            var Ag = 1.5 * Ai;
            Aj = Am.p2c(Aj);
            Ah = Ak.p2c(Ah);
            Ad.beginPath();
            if (Af.points.symbol == "circle") {
                Ad.arc(Aj, Ah, Ag, 0, 2 * Math.PI, false)
            } else {
                Af.points.symbol(Ad, Aj, Ah, Ag, false)
            }
            Ad.closePath();
            Ad.stroke()
        }

        function AQ(Ai, Af) {
            var Aj = (typeof Ai.highlightColor === "string") ? Ai.highlightColor : G.color.parse(Ai.color).scale("a", 0.5).toString(),
                Ah = Aj,
                Ag;
            switch (Ai.bars.align) {
                case "left":
                    Ag = 0;
                    break;
                case "right":
                    Ag = -Ai.bars.barWidth;
                    break;
                default:
                    Ag = -Ai.bars.barWidth / 2
            }
            Ad.lineWidth = Ai.bars.lineWidth;
            Ad.strokeStyle = Aj;
            AS(Af[0], Af[1], Af[2] || 0, Ag, Ag + Ai.bars.barWidth, function() {
                return Ah
            }, Ai.xaxis, Ai.yaxis, Ad, Ai.bars.horizontal, Ai.bars.lineWidth)
        }

        function X(An, Af, Al, Ag) {
            if (typeof An == "string") {
                return An
            } else {
                var Am = f.createLinearGradient(0, Al, 0, Af);
                for (var Ai = 0, Ah = An.colors.length; Ai < Ah; ++Ai) {
                    var Aj = An.colors[Ai];
                    if (typeof Aj != "string") {
                        var Ak = G.color.parse(Ag);
                        if (Aj.brightness != null) {
                            Ak = Ak.scale("rgb", Aj.brightness)
                        }
                        if (Aj.opacity != null) {
                            Ak.a *= Aj.opacity
                        }
                        Aj = Ak.toString()
                    }
                    Am.addColorStop(Ai / (Ah - 1), Aj)
                }
                return Am
            }
        }
    }
    G.plot = function(K, I, H) {
        var J = new E(G(K), I, H, G.plot.plugins);
        return J
    };
    G.plot.version = "0.8.3";
    G.plot.plugins = [];
    G.fn.plot = function(I, H) {
        return this.each(function() {
            G.plot(this, I, H)
        })
    };

    function D(I, H) {
        return H * Math.floor(I / H)
    }
})(jQuery);
(function(F) {
    var M = {
        axisLabels: {
            show: true
        }
    };

    function G() {
        return !!document.createElement("canvas").getContext
    }

    function H() {
        if (!G()) {
            return false
        }
        var O = document.createElement("canvas");
        var N = O.getContext("2d");
        return typeof N.fillText == "function"
    }

    function K() {
        var N = document.createElement("div");
        return typeof N.style.MozTransition != "undefined" || typeof N.style.OTransition != "undefined" || typeof N.style.webkitTransition != "undefined" || typeof N.style.transition != "undefined"
    }

    function E(R, N, Q, P, O) {
        this.axisName = R;
        this.position = N;
        this.padding = Q;
        this.plot = P;
        this.opts = O;
        this.width = 0;
        this.height = 0
    }
    E.prototype.cleanup = function() {};
    D.prototype = new E();
    D.prototype.constructor = D;

    function D(R, N, Q, P, O) {
        E.prototype.constructor.call(this, R, N, Q, P, O)
    }
    D.prototype.calculateSize = function() {
        if (!this.opts.axisLabelFontSizePixels) {
            this.opts.axisLabelFontSizePixels = 14
        }
        if (!this.opts.axisLabelFontFamily) {
            this.opts.axisLabelFontFamily = "sans-serif"
        }
        var O = this.opts.axisLabelFontSizePixels + this.padding;
        var N = this.opts.axisLabelFontSizePixels + this.padding;
        if (this.position == "left" || this.position == "right") {
            this.width = this.opts.axisLabelFontSizePixels + this.padding;
            this.height = 0
        } else {
            this.width = 0;
            this.height = this.opts.axisLabelFontSizePixels + this.padding
        }
    };
    D.prototype.draw = function(R) {
        if (!this.opts.axisLabelColour) {
            this.opts.axisLabelColour = "black"
        }
        var P = this.plot.getCanvas().getContext("2d");
        P.save();
        P.font = this.opts.axisLabelFontSizePixels + "px " + this.opts.axisLabelFontFamily;
        P.fillStyle = this.opts.axisLabelColour;
        var Q = P.measureText(this.opts.axisLabel).width;
        var O = this.opts.axisLabelFontSizePixels;
        var N, T, S = 0;
        if (this.position == "top") {
            N = R.left + R.width / 2 - Q / 2;
            T = R.top + O * 0.72
        } else {
            if (this.position == "bottom") {
                N = R.left + R.width / 2 - Q / 2;
                T = R.top + R.height - O * 0.72
            } else {
                if (this.position == "left") {
                    N = R.left + O * 0.72;
                    T = R.height / 2 + R.top + Q / 2;
                    S = -Math.PI / 2
                } else {
                    if (this.position == "right") {
                        N = R.left + R.width - O * 0.72;
                        T = R.height / 2 + R.top - Q / 2;
                        S = Math.PI / 2
                    }
                }
            }
        }
        P.translate(N, T);
        P.rotate(S);
        P.fillText(this.opts.axisLabel, 0, 0);
        P.restore()
    };
    J.prototype = new E();
    J.prototype.constructor = J;

    function J(R, N, Q, P, O) {
        E.prototype.constructor.call(this, R, N, Q, P, O);
        this.elem = null
    }
    J.prototype.calculateSize = function() {
        var N = F('<div class="axisLabels" style="position:absolute;">' + this.opts.axisLabel + "</div>");
        this.plot.getPlaceholder().append(N);
        this.labelWidth = N.outerWidth(true);
        this.labelHeight = N.outerHeight(true);
        N.remove();
        this.width = this.height = 0;
        if (this.position == "left" || this.position == "right") {
            this.width = this.labelWidth + this.padding
        } else {
            this.height = this.labelHeight + this.padding
        }
    };
    J.prototype.cleanup = function() {
        if (this.elem) {
            this.elem.remove()
        }
    };
    J.prototype.draw = function(N) {
        this.plot.getPlaceholder().find("#" + this.axisName + "Label").remove();
        this.elem = F('<div id="' + this.axisName + 'Label" " class="axisLabels" style="position:absolute;">' + this.opts.axisLabel + "</div>");
        this.plot.getPlaceholder().append(this.elem);
        if (this.position == "top") {
            this.elem.css("left", N.left + N.width / 2 - this.labelWidth / 2 + "px");
            this.elem.css("top", N.top + "px")
        } else {
            if (this.position == "bottom") {
                this.elem.css("left", N.left + N.width / 2 - this.labelWidth / 2 + "px");
                this.elem.css("top", N.top + N.height - this.labelHeight + "px")
            } else {
                if (this.position == "left") {
                    this.elem.css("top", N.top + N.height / 2 - this.labelHeight / 2 + "px");
                    this.elem.css("left", N.left + "px")
                } else {
                    if (this.position == "right") {
                        this.elem.css("top", N.top + N.height / 2 - this.labelHeight / 2 + "px");
                        this.elem.css("left", N.left + N.width - this.labelWidth + "px")
                    }
                }
            }
        }
    };
    I.prototype = new J();
    I.prototype.constructor = I;

    function I(R, N, Q, P, O) {
        J.prototype.constructor.call(this, R, N, Q, P, O)
    }
    I.prototype.calculateSize = function() {
        J.prototype.calculateSize.call(this);
        this.width = this.height = 0;
        if (this.position == "left" || this.position == "right") {
            this.width = this.labelHeight + this.padding
        } else {
            this.height = this.labelHeight + this.padding
        }
    };
    I.prototype.transforms = function(P, T, S) {
        var Q = {
            "-moz-transform": "",
            "-webkit-transform": "",
            "-o-transform": "",
            "-ms-transform": ""
        };
        if (T != 0 || S != 0) {
            var N = " translate(" + T + "px, " + S + "px)";
            Q["-moz-transform"] += N;
            Q["-webkit-transform"] += N;
            Q["-o-transform"] += N;
            Q["-ms-transform"] += N
        }
        if (P != 0) {
            var U = P / 90;
            var R = " rotate(" + P + "deg)";
            Q["-moz-transform"] += R;
            Q["-webkit-transform"] += R;
            Q["-o-transform"] += R;
            Q["-ms-transform"] += R
        }
        var V = "top: 0; left: 0; ";
        for (var O in Q) {
            if (Q[O]) {
                V += O + ":" + Q[O] + ";"
            }
        }
        V += ";";
        return V
    };
    I.prototype.calculateOffsets = function(O) {
        var N = {
            x: 0,
            y: 0,
            degrees: 0
        };
        if (this.position == "bottom") {
            N.x = O.left + O.width / 2 - this.labelWidth / 2;
            N.y = O.top + O.height - this.labelHeight
        } else {
            if (this.position == "top") {
                N.x = O.left + O.width / 2 - this.labelWidth / 2;
                N.y = O.top
            } else {
                if (this.position == "left") {
                    N.degrees = -90;
                    N.x = O.left - this.labelWidth / 2 + this.labelHeight / 2;
                    N.y = O.height / 2 + O.top
                } else {
                    if (this.position == "right") {
                        N.degrees = 90;
                        N.x = O.left + O.width - this.labelWidth / 2 - this.labelHeight / 2;
                        N.y = O.height / 2 + O.top
                    }
                }
            }
        }
        N.x = Math.round(N.x);
        N.y = Math.round(N.y);
        return N
    };
    I.prototype.draw = function(O) {
        this.plot.getPlaceholder().find("." + this.axisName + "Label").remove();
        var N = this.calculateOffsets(O);
        this.elem = F('<div class="axisLabels ' + this.axisName + 'Label" style="position:absolute; ' + this.transforms(N.degrees, N.x, N.y) + '">' + this.opts.axisLabel + "</div>");
        this.plot.getPlaceholder().append(this.elem)
    };
    C.prototype = new I();
    C.prototype.constructor = C;

    function C(R, N, Q, P, O) {
        I.prototype.constructor.call(this, R, N, Q, P, O);
        this.requiresResize = false
    }
    C.prototype.transforms = function(Q, N, R) {
        var P = "";
        if (Q != 0) {
            var O = Q / 90;
            while (O < 0) {
                O += 4
            }
            P += " filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=" + O + "); ";
            this.requiresResize = (this.position == "right")
        }
        if (N != 0) {
            P += "left: " + N + "px; "
        }
        if (R != 0) {
            P += "top: " + R + "px; "
        }
        return P
    };
    C.prototype.calculateOffsets = function(O) {
        var N = I.prototype.calculateOffsets.call(this, O);
        if (this.position == "top") {
            N.y = O.top + 1
        } else {
            if (this.position == "left") {
                N.x = O.left;
                N.y = O.height / 2 + O.top - this.labelWidth / 2
            } else {
                if (this.position == "right") {
                    N.x = O.left + O.width - this.labelHeight;
                    N.y = O.height / 2 + O.top - this.labelWidth / 2
                }
            }
        }
        return N
    };
    C.prototype.draw = function(N) {
        I.prototype.draw.call(this, N);
        if (this.requiresResize) {
            this.elem = this.plot.getPlaceholder().find("." + this.axisName + "Label");
            this.elem.css("width", this.labelWidth);
            this.elem.css("height", this.labelHeight)
        }
    };

    function L(N) {
        N.hooks.processOptions.push(function(S, O) {
            if (!O.axisLabels.show) {
                return
            }
            var Q = false;
            var P = {};
            var T = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };
            var R = 2;
            S.hooks.draw.push(function(V, U) {
                var W = false;
                if (!Q) {
                    F.each(V.getAxes(), function(d, Z) {
                        var a = Z.options || V.getOptions()[d];
                        if (d in P) {
                            Z.labelHeight = Z.labelHeight - P[d].height;
                            Z.labelWidth = Z.labelWidth - P[d].width;
                            a.labelHeight = Z.labelHeight;
                            a.labelWidth = Z.labelWidth;
                            P[d].cleanup();
                            delete P[d]
                        }
                        if (!a || !a.axisLabel || !Z.show) {
                            return
                        }
                        W = true;
                        var b = null;
                        if (!a.axisLabelUseHtml && navigator.appName == "Microsoft Internet Explorer") {
                            var X = navigator.userAgent;
                            var Y = new RegExp("MSIE ([0-9]{1,}[.0-9]{0,})");
                            if (Y.exec(X) != null) {
                                rv = parseFloat(RegExp.$1)
                            }
                            if (rv >= 9 && !a.axisLabelUseCanvas && !a.axisLabelUseHtml) {
                                b = I
                            } else {
                                if (!a.axisLabelUseCanvas && !a.axisLabelUseHtml) {
                                    b = C
                                } else {
                                    if (a.axisLabelUseCanvas) {
                                        b = D
                                    } else {
                                        b = J
                                    }
                                }
                            }
                        } else {
                            if (a.axisLabelUseHtml || (!K() && !H()) && !a.axisLabelUseCanvas) {
                                b = J
                            } else {
                                if (a.axisLabelUseCanvas || !K()) {
                                    b = D
                                } else {
                                    b = I
                                }
                            }
                        }
                        var c = a.axisLabelPadding === undefined ? R : a.axisLabelPadding;
                        P[d] = new b(d, Z.position, c, V, a);
                        P[d].calculateSize();
                        a.labelHeight = Z.labelHeight + P[d].height;
                        a.labelWidth = Z.labelWidth + P[d].width
                    });
                    if (W) {
                        Q = true;
                        V.setupGrid();
                        V.draw()
                    }
                } else {
                    Q = false;
                    F.each(V.getAxes(), function(Z, X) {
                        var Y = X.options || V.getOptions()[Z];
                        if (!Y || !Y.axisLabel || !X.show) {
                            return
                        }
                        P[Z].draw(X.box)
                    })
                }
            })
        })
    }
    F.plot.plugins.push({
        init: L,
        options: M,
        name: "axisLabels",
        version: "2.0"
    })
})(jQuery);
(function(C) {
    var M = {
        xaxis: {
            timezone: null,
            timeformat: null,
            twelveHourClock: false,
            monthNames: null
        }
    };

    function I(O, N) {
        return N * Math.floor(O / N)
    }

    function L(U, P, S, O) {
        if (typeof U.strftime == "function") {
            return U.strftime(P)
        }
        var X = function(a, Z) {
            a = "" + a;
            Z = "" + (Z == null ? "0" : Z);
            return a.length == 1 ? Z + a : a
        };
        var N = [];
        var Y = false;
        var W = U.getHours();
        var T = W < 12;
        if (S == null) {
            S = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
        }
        if (O == null) {
            O = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
        }
        var Q;
        if (W > 12) {
            Q = W - 12
        } else {
            if (W == 0) {
                Q = 12
            } else {
                Q = W
            }
        }
        for (var R = 0; R < P.length; ++R) {
            var V = P.charAt(R);
            if (Y) {
                switch (V) {
                    case "a":
                        V = "" + O[U.getDay()];
                        break;
                    case "b":
                        V = "" + S[U.getMonth()];
                        break;
                    case "d":
                        V = X(U.getDate());
                        break;
                    case "e":
                        V = X(U.getDate(), " ");
                        break;
                    case "h":
                    case "H":
                        V = X(W);
                        break;
                    case "I":
                        V = X(Q);
                        break;
                    case "l":
                        V = X(Q, " ");
                        break;
                    case "m":
                        V = X(U.getMonth() + 1);
                        break;
                    case "M":
                        V = X(U.getMinutes());
                        break;
                    case "q":
                        V = "" + (Math.floor(U.getMonth() / 3) + 1);
                        break;
                    case "S":
                        V = X(U.getSeconds());
                        break;
                    case "y":
                        V = X(U.getFullYear() % 100);
                        break;
                    case "Y":
                        V = "" + U.getFullYear();
                        break;
                    case "p":
                        V = (T) ? ("am") : ("pm");
                        break;
                    case "P":
                        V = (T) ? ("AM") : ("PM");
                        break;
                    case "w":
                        V = "" + U.getDay();
                        break
                }
                N.push(V);
                Y = false
            } else {
                if (V == "%") {
                    Y = true
                } else {
                    N.push(V)
                }
            }
        }
        return N.join("")
    }

    function K(R) {
        function N(U, T, S, V) {
            U[T] = function() {
                return S[V].apply(S, arguments)
            }
        }
        var P = {
            date: R
        };
        if (R.strftime != undefined) {
            N(P, "strftime", R, "strftime")
        }
        N(P, "getTime", R, "getTime");
        N(P, "setTime", R, "setTime");
        var O = ["Date", "Day", "FullYear", "Hours", "Milliseconds", "Minutes", "Month", "Seconds"];
        for (var Q = 0; Q < O.length; Q++) {
            N(P, "get" + O[Q], R, "getUTC" + O[Q]);
            N(P, "set" + O[Q], R, "setUTC" + O[Q])
        }
        return P
    }

    function G(O, N) {
        if (N.timezone == "browser") {
            return new Date(O)
        } else {
            if (!N.timezone || N.timezone == "utc") {
                return K(new Date(O))
            } else {
                if (typeof timezoneJS != "undefined" && typeof timezoneJS.Date != "undefined") {
                    var P = new timezoneJS.Date();
                    P.setTimezone(N.timezone);
                    P.setTime(O);
                    return P
                } else {
                    return K(new Date(O))
                }
            }
        }
    }
    var E = {
        second: 1000,
        minute: 60 * 1000,
        hour: 60 * 60 * 1000,
        day: 24 * 60 * 60 * 1000,
        month: 30 * 24 * 60 * 60 * 1000,
        quarter: 3 * 30 * 24 * 60 * 60 * 1000,
        year: 365.2425 * 24 * 60 * 60 * 1000
    };
    var H = [
        [1, "second"],
        [2, "second"],
        [5, "second"],
        [10, "second"],
        [30, "second"],
        [1, "minute"],
        [2, "minute"],
        [5, "minute"],
        [10, "minute"],
        [30, "minute"],
        [1, "hour"],
        [2, "hour"],
        [4, "hour"],
        [8, "hour"],
        [12, "hour"],
        [1, "day"],
        [2, "day"],
        [3, "day"],
        [0.25, "month"],
        [0.5, "month"],
        [1, "month"],
        [2, "month"]
    ];
    var D = H.concat([
        [3, "month"],
        [6, "month"],
        [1, "year"]
    ]);
    var F = H.concat([
        [1, "quarter"],
        [2, "quarter"],
        [1, "year"]
    ]);

    function J(N) {
        N.hooks.processOptions.push(function(P, O) {
            C.each(P.getAxes(), function(S, Q) {
                var R = Q.options;
                if (R.mode == "time") {
                    Q.tickGenerator = function(Y) {
                        var f = [];
                        var e = G(Y.min, R);
                        var W = 0;
                        var k = (R.tickSize && R.tickSize[1] === "quarter") || (R.minTickSize && R.minTickSize[1] === "quarter") ? F : D;
                        if (R.minTickSize != null) {
                            if (typeof R.tickSize == "number") {
                                W = R.tickSize
                            } else {
                                W = R.minTickSize[0] * E[R.minTickSize[1]]
                            }
                        }
                        for (var c = 0; c < k.length - 1; ++c) {
                            if (Y.delta < (k[c][0] * E[k[c][1]] + k[c + 1][0] * E[k[c + 1][1]]) / 2 && k[c][0] * E[k[c][1]] >= W) {
                                break
                            }
                        }
                        var o = k[c][0];
                        var g = k[c][1];
                        if (g == "year") {
                            if (R.minTickSize != null && R.minTickSize[1] == "year") {
                                o = Math.floor(R.minTickSize[0])
                            } else {
                                var U = Math.pow(10, Math.floor(Math.log(Y.delta / E.year) / Math.LN10));
                                var T = (Y.delta / E.year) / U;
                                if (T < 1.5) {
                                    o = 1
                                } else {
                                    if (T < 3) {
                                        o = 2
                                    } else {
                                        if (T < 7.5) {
                                            o = 5
                                        } else {
                                            o = 10
                                        }
                                    }
                                }
                                o *= U
                            }
                            if (o < 1) {
                                o = 1
                            }
                        }
                        Y.tickSize = R.tickSize || [o, g];
                        var b = Y.tickSize[0];
                        g = Y.tickSize[1];
                        var X = b * E[g];
                        if (g == "second") {
                            e.setSeconds(I(e.getSeconds(), b))
                        } else {
                            if (g == "minute") {
                                e.setMinutes(I(e.getMinutes(), b))
                            } else {
                                if (g == "hour") {
                                    e.setHours(I(e.getHours(), b))
                                } else {
                                    if (g == "month") {
                                        e.setMonth(I(e.getMonth(), b))
                                    } else {
                                        if (g == "quarter") {
                                            e.setMonth(3 * I(e.getMonth() / 3, b))
                                        } else {
                                            if (g == "year") {
                                                e.setFullYear(I(e.getFullYear(), b))
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        e.setMilliseconds(0);
                        if (X >= E.minute) {
                            e.setSeconds(0)
                        }
                        if (X >= E.hour) {
                            e.setMinutes(0)
                        }
                        if (X >= E.day) {
                            e.setHours(0)
                        }
                        if (X >= E.day * 4) {
                            e.setDate(1)
                        }
                        if (X >= E.month * 2) {
                            e.setMonth(I(e.getMonth(), 3))
                        }
                        if (X >= E.quarter * 2) {
                            e.setMonth(I(e.getMonth(), 6))
                        }
                        if (X >= E.year) {
                            e.setMonth(0)
                        }
                        var m = 0;
                        var j = Number.NaN;
                        var Z;
                        do {
                            Z = j;
                            j = e.getTime();
                            f.push(j);
                            if (g == "month" || g == "quarter") {
                                if (b < 1) {
                                    e.setDate(1);
                                    var V = e.getTime();
                                    e.setMonth(e.getMonth() + (g == "quarter" ? 3 : 1));
                                    var a = e.getTime();
                                    e.setTime(j + m * E.hour + (a - V) * b);
                                    m = e.getHours();
                                    e.setHours(0)
                                } else {
                                    e.setMonth(e.getMonth() + b * (g == "quarter" ? 3 : 1))
                                }
                            } else {
                                if (g == "year") {
                                    e.setFullYear(e.getFullYear() + b)
                                } else {
                                    e.setTime(j + X)
                                }
                            }
                        } while (j < Y.max && j != Z);
                        return f
                    };
                    Q.tickFormatter = function(Y, U) {
                        var W = G(Y, U.options);
                        if (R.timeformat != null) {
                            return L(W, R.timeformat, R.monthNames, R.dayNames)
                        }
                        var c = (U.options.tickSize && U.options.tickSize[1] == "quarter") || (U.options.minTickSize && U.options.minTickSize[1] == "quarter");
                        var b = U.tickSize[0] * E[U.tickSize[1]];
                        var X = U.max - U.min;
                        var a = (R.twelveHourClock) ? " %p" : "";
                        var Z = (R.twelveHourClock) ? "%I" : "%H";
                        var T;
                        if (b < E.minute) {
                            T = Z + ":%M:%S" + a
                        } else {
                            if (b < E.day) {
                                if (X < 2 * E.day) {
                                    T = Z + ":%M" + a
                                } else {
                                    T = "%b %d " + Z + ":%M" + a
                                }
                            } else {
                                if (b < E.month) {
                                    T = "%b %d"
                                } else {
                                    if ((c && b < E.quarter) || (!c && b < E.year)) {
                                        if (X < E.year) {
                                            T = "%b"
                                        } else {
                                            T = "%b %Y"
                                        }
                                    } else {
                                        if (c && b < E.year) {
                                            if (X < E.year) {
                                                T = "Q%q"
                                            } else {
                                                T = "Q%q %Y"
                                            }
                                        } else {
                                            T = "%Y"
                                        }
                                    }
                                }
                            }
                        }
                        var V = L(W, T, R.monthNames, R.dayNames);
                        return V
                    }
                }
            })
        })
    }
    C.plot.plugins.push({
        init: J,
        options: M,
        name: "time",
        version: "1.0"
    });
    C.plot.formatDate = L;
    C.plot.dateGenerator = G
})(jQuery);
if (!document.createElement("canvas").getContext) {
    (function() {
        var Ac = Math;
        var AR = Ac.round;
        var AS = Ac.sin;
        var AH = Ac.cos;
        var At = Ac.abs;
        var An = Ac.sqrt;
        var AY = 10;
        var AW = AY / 2;

        function AI() {
            return this.context_ || (this.context_ = new p(this))
        }
        var AN = Array.prototype.slice;

        function AV(E, D, C) {
            var F = AN.call(arguments, 2);
            return function() {
                return E.apply(D, F.concat(AN.call(arguments)))
            }
        }

        function j(C) {
            return String(C).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
        }

        function Aj(C) {
            if (!C.namespaces.g_vml_) {
                C.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML")
            }
            if (!C.namespaces.g_o_) {
                C.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML")
            }
            if (!C.styleSheets.ex_canvas_) {
                var D = C.createStyleSheet();
                D.owningElement.id = "ex_canvas_";
                D.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}"
            }
        }
        Aj(document);
        var AX = {
            init: function(D) {
                if (/MSIE/.test(navigator.userAgent) && !window.opera) {
                    var C = D || document;
                    C.createElement("canvas");
                    C.attachEvent("onreadystatechange", AV(this.init_, this, C))
                }
            },
            init_: function(C) {
                var D = C.getElementsByTagName("canvas");
                for (var E = 0; E < D.length; E++) {
                    this.initElement(D[E])
                }
            },
            initElement: function(C) {
                if (!C.getContext) {
                    C.getContext = AI;
                    Aj(C.ownerDocument);
                    C.innerHTML = "";
                    C.attachEvent("onpropertychange", AJ);
                    C.attachEvent("onresize", Af);
                    var D = C.attributes;
                    if (D.width && D.width.specified) {
                        C.style.width = D.width.nodeValue + "px"
                    } else {
                        C.width = C.clientWidth
                    }
                    if (D.height && D.height.specified) {
                        C.style.height = D.height.nodeValue + "px"
                    } else {
                        C.height = C.clientHeight
                    }
                }
                return C
            }
        };

        function AJ(C) {
            var D = C.srcElement;
            switch (C.propertyName) {
                case "width":
                    D.getContext().clearRect();
                    D.style.width = D.attributes.width.nodeValue + "px";
                    D.firstChild.style.width = D.clientWidth + "px";
                    break;
                case "height":
                    D.getContext().clearRect();
                    D.style.height = D.attributes.height.nodeValue + "px";
                    D.firstChild.style.height = D.clientHeight + "px";
                    break
            }
        }

        function Af(C) {
            var D = C.srcElement;
            if (D.firstChild) {
                D.firstChild.style.width = D.clientWidth + "px";
                D.firstChild.style.height = D.clientHeight + "px"
            }
        }
        AX.init();
        var AT = [];
        for (var AD = 0; AD < 16; AD++) {
            for (var AE = 0; AE < 16; AE++) {
                AT[AD * 16 + AE] = AD.toString(16) + AE.toString(16)
            }
        }

        function AF() {
            return [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ]
        }

        function Ar(C, D) {
            var F = AF();
            for (var I = 0; I < 3; I++) {
                for (var E = 0; E < 3; E++) {
                    var H = 0;
                    for (var G = 0; G < 3; G++) {
                        H += C[I][G] * D[G][E]
                    }
                    F[I][E] = H
                }
            }
            return F
        }

        function AL(C, D) {
            D.fillStyle = C.fillStyle;
            D.lineCap = C.lineCap;
            D.lineJoin = C.lineJoin;
            D.lineWidth = C.lineWidth;
            D.miterLimit = C.miterLimit;
            D.shadowBlur = C.shadowBlur;
            D.shadowColor = C.shadowColor;
            D.shadowOffsetX = C.shadowOffsetX;
            D.shadowOffsetY = C.shadowOffsetY;
            D.strokeStyle = C.strokeStyle;
            D.globalAlpha = C.globalAlpha;
            D.font = C.font;
            D.textAlign = C.textAlign;
            D.textBaseline = C.textBaseline;
            D.arcScaleX_ = C.arcScaleX_;
            D.arcScaleY_ = C.arcScaleY_;
            D.lineScale_ = C.lineScale_
        }
        var Aa = {
            aliceblue: "#F0F8FF",
            antiquewhite: "#FAEBD7",
            aquamarine: "#7FFFD4",
            azure: "#F0FFFF",
            beige: "#F5F5DC",
            bisque: "#FFE4C4",
            black: "#000000",
            blanchedalmond: "#FFEBCD",
            blueviolet: "#8A2BE2",
            brown: "#A52A2A",
            burlywood: "#DEB887",
            cadetblue: "#5F9EA0",
            chartreuse: "#7FFF00",
            chocolate: "#D2691E",
            coral: "#FF7F50",
            cornflowerblue: "#6495ED",
            cornsilk: "#FFF8DC",
            crimson: "#DC143C",
            cyan: "#00FFFF",
            darkblue: "#00008B",
            darkcyan: "#008B8B",
            darkgoldenrod: "#B8860B",
            darkgray: "#A9A9A9",
            darkgreen: "#006400",
            darkgrey: "#A9A9A9",
            darkkhaki: "#BDB76B",
            darkmagenta: "#8B008B",
            darkolivegreen: "#556B2F",
            darkorange: "#FF8C00",
            darkorchid: "#9932CC",
            darkred: "#8B0000",
            darksalmon: "#E9967A",
            darkseagreen: "#8FBC8F",
            darkslateblue: "#483D8B",
            darkslategray: "#2F4F4F",
            darkslategrey: "#2F4F4F",
            darkturquoise: "#00CED1",
            darkviolet: "#9400D3",
            deeppink: "#FF1493",
            deepskyblue: "#00BFFF",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1E90FF",
            firebrick: "#B22222",
            floralwhite: "#FFFAF0",
            forestgreen: "#228B22",
            gainsboro: "#DCDCDC",
            ghostwhite: "#F8F8FF",
            gold: "#FFD700",
            goldenrod: "#DAA520",
            grey: "#808080",
            greenyellow: "#ADFF2F",
            honeydew: "#F0FFF0",
            hotpink: "#FF69B4",
            indianred: "#CD5C5C",
            indigo: "#4B0082",
            ivory: "#FFFFF0",
            khaki: "#F0E68C",
            lavender: "#E6E6FA",
            lavenderblush: "#FFF0F5",
            lawngreen: "#7CFC00",
            lemonchiffon: "#FFFACD",
            lightblue: "#ADD8E6",
            lightcoral: "#F08080",
            lightcyan: "#E0FFFF",
            lightgoldenrodyellow: "#FAFAD2",
            lightgreen: "#90EE90",
            lightgrey: "#D3D3D3",
            lightpink: "#FFB6C1",
            lightsalmon: "#FFA07A",
            lightseagreen: "#20B2AA",
            lightskyblue: "#87CEFA",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#B0C4DE",
            lightyellow: "#FFFFE0",
            limegreen: "#32CD32",
            linen: "#FAF0E6",
            magenta: "#FF00FF",
            mediumaquamarine: "#66CDAA",
            mediumblue: "#0000CD",
            mediumorchid: "#BA55D3",
            mediumpurple: "#9370DB",
            mediumseagreen: "#3CB371",
            mediumslateblue: "#7B68EE",
            mediumspringgreen: "#00FA9A",
            mediumturquoise: "#48D1CC",
            mediumvioletred: "#C71585",
            midnightblue: "#191970",
            mintcream: "#F5FFFA",
            mistyrose: "#FFE4E1",
            moccasin: "#FFE4B5",
            navajowhite: "#FFDEAD",
            oldlace: "#FDF5E6",
            olivedrab: "#6B8E23",
            orange: "#FFA500",
            orangered: "#FF4500",
            orchid: "#DA70D6",
            palegoldenrod: "#EEE8AA",
            palegreen: "#98FB98",
            paleturquoise: "#AFEEEE",
            palevioletred: "#DB7093",
            papayawhip: "#FFEFD5",
            peachpuff: "#FFDAB9",
            peru: "#CD853F",
            pink: "#FFC0CB",
            plum: "#DDA0DD",
            powderblue: "#B0E0E6",
            rosybrown: "#BC8F8F",
            royalblue: "#4169E1",
            saddlebrown: "#8B4513",
            salmon: "#FA8072",
            sandybrown: "#F4A460",
            seagreen: "#2E8B57",
            seashell: "#FFF5EE",
            sienna: "#A0522D",
            skyblue: "#87CEEB",
            slateblue: "#6A5ACD",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#FFFAFA",
            springgreen: "#00FF7F",
            steelblue: "#4682B4",
            tan: "#D2B48C",
            thistle: "#D8BFD8",
            tomato: "#FF6347",
            turquoise: "#40E0D0",
            violet: "#EE82EE",
            wheat: "#F5DEB3",
            whitesmoke: "#F5F5F5",
            yellowgreen: "#9ACD32"
        };

        function Ao(E) {
            var C = E.indexOf("(", 3);
            var F = E.indexOf(")", C + 1);
            var D = E.substring(C + 1, F).split(",");
            if (D.length == 4 && E.substr(3, 1) == "a") {
                alpha = Number(D[3])
            } else {
                D[3] = 1
            }
            return D
        }

        function AZ(C) {
            return parseFloat(C) / 100
        }

        function AO(D, C, E) {
            return Math.min(E, Math.max(C, D))
        }

        function As(F) {
            var D, E, H;
            h = parseFloat(F[0]) / 360 % 360;
            if (h < 0) {
                h++
            }
            s = AO(AZ(F[1]), 0, 1);
            l = AO(AZ(F[2]), 0, 1);
            if (s == 0) {
                D = E = H = l
            } else {
                var C = l < 0.5 ? l * (1 + s) : l + s - l * s;
                var G = 2 * l - C;
                D = Ab(G, C, h + 1 / 3);
                E = Ab(G, C, h);
                H = Ab(G, C, h - 1 / 3)
            }
            return "#" + AT[Math.floor(D * 255)] + AT[Math.floor(E * 255)] + AT[Math.floor(H * 255)]
        }

        function Ab(D, E, C) {
            if (C < 0) {
                C++
            }
            if (C > 1) {
                C--
            }
            if (6 * C < 1) {
                return D + (E - D) * 6 * C
            } else {
                if (2 * C < 1) {
                    return E
                } else {
                    if (3 * C < 2) {
                        return D + (E - D) * (2 / 3 - C) * 6
                    } else {
                        return D
                    }
                }
            }
        }

        function Z(H) {
            var F, G = 1;
            H = String(H);
            if (H.charAt(0) == "#") {
                F = H
            } else {
                if (/^rgb/.test(H)) {
                    var C = Ao(H);
                    var F = "#",
                        E;
                    for (var D = 0; D < 3; D++) {
                        if (C[D].indexOf("%") != -1) {
                            E = Math.floor(AZ(C[D]) * 255)
                        } else {
                            E = Number(C[D])
                        }
                        F += AT[AO(E, 0, 255)]
                    }
                    G = C[3]
                } else {
                    if (/^hsl/.test(H)) {
                        var C = Ao(H);
                        F = As(C);
                        G = C[3]
                    } else {
                        F = Aa[H] || H
                    }
                }
            }
            return {
                color: F,
                alpha: G
            }
        }
        var AQ = {
            style: "normal",
            variant: "normal",
            weight: "normal",
            size: 10,
            family: "sans-serif"
        };
        var Ap = {};

        function m(F) {
            if (Ap[F]) {
                return Ap[F]
            }
            var C = document.createElement("div");
            var D = C.style;
            try {
                D.font = F
            } catch (E) {}
            return Ap[F] = {
                style: D.fontStyle || AQ.style,
                variant: D.fontVariant || AQ.variant,
                weight: D.fontWeight || AQ.weight,
                size: D.fontSize || AQ.size,
                family: D.fontFamily || AQ.family
            }
        }

        function AM(D, F) {
            var H = {};
            for (var E in D) {
                H[E] = D[E]
            }
            var G = parseFloat(F.currentStyle.fontSize),
                C = parseFloat(D.size);
            if (typeof D.size == "number") {
                H.size = D.size
            } else {
                if (D.size.indexOf("px") != -1) {
                    H.size = C
                } else {
                    if (D.size.indexOf("em") != -1) {
                        H.size = G * C
                    } else {
                        if (D.size.indexOf("%") != -1) {
                            H.size = (G / 100) * C
                        } else {
                            if (D.size.indexOf("pt") != -1) {
                                H.size = C / 0.75
                            } else {
                                H.size = G
                            }
                        }
                    }
                }
            }
            H.size *= 0.981;
            return H
        }

        function AG(C) {
            return C.style + " " + C.variant + " " + C.weight + " " + C.size + "px " + C.family
        }

        function Ai(C) {
            switch (C) {
                case "butt":
                    return "flat";
                case "round":
                    return "round";
                case "square":
                default:
                    return "square"
            }
        }

        function p(C) {
            this.m_ = AF();
            this.mStack_ = [];
            this.aStack_ = [];
            this.currentPath_ = [];
            this.strokeStyle = "#000";
            this.fillStyle = "#000";
            this.lineWidth = 1;
            this.lineJoin = "miter";
            this.lineCap = "butt";
            this.miterLimit = AY * 1;
            this.globalAlpha = 1;
            this.font = "10px sans-serif";
            this.textAlign = "left";
            this.textBaseline = "alphabetic";
            this.canvas = C;
            var D = C.ownerDocument.createElement("div");
            D.style.width = C.clientWidth + "px";
            D.style.height = C.clientHeight + "px";
            D.style.overflow = "hidden";
            D.style.position = "absolute";
            C.appendChild(D);
            this.element_ = D;
            this.arcScaleX_ = 1;
            this.arcScaleY_ = 1;
            this.lineScale_ = 1
        }
        var AP = p.prototype;
        AP.clearRect = function() {
            if (this.textMeasureEl_) {
                this.textMeasureEl_.removeNode(true);
                this.textMeasureEl_ = null
            }
            this.element_.innerHTML = ""
        };
        AP.beginPath = function() {
            this.currentPath_ = []
        };
        AP.moveTo = function(D, E) {
            var C = this.getCoords_(D, E);
            this.currentPath_.push({
                type: "moveTo",
                x: C.x,
                y: C.y
            });
            this.currentX_ = C.x;
            this.currentY_ = C.y
        };
        AP.lineTo = function(D, E) {
            var C = this.getCoords_(D, E);
            this.currentPath_.push({
                type: "lineTo",
                x: C.x,
                y: C.y
            });
            this.currentX_ = C.x;
            this.currentY_ = C.y
        };
        AP.bezierCurveTo = function(J, K, D, F, G, I) {
            var C = this.getCoords_(G, I);
            var H = this.getCoords_(J, K);
            var E = this.getCoords_(D, F);
            Aq(this, H, E, C)
        };

        function Aq(F, C, D, E) {
            F.currentPath_.push({
                type: "bezierCurveTo",
                cp1x: C.x,
                cp1y: C.y,
                cp2x: D.x,
                cp2y: D.y,
                x: E.x,
                y: E.y
            });
            F.currentX_ = E.x;
            F.currentY_ = E.y
        }
        AP.quadraticCurveTo = function(F, E, H, J) {
            var G = this.getCoords_(F, E);
            var I = this.getCoords_(H, J);
            var D = {
                x: this.currentX_ + 2 / 3 * (G.x - this.currentX_),
                y: this.currentY_ + 2 / 3 * (G.y - this.currentY_)
            };
            var C = {
                x: D.x + (I.x - this.currentX_) / 3,
                y: D.y + (I.y - this.currentY_) / 3
            };
            Aq(this, D, C, I)
        };
        AP.arc = function(G, J, H, M, O, N) {
            H *= AY;
            var P = N ? "at" : "wa";
            var F = G + AH(M) * H - AW;
            var C = J + AS(M) * H - AW;
            var E = G + AH(O) * H - AW;
            var D = J + AS(O) * H - AW;
            if (F == E && !N) {
                F += 0.125
            }
            var I = this.getCoords_(G, J);
            var K = this.getCoords_(F, C);
            var L = this.getCoords_(E, D);
            this.currentPath_.push({
                type: P,
                x: I.x,
                y: I.y,
                radius: H,
                xStart: K.x,
                yStart: K.y,
                xEnd: L.x,
                yEnd: L.y
            })
        };
        AP.rect = function(D, E, F, C) {
            this.moveTo(D, E);
            this.lineTo(D + F, E);
            this.lineTo(D + F, E + C);
            this.lineTo(D, E + C);
            this.closePath()
        };
        AP.strokeRect = function(D, E, G, C) {
            var F = this.currentPath_;
            this.beginPath();
            this.moveTo(D, E);
            this.lineTo(D + G, E);
            this.lineTo(D + G, E + C);
            this.lineTo(D, E + C);
            this.closePath();
            this.stroke();
            this.currentPath_ = F
        };
        AP.fillRect = function(D, E, G, C) {
            var F = this.currentPath_;
            this.beginPath();
            this.moveTo(D, E);
            this.lineTo(D + G, E);
            this.lineTo(D + G, E + C);
            this.lineTo(D, E + C);
            this.closePath();
            this.fill();
            this.currentPath_ = F
        };
        AP.createLinearGradient = function(E, C, G, D) {
            var F = new Ag("gradient");
            F.x0_ = E;
            F.y0_ = C;
            F.x1_ = G;
            F.y1_ = D;
            return F
        };
        AP.createRadialGradient = function(C, G, D, F, I, H) {
            var E = new Ag("gradientradial");
            E.x0_ = C;
            E.y0_ = G;
            E.r0_ = D;
            E.x1_ = F;
            E.y1_ = I;
            E.r1_ = H;
            return E
        };
        AP.drawImage = function(M, a) {
            var T, W, R, F, O, Q, K, D;
            var S = M.runtimeStyle.width;
            var N = M.runtimeStyle.height;
            M.runtimeStyle.width = "auto";
            M.runtimeStyle.height = "auto";
            var V = M.width;
            var H = M.height;
            M.runtimeStyle.width = S;
            M.runtimeStyle.height = N;
            if (arguments.length == 3) {
                T = arguments[1];
                W = arguments[2];
                O = Q = 0;
                K = R = V;
                D = F = H
            } else {
                if (arguments.length == 5) {
                    T = arguments[1];
                    W = arguments[2];
                    R = arguments[3];
                    F = arguments[4];
                    O = Q = 0;
                    K = V;
                    D = H
                } else {
                    if (arguments.length == 9) {
                        O = arguments[1];
                        Q = arguments[2];
                        K = arguments[3];
                        D = arguments[4];
                        T = arguments[5];
                        W = arguments[6];
                        R = arguments[7];
                        F = arguments[8]
                    } else {
                        throw Error("Invalid number of arguments")
                    }
                }
            }
            var E = this.getCoords_(T, W);
            var Y = K / 2;
            var b = D / 2;
            var G = [];
            var C = 10;
            var X = 10;
            G.push(" <g_vml_:group", ' coordsize="', AY * C, ",", AY * X, '"', ' coordorigin="0,0"', ' style="width:', C, "px;height:", X, "px;position:absolute;");
            if (this.m_[0][0] != 1 || this.m_[0][1] || this.m_[1][1] != 1 || this.m_[1][0]) {
                var U = [];
                U.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", AR(E.x / AY), ",", "Dy=", AR(E.y / AY), "");
                var I = E;
                var J = this.getCoords_(T + R, W);
                var L = this.getCoords_(T, W + F);
                var P = this.getCoords_(T + R, W + F);
                I.x = Ac.max(I.x, J.x, L.x, P.x);
                I.y = Ac.max(I.y, J.y, L.y, P.y);
                G.push("padding:0 ", AR(I.x / AY), "px ", AR(I.y / AY), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", U.join(""), ", sizingmethod='clip');")
            } else {
                G.push("top:", AR(E.y / AY), "px;left:", AR(E.x / AY), "px;")
            }
            G.push(' ">', '<g_vml_:image src="', M.src, '"', ' style="width:', AY * R, "px;", " height:", AY * F, 'px"', ' cropleft="', O / V, '"', ' croptop="', Q / H, '"', ' cropright="', (V - O - K) / V, '"', ' cropbottom="', (H - Q - D) / H, '"', " />", "</g_vml_:group>");
            this.element_.insertAdjacentHTML("BeforeEnd", G.join(""))
        };
        AP.stroke = function(C) {
            var J = 10;
            var O = 10;
            var M = 5000;
            var K = {
                x: null,
                y: null
            };
            var E = {
                x: null,
                y: null
            };
            for (var I = 0; I < this.currentPath_.length; I += M) {
                var F = [];
                var L = false;
                F.push("<g_vml_:shape", ' filled="', !!C, '"', ' style="position:absolute;width:', J, "px;height:", O, 'px;"', ' coordorigin="0,0"', ' coordsize="', AY * J, ",", AY * O, '"', ' stroked="', !C, '"', ' path="');
                var N = false;
                for (var H = I; H < Math.min(I + M, this.currentPath_.length); H++) {
                    if (H % M == 0 && H > 0) {
                        F.push(" m ", AR(this.currentPath_[H - 1].x), ",", AR(this.currentPath_[H - 1].y))
                    }
                    var D = this.currentPath_[H];
                    var G;
                    switch (D.type) {
                        case "moveTo":
                            G = D;
                            F.push(" m ", AR(D.x), ",", AR(D.y));
                            break;
                        case "lineTo":
                            F.push(" l ", AR(D.x), ",", AR(D.y));
                            break;
                        case "close":
                            F.push(" x ");
                            D = null;
                            break;
                        case "bezierCurveTo":
                            F.push(" c ", AR(D.cp1x), ",", AR(D.cp1y), ",", AR(D.cp2x), ",", AR(D.cp2y), ",", AR(D.x), ",", AR(D.y));
                            break;
                        case "at":
                        case "wa":
                            F.push(" ", D.type, " ", AR(D.x - this.arcScaleX_ * D.radius), ",", AR(D.y - this.arcScaleY_ * D.radius), " ", AR(D.x + this.arcScaleX_ * D.radius), ",", AR(D.y + this.arcScaleY_ * D.radius), " ", AR(D.xStart), ",", AR(D.yStart), " ", AR(D.xEnd), ",", AR(D.yEnd));
                            break
                    }
                    if (D) {
                        if (K.x == null || D.x < K.x) {
                            K.x = D.x
                        }
                        if (E.x == null || D.x > E.x) {
                            E.x = D.x
                        }
                        if (K.y == null || D.y < K.y) {
                            K.y = D.y
                        }
                        if (E.y == null || D.y > E.y) {
                            E.y = D.y
                        }
                    }
                }
                F.push(' ">');
                if (!C) {
                    AK(this, F)
                } else {
                    Au(this, F, K, E)
                }
                F.push("</g_vml_:shape>");
                this.element_.insertAdjacentHTML("beforeEnd", F.join(""))
            }
        };

        function AK(D, F) {
            var E = Z(D.strokeStyle);
            var C = E.color;
            var H = E.alpha * D.globalAlpha;
            var G = D.lineScale_ * D.lineWidth;
            if (G < 1) {
                H *= G
            }
            F.push("<g_vml_:stroke", ' opacity="', H, '"', ' joinstyle="', D.lineJoin, '"', ' miterlimit="', D.miterLimit, '"', ' endcap="', Ai(D.lineCap), '"', ' weight="', G, 'px"', ' color="', C, '" />')
        }

        function Au(o, F, L, k) {
            var E = o.fillStyle;
            var W = o.arcScaleX_;
            var X = o.arcScaleY_;
            var H = k.x - L.x;
            var V = k.y - L.y;
            if (E instanceof Ag) {
                var t = 0;
                var Q = {
                    x: 0,
                    y: 0
                };
                var c = 0;
                var u = 1;
                if (E.type_ == "gradient") {
                    var C = E.x0_ / W;
                    var a = E.y0_ / X;
                    var D = E.x1_ / W;
                    var J = E.y1_ / X;
                    var M = o.getCoords_(C, a);
                    var N = o.getCoords_(D, J);
                    var I = N.x - M.x;
                    var T = N.y - M.y;
                    t = Math.atan2(I, T) * 180 / Math.PI;
                    if (t < 0) {
                        t += 360
                    }
                    if (t < 0.000001) {
                        t = 0
                    }
                } else {
                    var M = o.getCoords_(E.x0_, E.y0_);
                    Q = {
                        x: (M.x - L.x) / H,
                        y: (M.y - L.y) / V
                    };
                    H /= W * AY;
                    V /= X * AY;
                    var S = Ac.max(H, V);
                    c = 2 * E.r0_ / S;
                    u = 2 * E.r1_ / S - c
                }
                var e = E.colors_;
                e.sort(function(v, w) {
                    return v.offset - w.offset
                });
                var q = e.length;
                var f = e[0].color;
                var g = e[q - 1].color;
                var Y = e[0].alpha * o.globalAlpha;
                var b = e[q - 1].alpha * o.globalAlpha;
                var R = [];
                for (var O = 0; O < q; O++) {
                    var r = e[O];
                    R.push(r.offset * u + c + " " + r.color)
                }
                F.push('<g_vml_:fill type="', E.type_, '"', ' method="none" focus="100%"', ' color="', f, '"', ' color2="', g, '"', ' colors="', R.join(","), '"', ' opacity="', b, '"', ' g_o_:opacity2="', Y, '"', ' angle="', t, '"', ' focusposition="', Q.x, ",", Q.y, '" />')
            } else {
                if (E instanceof Ah) {
                    if (H && V) {
                        var G = -L.x;
                        var U = -L.y;
                        F.push("<g_vml_:fill", ' position="', G / H * W * W, ",", U / V * X * X, '"', ' type="tile"', ' src="', E.src_, '" />')
                    }
                } else {
                    var K = Z(o.fillStyle);
                    var d = K.color;
                    var P = K.alpha * o.globalAlpha;
                    F.push('<g_vml_:fill color="', d, '" opacity="', P, '" />')
                }
            }
        }
        AP.fill = function() {
            this.stroke(true)
        };
        AP.closePath = function() {
            this.currentPath_.push({
                type: "close"
            })
        };
        AP.getCoords_ = function(C, D) {
            var E = this.m_;
            return {
                x: AY * (C * E[0][0] + D * E[1][0] + E[2][0]) - AW,
                y: AY * (C * E[0][1] + D * E[1][1] + E[2][1]) - AW
            }
        };
        AP.save = function() {
            var C = {};
            AL(this, C);
            this.aStack_.push(C);
            this.mStack_.push(this.m_);
            this.m_ = Ar(AF(), this.m_)
        };
        AP.restore = function() {
            if (this.aStack_.length) {
                AL(this.aStack_.pop(), this);
                this.m_ = this.mStack_.pop()
            }
        };

        function AU(C) {
            return isFinite(C[0][0]) && isFinite(C[0][1]) && isFinite(C[1][0]) && isFinite(C[1][1]) && isFinite(C[2][0]) && isFinite(C[2][1])
        }

        function Ad(D, F, C) {
            if (!AU(F)) {
                return
            }
            D.m_ = F;
            if (C) {
                var E = F[0][0] * F[1][1] - F[0][1] * F[1][0];
                D.lineScale_ = An(At(E))
            }
        }
        AP.translate = function(C, D) {
            var E = [
                [1, 0, 0],
                [0, 1, 0],
                [C, D, 1]
            ];
            Ad(this, Ar(E, this.m_), false)
        };
        AP.rotate = function(E) {
            var C = AH(E);
            var D = AS(E);
            var F = [
                [C, D, 0],
                [-D, C, 0],
                [0, 0, 1]
            ];
            Ad(this, Ar(F, this.m_), false)
        };
        AP.scale = function(C, D) {
            this.arcScaleX_ *= C;
            this.arcScaleY_ *= D;
            var E = [
                [C, 0, 0],
                [0, D, 0],
                [0, 0, 1]
            ];
            Ad(this, Ar(E, this.m_), true)
        };
        AP.transform = function(I, C, F, G, E, H) {
            var D = [
                [I, C, 0],
                [F, G, 0],
                [E, H, 1]
            ];
            Ad(this, Ar(D, this.m_), true)
        };
        AP.setTransform = function(G, I, D, F, C, E) {
            var H = [
                [G, I, 0],
                [D, F, 0],
                [C, E, 1]
            ];
            Ad(this, H, true)
        };
        AP.drawText_ = function(K, M, N, H, O) {
            var I = this.m_,
                E = 1000,
                T = 0,
                F = E,
                Q = {
                    x: 0,
                    y: 0
                },
                R = [];
            var C = AM(m(this.font), this.element_);
            var S = AG(C);
            var D = this.element_.currentStyle;
            var P = this.textAlign.toLowerCase();
            switch (P) {
                case "left":
                case "center":
                case "right":
                    break;
                case "end":
                    P = D.direction == "ltr" ? "right" : "left";
                    break;
                case "start":
                    P = D.direction == "rtl" ? "right" : "left";
                    break;
                default:
                    P = "left"
            }
            switch (this.textBaseline) {
                case "hanging":
                case "top":
                    Q.y = C.size / 1.75;
                    break;
                case "middle":
                    break;
                default:
                case null:
                case "alphabetic":
                case "ideographic":
                case "bottom":
                    Q.y = -C.size / 2.25;
                    break
            }
            switch (P) {
                case "right":
                    T = E;
                    F = 0.05;
                    break;
                case "center":
                    T = F = E / 2;
                    break
            }
            var G = this.getCoords_(M + Q.x, N + Q.y);
            R.push('<g_vml_:line from="', -T, ' 0" to="', F, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !O, '" stroked="', !!O, '" style="position:absolute;width:1px;height:1px;">');
            if (O) {
                AK(this, R)
            } else {
                Au(this, R, {
                    x: -T,
                    y: 0
                }, {
                    x: F,
                    y: C.size
                })
            }
            var J = I[0][0].toFixed(3) + "," + I[1][0].toFixed(3) + "," + I[0][1].toFixed(3) + "," + I[1][1].toFixed(3) + ",0,0";
            var L = AR(G.x / AY) + "," + AR(G.y / AY);
            R.push('<g_vml_:skew on="t" matrix="', J, '" ', ' offset="', L, '" origin="', T, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', j(K), '" style="v-text-align:', P, ";font:", j(S), '" /></g_vml_:line>');
            this.element_.insertAdjacentHTML("beforeEnd", R.join(""))
        };
        AP.fillText = function(D, F, C, E) {
            this.drawText_(D, F, C, E, false)
        };
        AP.strokeText = function(D, F, C, E) {
            this.drawText_(D, F, C, E, true)
        };
        AP.measureText = function(C) {
            if (!this.textMeasureEl_) {
                var E = '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>';
                this.element_.insertAdjacentHTML("beforeEnd", E);
                this.textMeasureEl_ = this.element_.lastChild
            }
            var D = this.element_.ownerDocument;
            this.textMeasureEl_.innerHTML = "";
            this.textMeasureEl_.style.font = this.font;
            this.textMeasureEl_.appendChild(D.createTextNode(C));
            return {
                width: this.textMeasureEl_.offsetWidth
            }
        };
        AP.clip = function() {};
        AP.arcTo = function() {};
        AP.createPattern = function(C, D) {
            return new Ah(C, D)
        };

        function Ag(C) {
            this.type_ = C;
            this.x0_ = 0;
            this.y0_ = 0;
            this.r0_ = 0;
            this.x1_ = 0;
            this.y1_ = 0;
            this.r1_ = 0;
            this.colors_ = []
        }
        Ag.prototype.addColorStop = function(C, D) {
            D = Z(D);
            this.colors_.push({
                offset: C,
                color: D.color,
                alpha: D.alpha
            })
        };

        function Ah(C, D) {
            Ak(C);
            switch (D) {
                case "repeat":
                case null:
                case "":
                    this.repetition_ = "repeat";
                    break;
                case "repeat-x":
                case "repeat-y":
                case "no-repeat":
                    this.repetition_ = D;
                    break;
                default:
                    Am("SYNTAX_ERR")
            }
            this.src_ = C.src;
            this.width_ = C.width;
            this.height_ = C.height
        }

        function Am(C) {
            throw new Al(C)
        }

        function Ak(C) {
            if (!C || C.nodeType != 1 || C.tagName != "IMG") {
                Am("TYPE_MISMATCH_ERR")
            }
            if (C.readyState != "complete") {
                Am("INVALID_STATE_ERR")
            }
        }

        function Al(C) {
            this.code = this[C];
            this.message = C + ": DOM Exception " + this.code
        }
        var Ae = Al.prototype = new Error;
        Ae.INDEX_SIZE_ERR = 1;
        Ae.DOMSTRING_SIZE_ERR = 2;
        Ae.HIERARCHY_REQUEST_ERR = 3;
        Ae.WRONG_DOCUMENT_ERR = 4;
        Ae.INVALID_CHARACTER_ERR = 5;
        Ae.NO_DATA_ALLOWED_ERR = 6;
        Ae.NO_MODIFICATION_ALLOWED_ERR = 7;
        Ae.NOT_FOUND_ERR = 8;
        Ae.NOT_SUPPORTED_ERR = 9;
        Ae.INUSE_ATTRIBUTE_ERR = 10;
        Ae.INVALID_STATE_ERR = 11;
        Ae.SYNTAX_ERR = 12;
        Ae.INVALID_MODIFICATION_ERR = 13;
        Ae.NAMESPACE_ERR = 14;
        Ae.INVALID_ACCESS_ERR = 15;
        Ae.VALIDATION_ERR = 16;
        Ae.TYPE_MISMATCH_ERR = 17;
        G_vmlCanvasManager = AX;
        CanvasRenderingContext2D = p;
        CanvasGradient = Ag;
        CanvasPattern = Ah;
        DOMException = Al
    })()
}(function(C) {
    var D = {
        onClick: function() {
            C(this).find(">a").each(function() {
                if (this.href) {
                    window.location = this.href
                }
            })
        },
        arrowSrc: "",
        subDelay: 200,
        mainDelay: 10
    };
    C.fn.clickMenu = function(H) {
        var E = false;
        var Q = C.extend({}, D, H);
        var F = function(Y, X) {
            if (Y.timer && !Y.isVisible) {
                clearTimeout(Y.timer)
            } else {
                if (Y.timer) {
                    return
                }
            }
            if (Y.isVisible) {
                Y.timer = setTimeout(function() {
                    C(L(I(Y, "UL"), "LI")).unbind("mouseover", J).unbind("mouseout", R).unbind("click", Q.onClick);
                    C(Y).hide();
                    Y.isVisible = false;
                    Y.timer = null
                }, X)
            }
        };
        var N = function(Y, X) {
            if (Y.timer) {
                clearTimeout(Y.timer)
            }
            if (!Y.isVisible) {
                Y.timer = setTimeout(function() {
                    if (!V(Y.parentNode, "hover")) {
                        return
                    }
                    C(L(I(Y, "UL"), "LI")).mouseover(J).mouseout(R).click(Q.onClick);
                    if (!V(Y.parentNode, "main")) {
                        C(Y).css("left", Y.parentNode.offsetWidth)
                    }
                    Y.isVisible = true;
                    C(Y).show();
                    Y.timer = null
                }, X)
            }
        };
        var W = function(Y) {
            var X = (Y.type == "mouseover" ? Y.fromElement : Y.toElement) || Y.relatedTarget;
            while (X && X != this) {
                try {
                    X = X.parentNode
                } catch (Y) {
                    X = this
                }
            }
            if (X == this) {
                return false
            }
            return true
        };
        var S = function(a) {
            var X = L(this.parentNode, "LI");
            var Z = new RegExp("(^|\\s)hover(\\s|$)");
            for (var Y = 0; Y < X.length; Y++) {
                if (Z.test(X[Y].className)) {
                    C(X[Y]).removeClass("hover")
                }
            }
            C(this).addClass("hover");
            if (E) {
                P(this, Q.mainDelay)
            }
        };
        var J = function(X) {
            if (!W(X)) {
                return false
            }
            if (X.target != this) {
                if (!K(this, X.target)) {
                    return
                }
            }
            P(this, Q.subDelay)
        };
        var P = function(X, Y) {
            var a = I(X, "DIV");
            var c = X.parentNode.firstChild;
            for (; c; c = c.nextSibling) {
                if (c.nodeType == 1 && c.nodeName.toUpperCase() == "LI") {
                    var b = I(c, "DIV");
                    if (b && b.timer && !b.isVisible) {
                        clearTimeout(b.timer);
                        b.timer = null
                    }
                }
            }
            var Z = X.parentNode;
            for (; Z; Z = Z.parentNode) {
                if (Z.nodeType == 1 && Z.nodeName.toUpperCase() == "DIV") {
                    if (Z.timer) {
                        clearTimeout(Z.timer);
                        Z.timer = null;
                        C(Z.parentNode).addClass("hover")
                    }
                }
            }
            C(X).addClass("hover");
            if (a && a.isVisible) {
                if (a.timer) {
                    clearTimeout(a.timer);
                    a.timer = null
                } else {
                    return
                }
            }
            C(X.parentNode.getElementsByTagName("DIV")).each(function() {
                if (this != a && this.isVisible) {
                    F(this, Y);
                    C(this.parentNode).removeClass("hover")
                }
            });
            if (a) {
                N(a, Y)
            }
        };
        var R = function(X) {
            if (!W(X)) {
                return false
            }
            if (X.target != this) {
                if (!K(this, X.target)) {
                    return
                }
            }
            var Y = I(this, "DIV");
            if (!Y) {
                C(this).removeClass("hover")
            } else {
                if (!Y.isVisible) {
                    C(this).removeClass("hover")
                }
            }
        };
        var T = function(Z) {
            var a = I(this, "DIV");
            var Y = Z.relatedTarget || Z.toElement;
            var X;
            if (!E) {
                C(this).removeClass("hover")
            } else {
                if (!a && Y) {
                    X = G(Z.target, "UL", "clickMenu");
                    if (X.contains(Y)) {
                        C(this).removeClass("hover")
                    }
                } else {
                    if (Y) {
                        X = G(Z.target, "UL", "clickMenu");
                        if (!a.isVisible && (X.contains(Y))) {
                            C(this).removeClass("hover")
                        }
                    }
                }
            }
        };
        var M = function() {
            var X = I(this, "DIV");
            if (X && X.isVisible) {
                O();
                C(this).addClass("hover")
            } else {
                P(this, Q.mainDelay);
                E = true;
                C(document).bind("mousedown", U)
            }
            return false
        };
        var U = function(Z) {
            var Y = false;
            var X = G(Z.target, "UL", "clickMenu");
            if (X) {
                C(X.getElementsByTagName("DIV")).each(function() {
                    if (this.isVisible) {
                        Y = true
                    }
                })
            }
            if (!Y) {
                O()
            }
        };
        var O = function() {
            C("ul.clickMenu div.outerbox").each(function() {
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null
                }
                if (this.isVisible) {
                    C(this).hide();
                    this.isVisible = false
                }
            });
            C("ul.clickMenu li").removeClass("hover");
            C("ul.clickMenu>li li").unbind("mouseover", J).unbind("mouseout", R).unbind("click", Q.onClick);
            C(document).unbind("mousedown", U);
            E = false
        };
        var I = function(Y, X) {
            if (!Y) {
                return null
            }
            var Z = Y.firstChild;
            for (; Z; Z = Z.nextSibling) {
                if (Z.nodeType == 1 && Z.nodeName.toUpperCase() == X) {
                    return Z
                }
            }
            return null
        };
        var L = function(Z, X) {
            if (!Z) {
                return []
            }
            var Y = [];
            var a = Z.firstChild;
            for (; a; a = a.nextSibling) {
                if (a.nodeType == 1 && a.nodeName.toUpperCase() == X) {
                    Y[Y.length] = a
                }
            }
            return Y
        };
        var G = function(Z, Y, b) {
            var X = Z.parentNode;
            var a = new RegExp("(^|\\s)" + b + "(\\s|$)");
            for (; X; X = X.parentNode) {
                if (X.nodeType == 1 && X.nodeName.toUpperCase() == Y && a.test(X.className)) {
                    return X
                }
            }
            return null
        };
        var V = function(X, Z) {
            var Y = new RegExp("(^|\\s)" + Z + "(\\s|$)");
            if (Y.test(X.className)) {
                return true
            }
            return false
        };
        var K = function(Y, X) {
            var Z = Y.firstChild;
            for (; Z; Z = Z.nextSibling) {
                if (Z == X) {
                    return true
                }
            }
            return false
        };
        return this.each(function() {
            if (window.Node && Node.prototype && !Node.prototype.contains) {
                Node.prototype.contains = function(Z) {
                    return !!(this.compareDocumentPosition(Z) & 16)
                }
            }
            if (!V(this, "clickMenu")) {
                C(this).addClass("clickMenu")
            }
            C("ul", this).shadowBox();
            C(this).bind("closemenu", function() {
                O()
            });
            var X = L(this, "LI");
            for (var Y = 0; Y < X.length; Y++) {
                if (I(I(I(X[Y], "DIV"), "UL"), "LI")) {
                    C(X[Y]).click(M).addClass("main")
                } else {
                    C(X[Y]).click(Q.onClick).addClass("mainNoSub")
                }
            }
            C(X).hover(S, T).find(">div").addClass("inner");
            if (Q.arrowSrc) {
                C("div.inner div.outerbox", this).before('<img src="' + Q.arrowSrc + '" class="liArrow" />')
            }
            C(this).wrap('<div class="cmDiv"></div>').after('<div style="clear: both; visibility: hidden;"></div>')
        })
    };
    C.fn.clickMenu.setDefaults = function(E) {
        C.extend(D, E)
    }
})(jQuery);
(function(C) {
    C.fn.shadowBox = function() {
        return this.each(function() {
            var D = C('<div class="outerbox" style="visibility: visible"></div>').get(0);
            if (C(this).css("position") == "absolute") {
                C(D).css({
                    position: "relative",
                    width: this.offsetWidth,
                    height: this.offsetHeight
                })
            } else {
                C(D).css("position", "absolute")
            }
            C(this).addClass("innerBox").wrap(D).before('<div class="menushadowbox1" style=""></div><div class="menushadowbox2"></div><div class="menushadowbox3"></div>')
        })
    }
})(jQuery);
(function($, window, document) {
    $.fn.dataTableSettings = [];
    var _aoSettings = $.fn.dataTableSettings;
    $.fn.dataTableExt = {};
    var _oExt = $.fn.dataTableExt;
    _oExt.sVersion = "1.8.2";
    _oExt.sErrMode = "alert";
    _oExt.iApiIndex = 0;
    _oExt.oApi = {};
    _oExt.afnFiltering = [];
    _oExt.aoFeatures = [];
    _oExt.ofnSearch = {};
    _oExt.afnSortData = [];
    _oExt.oStdClasses = {
        sPagePrevEnabled: "paginate_enabled_previous",
        sPagePrevDisabled: "paginate_disabled_previous",
        sPageNextEnabled: "paginate_enabled_next",
        sPageNextDisabled: "paginate_disabled_next",
        sPageJUINext: "",
        sPageJUIPrev: "",
        sPageButton: "paginate_button",
        sPageButtonActive: "paginate_active",
        sPageButtonStaticDisabled: "paginate_button paginate_button_disabled",
        sPageFirst: "first",
        sPagePrevious: "previous",
        sPageNext: "next",
        sPageLast: "last",
        sStripeOdd: "odd",
        sStripeEven: "even",
        sRowEmpty: "dataTables_empty",
        sWrapper: "dataTables_wrapper",
        sFilter: "dataTables_filter",
        sInfo: "dataTables_info",
        sPaging: "dataTables_paginate paging_",
        sLength: "dataTables_length",
        sProcessing: "dataTables_processing",
        sSortAsc: "sorting_asc",
        sSortDesc: "sorting_desc",
        sSortable: "sorting",
        sSortableAsc: "sorting_asc_disabled",
        sSortableDesc: "sorting_desc_disabled",
        sSortableNone: "sorting_disabled",
        sSortColumn: "sorting_",
        sSortJUIAsc: "",
        sSortJUIDesc: "",
        sSortJUI: "",
        sSortJUIAscAllowed: "",
        sSortJUIDescAllowed: "",
        sSortJUIWrapper: "",
        sSortIcon: "",
        sScrollWrapper: "dataTables_scroll",
        sScrollHead: "dataTables_scrollHead",
        sScrollHeadInner: "dataTables_scrollHeadInner",
        sScrollBody: "dataTables_scrollBody",
        sScrollFoot: "dataTables_scrollFoot",
        sScrollFootInner: "dataTables_scrollFootInner",
        sFooterTH: ""
    };
    _oExt.oJUIClasses = {
        sPagePrevEnabled: "fg-button ui-button ui-state-default ui-corner-left",
        sPagePrevDisabled: "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
        sPageNextEnabled: "fg-button ui-button ui-state-default ui-corner-right",
        sPageNextDisabled: "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
        sPageJUINext: "ui-icon ui-icon-circle-arrow-e",
        sPageJUIPrev: "ui-icon ui-icon-circle-arrow-w",
        sPageButton: "fg-button ui-button ui-state-default",
        sPageButtonActive: "fg-button ui-button ui-state-default ui-state-disabled",
        sPageButtonStaticDisabled: "fg-button ui-button ui-state-default ui-state-disabled",
        sPageFirst: "first ui-corner-tl ui-corner-bl",
        sPagePrevious: "previous",
        sPageNext: "next",
        sPageLast: "last ui-corner-tr ui-corner-br",
        sStripeOdd: "odd",
        sStripeEven: "even",
        sRowEmpty: "dataTables_empty",
        sWrapper: "dataTables_wrapper",
        sFilter: "dataTables_filter",
        sInfo: "dataTables_info",
        sPaging: "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ui-buttonset-multi paging_",
        sLength: "dataTables_length",
        sProcessing: "dataTables_processing",
        sSortAsc: "ui-state-default",
        sSortDesc: "ui-state-default",
        sSortable: "ui-state-default",
        sSortableAsc: "ui-state-default",
        sSortableDesc: "ui-state-default",
        sSortableNone: "ui-state-default",
        sSortColumn: "sorting_",
        sSortJUIAsc: "css_right ui-icon ui-icon-triangle-1-n",
        sSortJUIDesc: "css_right ui-icon ui-icon-triangle-1-s",
        sSortJUI: "css_right ui-icon ui-icon-carat-2-n-s",
        sSortJUIAscAllowed: "css_right ui-icon ui-icon-carat-1-n",
        sSortJUIDescAllowed: "css_right ui-icon ui-icon-carat-1-s",
        sSortJUIWrapper: "DataTables_sort_wrapper",
        sSortIcon: "DataTables_sort_icon",
        sScrollWrapper: "dataTables_scroll",
        sScrollHead: "dataTables_scrollHead ui-state-default",
        sScrollHeadInner: "dataTables_scrollHeadInner",
        sScrollBody: "dataTables_scrollBody",
        sScrollFoot: "dataTables_scrollFoot ui-state-default",
        sScrollFootInner: "dataTables_scrollFootInner",
        sFooterTH: "ui-state-default"
    };
    _oExt.oPagination = {
        two_button: {
            fnInit: function(oSettings, nPaging, fnCallbackDraw) {
                var nPrevious, nNext, nPreviousInner, nNextInner;
                if (!oSettings.bJUI) {
                    nPrevious = document.createElement("div");
                    nNext = document.createElement("div")
                } else {
                    nPrevious = document.createElement("a");
                    nNext = document.createElement("a");
                    nNextInner = document.createElement("span");
                    nNextInner.className = oSettings.oClasses.sPageJUINext;
                    nNext.appendChild(nNextInner);
                    nPreviousInner = document.createElement("span");
                    nPreviousInner.className = oSettings.oClasses.sPageJUIPrev;
                    nPrevious.appendChild(nPreviousInner)
                }
                nPrevious.className = oSettings.oClasses.sPagePrevDisabled;
                nNext.className = oSettings.oClasses.sPageNextDisabled;
                nPrevious.title = oSettings.oLanguage.oPaginate.sPrevious;
                nNext.title = oSettings.oLanguage.oPaginate.sNext;
                nPrevious.tabIndex = 0;
                nNext.tabIndex = 0;
                nPaging.appendChild(nPrevious);
                nPaging.appendChild(nNext);
                var prevClickHandler = function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "previous")) {
                        fnCallbackDraw(oSettings)
                    }
                };
                $(nPrevious).bind("click.DT", prevClickHandler);
                $(nPrevious).bind("keydown", function(e) {
                    if (e.keyCode == 13) {
                        prevClickHandler.call()
                    }
                });
                var nextClickHandler = function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "next")) {
                        fnCallbackDraw(oSettings)
                    }
                };
                $(nNext).bind("click.DT", nextClickHandler);
                $(nNext).bind("keydown", function(e) {
                    if (e.keyCode == 13) {
                        nextClickHandler.call()
                    }
                });
                $(nPrevious).bind("selectstart.DT", function() {
                    return false
                });
                $(nNext).bind("selectstart.DT", function() {
                    return false
                });
                if (oSettings.sTableId !== "" && typeof oSettings.aanFeatures.p == "undefined") {
                    nPaging.setAttribute("id", oSettings.sTableId + "_paginate");
                    nPrevious.setAttribute("id", oSettings.sTableId + "_previous");
                    nNext.setAttribute("id", oSettings.sTableId + "_next")
                }
            },
            fnUpdate: function(oSettings, fnCallbackDraw) {
                if (!oSettings.aanFeatures.p) {
                    return
                }
                var an = oSettings.aanFeatures.p;
                for (var i = 0, iLen = an.length; i < iLen; i++) {
                    if (an[i].childNodes.length !== 0) {
                        an[i].childNodes[0].className = (oSettings._iDisplayStart === 0) ? oSettings.oClasses.sPagePrevDisabled : oSettings.oClasses.sPagePrevEnabled;
                        an[i].childNodes[1].className = (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) ? oSettings.oClasses.sPageNextDisabled : oSettings.oClasses.sPageNextEnabled
                    }
                }
            }
        },
        iFullNumbersShowPages: 5,
        full_numbers: {
            fnInit: function(oSettings, nPaging, fnCallbackDraw) {
                var nFirst = document.createElement("span");
                var nPrevious = document.createElement("span");
                var nList = document.createElement("span");
                var nNext = document.createElement("span");
                var nLast = document.createElement("span");
                nFirst.innerHTML = oSettings.oLanguage.oPaginate.sFirst;
                nPrevious.innerHTML = oSettings.oLanguage.oPaginate.sPrevious;
                nNext.innerHTML = oSettings.oLanguage.oPaginate.sNext;
                nLast.innerHTML = oSettings.oLanguage.oPaginate.sLast;
                var oClasses = oSettings.oClasses;
                nFirst.className = oClasses.sPageButton + " " + oClasses.sPageFirst;
                nPrevious.className = oClasses.sPageButton + " " + oClasses.sPagePrevious;
                nNext.className = oClasses.sPageButton + " " + oClasses.sPageNext;
                nLast.className = oClasses.sPageButton + " " + oClasses.sPageLast;
                nPaging.appendChild(nFirst);
                nPaging.appendChild(nPrevious);
                nPaging.appendChild(nList);
                nPaging.appendChild(nNext);
                nPaging.appendChild(nLast);
                $(nFirst).bind("click.DT", function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "first")) {
                        fnCallbackDraw(oSettings)
                    }
                });
                $(nPrevious).bind("click.DT", function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "previous")) {
                        fnCallbackDraw(oSettings)
                    }
                });
                $(nNext).bind("click.DT", function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "next")) {
                        fnCallbackDraw(oSettings)
                    }
                });
                $(nLast).bind("click.DT", function() {
                    if (oSettings.oApi._fnPageChange(oSettings, "last")) {
                        fnCallbackDraw(oSettings)
                    }
                });
                $("span", nPaging).bind("mousedown.DT", function() {
                    return false
                }).bind("selectstart.DT", function() {
                    return false
                });
                if (oSettings.sTableId !== "" && typeof oSettings.aanFeatures.p == "undefined") {
                    nPaging.setAttribute("id", oSettings.sTableId + "_paginate");
                    nFirst.setAttribute("id", oSettings.sTableId + "_first");
                    nPrevious.setAttribute("id", oSettings.sTableId + "_previous");
                    nNext.setAttribute("id", oSettings.sTableId + "_next");
                    nLast.setAttribute("id", oSettings.sTableId + "_last")
                }
            },
            fnUpdate: function(oSettings, fnCallbackDraw) {
                if (!oSettings.aanFeatures.p) {
                    return
                }
                var iPageCount = _oExt.oPagination.iFullNumbersShowPages;
                var iPageCountHalf = Math.floor(iPageCount / 2);
                var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
                var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
                var sList = "";
                var iStartButton, iEndButton, i, iLen;
                var oClasses = oSettings.oClasses;
                if (iPages < iPageCount) {
                    iStartButton = 1;
                    iEndButton = iPages
                } else {
                    if (iCurrentPage <= iPageCountHalf) {
                        iStartButton = 1;
                        iEndButton = iPageCount
                    } else {
                        if (iCurrentPage >= (iPages - iPageCountHalf)) {
                            iStartButton = iPages - iPageCount + 1;
                            iEndButton = iPages
                        } else {
                            iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
                            iEndButton = iStartButton + iPageCount - 1
                        }
                    }
                }
                for (i = iStartButton; i <= iEndButton; i++) {
                    if (iCurrentPage != i) {
                        sList += '<span class="' + oClasses.sPageButton + '">' + i + "</span>"
                    } else {
                        sList += '<span class="' + oClasses.sPageButtonActive + '">' + i + "</span>"
                    }
                }
                var an = oSettings.aanFeatures.p;
                var anButtons, anStatic, nPaginateList;
                var fnClick = function(e) {
                    var iTarget = (this.innerHTML * 1) - 1;
                    oSettings._iDisplayStart = iTarget * oSettings._iDisplayLength;
                    fnCallbackDraw(oSettings);
                    e.preventDefault()
                };
                var fnFalse = function() {
                    return false
                };
                for (i = 0, iLen = an.length; i < iLen; i++) {
                    if (an[i].childNodes.length === 0) {
                        continue
                    }
                    var qjPaginateList = $("span:eq(2)", an[i]);
                    qjPaginateList.html(sList);
                    $("span", qjPaginateList).bind("click.DT", fnClick).bind("mousedown.DT", fnFalse).bind("selectstart.DT", fnFalse);
                    anButtons = an[i].getElementsByTagName("span");
                    anStatic = [anButtons[0], anButtons[1], anButtons[anButtons.length - 2], anButtons[anButtons.length - 1]];
                    $(anStatic).removeClass(oClasses.sPageButton + " " + oClasses.sPageButtonActive + " " + oClasses.sPageButtonStaticDisabled);
                    if (iCurrentPage == 1) {
                        anStatic[0].className += " " + oClasses.sPageButtonStaticDisabled;
                        anStatic[1].className += " " + oClasses.sPageButtonStaticDisabled
                    } else {
                        anStatic[0].className += " " + oClasses.sPageButton;
                        anStatic[1].className += " " + oClasses.sPageButton
                    }
                    if (iPages === 0 || iCurrentPage == iPages || oSettings._iDisplayLength == -1) {
                        anStatic[2].className += " " + oClasses.sPageButtonStaticDisabled;
                        anStatic[3].className += " " + oClasses.sPageButtonStaticDisabled
                    } else {
                        anStatic[2].className += " " + oClasses.sPageButton;
                        anStatic[3].className += " " + oClasses.sPageButton
                    }
                }
            }
        }
    };
    _oExt.oSort = {
        "string-asc": function(a, b) {
            if (typeof a != "string") {
                a = ""
            }
            if (typeof b != "string") {
                b = ""
            }
            var x = a.toLowerCase();
            var y = b.toLowerCase();
            return ((x < y) ? -1 : ((x > y) ? 1 : 0))
        },
        "string-desc": function(a, b) {
            if (typeof a != "string") {
                a = ""
            }
            if (typeof b != "string") {
                b = ""
            }
            var x = a.toLowerCase();
            var y = b.toLowerCase();
            return ((x < y) ? 1 : ((x > y) ? -1 : 0))
        },
        "html-asc": function(a, b) {
            var x = a.replace(/<.*?>/g, "").toLowerCase();
            var y = b.replace(/<.*?>/g, "").toLowerCase();
            return ((x < y) ? -1 : ((x > y) ? 1 : 0))
        },
        "html-desc": function(a, b) {
            var x = a.replace(/<.*?>/g, "").toLowerCase();
            var y = b.replace(/<.*?>/g, "").toLowerCase();
            return ((x < y) ? 1 : ((x > y) ? -1 : 0))
        },
        "date-asc": function(a, b) {
            var x = Date.parse(a);
            var y = Date.parse(b);
            if (isNaN(x) || x === "") {
                x = Date.parse("01/01/1970 00:00:00")
            }
            if (isNaN(y) || y === "") {
                y = Date.parse("01/01/1970 00:00:00")
            }
            return x - y
        },
        "date-desc": function(a, b) {
            var x = Date.parse(a);
            var y = Date.parse(b);
            if (isNaN(x) || x === "") {
                x = Date.parse("01/01/1970 00:00:00")
            }
            if (isNaN(y) || y === "") {
                y = Date.parse("01/01/1970 00:00:00")
            }
            return y - x
        },
        "numeric-asc": function(a, b) {
            var x = (a == "-" || a === "") ? 0 : a * 1;
            var y = (b == "-" || b === "") ? 0 : b * 1;
            return x - y
        },
        "numeric-desc": function(a, b) {
            var x = (a == "-" || a === "") ? 0 : a * 1;
            var y = (b == "-" || b === "") ? 0 : b * 1;
            return y - x
        },
        "integer-asc": function(a, b) {
            var x = (a == "-" || a === "") ? 0 : a * 1;
            var y = (b == "-" || b === "") ? 0 : b * 1;
            return x - y
        },
        "integer-desc": function(a, b) {
            var x = (a == "-" || a === "") ? 0 : a * 1;
            var y = (b == "-" || b === "") ? 0 : b * 1;
            return y - x
        },
        "diskslot-asc": function(a, b) {
            var diskSlotA = a.split(".");
            var diskSlotB = b.split(".");
            var encA = parseInt(diskSlotA[0]);
            var slotA = parseInt(diskSlotA[1]);
            var encB = parseInt(diskSlotB[0]);
            var slotB = parseInt(diskSlotB[1]);
            var compValue = encA - encB;
            if (compValue == 0) {
                return slotA - slotB
            } else {
                return compValue
            }
        },
        "diskslot-desc": function(a, b) {
            var diskSlotA = a.split(".");
            var diskSlotB = b.split(".");
            var encA = parseInt(diskSlotA[0]);
            var slotA = parseInt(diskSlotA[1]);
            var encB = parseInt(diskSlotB[0]);
            var slotB = parseInt(diskSlotB[1]);
            var compValue = encB - encA;
            if (compValue == 0) {
                return slotB - slotA
            } else {
                return compValue
            }
        },
        "size-asc": function(a, b) {
            var sizeA = new Size(a);
            var sizeB = new Size(b);
            return sizeA.value - sizeB.value
        },
        "size-desc": function(a, b) {
            var sizeA = new Size(a);
            var sizeB = new Size(b);
            return sizeB.value - sizeA.value
        },
        "location-asc": function(a, b) {
            var aMod = "" + a;
            var bMod = "" + b;
            var aLocs = aMod.match(/[0-9]+\.[0-9]+/g);
            var bLocs = bMod.match(/[0-9]+\.[0-9]+/g);
            if (aLocs) {
                for (var i = 0; i < aLocs.length; i++) {
                    var parts = aLocs[i].split(".");
                    var newStr = leadingZeros(parts[0], 4) + leadingZeros(parts[1], 4);
                    aMod = aMod.replace(aLocs[i], newStr)
                }
            }
            if (bLocs) {
                for (var i = 0; i < bLocs.length; i++) {
                    var parts = bLocs[i].split(".");
                    var newStr = leadingZeros(parts[0], 4) + leadingZeros(parts[1], 4);
                    bMod = bMod.replace(bLocs[i], newStr)
                }
            }
            var x = aMod.toLowerCase();
            var y = bMod.toLowerCase();
            return ((x < y) ? -1 : ((x > y) ? 1 : 0))
        },
        "location-desc": function(b, a) {
            var aMod = "" + a;
            var bMod = "" + b;
            var aLocs = aMod.match(/[0-9]+\.[0-9]+/g);
            var bLocs = bMod.match(/[0-9]+\.[0-9]+/g);
            if (aLocs) {
                for (var i = 0; i < aLocs.length; i++) {
                    var parts = aLocs[i].split(".");
                    var newStr = leadingZeros(parts[0], 4) + leadingZeros(parts[1], 4);
                    aMod = aMod.replace(aLocs[i], newStr)
                }
            }
            if (bLocs) {
                for (var i = 0; i < bLocs.length; i++) {
                    var parts = bLocs[i].split(".");
                    var newStr = leadingZeros(parts[0], 4) + leadingZeros(parts[1], 4);
                    bMod = bMod.replace(bLocs[i], newStr)
                }
            }
            var x = aMod.toLowerCase();
            var y = bMod.toLowerCase();
            return ((x < y) ? -1 : ((x > y) ? 1 : 0))
        }
    };
    _oExt.aTypes = [function(sData) {
        if (typeof sData == "number") {
            return "numeric"
        } else {
            if (typeof sData != "string") {
                return null
            }
        }
        var sValidFirstChars = "0123456789-";
        var sValidChars = "0123456789.";
        var Char;
        var bDecimal = false;
        Char = sData.charAt(0);
        if (sValidFirstChars.indexOf(Char) == -1) {
            return null
        }
        for (var i = 1; i < sData.length; i++) {
            Char = sData.charAt(i);
            if (sValidChars.indexOf(Char) == -1) {
                return null
            }
            if (Char == ".") {
                if (bDecimal) {
                    return null
                }
                bDecimal = true
            }
        }
        return "numeric"
    }, function(sData) {
        var iParse = Date.parse(sData);
        if ((iParse !== null && !isNaN(iParse)) || (typeof sData == "string" && sData.length === 0)) {
            return "date"
        }
        return null
    }, function(sData) {
        if (typeof sData == "string" && sData.indexOf("<") != -1 && sData.indexOf(">") != -1) {
            return "html"
        }
        return null
    }];
    _oExt.fnVersionCheck = function(sVersion) {
        var fnZPad = function(Zpad, count) {
            while (Zpad.length < count) {
                Zpad += "0"
            }
            return Zpad
        };
        var aThis = _oExt.sVersion.split(".");
        var aThat = sVersion.split(".");
        var sThis = "",
            sThat = "";
        for (var i = 0, iLen = aThat.length; i < iLen; i++) {
            sThis += fnZPad(aThis[i], 3);
            sThat += fnZPad(aThat[i], 3)
        }
        return parseInt(sThis, 10) >= parseInt(sThat, 10)
    };
    _oExt._oExternConfig = {
        iNextUnique: 0
    };
    $.fn.dataTable = function(oInit) {
        function classSettings() {
            this.fnRecordsTotal = function() {
                if (this.oFeatures.bServerSide) {
                    return parseInt(this._iRecordsTotal, 10)
                } else {
                    return this.aiDisplayMaster.length
                }
            };
            this.fnRecordsDisplay = function() {
                if (this.oFeatures.bServerSide) {
                    return parseInt(this._iRecordsDisplay, 10)
                } else {
                    return this.aiDisplay.length
                }
            };
            this.fnDisplayEnd = function() {
                if (this.oFeatures.bServerSide) {
                    if (this.oFeatures.bPaginate === false || this._iDisplayLength == -1) {
                        return this._iDisplayStart + this.aiDisplay.length
                    } else {
                        return Math.min(this._iDisplayStart + this._iDisplayLength, this._iRecordsDisplay)
                    }
                } else {
                    return this._iDisplayEnd
                }
            };
            this.oInstance = null;
            this.sInstance = null;
            this.oFeatures = {
                oCriteria: null,
                sBasetype: "",
                bPaginate: true,
                bLengthChange: true,
                bFilter: true,
                bSort: true,
                bInfo: true,
                bAutoWidth: true,
                bProcessing: false,
                bSortClasses: true,
                bStateSave: false,
                bServerSide: false,
                bDeferRender: false
            };
            this.oScroll = {
                sX: "",
                sXInner: "",
                sY: "",
                bCollapse: false,
                bInfinite: false,
                iLoadGap: 100,
                iBarWidth: 0,
                bAutoCss: true
            };
            this.aanFeatures = [];
            this.oLanguage = {
                sProcessing: "Processing...",
                sLengthMenu: "Show _MENU_ ",
                sZeroRecords: "No matching records found",
                sEmptyTable: "No data available in table",
                sLoadingRecords: "Loading...",
                sInfo: "Showing _START_ to _END_ of _TOTAL_ entries",
                sInfoEmpty: "Showing 0 to 0 of 0 entries",
                sInfoFiltered: "(filtered from _MAX_ total entries)",
                sInfoPostFix: "",
                sInfoThousands: ",",
                sSearch: "Search:",
                sSearch: "",
                sUrl: "",
                oPaginate: {
                    sFirst: "First",
                    sPrevious: "Previous",
                    sNext: "Next",
                    sLast: "Last"
                },
                fnInfoCallback: null
            };
            this.aoData = [];
            this.aiDisplay = [];
            this.aiDisplayMaster = [];
            this.aoColumns = [];
            this.aoHeader = [];
            this.aoFooter = [];
            this.iNextId = 0;
            this.asDataSearch = [];
            this.oPreviousSearch = {
                sSearch: "",
                bRegex: false,
                bSmart: true
            };
            this.aoPreSearchCols = [];
            this.aaSorting = [
                [0, "asc", 0]
            ];
            this.aaSortingFixed = null;
            this.asStripeClasses = [];
            this.asDestroyStripes = [];
            this.sDestroyWidth = 0;
            this.fnRowCallback = null;
            this.fnFilterCallback = null;
            this.fnHeaderCallback = null;
            this.fnFooterCallback = null;
            this.aoDrawCallback = [];
            this.fnPreDrawCallback = null;
            this.fnInitComplete = null;
            this.sTableId = "";
            this.nTable = null;
            this.nTHead = null;
            this.nTFoot = null;
            this.nTBody = null;
            this.nTableWrapper = null;
            this.bDeferLoading = false;
            this.bInitialised = false;
            this.aoOpenRows = [];
            this.sDom = "lfrtip";
            this.sPaginationType = "two_button";
            this.iCookieDuration = 60 * 60 * 2;
            this.sCookiePrefix = "SpryMedia_DataTables_";
            this.fnCookieCallback = null;
            this.aoStateSave = [];
            this.aoStateLoad = [];
            this.oLoadedState = null;
            this.sAjaxSource = null;
            this.sAjaxDataProp = "aaData";
            this.bAjaxDataGet = true;
            this.jqXHR = null;
            this.fnServerData = function(url, data, callback, settings) {
                settings.jqXHR = $.ajax({
                    url: url,
                    data: data,
                    success: function(json) {
                        $(settings.oInstance).trigger("xhr", settings);
                        callback(json)
                    },
                    dataType: "json",
                    cache: false,
                    error: function(xhr, error, thrown) {
                        if (error == "parsererror") {
                            alert("DataTables warning: JSON data from server could not be parsed. This is caused by a JSON formatting error.")
                        }
                    }
                })
            };
            this.aoServerParams = [];
            this.fnFormatNumber = function(iIn) {
                if (iIn < 1000) {
                    return iIn
                } else {
                    var s = (iIn + ""),
                        a = s.split(""),
                        out = "",
                        iLen = s.length;
                    for (var i = 0; i < iLen; i++) {
                        if (i % 3 === 0 && i !== 0) {
                            out = this.oLanguage.sInfoThousands + out
                        }
                        out = a[iLen - i - 1] + out
                    }
                }
                return out
            };
            this.aLengthMenu = [10, 25, 50, 100];
            this.iDraw = 0;
            this.bDrawing = 0;
            this.iDrawError = -1;
            this._iDisplayLength = 10;
            this._iDisplayStart = 0;
            this._iDisplayEnd = 10;
            this._iRecordsTotal = 0;
            this._iRecordsDisplay = 0;
            this.bJUI = false;
            this.oClasses = _oExt.oStdClasses;
            this.bFiltered = false;
            this.bSorted = false;
            this.bSortCellsTop = false;
            this.oInit = null;
            this.aoDestroyCallback = []
        }
        this.oApi = {};
        this.fnDraw = function(bComplete) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (typeof bComplete != "undefined" && bComplete === false) {
                _fnCalculateEnd(oSettings);
                _fnDraw(oSettings)
            } else {
                _fnReDraw(oSettings)
            }
        };
        this.fnFindCellRowIndexes = function(sSearch, iColumn) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var i, iLen, j, jLen, val, aOut = [],
                aData, columns = oSettings.aoColumns;
            for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                aData = oSettings.aoData[i]._aData;
                if (iColumn === undefined) {
                    for (j = 0, jLen = columns.length; j < jLen; j++) {
                        val = this.fnGetData(i, j);
                        if (val == sSearch) {
                            aOut.push(i)
                        }
                    }
                } else {
                    if (this.fnGetData(i, iColumn) == sSearch) {
                        aOut.push(i)
                    }
                }
            }
            return aOut
        };
        this.fnGetFilteredNodes = function() {
            var anRows = [];
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            for (var i = 0, iLen = oSettings.aiDisplay.length; i < iLen; i++) {
                var nRow = oSettings.aoData[oSettings.aiDisplay[i]].nTr;
                anRows.push(nRow)
            }
            return anRows
        };
        this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (!oSettings.oFeatures.bFilter) {
                return
            }
            if (typeof bRegex == "undefined") {
                bRegex = false
            }
            if (typeof bSmart == "undefined") {
                bSmart = true
            }
            if (typeof bShowGlobal == "undefined") {
                bShowGlobal = true
            }
            if (typeof iColumn == "undefined" || iColumn === null) {
                _fnFilterComplete(oSettings, {
                    sSearch: sInput,
                    bRegex: bRegex,
                    bSmart: bSmart
                }, 1);
                if (bShowGlobal && typeof oSettings.aanFeatures.f != "undefined") {
                    var n = oSettings.aanFeatures.f;
                    for (var i = 0, iLen = n.length; i < iLen; i++) {
                        $("input", n[i]).val(sInput)
                    }
                }
            } else {
                oSettings.aoPreSearchCols[iColumn].sSearch = sInput;
                oSettings.aoPreSearchCols[iColumn].bRegex = bRegex;
                oSettings.aoPreSearchCols[iColumn].bSmart = bSmart;
                _fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1);
                if (bShowGlobal && oSettings.aoColumns[iColumn].bFilterMenu) {
                    var filterSpan$ = $("span.colFilter", oSettings.aoColumns[iColumn].nTh);
                    if (sInput) {
                        filterSpan$.removeClass("colFilter_on colFilter_off").addClass("colFilter_on")
                    } else {
                        filterSpan$.removeClass("colFilter_on colFilter_off").addClass("colFilter_off")
                    }
                }
            }
        };
        this.fnSettings = function(nNode) {
            return _fnSettingsFromNode(this[_oExt.iApiIndex])
        };
        this.fnVersionCheck = _oExt.fnVersionCheck;
        this.fnSort = function(aaSort) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            oSettings.aaSorting = aaSort;
            _fnSort(oSettings)
        };
        this.fnSortListener = function(nNode, iColumn, fnCallback) {
            _fnSortAttachListener(_fnSettingsFromNode(this[_oExt.iApiIndex]), nNode, iColumn, fnCallback)
        };
        this.fnAddData = function(mData, bRedraw) {
            if (mData.length === 0) {
                return []
            }
            var aiReturn = [];
            var iTest;
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (typeof mData[0] == "object") {
                for (var i = 0; i < mData.length; i++) {
                    iTest = _fnAddData(oSettings, mData[i]);
                    if (iTest == -1) {
                        return aiReturn
                    }
                    aiReturn.push(iTest)
                }
            } else {
                iTest = _fnAddData(oSettings, mData);
                if (iTest == -1) {
                    return aiReturn
                }
                aiReturn.push(iTest)
            }
            _fnCalculateMostFreq(oSettings);
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            if (typeof bRedraw == "undefined" || bRedraw) {
                _fnReDraw(oSettings)
            }
            return aiReturn
        };
        this.fnDeleteRow = function(mTarget, fnCallBack, bRedraw) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var i, iAODataIndex;
            iAODataIndex = (typeof mTarget == "object") ? _fnNodeToDataIndex(oSettings, mTarget) : mTarget;
            var oData = oSettings.aoData.splice(iAODataIndex, 1);
            var iDisplayIndex = $.inArray(iAODataIndex, oSettings.aiDisplay);
            oSettings.asDataSearch.splice(iDisplayIndex, 1);
            _fnDeleteIndex(oSettings.aiDisplayMaster, iAODataIndex);
            _fnDeleteIndex(oSettings.aiDisplay, iAODataIndex);
            if (typeof fnCallBack == "function") {
                fnCallBack.call(this, oSettings, oData)
            }
            if (oSettings._iDisplayStart >= oSettings.aiDisplay.length) {
                oSettings._iDisplayStart -= oSettings._iDisplayLength;
                if (oSettings._iDisplayStart < 0) {
                    oSettings._iDisplayStart = 0
                }
            }
            if (typeof bRedraw == "undefined" || bRedraw) {
                _fnCalculateEnd(oSettings);
                _fnDraw(oSettings)
            }
            return oData
        };
        this.fnClearTable = function(bRedraw) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            _fnClearTable(oSettings);
            if (typeof bRedraw == "undefined" || bRedraw) {
                _fnDraw(oSettings)
            }
        };
        this.fnOpen = function(nTr, mHtml, sClass) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            this.fnClose(nTr);
            var nNewRow = document.createElement("tr");
            var nNewCell = document.createElement("td");
            nNewRow.appendChild(nNewCell);
            nNewCell.className = sClass;
            nNewCell.colSpan = _fnVisbleColumns(oSettings);
            if (typeof mHtml.jquery != "undefined" || typeof mHtml == "object") {
                nNewCell.appendChild(mHtml)
            } else {
                nNewCell.innerHTML = mHtml
            }
            var nTrs = $("tr", oSettings.nTBody);
            if ($.inArray(nTr, nTrs) != -1) {
                $(nNewRow).insertAfter(nTr)
            }
            oSettings.aoOpenRows.push({
                nTr: nNewRow,
                nParent: nTr
            });
            return nNewRow
        };
        this.fnClose = function(nTr) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            for (var i = 0; i < oSettings.aoOpenRows.length; i++) {
                if (oSettings.aoOpenRows[i].nParent == nTr) {
                    var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
                    if (nTrParent) {
                        nTrParent.removeChild(oSettings.aoOpenRows[i].nTr)
                    }
                    oSettings.aoOpenRows.splice(i, 1);
                    return 0
                }
            }
            return 1
        };
        this.fnGetData = function(mRow, iCol) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (typeof mRow != "undefined") {
                var iRow = (typeof mRow == "object") ? _fnNodeToDataIndex(oSettings, mRow) : mRow;
                if (typeof iCol != "undefined") {
                    return _fnGetCellData(oSettings, iRow, iCol, "")
                }
                return (typeof oSettings.aoData[iRow] != "undefined") ? oSettings.aoData[iRow]._aData : null
            }
            return _fnGetDataMaster(oSettings)
        };
        this.fnGetNodes = function(iRow) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (typeof iRow != "undefined") {
                return (typeof oSettings.aoData[iRow] != "undefined") ? oSettings.aoData[iRow].nTr : null
            }
            return _fnGetTrNodes(oSettings)
        };
        this.fnGetTd = function(iRow, iCol) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            if (iRow == undefined || iCol == undefined) {
                return null
            }
            var tdNodes = _fnGetTdNodes(oSettings, iRow);
            if (!tdNodes || tdNodes.length == 0) {
                return null
            }
            return tdNodes[iCol]
        };
        this.fnGetPosition = function(nNode) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var sNodeName = nNode.nodeName.toUpperCase();
            if (sNodeName == "TR") {
                return _fnNodeToDataIndex(oSettings, nNode)
            } else {
                if (sNodeName == "TD" || sNodeName == "TH") {
                    var iDataIndex = _fnNodeToDataIndex(oSettings, nNode.parentNode);
                    var anCells = _fnGetTdNodes(oSettings, iDataIndex);
                    for (var i = 0; i < oSettings.aoColumns.length; i++) {
                        if (anCells[i] == nNode) {
                            return [iDataIndex, _fnColumnIndexToVisible(oSettings, i), i]
                        }
                    }
                }
            }
            return null
        };
        this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var iVisibleColumn, i, iLen, sDisplay;
            var iRow = (typeof mRow == "object") ? _fnNodeToDataIndex(oSettings, mRow) : mRow;
            if ($.isArray(mData) && typeof mData == "object" && (iColumn == undefined || iColumn == -1)) {
                oSettings.aoData[iRow]._aData = mData.slice();
                for (i = 0; i < oSettings.aoColumns.length; i++) {
                    this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false)
                }
            } else {
                if (mData !== null && typeof mData == "object" && (iColumn == undefined || iColumn == -1)) {
                    oSettings.aoData[iRow]._aData = $.extend(true, {}, mData);
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        this.fnUpdate(_fnGetCellData(oSettings, iRow, i), iRow, i, false, false)
                    }
                } else {
                    if (iColumn != undefined && iColumn != -1) {
                        sDisplay = mData;
                        _fnSetCellData(oSettings, iRow, iColumn, sDisplay);
                        if (oSettings.aoColumns[iColumn].fnRender !== null) {
                            sDisplay = oSettings.aoColumns[iColumn].fnRender({
                                iDataRow: iRow,
                                iDataColumn: iColumn,
                                aData: oSettings.aoData[iRow]._aData,
                                oSettings: oSettings
                            });
                            if (oSettings.aoColumns[iColumn].bUseRendered) {
                                _fnSetCellData(oSettings, iRow, iColumn, sDisplay)
                            }
                        }
                        if (oSettings.aoData[iRow].nTr !== null) {
                            _fnGetTdNodes(oSettings, iRow)[iColumn].innerHTML = sDisplay
                        }
                    }
                }
            }
            var iDisplayIndex = $.inArray(iRow, oSettings.aiDisplay);
            oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow(oSettings, _fnGetRowData(oSettings, iRow, "filter"));
            if (typeof bAction == "undefined" || bAction) {
                _fnAdjustColumnSizing(oSettings)
            }
            if (typeof bRedraw == "undefined" || bRedraw === true) {
                _fnReDraw(oSettings)
            } else {
                if (bRedraw == "keepPage") {
                    _fnStandingReDraw(oSettings)
                }
            }
            return 0
        };
        this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var i, iLen;
            var iColumns = oSettings.aoColumns.length;
            var nTd, nCell, anTrs, jqChildren, bAppend, iBefore;
            if (oSettings.aoColumns[iCol].bVisible == bShow) {
                return
            }
            if (bShow) {
                var iInsert = 0;
                for (i = 0; i < iCol; i++) {
                    if (oSettings.aoColumns[i].bVisible) {
                        iInsert++
                    }
                }
                bAppend = (iInsert >= _fnVisbleColumns(oSettings));
                if (!bAppend) {
                    for (i = iCol; i < iColumns; i++) {
                        if (oSettings.aoColumns[i].bVisible) {
                            iBefore = i;
                            break
                        }
                    }
                }
                for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                    if (oSettings.aoData[i].nTr !== null) {
                        if (bAppend) {
                            oSettings.aoData[i].nTr.appendChild(oSettings.aoData[i]._anHidden[iCol])
                        } else {
                            oSettings.aoData[i].nTr.insertBefore(oSettings.aoData[i]._anHidden[iCol], _fnGetTdNodes(oSettings, i)[iBefore])
                        }
                    }
                }
            } else {
                for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                    if (oSettings.aoData[i].nTr !== null) {
                        nTd = _fnGetTdNodes(oSettings, i)[iCol];
                        oSettings.aoData[i]._anHidden[iCol] = nTd;
                        nTd.parentNode.removeChild(nTd)
                    }
                }
            }
            oSettings.aoColumns[iCol].bVisible = bShow;
            _fnDrawHead(oSettings, oSettings.aoHeader);
            if (oSettings.nTFoot) {
                _fnDrawHead(oSettings, oSettings.aoFooter)
            }
            for (i = 0, iLen = oSettings.aoOpenRows.length; i < iLen; i++) {
                oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns(oSettings)
            }
            if (typeof bRedraw == "undefined" || bRedraw) {
                _fnAdjustColumnSizing(oSettings);
                _fnDraw(oSettings)
            }
            _fnSaveState(oSettings)
        };
        this.fnPageChange = function(mAction, bRedraw) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            _fnPageChange(oSettings, mAction);
            _fnCalculateEnd(oSettings);
            if (typeof bRedraw == "undefined" || bRedraw) {
                _fnDraw(oSettings)
            }
        };
        this.fnDestroy = function() {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            var nOrig = oSettings.nTableWrapper.parentNode;
            var nBody = oSettings.nTBody;
            var i, iLen;
            oSettings.bDestroying = true;
            for (i = 0, iLen = oSettings.aoDestroyCallback.length; i < iLen; i++) {
                oSettings.aoDestroyCallback[i].fn()
            }
            for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                if (oSettings.aoColumns[i].bVisible === false) {
                    this.fnSetColumnVis(i, true)
                }
            }
            $(oSettings.nTableWrapper).find("*").andSelf().unbind(".DT");
            $("tbody>tr>td." + oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();
            if (oSettings.nTable != oSettings.nTHead.parentNode) {
                $(oSettings.nTable).children("thead").remove();
                oSettings.nTable.appendChild(oSettings.nTHead)
            }
            if (oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode) {
                $(oSettings.nTable).children("tfoot").remove();
                oSettings.nTable.appendChild(oSettings.nTFoot)
            }
            oSettings.nTable.parentNode.removeChild(oSettings.nTable);
            $(oSettings.nTableWrapper).remove();
            oSettings.aaSorting = [];
            oSettings.aaSortingFixed = [];
            _fnSortingClasses(oSettings);
            $(_fnGetTrNodes(oSettings)).removeClass(oSettings.asStripeClasses.join(" "));
            if (!oSettings.bJUI) {
                $("th", oSettings.nTHead).removeClass([_oExt.oStdClasses.sSortable, _oExt.oStdClasses.sSortableAsc, _oExt.oStdClasses.sSortableDesc, _oExt.oStdClasses.sSortableNone].join(" "))
            } else {
                $("th", oSettings.nTHead).removeClass([_oExt.oStdClasses.sSortable, _oExt.oJUIClasses.sSortableAsc, _oExt.oJUIClasses.sSortableDesc, _oExt.oJUIClasses.sSortableNone].join(" "));
                $("th span." + _oExt.oJUIClasses.sSortIcon, oSettings.nTHead).remove();
                $("th", oSettings.nTHead).each(function() {
                    var jqWrapper = $("div." + _oExt.oJUIClasses.sSortJUIWrapper, this);
                    var kids = jqWrapper.contents();
                    $(this).append(kids);
                    jqWrapper.remove()
                })
            }
            if (oSettings.nTableReinsertBefore) {
                nOrig.insertBefore(oSettings.nTable, oSettings.nTableReinsertBefore)
            } else {
                nOrig.appendChild(oSettings.nTable)
            }
            for (i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                if (oSettings.aoData[i].nTr !== null) {
                    nBody.appendChild(oSettings.aoData[i].nTr)
                }
            }
            if (oSettings.oFeatures.bAutoWidth === true) {
                oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth)
            }
            $(nBody).children("tr:even").addClass(oSettings.asDestroyStripes[0]);
            $(nBody).children("tr:odd").addClass(oSettings.asDestroyStripes[1]);
            for (i = 0, iLen = _aoSettings.length; i < iLen; i++) {
                if (_aoSettings[i] == oSettings) {
                    _aoSettings.splice(i, 1)
                }
            }
            oSettings = null
        };
        this.fnAdjustColumnSizing = function(bRedraw) {
            var oSettings = _fnSettingsFromNode(this[_oExt.iApiIndex]);
            _fnAdjustColumnSizing(oSettings);
            if (typeof bRedraw == "undefined" || bRedraw) {
                this.fnDraw(false)
            } else {
                if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
                    this.oApi._fnScrollDraw(oSettings)
                }
            }
        };
        this._fnHandleFilterMenuClick = function(e, done) {
            var decodeEntities = function(html) {
                var txt = document.createElement("textarea");
                txt.innerHTML = html;
                return txt.value
            };
            var target$ = $(e.target);
            var isText = target$.hasClass("colFilterInput");
            if (isText) {
                if (e.type == "click" && !done) {
                    return false
                }
            } else {
                target$ = target$.closest("li")
            }
            if (!target$ || target$.length == 0) {
                return
            }
            var value = "";
            var regex = false;
            var filterClass = "colFilter_on";
            if (isText) {
                value = target$.val()
            } else {
                value = decodeEntities(target$.html());
                if (value == strings.All) {
                    value = ""
                } else {
                    if (target$.hasClass("isColValue")) {
                        value = "/^" + _fnEscapeRegex(value) + "$/"
                    }
                }
            }
            var col = target$.attr("tableColumn");
            if (value == "") {
                filterClass = "colFilter_off"
            } else {
                if (value.charAt(0) == "/" && value.charAt(value.length - 1) == "/") {
                    value = value.substr(1, value.length - 2);
                    regex = true
                }
            }
            var oSettings = this.fnSettings();
            var filterSpan$ = $("span.colFilter", oSettings.aoColumns[col].nTh);
            filterSpan$.removeClass("colFilter_on colFilter_off").addClass(filterClass);
            this.fnFilter(value, col, regex);
            if (isText && e.keyCode == 13) {
                target$.trigger("click", true)
            }
        };

        function _fnExternApiFunc(sFunc) {
            return function() {
                var aArgs = [_fnSettingsFromNode(this[_oExt.iApiIndex])].concat(Array.prototype.slice.call(arguments));
                return _oExt.oApi[sFunc].apply(this, aArgs)
            }
        }
        for (var sFunc in _oExt.oApi) {
            if (sFunc) {
                this[sFunc] = _fnExternApiFunc(sFunc)
            }
        }

        function _fnInitialise(oSettings) {
            var i, iLen, iAjaxStart = oSettings.iInitDisplayStart;
            if (oSettings.bInitialised === false) {
                setTimeout(function() {
                    _fnInitialise(oSettings)
                }, 200);
                return
            }
            _fnAddOptionsHtml(oSettings);
            _fnBuildHead(oSettings);
            _fnDrawHead(oSettings, oSettings.aoHeader);
            if (oSettings.nTFoot) {
                _fnDrawHead(oSettings, oSettings.aoFooter)
            }
            _fnProcessingDisplay(oSettings, true);
            if (oSettings.oFeatures.bAutoWidth) {
                _fnCalculateColumnWidths(oSettings)
            }
            for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                if (oSettings.aoColumns[i].sWidth !== null) {
                    oSettings.aoColumns[i].nTh.style.width = _fnStringToCss(oSettings.aoColumns[i].sWidth)
                }
            }
            if (oSettings.oFeatures.bSort) {
                _fnSort(oSettings)
            } else {
                if (oSettings.oFeatures.bFilter) {
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch)
                } else {
                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings)
                }
            }
            if (oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
                var aoData = [];
                _fnServerParams(oSettings, aoData);
                oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData, function(json) {
                    var aData = json;
                    if (oSettings.sAjaxDataProp !== "") {
                        var fnDataSrc = _fnGetObjectDataFn(oSettings.sAjaxDataProp);
                        aData = fnDataSrc(json)
                    }
                    for (i = 0; i < aData.length; i++) {
                        _fnAddData(oSettings, aData[i])
                    }
                    oSettings.iInitDisplayStart = iAjaxStart;
                    if (oSettings.oFeatures.bSort) {
                        _fnSort(oSettings)
                    } else {
                        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                        _fnCalculateEnd(oSettings);
                        _fnDraw(oSettings)
                    }
                    _fnProcessingDisplay(oSettings, false);
                    _fnInitComplete(oSettings, json)
                }, oSettings);
                return
            }
            if (!oSettings.oFeatures.bServerSide) {
                _fnProcessingDisplay(oSettings, false);
                _fnInitComplete(oSettings)
            }
        }

        function _fnInitComplete(oSettings, json) {
            oSettings._bInitComplete = true;
            if (typeof oSettings.fnInitComplete == "function") {
                if (typeof json != "undefined") {
                    oSettings.fnInitComplete.call(oSettings.oInstance, oSettings, json)
                } else {
                    oSettings.fnInitComplete.call(oSettings.oInstance, oSettings)
                }
            }
        }

        function _fnLanguageProcess(oSettings, oLanguage, bInit) {
            oSettings.oLanguage = $.extend(true, oSettings.oLanguage, oLanguage);
            if (typeof oLanguage.sEmptyTable == "undefined" && typeof oLanguage.sZeroRecords != "undefined") {
                _fnMap(oSettings.oLanguage, oLanguage, "sZeroRecords", "sEmptyTable")
            }
            if (typeof oLanguage.sLoadingRecords == "undefined" && typeof oLanguage.sZeroRecords != "undefined") {
                _fnMap(oSettings.oLanguage, oLanguage, "sZeroRecords", "sLoadingRecords")
            }
            if (bInit) {
                _fnInitialise(oSettings)
            }
        }

        function _fnAddColumn(oSettings, nTh) {
            var iCol = oSettings.aoColumns.length;
            var oCol = {
                sType: null,
                _bAutoType: true,
                bVisible: true,
                bSearchable: true,
                bSortable: true,
                asSorting: ["asc", "desc"],
                sSortingClass: oSettings.oClasses.sSortable,
                sSortingClassJUI: oSettings.oClasses.sSortJUI,
                sTitle: nTh ? nTh.innerHTML : "",
                sName: "",
                sWidth: null,
                sWidthOrig: null,
                sClass: null,
                fnRender: null,
                bIsBasetype: false,
                bIsKey: false,
                bUseRendered: true,
                iDataSort: iCol,
                mDataProp: iCol,
                fnGetData: null,
                fnSetData: null,
                sSortDataType: "std",
                sDefaultContent: null,
                sContentPadding: "",
                nTh: nTh ? nTh : document.createElement("th"),
                nTf: null
            };
            oSettings.aoColumns.push(oCol);
            if (typeof oSettings.aoPreSearchCols[iCol] == "undefined" || oSettings.aoPreSearchCols[iCol] === null) {
                oSettings.aoPreSearchCols[iCol] = {
                    sSearch: "",
                    bRegex: false,
                    bSmart: true
                }
            } else {
                if (typeof oSettings.aoPreSearchCols[iCol].bRegex == "undefined") {
                    oSettings.aoPreSearchCols[iCol].bRegex = true
                }
                if (typeof oSettings.aoPreSearchCols[iCol].bSmart == "undefined") {
                    oSettings.aoPreSearchCols[iCol].bSmart = true
                }
            }
            _fnColumnOptions(oSettings, iCol, null)
        }

        function _fnColumnOptions(oSettings, iCol, oOptions) {
            var oCol = oSettings.aoColumns[iCol];
            if (typeof oOptions != "undefined" && oOptions !== null) {
                if (typeof oOptions.sType != "undefined") {
                    oCol.sType = oOptions.sType;
                    oCol._bAutoType = false
                }
                _fnMap(oCol, oOptions, "bVisible");
                _fnMap(oCol, oOptions, "bSearchable");
                _fnMap(oCol, oOptions, "bSortable");
                _fnMap(oCol, oOptions, "bFilterMenu");
                _fnMap(oCol, oOptions, "bIsBasetype");
                _fnMap(oCol, oOptions, "bIsKey");
                _fnMap(oCol, oOptions, "editable");
                _fnMap(oCol, oOptions, "sTitle");
                _fnMap(oCol, oOptions, "sName");
                _fnMap(oCol, oOptions, "sWidth");
                _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
                _fnMap(oCol, oOptions, "sClass");
                _fnMap(oCol, oOptions, "fnRender");
                _fnMap(oCol, oOptions, "bUseRendered");
                _fnMap(oCol, oOptions, "iDataSort");
                _fnMap(oCol, oOptions, "mDataProp");
                _fnMap(oCol, oOptions, "asSorting");
                _fnMap(oCol, oOptions, "sSortDataType");
                _fnMap(oCol, oOptions, "sDefaultContent");
                _fnMap(oCol, oOptions, "sContentPadding")
            }
            oCol.fnGetData = _fnGetObjectDataFn(oCol.mDataProp);
            oCol.fnSetData = _fnSetObjectDataFn(oCol.mDataProp);
            if (!oSettings.oFeatures.bSort) {
                oCol.bSortable = false
            }
            if (!oCol.bSortable || ($.inArray("asc", oCol.asSorting) == -1 && $.inArray("desc", oCol.asSorting) == -1)) {
                oCol.sSortingClass = oSettings.oClasses.sSortableNone;
                oCol.sSortingClassJUI = ""
            } else {
                if (oCol.bSortable || ($.inArray("asc", oCol.asSorting) == -1 && $.inArray("desc", oCol.asSorting) == -1)) {
                    oCol.sSortingClass = oSettings.oClasses.sSortable;
                    oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI
                } else {
                    if ($.inArray("asc", oCol.asSorting) != -1 && $.inArray("desc", oCol.asSorting) == -1) {
                        oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
                        oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed
                    } else {
                        if ($.inArray("asc", oCol.asSorting) == -1 && $.inArray("desc", oCol.asSorting) != -1) {
                            oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
                            oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed
                        }
                    }
                }
            }
        }

        function _fnAddData(oSettings, aDataSupplied) {
            var oCol;
            var aDataIn = {};
            if (aDataSupplied instanceof APIObject) {
                if (oSettings.oFeatures.oCriteria && !aDataSupplied.matches(oSettings.oFeatures.oCriteria)) {
                    return
                }
                aDataIn = {
                    prop: {}
                };
                for (var prop in aDataSupplied.prop) {
                    aDataIn.prop[prop] = {
                        text: aDataSupplied.prop[prop].text
                    }
                }
                var key = aDataSupplied.getKeyValue();
                if (key) {
                    aDataIn.DT_RowId = oSettings.sTableId + "_" + aDataSupplied.basetype + "_" + key
                }
            } else {
                aDataIn = ($.isArray(aDataSupplied)) ? aDataSupplied.slice() : $.extend(true, {}, aDataSupplied)
            }
            var iRow = oSettings.aoData.length;
            var oData = {
                nTr: null,
                _iId: oSettings.iNextId++,
                _aData: aDataIn,
                _anHidden: [],
                _sRowStripe: ""
            };
            oSettings.aoData.push(oData);
            var nTd, sThisType;
            var basetype = oSettings.oFeatures.sBasetype || "";
            var key;
            for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                oCol = oSettings.aoColumns[i];
                var cellData = aDataIn[i];
                if (typeof oCol.fnRender == "function" && oCol.bUseRendered && oCol.mDataProp !== null) {
                    cellData = oCol.fnRender({
                        iDataRow: iRow,
                        iDataColumn: i,
                        aData: oData._aData,
                        oSettings: oSettings
                    });
                    _fnSetCellData(oSettings, iRow, i, cellData)
                }
                if (oCol.bIsBasetype) {
                    basetype = cellData
                }
                if (oCol.bIsKey) {
                    key = cellData
                }
                if (oCol._bAutoType && oCol.sType != "string") {
                    var sVarType = _fnGetCellData(oSettings, iRow, i, "type");
                    if (sVarType !== null && sVarType !== "") {
                        sThisType = _fnDetectType(sVarType);
                        if (oCol.sType === null) {
                            oCol.sType = sThisType
                        } else {
                            if (oCol.sType != sThisType && oCol.sType != "html") {
                                oCol.sType = "string"
                            }
                        }
                    }
                }
                if (oSettings.oFeatures.bFilter && oCol.bFilterMenu && !oCol.bFilterMenu.list) {
                    if (oCol.valueFreq == undefined) {
                        oCol.valueFreq = {}
                    }
                    var sData = _fnGetCellData(oSettings, iRow, i, "filter");
                    if (oCol.sType == "numeric" || (oCol.sType == "string" && sData.length > 0 && sData.length < 120)) {
                        if (oCol.valueFreq[sData] == undefined) {
                            oCol.valueFreq[sData] = 1
                        } else {
                            oCol.valueFreq[sData]++
                        }
                    }
                }
            }
            if (key && aDataIn.DT_RowId == undefined) {
                aDataIn.DT_RowId = oSettings.sTableId + "_" + basetype + "_" + key
            }
            oSettings.aiDisplayMaster.push(iRow);
            if (!oSettings.oFeatures.bDeferRender) {
                _fnCreateTr(oSettings, iRow)
            }
            return iRow
        }

        function _fnCalculateMostFreq(oSettings) {
            var columns = oSettings.aoColumns;
            for (var col = 0; col < columns.length; col++) {
                var oCol = columns[col];
                if (oCol.bFilterMenu) {
                    if (oCol.bFilterMenu.list) {
                        oCol.mostFreq = [];
                        for (var i = 0, len = oCol.bFilterMenu.list.length; i < len; i++) {
                            oCol.mostFreq.push({
                                value: oCol.bFilterMenu.list[i]
                            })
                        }
                    } else {
                        if (oCol.mostFreq == undefined) {
                            oCol.mostFreq = [];
                            if (oCol.bFilterMenu.numItems != undefined) {
                                var numItems = oCol.bFilterMenu.numItems
                            } else {
                                var numItems = 10
                            }
                            for (var i = 0; i < numItems; i++) {
                                oCol.mostFreq.push({
                                    value: "",
                                    occurs: 0
                                })
                            }
                        }
                        for (var value in oCol.valueFreq) {
                            if (oCol.valueFreq[value] <= 1 && !oCol.bFilterMenu.allowSingles) {
                                continue
                            }
                            var index = oCol.mostFreq.length - 1;
                            var found = false;
                            while (index >= 0 && oCol.valueFreq[value] > oCol.mostFreq[index].occurs) {
                                found = true;
                                index--
                            }
                            if (found) {
                                index++;
                                oCol.mostFreq.splice(index, 0, {
                                    value: value,
                                    isColValue: true,
                                    occurs: oCol.valueFreq[value]
                                });
                                oCol.mostFreq.pop()
                            }
                        }
                        if (oCol.sType == "numeric") {
                            oCol.mostFreq.sort(function(a, b) {
                                return parseFloat(a.value) - parseFloat(b.value)
                            })
                        }
                    }
                }
            }
        }

        function _fnCreateTr(oSettings, iRow) {
            var oData = oSettings.aoData[iRow];
            var nTd;
            if (oData.nTr === null) {
                oData.nTr = document.createElement("tr");
                if (typeof oData._aData.DT_RowId != "undefined") {
                    oData.nTr.setAttribute("id", oData._aData.DT_RowId)
                }
                if (typeof oData._aData.DT_RowClass != "undefined") {
                    $(oData.nTr).addClass(oData._aData.DT_RowClass)
                }
                for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    var oCol = oSettings.aoColumns[i];
                    nTd = document.createElement("td");
                    if (typeof oCol.fnRender == "function" && (!oCol.bUseRendered || oCol.mDataProp === null)) {
                        nTd.innerHTML = oCol.fnRender({
                            iDataRow: iRow,
                            iDataColumn: i,
                            aData: oData._aData,
                            oSettings: oSettings
                        })
                    } else {
                        nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, "display")
                    }
                    if (oCol.sClass !== null) {
                        nTd.className = oCol.sClass
                    }
                    if (oCol.bVisible) {
                        oData.nTr.appendChild(nTd);
                        oData._anHidden[i] = null
                    } else {
                        oData._anHidden[i] = nTd
                    }
                }
            }
        }

        function _fnGatherData(oSettings) {
            var iLoop, i, iLen, j, jLen, jInner, nTds, nTrs, nTd, aLocalData, iThisIndex, iRow, iRows, iColumn, iColumns, sNodeName;
            if (oSettings.bDeferLoading || oSettings.sAjaxSource === null) {
                nTrs = oSettings.nTBody.childNodes;
                for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                    if (nTrs[i].nodeName.toUpperCase() == "TR") {
                        iThisIndex = oSettings.aoData.length;
                        oSettings.aoData.push({
                            nTr: nTrs[i],
                            _iId: oSettings.iNextId++,
                            _aData: [],
                            _anHidden: [],
                            _sRowStripe: ""
                        });
                        oSettings.aiDisplayMaster.push(iThisIndex);
                        nTds = nTrs[i].childNodes;
                        jInner = 0;
                        for (j = 0, jLen = nTds.length; j < jLen; j++) {
                            sNodeName = nTds[j].nodeName.toUpperCase();
                            if (sNodeName == "TD" || sNodeName == "TH") {
                                _fnSetCellData(oSettings, iThisIndex, jInner, $.trim(nTds[j].innerHTML));
                                jInner++
                            }
                        }
                    }
                }
            }
            nTrs = _fnGetTrNodes(oSettings);
            nTds = [];
            for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                for (j = 0, jLen = nTrs[i].childNodes.length; j < jLen; j++) {
                    nTd = nTrs[i].childNodes[j];
                    sNodeName = nTd.nodeName.toUpperCase();
                    if (sNodeName == "TD" || sNodeName == "TH") {
                        nTds.push(nTd)
                    }
                }
            }
            if (nTds.length != nTrs.length * oSettings.aoColumns.length) {
                _fnLog(oSettings, 1, "Unexpected number of TD elements. Expected " + (nTrs.length * oSettings.aoColumns.length) + " and got " + nTds.length + ". DataTables does not support rowspan / colspan in the table body, and there must be one cell for each row/column combination.")
            }
            for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
                if (oSettings.aoColumns[iColumn].sTitle === null) {
                    oSettings.aoColumns[iColumn].sTitle = oSettings.aoColumns[iColumn].nTh.innerHTML
                }
                var bAutoType = oSettings.aoColumns[iColumn]._bAutoType,
                    bRender = typeof oSettings.aoColumns[iColumn].fnRender == "function",
                    bClass = oSettings.aoColumns[iColumn].sClass !== null,
                    bVisible = oSettings.aoColumns[iColumn].bVisible,
                    nCell, sThisType, sRendered, sValType;
                if (bAutoType || bRender || bClass || !bVisible) {
                    for (iRow = 0, iRows = oSettings.aoData.length; iRow < iRows; iRow++) {
                        nCell = nTds[(iRow * iColumns) + iColumn];
                        if (bAutoType && oSettings.aoColumns[iColumn].sType != "string") {
                            sValType = _fnGetCellData(oSettings, iRow, iColumn, "type");
                            if (sValType !== "") {
                                sThisType = _fnDetectType(sValType);
                                if (oSettings.aoColumns[iColumn].sType === null) {
                                    oSettings.aoColumns[iColumn].sType = sThisType
                                } else {
                                    if (oSettings.aoColumns[iColumn].sType != sThisType && oSettings.aoColumns[iColumn].sType != "html") {
                                        oSettings.aoColumns[iColumn].sType = "string"
                                    }
                                }
                            }
                        }
                        if (bRender) {
                            sRendered = oSettings.aoColumns[iColumn].fnRender({
                                iDataRow: iRow,
                                iDataColumn: iColumn,
                                aData: oSettings.aoData[iRow]._aData,
                                oSettings: oSettings
                            });
                            nCell.innerHTML = sRendered;
                            if (oSettings.aoColumns[iColumn].bUseRendered) {
                                _fnSetCellData(oSettings, iRow, iColumn, sRendered)
                            }
                        }
                        if (bClass) {
                            nCell.className += " " + oSettings.aoColumns[iColumn].sClass
                        }
                        if (!bVisible) {
                            oSettings.aoData[iRow]._anHidden[iColumn] = nCell;
                            nCell.parentNode.removeChild(nCell)
                        } else {
                            oSettings.aoData[iRow]._anHidden[iColumn] = null
                        }
                    }
                }
            }
        }

        function _fnBuildHead(oSettings) {
            var i, nTh, iLen, j, jLen;
            var anTr = oSettings.nTHead.getElementsByTagName("tr");
            var iThs = oSettings.nTHead.getElementsByTagName("th").length;
            var iCorrector = 0;
            var jqChildren;
            var filterMenuId = oSettings.sTableId + "filtermenu";
            if (!oSettings.nFilterMenu) {
                oSettings.nFilterMenu = $('<ul id="' + filterMenuId + '" style="display: none;"></ul>').appendTo(oSettings.nTableWrapper);
                oSettings.nFilterMenu.click(createObjectCallback(oSettings.oInstance, oSettings.oInstance._fnHandleFilterMenuClick))
            }
            if (iThs !== 0) {
                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    nTh = oSettings.aoColumns[i].nTh;
                    if (oSettings.aoColumns[i].sClass !== null) {
                        $(nTh).addClass(oSettings.aoColumns[i].sClass)
                    }
                    if (oSettings.aoColumns[i].sTitle != nTh.innerHTML) {
                        nTh.innerHTML = '<span class="colTitle">' + oSettings.aoColumns[i].sTitle + "</span"
                    }
                }
            } else {
                var nTr = document.createElement("tr");
                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    nTh = oSettings.aoColumns[i].nTh;
                    nTh.innerHTML = '<span class="colTitle">' + oSettings.aoColumns[i].sTitle + "</span>";
                    if (oSettings.aoColumns[i].sClass !== null) {
                        $(nTh).addClass(oSettings.aoColumns[i].sClass)
                    }
                    nTr.appendChild(nTh)
                }
                $(oSettings.nTHead).html("")[0].appendChild(nTr);
                _fnDetectHeader(oSettings.aoHeader, oSettings.nTHead)
            }
            if (oSettings.bJUI) {
                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    nTh = oSettings.aoColumns[i].nTh;
                    var nDiv = document.createElement("div");
                    nDiv.className = oSettings.oClasses.sSortJUIWrapper;
                    $(nTh).contents().appendTo(nDiv);
                    var nSpan = document.createElement("span");
                    nSpan.className = oSettings.oClasses.sSortIcon;
                    nDiv.appendChild(nSpan);
                    nTh.appendChild(nDiv)
                }
            }
            var fnNoSelect = function(e) {
                this.onselectstart = function() {
                    return false
                };
                return false
            };
            for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                var oCol = oSettings.aoColumns[i];
                if (oSettings.oFeatures.bFilter && oCol.bFilterMenu) {
                    var filterElem = $('<span class="colFilter colFilter_off"></span>').appendTo(oSettings.aoColumns[i].nTh);
                    oCol.filterMenu = filterElem.contextMenu("#" + filterMenuId, createObjectCallback(oSettings, _fnCreateFilterMenu, i), true)
                }
            }
            if (oSettings.oFeatures.bSort) {
                for (i = 0; i < oSettings.aoColumns.length; i++) {
                    if (oSettings.aoColumns[i].bSortable !== false) {
                        var sortElem = $('<span class="dtSortable"></span>').appendTo(oSettings.aoColumns[i].nTh);
                        _fnSortAttachListener(oSettings, oSettings.aoColumns[i].nTh, i);
                        $(oSettings.aoColumns[i].nTh).bind("mousedown.DT", fnNoSelect)
                    } else {
                        $(oSettings.aoColumns[i].nTh).addClass(oSettings.oClasses.sSortableNone)
                    }
                }
            }
            if (oSettings.oClasses.sFooterTH !== "") {
                $(oSettings.nTFoot).children("tr").children("th").addClass(oSettings.oClasses.sFooterTH)
            }
            if (oSettings.nTFoot !== null) {
                var anCells = _fnGetUniqueThs(oSettings, null, oSettings.aoFooter);
                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                    if (typeof anCells[i] != "undefined") {
                        oSettings.aoColumns[i].nTf = anCells[i]
                    }
                }
            }
        }

        function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
            var i, iLen, j, jLen, k, kLen;
            var aoLocal = [];
            var aApplied = [];
            var iColumns = oSettings.aoColumns.length;
            var iRowspan, iColspan;
            if (typeof bIncludeHidden == "undefined") {
                bIncludeHidden = false
            }
            for (i = 0, iLen = aoSource.length; i < iLen; i++) {
                aoLocal[i] = aoSource[i].slice();
                aoLocal[i].nTr = aoSource[i].nTr;
                for (j = iColumns - 1; j >= 0; j--) {
                    if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {
                        aoLocal[i].splice(j, 1)
                    }
                }
                aApplied.push([])
            }
            for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
                if (aoLocal[i].nTr) {
                    for (k = 0, kLen = aoLocal[i].nTr.childNodes.length; k < kLen; k++) {
                        aoLocal[i].nTr.removeChild(aoLocal[i].nTr.childNodes[0])
                    }
                }
                for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {
                    iRowspan = 1;
                    iColspan = 1;
                    if (typeof aApplied[i][j] == "undefined") {
                        aoLocal[i].nTr.appendChild(aoLocal[i][j].cell);
                        aApplied[i][j] = 1;
                        while (typeof aoLocal[i + iRowspan] != "undefined" && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {
                            aApplied[i + iRowspan][j] = 1;
                            iRowspan++
                        }
                        while (typeof aoLocal[i][j + iColspan] != "undefined" && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {
                            for (k = 0; k < iRowspan; k++) {
                                aApplied[i + k][j + iColspan] = 1
                            }
                            iColspan++
                        }
                        aoLocal[i][j].cell.rowSpan = iRowspan;
                        aoLocal[i][j].cell.colSpan = iColspan
                    }
                }
            }
        }

        function _fnDraw(oSettings) {
            var i, iLen;
            var anRows = [];
            var iRowCount = 0;
            var bRowError = false;
            var iStripes = oSettings.asStripeClasses.length;
            var iOpenRows = oSettings.aoOpenRows.length;
            if (oSettings.fnPreDrawCallback !== null && oSettings.fnPreDrawCallback.call(oSettings.oInstance, oSettings) === false) {
                return
            }
            oSettings.bDrawing = true;
            if (typeof oSettings.iInitDisplayStart != "undefined" && oSettings.iInitDisplayStart != -1) {
                if (oSettings.oFeatures.bServerSide) {
                    oSettings._iDisplayStart = oSettings.iInitDisplayStart
                } else {
                    oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ? 0 : oSettings.iInitDisplayStart
                }
                oSettings.iInitDisplayStart = -1;
                _fnCalculateEnd(oSettings)
            }
            if (oSettings.bDeferLoading) {
                oSettings.bDeferLoading = false;
                oSettings.iDraw++
            } else {
                if (!oSettings.oFeatures.bServerSide) {
                    oSettings.iDraw++
                } else {
                    if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {
                        return
                    }
                }
            }
            if (oSettings.aiDisplay.length !== 0) {
                var iStart = oSettings._iDisplayStart;
                var iEnd = oSettings._iDisplayEnd;
                if (oSettings.oFeatures.bServerSide) {
                    iStart = 0;
                    iEnd = oSettings.aoData.length
                }
                for (var j = iStart; j < iEnd; j++) {
                    var aoData = oSettings.aoData[oSettings.aiDisplay[j]];
                    if (aoData.nTr === null) {
                        _fnCreateTr(oSettings, oSettings.aiDisplay[j])
                    }
                    var nRow = aoData.nTr;
                    if (iStripes !== 0) {
                        var sStripe = oSettings.asStripeClasses[iRowCount % iStripes];
                        if (aoData._sRowStripe != sStripe) {
                            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);
                            aoData._sRowStripe = sStripe
                        }
                    }
                    if (typeof oSettings.fnRowCallback == "function") {
                        nRow = oSettings.fnRowCallback.call(oSettings.oInstance, nRow, oSettings.aoData[oSettings.aiDisplay[j]]._aData, iRowCount, j);
                        if (!nRow && !bRowError) {
                            _fnLog(oSettings, 0, "A node was not returned by fnRowCallback");
                            bRowError = true
                        }
                    }
                    anRows.push(nRow);
                    iRowCount++;
                    if (iOpenRows !== 0) {
                        for (var k = 0; k < iOpenRows; k++) {
                            if (nRow == oSettings.aoOpenRows[k].nParent) {
                                anRows.push(oSettings.aoOpenRows[k].nTr)
                            }
                        }
                    }
                }
            } else {
                anRows[0] = document.createElement("tr");
                if (typeof oSettings.asStripeClasses[0] != "undefined") {
                    anRows[0].className = oSettings.asStripeClasses[0]
                }
                var sZero = oSettings.oLanguage.sZeroRecords.replace("_MAX_", oSettings.fnFormatNumber(oSettings.fnRecordsTotal()));
                if (oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide) {
                    sZero = oSettings.oLanguage.sLoadingRecords
                } else {
                    if (typeof oSettings.oLanguage.sEmptyTable != "undefined" && oSettings.fnRecordsTotal() === 0) {
                        sZero = oSettings.oLanguage.sEmptyTable
                    }
                }
                var nTd = document.createElement("td");
                nTd.setAttribute("valign", "top");
                nTd.colSpan = _fnVisbleColumns(oSettings);
                nTd.className = oSettings.oClasses.sRowEmpty;
                nTd.innerHTML = sZero;
                anRows[iRowCount].appendChild(nTd)
            }
            if (typeof oSettings.fnHeaderCallback == "function") {
                oSettings.fnHeaderCallback.call(oSettings.oInstance, $(oSettings.nTHead).children("tr")[0], _fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay)
            }
            if (typeof oSettings.fnFooterCallback == "function") {
                oSettings.fnFooterCallback.call(oSettings.oInstance, $(oSettings.nTFoot).children("tr")[0], _fnGetDataMaster(oSettings), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay)
            }
            var nAddFrag = document.createDocumentFragment(),
                nRemoveFrag = document.createDocumentFragment(),
                nBodyPar, nTrs;
            if (oSettings.nTBody) {
                nBodyPar = oSettings.nTBody.parentNode;
                nRemoveFrag.appendChild(oSettings.nTBody);
                if (!oSettings.oScroll.bInfinite || !oSettings._bInitComplete || oSettings.bSorted || oSettings.bFiltered) {
                    nTrs = oSettings.nTBody.childNodes;
                    for (i = nTrs.length - 1; i >= 0; i--) {
                        nTrs[i].parentNode.removeChild(nTrs[i])
                    }
                }
                for (i = 0, iLen = anRows.length; i < iLen; i++) {
                    nAddFrag.appendChild(anRows[i])
                }
                oSettings.nTBody.appendChild(nAddFrag);
                if (nBodyPar !== null) {
                    nBodyPar.appendChild(oSettings.nTBody)
                }
            }
            for (i = oSettings.aoDrawCallback.length - 1; i >= 0; i--) {
                oSettings.aoDrawCallback[i].fn.call(oSettings.oInstance, oSettings)
            }
            $(oSettings.oInstance).trigger("draw", oSettings);
            oSettings.bSorted = false;
            oSettings.bFiltered = false;
            oSettings.bDrawing = false;
            if (oSettings.oFeatures.bServerSide) {
                _fnProcessingDisplay(oSettings, false);
                if (typeof oSettings._bInitComplete == "undefined") {
                    _fnInitComplete(oSettings)
                }
            }
        }

        function _fnReDraw(oSettings) {
            if (oSettings.oFeatures.bSort) {
                _fnSort(oSettings, oSettings.oPreviousSearch)
            } else {
                if (oSettings.oFeatures.bFilter) {
                    _fnFilterComplete(oSettings, oSettings.oPreviousSearch)
                } else {
                    _fnCalculateEnd(oSettings);
                    _fnDraw(oSettings)
                }
            }
        }

        function _fnStandingReDraw(oSettings) {
            var before = oSettings._iDisplayStart;
            oSettings.oApi._fnReDraw(oSettings);
            oSettings._iDisplayStart = before;
            oSettings.oApi._fnCalculateEnd(oSettings);
            oSettings.oApi._fnDraw(oSettings)
        }

        function _fnAjaxUpdate(oSettings) {
            if (oSettings.bAjaxDataGet) {
                oSettings.iDraw++;
                _fnProcessingDisplay(oSettings, true);
                var iColumns = oSettings.aoColumns.length;
                var aoData = _fnAjaxParameters(oSettings);
                _fnServerParams(oSettings, aoData);
                oSettings.fnServerData.call(oSettings.oInstance, oSettings.sAjaxSource, aoData, function(json) {
                    _fnAjaxUpdateDraw(oSettings, json)
                }, oSettings);
                return false
            } else {
                return true
            }
        }

        function _fnAjaxParameters(oSettings) {
            var iColumns = oSettings.aoColumns.length;
            var aoData = [],
                mDataProp;
            var i;
            aoData.push({
                name: "sEcho",
                value: oSettings.iDraw
            });
            aoData.push({
                name: "iColumns",
                value: iColumns
            });
            aoData.push({
                name: "sColumns",
                value: _fnColumnOrdering(oSettings)
            });
            aoData.push({
                name: "iDisplayStart",
                value: oSettings._iDisplayStart
            });
            aoData.push({
                name: "iDisplayLength",
                value: oSettings.oFeatures.bPaginate !== false ? oSettings._iDisplayLength : -1
            });
            for (i = 0; i < iColumns; i++) {
                mDataProp = oSettings.aoColumns[i].mDataProp;
                aoData.push({
                    name: "mDataProp_" + i,
                    value: typeof(mDataProp) == "function" ? "function" : mDataProp
                })
            }
            if (oSettings.oFeatures.bFilter !== false) {
                aoData.push({
                    name: "sSearch",
                    value: oSettings.oPreviousSearch.sSearch
                });
                aoData.push({
                    name: "bRegex",
                    value: oSettings.oPreviousSearch.bRegex
                });
                for (i = 0; i < iColumns; i++) {
                    aoData.push({
                        name: "sSearch_" + i,
                        value: oSettings.aoPreSearchCols[i].sSearch
                    });
                    aoData.push({
                        name: "bRegex_" + i,
                        value: oSettings.aoPreSearchCols[i].bRegex
                    });
                    aoData.push({
                        name: "bSearchable_" + i,
                        value: oSettings.aoColumns[i].bSearchable
                    })
                }
            }
            if (oSettings.oFeatures.bSort !== false) {
                var iFixed = oSettings.aaSortingFixed !== null ? oSettings.aaSortingFixed.length : 0;
                var iUser = oSettings.aaSorting.length;
                aoData.push({
                    name: "iSortingCols",
                    value: iFixed + iUser
                });
                for (i = 0; i < iFixed; i++) {
                    aoData.push({
                        name: "iSortCol_" + i,
                        value: oSettings.aaSortingFixed[i][0]
                    });
                    aoData.push({
                        name: "sSortDir_" + i,
                        value: oSettings.aaSortingFixed[i][1]
                    })
                }
                for (i = 0; i < iUser; i++) {
                    aoData.push({
                        name: "iSortCol_" + (i + iFixed),
                        value: oSettings.aaSorting[i][0]
                    });
                    aoData.push({
                        name: "sSortDir_" + (i + iFixed),
                        value: oSettings.aaSorting[i][1]
                    })
                }
                for (i = 0; i < iColumns; i++) {
                    aoData.push({
                        name: "bSortable_" + i,
                        value: oSettings.aoColumns[i].bSortable
                    })
                }
            }
            return aoData
        }

        function _fnServerParams(oSettings, aoData) {
            for (var i = 0, iLen = oSettings.aoServerParams.length; i < iLen; i++) {
                oSettings.aoServerParams[i].fn.call(oSettings.oInstance, aoData)
            }
        }

        function _fnAjaxUpdateDraw(oSettings, json) {
            if (typeof json.sEcho != "undefined") {
                if (json.sEcho * 1 < oSettings.iDraw) {
                    return
                } else {
                    oSettings.iDraw = json.sEcho * 1
                }
            }
            if (!oSettings.oScroll.bInfinite || (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered))) {
                _fnClearTable(oSettings)
            }
            oSettings._iRecordsTotal = json.iTotalRecords;
            oSettings._iRecordsDisplay = json.iTotalDisplayRecords;
            var sOrdering = _fnColumnOrdering(oSettings);
            var bReOrder = (typeof json.sColumns != "undefined" && sOrdering !== "" && json.sColumns != sOrdering);
            if (bReOrder) {
                var aiIndex = _fnReOrderIndex(oSettings, json.sColumns)
            }
            var fnDataSrc = _fnGetObjectDataFn(oSettings.sAjaxDataProp);
            var aData = fnDataSrc(json);
            for (var i = 0, iLen = aData.length; i < iLen; i++) {
                if (bReOrder) {
                    var aDataSorted = [];
                    for (var j = 0, jLen = oSettings.aoColumns.length; j < jLen; j++) {
                        aDataSorted.push(aData[i][aiIndex[j]])
                    }
                    _fnAddData(oSettings, aDataSorted)
                } else {
                    _fnAddData(oSettings, aData[i])
                }
            }
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            oSettings.bAjaxDataGet = false;
            _fnDraw(oSettings);
            oSettings.bAjaxDataGet = true;
            _fnProcessingDisplay(oSettings, false)
        }

        function _fnAddOptionsHtml(oSettings) {
            var nHolding = document.createElement("div");
            oSettings.nTable.parentNode.insertBefore(nHolding, oSettings.nTable);
            oSettings.nTableWrapper = document.createElement("div");
            oSettings.nTableWrapper.className = oSettings.oClasses.sWrapper;
            if (oSettings.sTableId !== "") {
                oSettings.nTableWrapper.setAttribute("id", oSettings.sTableId + "_wrapper")
            }
            oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
            var nInsertNode = oSettings.nTableWrapper;
            var aDom = oSettings.sDom.split("");
            var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
            for (var i = 0; i < aDom.length; i++) {
                iPushFeature = 0;
                cOption = aDom[i];
                if (cOption == "<") {
                    nNewNode = document.createElement("div");
                    cNext = aDom[i + 1];
                    if (cNext == "'" || cNext == '"') {
                        sAttr = "";
                        j = 2;
                        while (aDom[i + j] != cNext) {
                            sAttr += aDom[i + j];
                            j++
                        }
                        if (sAttr == "H") {
                            sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix"
                        } else {
                            if (sAttr == "F") {
                                sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix"
                            }
                        }
                        if (sAttr.indexOf(".") != -1) {
                            var aSplit = sAttr.split(".");
                            nNewNode.setAttribute("id", aSplit[0].substr(1, aSplit[0].length - 1));
                            nNewNode.className = aSplit[1]
                        } else {
                            if (sAttr.charAt(0) == "#") {
                                nNewNode.setAttribute("id", sAttr.substr(1, sAttr.length - 1))
                            } else {
                                nNewNode.className = sAttr
                            }
                        }
                        i += j
                    }
                    nInsertNode.appendChild(nNewNode);
                    nInsertNode = nNewNode
                } else {
                    if (cOption == ">") {
                        nInsertNode = nInsertNode.parentNode
                    } else {
                        if (cOption == "l" && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange) {
                            nTmp = _fnFeatureHtmlLength(oSettings);
                            iPushFeature = 1
                        } else {
                            if (cOption == "f" && oSettings.oFeatures.bFilter) {
                                nTmp = _fnFeatureHtmlFilter(oSettings);
                                iPushFeature = 1
                            } else {
                                if (cOption == "r" && oSettings.oFeatures.bProcessing) {
                                    nTmp = _fnFeatureHtmlProcessing(oSettings);
                                    iPushFeature = 1
                                } else {
                                    if (cOption == "t") {
                                        nTmp = _fnFeatureHtmlTable(oSettings);
                                        iPushFeature = 1
                                    } else {
                                        if (cOption == "i" && oSettings.oFeatures.bInfo) {
                                            nTmp = _fnFeatureHtmlInfo(oSettings);
                                            iPushFeature = 1
                                        } else {
                                            if (cOption == "p" && oSettings.oFeatures.bPaginate) {
                                                nTmp = _fnFeatureHtmlPaginate(oSettings);
                                                iPushFeature = 1
                                            } else {
                                                if (_oExt.aoFeatures.length !== 0) {
                                                    var aoFeatures = _oExt.aoFeatures;
                                                    for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {
                                                        if (cOption == aoFeatures[k].cFeature) {
                                                            nTmp = aoFeatures[k].fnInit(oSettings);
                                                            if (nTmp) {
                                                                iPushFeature = 1
                                                            }
                                                            break
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (iPushFeature == 1 && nTmp !== null) {
                    if (typeof oSettings.aanFeatures[cOption] != "object") {
                        oSettings.aanFeatures[cOption] = []
                    }
                    oSettings.aanFeatures[cOption].push(nTmp);
                    nInsertNode.appendChild(nTmp)
                }
            }
            nHolding.parentNode.replaceChild(oSettings.nTableWrapper, nHolding)
        }

        function _fnFeatureHtmlTable(oSettings) {
            if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
                return oSettings.nTable
            }
            var nScroller = document.createElement("div"),
                nScrollHead = document.createElement("div"),
                nScrollHeadInner = document.createElement("div"),
                nScrollBody = document.createElement("div"),
                nScrollFoot = document.createElement("div"),
                nScrollFootInner = document.createElement("div"),
                nScrollHeadTable = oSettings.nTable.cloneNode(false),
                nScrollFootTable = oSettings.nTable.cloneNode(false),
                nThead = oSettings.nTable.getElementsByTagName("thead")[0],
                nTfoot = oSettings.nTable.getElementsByTagName("tfoot").length === 0 ? null : oSettings.nTable.getElementsByTagName("tfoot")[0],
                oClasses = (typeof oInit.bJQueryUI != "undefined" && oInit.bJQueryUI) ? _oExt.oJUIClasses : _oExt.oStdClasses;
            nScrollHead.appendChild(nScrollHeadInner);
            nScrollFoot.appendChild(nScrollFootInner);
            nScrollBody.appendChild(oSettings.nTable);
            nScroller.appendChild(nScrollHead);
            nScroller.appendChild(nScrollBody);
            nScrollHeadInner.appendChild(nScrollHeadTable);
            nScrollHeadTable.appendChild(nThead);
            if (nTfoot !== null) {
                nScroller.appendChild(nScrollFoot);
                nScrollFootInner.appendChild(nScrollFootTable);
                nScrollFootTable.appendChild(nTfoot)
            }
            nScroller.className = oClasses.sScrollWrapper;
            nScrollHead.className = oClasses.sScrollHead;
            nScrollHeadInner.className = oClasses.sScrollHeadInner;
            nScrollBody.className = oClasses.sScrollBody;
            nScrollFoot.className = oClasses.sScrollFoot;
            nScrollFootInner.className = oClasses.sScrollFootInner;
            if (oSettings.oScroll.bAutoCss) {
                nScrollHead.style.overflow = "hidden";
                nScrollHead.style.position = "relative";
                nScrollFoot.style.overflow = "hidden";
                nScrollBody.style.overflow = "auto"
            }
            nScrollHead.style.border = "0";
            nScrollHead.style.width = "100%";
            nScrollFoot.style.border = "0";
            nScrollHeadInner.style.width = "150%";
            nScrollHeadTable.removeAttribute("id");
            nScrollHeadTable.style.marginLeft = "0";
            oSettings.nTable.style.marginLeft = "0";
            if (nTfoot !== null) {
                nScrollFootTable.removeAttribute("id");
                nScrollFootTable.style.marginLeft = "0"
            }
            var nCaptions = $(oSettings.nTable).children("caption");
            for (var i = 0, iLen = nCaptions.length; i < iLen; i++) {
                nScrollHeadTable.appendChild(nCaptions[i])
            }
            if (oSettings.oScroll.sX !== "") {
                nScrollHead.style.width = _fnStringToCss(oSettings.oScroll.sX);
                nScrollBody.style.width = _fnStringToCss(oSettings.oScroll.sX);
                if (nTfoot !== null) {
                    nScrollFoot.style.width = _fnStringToCss(oSettings.oScroll.sX)
                }
                $(nScrollBody).scroll(function(e) {
                    nScrollHead.scrollLeft = this.scrollLeft;
                    if (nTfoot !== null) {
                        nScrollFoot.scrollLeft = this.scrollLeft
                    }
                })
            }
            if (oSettings.oScroll.sY !== "") {
                nScrollBody.style.height = _fnStringToCss(oSettings.oScroll.sY)
            }
            oSettings.aoDrawCallback.push({
                fn: _fnScrollDraw,
                sName: "scrolling"
            });
            if (oSettings.oScroll.bInfinite) {
                $(nScrollBody).scroll(function() {
                    if (!oSettings.bDrawing) {
                        if ($(this).scrollTop() + $(this).height() > $(oSettings.nTable).height() - oSettings.oScroll.iLoadGap) {
                            if (oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay()) {
                                _fnPageChange(oSettings, "next");
                                _fnCalculateEnd(oSettings);
                                _fnDraw(oSettings)
                            }
                        }
                    }
                })
            }
            oSettings.nScrollHead = nScrollHead;
            oSettings.nScrollFoot = nScrollFoot;
            return nScroller
        }

        function _fnScrollDraw(o) {
            var nScrollHeadInner = o.nScrollHead.getElementsByTagName("div")[0],
                nScrollHeadTable = nScrollHeadInner.getElementsByTagName("table")[0],
                nScrollBody = o.nTable.parentNode,
                i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis, iWidth, aApplied = [],
                iSanityWidth, nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName("div")[0] : null,
                nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName("table")[0] : null;
            var nTheadSize = o.nTable.getElementsByTagName("thead");
            if (nTheadSize.length > 0) {
                o.nTable.removeChild(nTheadSize[0])
            }
            if (o.nTFoot !== null) {
                var nTfootSize = o.nTable.getElementsByTagName("tfoot");
                if (nTfootSize.length > 0) {
                    o.nTable.removeChild(nTfootSize[0])
                }
            }
            nTheadSize = o.nTHead.cloneNode(true);
            o.nTable.insertBefore(nTheadSize, o.nTable.childNodes[0]);
            if (o.nTFoot !== null) {
                nTfootSize = o.nTFoot.cloneNode(true);
                o.nTable.insertBefore(nTfootSize, o.nTable.childNodes[1])
            }
            if (o.oScroll.sX === "") {
                nScrollBody.style.width = "100%";
                nScrollHeadInner.parentNode.style.width = "100%"
            }
            var nThs = _fnGetUniqueThs(o, nTheadSize);
            for (i = 0, iLen = nThs.length; i < iLen; i++) {
                iVis = _fnVisibleToColumnIndex(o, i);
                nThs[i].style.width = o.aoColumns[iVis].sWidth
            }
            if (o.nTFoot !== null) {
                _fnApplyToChildren(function(n) {
                    n.style.width = ""
                }, nTfootSize.getElementsByTagName("tr"))
            }
            iSanityWidth = $(o.nTable).outerWidth();
            if (o.oScroll.sX === "") {
                o.nTable.style.width = "100%";
                if (ie67 && (nScrollBody.scrollHeight > nScrollBody.offsetHeight || $(nScrollBody).css("overflow-y") == "scroll")) {
                    o.nTable.style.width = _fnStringToCss($(o.nTable).outerWidth() - o.oScroll.iBarWidth)
                }
            } else {
                if (o.oScroll.sXInner !== "") {
                    o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner)
                } else {
                    if (iSanityWidth == $(nScrollBody).width() && $(nScrollBody).height() < $(o.nTable).height()) {
                        o.nTable.style.width = _fnStringToCss(iSanityWidth - o.oScroll.iBarWidth);
                        if ($(o.nTable).outerWidth() > iSanityWidth - o.oScroll.iBarWidth) {
                            o.nTable.style.width = _fnStringToCss(iSanityWidth)
                        }
                    } else {
                        o.nTable.style.width = _fnStringToCss(iSanityWidth)
                    }
                }
            }
            iSanityWidth = $(o.nTable).outerWidth();
            anHeadToSize = o.nTHead.getElementsByTagName("tr");
            anHeadSizers = nTheadSize.getElementsByTagName("tr");
            _fnApplyToChildren(function(nSizer, nToSize) {
                oStyle = nSizer.style;
                oStyle.paddingTop = "0";
                oStyle.paddingBottom = "0";
                oStyle.borderTopWidth = "0";
                oStyle.borderBottomWidth = "0";
                oStyle.height = 0;
                iWidth = $(nSizer).width();
                nToSize.style.width = _fnStringToCss(iWidth);
                aApplied.push(iWidth)
            }, anHeadSizers, anHeadToSize);
            $(anHeadSizers).height(0);
            if (o.nTFoot !== null) {
                anFootSizers = nTfootSize.getElementsByTagName("tr");
                anFootToSize = o.nTFoot.getElementsByTagName("tr");
                _fnApplyToChildren(function(nSizer, nToSize) {
                    oStyle = nSizer.style;
                    oStyle.paddingTop = "0";
                    oStyle.paddingBottom = "0";
                    oStyle.borderTopWidth = "0";
                    oStyle.borderBottomWidth = "0";
                    oStyle.height = 0;
                    iWidth = $(nSizer).width();
                    nToSize.style.width = _fnStringToCss(iWidth);
                    aApplied.push(iWidth)
                }, anFootSizers, anFootToSize);
                $(anFootSizers).height(0)
            }
            _fnApplyToChildren(function(nSizer) {
                nSizer.innerHTML = "";
                nSizer.style.width = _fnStringToCss(aApplied.shift())
            }, anHeadSizers);
            if (o.nTFoot !== null) {
                _fnApplyToChildren(function(nSizer) {
                    nSizer.innerHTML = "";
                    nSizer.style.width = _fnStringToCss(aApplied.shift())
                }, anFootSizers)
            }
            if ($(o.nTable).outerWidth() < iSanityWidth) {
                var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight || $(nScrollBody).css("overflow-y") == "scroll")) ? iSanityWidth + o.oScroll.iBarWidth : iSanityWidth;
                if (ie67 && (nScrollBody.scrollHeight > nScrollBody.offsetHeight || $(nScrollBody).css("overflow-y") == "scroll")) {
                    o.nTable.style.width = _fnStringToCss(iCorrection - o.oScroll.iBarWidth)
                }
                nScrollBody.style.width = _fnStringToCss(iCorrection);
                nScrollHeadInner.parentNode.style.width = _fnStringToCss(iCorrection);
                if (o.nTFoot !== null) {
                    nScrollFootInner.parentNode.style.width = _fnStringToCss(iCorrection)
                }
                if (o.oScroll.sX === "") {
                    _fnLog(o, 1, "The table cannot fit into the current element which will cause column misalignment. The table has been drawn at its minimum possible width.")
                } else {
                    if (o.oScroll.sXInner !== "") {
                        _fnLog(o, 1, "The table cannot fit into the current element which will cause column misalignment. Increase the sScrollXInner value or remove it to allow automatic calculation")
                    }
                }
            } else {
                nScrollBody.style.width = _fnStringToCss("100%");
                nScrollHeadInner.parentNode.style.width = _fnStringToCss("100%");
                if (o.nTFoot !== null) {
                    nScrollFootInner.parentNode.style.width = _fnStringToCss("100%")
                }
            }
            if (o.oScroll.sY === "") {
                if (ie67) {
                    nScrollBody.style.height = _fnStringToCss(o.nTable.offsetHeight + o.oScroll.iBarWidth)
                }
            }
            if (o.oScroll.sY !== "" && o.oScroll.bCollapse) {
                nScrollBody.style.height = _fnStringToCss(o.oScroll.sY);
                var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ? o.oScroll.iBarWidth : 0;
                if (o.nTable.offsetHeight < nScrollBody.offsetHeight) {
                    nScrollBody.style.height = _fnStringToCss($(o.nTable).height() + iExtra)
                }
            }
            var iOuterWidth = $(o.nTable).outerWidth();
            nScrollHeadTable.style.width = _fnStringToCss(iOuterWidth);
            nScrollHeadInner.style.width = _fnStringToCss(iOuterWidth + o.oScroll.iBarWidth);
            if (o.nTFoot !== null) {
                nScrollFootInner.style.width = _fnStringToCss(o.nTable.offsetWidth + o.oScroll.iBarWidth);
                nScrollFootTable.style.width = _fnStringToCss(o.nTable.offsetWidth)
            }
            if (o.bSorted || o.bFiltered) {
                nScrollBody.scrollTop = 0
            }
        }

        function _fnAdjustColumnSizing(oSettings) {
            if (oSettings.oFeatures.bAutoWidth === false) {
                return false
            }
            _fnCalculateColumnWidths(oSettings);
            for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth
            }
        }

        function _fnFeatureHtmlFilter(oSettings) {
            var sSearchStr = oSettings.oLanguage.sSearch;
            sSearchStr = (sSearchStr.indexOf("_INPUT_") !== -1) ? sSearchStr.replace("_INPUT_", '<input type="text" />') : sSearchStr === "" ? '<input type="text" />' : sSearchStr + ' <input type="text" />';
            var nFilter = document.createElement("div");
            nFilter.className = oSettings.oClasses.sFilter;
            nFilter.innerHTML = "<label>" + sSearchStr + "</label>";
            if (oSettings.sTableId !== "" && typeof oSettings.aanFeatures.f == "undefined") {
                nFilter.setAttribute("id", oSettings.sTableId + "_filter")
            }
            var jqFilter = $("input", nFilter);
            jqFilter.val(oSettings.oPreviousSearch.sSearch.replace('"', "&quot;"));
            jqFilter.bind("keyup.DT", function(e) {
                var n = oSettings.aanFeatures.f;
                for (var i = 0, iLen = n.length; i < iLen; i++) {
                    if (n[i] != $(this).parents("div.dataTables_filter")[0]) {
                        $("input", n[i]).val(this.value)
                    }
                }
                if (this.value != oSettings.oPreviousSearch.sSearch) {
                    _fnFilterComplete(oSettings, {
                        sSearch: this.value,
                        bRegex: oSettings.oPreviousSearch.bRegex,
                        bSmart: oSettings.oPreviousSearch.bSmart
                    })
                }
            });
            jqFilter.bind("keypress.DT", function(e) {
                if (e.keyCode == 13) {
                    return false
                }
            });
            return nFilter
        }

        function _fnFilterComplete(oSettings, oInput, iForce) {
            _fnFilter(oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart);
            for (var i = 0; i < oSettings.aoPreSearchCols.length; i++) {
                _fnFilterColumn(oSettings, oSettings.aoPreSearchCols[i].sSearch, i, oSettings.aoPreSearchCols[i].bRegex, oSettings.aoPreSearchCols[i].bSmart)
            }
            if (_oExt.afnFiltering.length !== 0) {
                _fnFilterCustom(oSettings)
            }
            oSettings.bFiltered = true;
            $(oSettings.oInstance).trigger("filter", oSettings);
            oSettings._iDisplayStart = 0;
            _fnCalculateEnd(oSettings);
            if (typeof oSettings.fnFilterCallback == "function") {
                oSettings.fnFilterCallback(oSettings)
            }
            _fnDraw(oSettings);
            _fnBuildSearchArray(oSettings, 0)
        }

        function _fnFilterCustom(oSettings) {
            var afnFilters = _oExt.afnFiltering;
            for (var i = 0, iLen = afnFilters.length; i < iLen; i++) {
                var iCorrector = 0;
                for (var j = 0, jLen = oSettings.aiDisplay.length; j < jLen; j++) {
                    var iDisIndex = oSettings.aiDisplay[j - iCorrector];
                    if (!afnFilters[i](oSettings, _fnGetRowData(oSettings, iDisIndex, "filter"), iDisIndex)) {
                        oSettings.aiDisplay.splice(j - iCorrector, 1);
                        iCorrector++
                    }
                }
            }
        }

        function _fnFilterColumn(oSettings, sInput, iColumn, bRegex, bSmart) {
            if (sInput === "") {
                return
            }
            var htmlRegex = new RegExp(".*\\<[^>]+>.*");
            var iIndexCorrector = 0;
            var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart);
            for (var i = oSettings.aiDisplay.length - 1; i >= 0; i--) {
                var sData = _fnDataToSearch(_fnGetCellData(oSettings, oSettings.aiDisplay[i], iColumn, "filter"), oSettings.aoColumns[iColumn].sType);
                if (sData) {
                    if (htmlRegex.test(sData) && !htmlRegex.test(sInput)) {
                        sData = jQuery("<p>" + sData + "</p>").text()
                    }
                }
                if (!rpSearch.test(sData)) {
                    oSettings.aiDisplay.splice(i, 1);
                    iIndexCorrector++
                }
            }
        }

        function _fnFilter(oSettings, sInput, iForce, bRegex, bSmart) {
            var i;
            var rpSearch = _fnFilterCreateSearch(sInput, bRegex, bSmart);
            if (typeof iForce == "undefined" || iForce === null) {
                iForce = 0
            }
            if (_oExt.afnFiltering.length !== 0) {
                iForce = 1
            }
            if (sInput.length <= 0) {
                oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice()
            } else {
                if (oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length || oSettings.oPreviousSearch.sSearch.length > sInput.length || iForce == 1 || sInput.indexOf(oSettings.oPreviousSearch.sSearch) !== 0) {
                    oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
                    _fnBuildSearchArray(oSettings, 1);
                    for (i = 0; i < oSettings.aiDisplayMaster.length; i++) {
                        if (rpSearch.test(oSettings.asDataSearch[i])) {
                            oSettings.aiDisplay.push(oSettings.aiDisplayMaster[i])
                        }
                    }
                } else {
                    var iIndexCorrector = 0;
                    for (i = 0; i < oSettings.asDataSearch.length; i++) {
                        if (!rpSearch.test(oSettings.asDataSearch[i])) {
                            oSettings.aiDisplay.splice(i - iIndexCorrector, 1);
                            iIndexCorrector++
                        }
                    }
                }
            }
            oSettings.oPreviousSearch.sSearch = sInput;
            oSettings.oPreviousSearch.bRegex = bRegex;
            oSettings.oPreviousSearch.bSmart = bSmart
        }

        function _fnBuildSearchArray(oSettings, iMaster) {
            if (!oSettings.oFeatures.bServerSide) {
                oSettings.asDataSearch.splice(0, oSettings.asDataSearch.length);
                var aArray = (typeof iMaster != "undefined" && iMaster == 1) ? oSettings.aiDisplayMaster : oSettings.aiDisplay;
                for (var i = 0, iLen = aArray.length; i < iLen; i++) {
                    oSettings.asDataSearch[i] = _fnBuildSearchRow(oSettings, _fnGetRowData(oSettings, aArray[i], "filter"))
                }
            }
        }

        function _fnBuildSearchRow(oSettings, aData) {
            var sSearch = "";
            if (typeof oSettings.__nTmpFilter == "undefined") {
                oSettings.__nTmpFilter = document.createElement("div")
            }
            var nTmp = oSettings.__nTmpFilter;
            for (var j = 0, jLen = oSettings.aoColumns.length; j < jLen; j++) {
                if (oSettings.aoColumns[j].bSearchable) {
                    var sData = aData[j];
                    sSearch += _fnDataToSearch(sData, oSettings.aoColumns[j].sType) + "  "
                }
            }
            if (sSearch.indexOf("&") !== -1) {
                nTmp.innerHTML = sSearch;
                sSearch = nTmp.textContent ? nTmp.textContent : nTmp.innerText;
                sSearch = sSearch.replace(/\n/g, " ").replace(/\r/g, "")
            }
            return sSearch
        }

        function _fnFilterCreateSearch(sSearch, bRegex, bSmart) {
            var asSearch, sRegExpString;
            if (bSmart) {
                asSearch = bRegex ? sSearch.split(" ") : _fnEscapeRegex(sSearch).split(" ");
                sRegExpString = "^(?=.*?" + asSearch.join(")(?=.*?") + ").*$";
                return new RegExp(sRegExpString, "i")
            } else {
                sSearch = bRegex ? sSearch : _fnEscapeRegex(sSearch);
                return new RegExp(sSearch, "i")
            }
        }

        function _fnDataToSearch(sData, sType) {
            if (typeof _oExt.ofnSearch[sType] == "function") {
                return _oExt.ofnSearch[sType](sData)
            } else {
                if (sType == "html") {
                    return sData.replace(/\n/g, " ").replace(/<.*?>/g, "")
                } else {
                    if (typeof sData == "string") {
                        return sData.replace(/\n/g, " ")
                    } else {
                        if (sData === null) {
                            return ""
                        }
                    }
                }
            }
            return sData
        }

        function _fnCreateFilterMenu(col) {
            var column = this.aoColumns[col];
            var sText = _fnUnescapeRegex(this.aoPreSearchCols[col].sSearch);
            var itemList = "";
            var foundMatch = false;
            for (var j = 0; j < column.mostFreq.length; j++) {
                var value = column.mostFreq[j].value;
                if (value != "") {
                    var myClass = "";
                    if (column.mostFreq[j].isColValue) {
                        myClass = "isColValue";
                        if (sText.length > 0 && value.match(this.aoPreSearchCols[col].sSearch)) {
                            myClass = "isColValue ContextSelectedItem";
                            foundMatch = true
                        }
                    }
                    itemList += '<li class="ContextItem ' + myClass + '" name="mostFreq' + j + '" tableColumn="' + column.iDataSort + '">' + value + "</li>"
                }
            }
            if (foundMatch) {
                sText = ""
            } else {
                if (sText.charAt(0) == "^" && sText.charAt(sText.length - 1) == "$") {
                    sText = sText.slice(1, -1)
                }
            }
            var menuHtml = '<li class="ContextItem" name="mostFreqAll" tableColumn="' + column.iDataSort + '">' + strings.All + "</li>";
            menuHtml += '<li><input name="colFilterText" class="colFilterInput" type="text" size="10" maxLength="120" tableColumn="' + column.iDataSort + "\" value='" + sText + "'></input></li>";
            menuHtml += itemList;
            this.nFilterMenu.empty().html(menuHtml);
            $(".colFilterInput", this.nFilterMenu).keyup(createObjectCallback(this.oInstance, this.oInstance._fnHandleFilterMenuClick))
        }

        function _fnSort(oSettings, bApplyClasses) {
            var iDataSort, iDataType, i, iLen, j, jLen, aaSort = [],
                aiOrig = [],
                oSort = _oExt.oSort,
                aoData = oSettings.aoData,
                aoColumns = oSettings.aoColumns;
            if (!oSettings.oFeatures.bServerSide && (oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null)) {
                if (oSettings.aaSortingFixed !== null) {
                    aaSort = oSettings.aaSortingFixed.concat(oSettings.aaSorting)
                } else {
                    aaSort = oSettings.aaSorting.slice()
                }
                for (i = 0; i < aaSort.length; i++) {
                    var iColumn = aaSort[i][0];
                    var iVisColumn = _fnColumnIndexToVisible(oSettings, iColumn);
                    var sDataType = oSettings.aoColumns[iColumn].sSortDataType;
                    if (typeof _oExt.afnSortData[sDataType] != "undefined") {
                        var aData = _oExt.afnSortData[sDataType](oSettings, iColumn, iVisColumn);
                        for (j = 0, jLen = aoData.length; j < jLen; j++) {
                            _fnSetCellData(oSettings, j, iColumn, aData[j])
                        }
                    }
                }
                for (i = 0, iLen = oSettings.aiDisplayMaster.length; i < iLen; i++) {
                    aiOrig[oSettings.aiDisplayMaster[i]] = i
                }
                var iSortLen = aaSort.length;
                oSettings.aiDisplayMaster.sort(function(a, b) {
                    var iTest, iDataSort, sDataType;
                    for (i = 0; i < iSortLen; i++) {
                        iDataSort = aoColumns[aaSort[i][0]].iDataSort;
                        sDataType = aoColumns[iDataSort].sType;
                        iTest = oSort[(sDataType ? sDataType : "string") + "-" + aaSort[i][1]](_fnGetCellData(oSettings, a, iDataSort, "sort"), _fnGetCellData(oSettings, b, iDataSort, "sort"));
                        if (iTest !== 0) {
                            return iTest
                        }
                    }
                    return oSort["numeric-asc"](aiOrig[a], aiOrig[b])
                })
            }
            if ((typeof bApplyClasses == "undefined" || bApplyClasses) && !oSettings.oFeatures.bDeferRender) {
                _fnSortingClasses(oSettings)
            }
            oSettings.bSorted = true;
            $(oSettings.oInstance).trigger("sort", oSettings);
            if (oSettings.oFeatures.bFilter) {
                _fnFilterComplete(oSettings, oSettings.oPreviousSearch, 1)
            } else {
                oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
                oSettings._iDisplayStart = 0;
                _fnCalculateEnd(oSettings);
                _fnDraw(oSettings)
            }
        }

        function _fnSortAttachListener(oSettings, nNode, iDataIndex, fnCallback) {
            $(nNode).bind("click.DT", function(e) {
                if (oSettings.aoColumns[iDataIndex].bSortable === false) {
                    return
                }
                var fnInnerSorting = function() {
                    var iColumn, iNextSort;
                    if (e.shiftKey) {
                        var bFound = false;
                        for (var i = 0; i < oSettings.aaSorting.length; i++) {
                            if (oSettings.aaSorting[i][0] == iDataIndex) {
                                bFound = true;
                                iColumn = oSettings.aaSorting[i][0];
                                iNextSort = oSettings.aaSorting[i][2] + 1;
                                if (typeof oSettings.aoColumns[iColumn].asSorting[iNextSort] == "undefined") {
                                    oSettings.aaSorting.splice(i, 1)
                                } else {
                                    oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                                    oSettings.aaSorting[i][2] = iNextSort
                                }
                                break
                            }
                        }
                        if (bFound === false) {
                            oSettings.aaSorting.push([iDataIndex, oSettings.aoColumns[iDataIndex].asSorting[0], 0])
                        }
                    } else {
                        if (oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex) {
                            iColumn = oSettings.aaSorting[0][0];
                            iNextSort = oSettings.aaSorting[0][2] + 1;
                            if (typeof oSettings.aoColumns[iColumn].asSorting[iNextSort] == "undefined") {
                                iNextSort = 0
                            }
                            oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
                            oSettings.aaSorting[0][2] = iNextSort
                        } else {
                            oSettings.aaSorting.splice(0, oSettings.aaSorting.length);
                            oSettings.aaSorting.push([iDataIndex, oSettings.aoColumns[iDataIndex].asSorting[0], 0])
                        }
                    }
                    _fnSort(oSettings)
                };
                if (!oSettings.oFeatures.bProcessing) {
                    fnInnerSorting()
                } else {
                    _fnProcessingDisplay(oSettings, true);
                    setTimeout(function() {
                        fnInnerSorting();
                        if (!oSettings.oFeatures.bServerSide) {
                            _fnProcessingDisplay(oSettings, false)
                        }
                    }, 0)
                }
                if (typeof fnCallback == "function") {
                    fnCallback(oSettings)
                }
            })
        }

        function _fnSortingClasses(oSettings) {
            var i, iLen, j, jLen, iFound;
            var aaSort, sClass;
            var iColumns = oSettings.aoColumns.length;
            var oClasses = oSettings.oClasses;
            for (i = 0; i < iColumns; i++) {
                if (oSettings.aoColumns[i].bSortable) {
                    $("span.dtSortable", oSettings.aoColumns[i].nTh).removeClass(oClasses.sSortAsc + " " + oClasses.sSortDesc + " " + oSettings.aoColumns[i].sSortingClass)
                }
            }
            if (oSettings.aaSortingFixed !== null) {
                aaSort = oSettings.aaSortingFixed.concat(oSettings.aaSorting)
            } else {
                aaSort = oSettings.aaSorting.slice()
            }
            for (i = 0; i < oSettings.aoColumns.length; i++) {
                if (oSettings.aoColumns[i].bSortable) {
                    sClass = oSettings.aoColumns[i].sSortingClass;
                    iFound = -1;
                    for (j = 0; j < aaSort.length; j++) {
                        if (aaSort[j][0] == i) {
                            sClass = (aaSort[j][1] == "asc") ? oClasses.sSortAsc : oClasses.sSortDesc;
                            iFound = j;
                            break
                        }
                    }
                    $("span.dtSortable", oSettings.aoColumns[i].nTh).addClass(sClass);
                    if (oSettings.bJUI) {
                        var jqSpan = $("span", oSettings.aoColumns[i].nTh);
                        jqSpan.removeClass(oClasses.sSortJUIAsc + " " + oClasses.sSortJUIDesc + " " + oClasses.sSortJUI + " " + oClasses.sSortJUIAscAllowed + " " + oClasses.sSortJUIDescAllowed);
                        var sSpanClass;
                        if (iFound == -1) {
                            sSpanClass = oSettings.aoColumns[i].sSortingClassJUI
                        } else {
                            if (aaSort[iFound][1] == "asc") {
                                sSpanClass = oClasses.sSortJUIAsc
                            } else {
                                sSpanClass = oClasses.sSortJUIDesc
                            }
                        }
                        jqSpan.addClass(sSpanClass)
                    }
                } else {
                    $(oSettings.aoColumns[i].nTh).addClass(oSettings.aoColumns[i].sSortingClass)
                }
            }
            sClass = oClasses.sSortColumn;
            if (oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses) {
                var nTds = _fnGetTdNodes(oSettings);
                if (oSettings.oFeatures.bDeferRender) {
                    $(nTds).removeClass(sClass + "1 " + sClass + "2 " + sClass + "3")
                } else {
                    if (nTds.length >= iColumns) {
                        for (i = 0; i < iColumns; i++) {
                            if (nTds[i].className.indexOf(sClass + "1") != -1) {
                                for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
                                    nTds[(iColumns * j) + i].className = $.trim(nTds[(iColumns * j) + i].className.replace(sClass + "1", ""))
                                }
                            } else {
                                if (nTds[i].className.indexOf(sClass + "2") != -1) {
                                    for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
                                        nTds[(iColumns * j) + i].className = $.trim(nTds[(iColumns * j) + i].className.replace(sClass + "2", ""))
                                    }
                                } else {
                                    if (nTds[i].className.indexOf(sClass + "3") != -1) {
                                        for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
                                            nTds[(iColumns * j) + i].className = $.trim(nTds[(iColumns * j) + i].className.replace(" " + sClass + "3", ""))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                var iClass = 1,
                    iTargetCol;
                for (i = 0; i < aaSort.length; i++) {
                    iTargetCol = parseInt(aaSort[i][0], 10);
                    for (j = 0, jLen = (nTds.length / iColumns); j < jLen; j++) {
                        nTds[(iColumns * j) + iTargetCol].className += " " + sClass + iClass
                    }
                    if (iClass < 3) {
                        iClass++
                    }
                }
            }
        }

        function _fnFeatureHtmlPaginate(oSettings) {
            if (oSettings.oScroll.bInfinite) {
                return null
            }
            var nPaginate = document.createElement("div");
            nPaginate.className = oSettings.oClasses.sPaging + oSettings.sPaginationType;
            _oExt.oPagination[oSettings.sPaginationType].fnInit(oSettings, nPaginate, function(oSettings) {
                _fnCalculateEnd(oSettings);
                _fnDraw(oSettings)
            });
            if (typeof oSettings.aanFeatures.p == "undefined") {
                oSettings.aoDrawCallback.push({
                    fn: function(oSettings) {
                        _oExt.oPagination[oSettings.sPaginationType].fnUpdate(oSettings, function(oSettings) {
                            _fnCalculateEnd(oSettings);
                            _fnDraw(oSettings)
                        })
                    },
                    sName: "pagination"
                })
            }
            return nPaginate
        }

        function _fnPageChange(oSettings, mAction) {
            var iOldStart = oSettings._iDisplayStart;
            if ((typeof mAction) === "number") {
                oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
                if (oSettings._iDisplayStart < 0 || oSettings._iDisplayStart > oSettings.fnRecordsDisplay()) {
                    oSettings._iDisplayStart = 0
                }
            } else {
                if (mAction == "first") {
                    oSettings._iDisplayStart = 0
                } else {
                    if (mAction == "previous") {
                        oSettings._iDisplayStart = oSettings._iDisplayLength >= 0 ? oSettings._iDisplayStart - oSettings._iDisplayLength : 0;
                        if (oSettings._iDisplayStart < 0) {
                            oSettings._iDisplayStart = 0
                        }
                    } else {
                        if (mAction == "next") {
                            if (oSettings._iDisplayLength >= 0) {
                                if (oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay()) {
                                    oSettings._iDisplayStart += oSettings._iDisplayLength
                                }
                            } else {
                                oSettings._iDisplayStart = 0
                            }
                        } else {
                            if (mAction == "last") {
                                if (oSettings._iDisplayLength >= 0) {
                                    var iPages = parseInt((oSettings.fnRecordsDisplay() - 1) / oSettings._iDisplayLength, 10) + 1;
                                    oSettings._iDisplayStart = (iPages - 1) * oSettings._iDisplayLength
                                } else {
                                    oSettings._iDisplayStart = 0
                                }
                            } else {
                                _fnLog(oSettings, 0, "Unknown paging action: " + mAction)
                            }
                        }
                    }
                }
            }
            $(oSettings.oInstance).trigger("page", oSettings);
            return iOldStart != oSettings._iDisplayStart
        }

        function _fnFeatureHtmlInfo(oSettings) {
            var nInfo = document.createElement("div");
            nInfo.className = oSettings.oClasses.sInfo;
            if (typeof oSettings.aanFeatures.i == "undefined") {
                oSettings.aoDrawCallback.push({
                    fn: _fnUpdateInfo,
                    sName: "information"
                });
                if (oSettings.sTableId !== "") {
                    nInfo.setAttribute("id", oSettings.sTableId + "_info")
                }
            }
            return nInfo
        }

        function _fnUpdateInfo(oSettings) {
            if (!oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0) {
                return
            }
            var iStart = oSettings._iDisplayStart + 1,
                iEnd = oSettings.fnDisplayEnd(),
                iMax = oSettings.fnRecordsTotal(),
                iTotal = oSettings.fnRecordsDisplay(),
                sStart = oSettings.fnFormatNumber(iStart),
                sEnd = oSettings.fnFormatNumber(iEnd),
                sMax = oSettings.fnFormatNumber(iMax),
                sTotal = oSettings.fnFormatNumber(iTotal),
                sOut;
            if (oSettings.oScroll.bInfinite) {
                sStart = oSettings.fnFormatNumber(1)
            }
            if (oSettings.fnRecordsDisplay() === 0 && oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal()) {
                sOut = oSettings.oLanguage.sInfoEmpty + oSettings.oLanguage.sInfoPostFix
            } else {
                if (oSettings.fnRecordsDisplay() === 0) {
                    sOut = oSettings.oLanguage.sInfoEmpty + " " + oSettings.oLanguage.sInfoFiltered(sMax) + oSettings.oLanguage.sInfoPostFix
                } else {
                    if (oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal()) {
                        sOut = oSettings.oLanguage.sInfo(sStart, sEnd, sTotal) + oSettings.oLanguage.sInfoPostFix
                    } else {
                        var sFiltered = oSettings.fnFormatNumber(oSettings.fnRecordsTotal());
                        sOut = oSettings.oLanguage.sInfo(sStart, sEnd, sTotal) + oSettings.oLanguage.sInfoFiltered(sFiltered) + oSettings.oLanguage.sInfoPostFix
                    }
                }
            }
            if (oSettings.oLanguage.fnInfoCallback !== null) {
                sOut = oSettings.oLanguage.fnInfoCallback(oSettings, iStart, iEnd, iMax, iTotal, sOut)
            }
            var n = oSettings.aanFeatures.i;
            for (var i = 0, iLen = n.length; i < iLen; i++) {
                $(n[i]).html(sOut)
            }
        }

        function _fnFeatureHtmlLength(oSettings) {
            if (oSettings.oScroll.bInfinite) {
                return null
            }
            var sName = (oSettings.sTableId === "") ? "" : 'name="' + oSettings.sTableId + '_length"';
            var sStdMenu = '<select size="1" ' + sName + ">";
            var i, iLen;
            if (oSettings.aLengthMenu.length == 2 && typeof oSettings.aLengthMenu[0] == "object" && typeof oSettings.aLengthMenu[1] == "object") {
                for (i = 0, iLen = oSettings.aLengthMenu[0].length; i < iLen; i++) {
                    sStdMenu += '<option value="' + oSettings.aLengthMenu[0][i] + '">' + oSettings.aLengthMenu[1][i] + "</option>"
                }
            } else {
                for (i = 0, iLen = oSettings.aLengthMenu.length; i < iLen; i++) {
                    sStdMenu += '<option value="' + oSettings.aLengthMenu[i] + '">' + oSettings.aLengthMenu[i] + "</option>"
                }
            }
            sStdMenu += "</select>";
            var nLength = document.createElement("div");
            if (oSettings.sTableId !== "" && typeof oSettings.aanFeatures.l == "undefined") {
                nLength.setAttribute("id", oSettings.sTableId + "_length")
            }
            nLength.className = oSettings.oClasses.sLength;
            nLength.innerHTML = "<label>" + oSettings.oLanguage.sLengthMenu + sStdMenu + "</label>";
            oSettings.nLengthSelect$ = $("select", nLength);
            $('select option[value="' + oSettings._iDisplayLength + '"]', nLength).prop("selected", true);
            $("select", nLength).bind("change.DT", function(e) {
                var iVal = $(this).val();
                var n = oSettings.aanFeatures.l;
                for (i = 0, iLen = n.length; i < iLen; i++) {
                    if (n[i] != this.parentNode) {
                        $("select", n[i]).val(iVal)
                    }
                }
                oSettings._iDisplayLength = parseInt(iVal, 10);
                _fnCalculateEnd(oSettings);
                if (oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay()) {
                    oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
                    if (oSettings._iDisplayStart < 0) {
                        oSettings._iDisplayStart = 0
                    }
                }
                if (oSettings._iDisplayLength == -1) {
                    oSettings._iDisplayStart = 0
                }
                _fnDraw(oSettings)
            });
            return nLength
        }

        function _fnFeatureHtmlProcessing(oSettings) {
            var nProcessing = document.createElement("div");
            if (oSettings.sTableId !== "" && typeof oSettings.aanFeatures.r == "undefined") {
                nProcessing.setAttribute("id", oSettings.sTableId + "_processing")
            }
            nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
            nProcessing.className = oSettings.oClasses.sProcessing;
            oSettings.nTable.parentNode.insertBefore(nProcessing, oSettings.nTable);
            return nProcessing
        }

        function _fnProcessingDisplay(oSettings, bShow) {
            if (oSettings.oFeatures.bProcessing) {
                var an = oSettings.aanFeatures.r;
                for (var i = 0, iLen = an.length; i < iLen; i++) {
                    an[i].style.visibility = bShow ? "visible" : "hidden"
                }
            }
        }

        function _fnVisibleToColumnIndex(oSettings, iMatch) {
            var iColumn = -1;
            for (var i = 0; i < oSettings.aoColumns.length; i++) {
                if (oSettings.aoColumns[i].bVisible === true) {
                    iColumn++
                }
                if (iColumn == iMatch) {
                    return i
                }
            }
            return null
        }

        function _fnColumnIndexToVisible(oSettings, iMatch) {
            var iVisible = -1;
            for (var i = 0; i < oSettings.aoColumns.length; i++) {
                if (oSettings.aoColumns[i].bVisible === true) {
                    iVisible++
                }
                if (i == iMatch) {
                    return oSettings.aoColumns[i].bVisible === true ? iVisible : null
                }
            }
            return null
        }

        function _fnNodeToDataIndex(s, n) {
            var i, iLen;
            for (i = s._iDisplayStart, iLen = s._iDisplayEnd; i < iLen; i++) {
                if (s.aoData[s.aiDisplay[i]].nTr == n) {
                    return s.aiDisplay[i]
                }
            }
            for (i = 0, iLen = s.aoData.length; i < iLen; i++) {
                if (s.aoData[i].nTr == n) {
                    return i
                }
            }
            return null
        }

        function _fnVisbleColumns(oS) {
            var iVis = 0;
            for (var i = 0; i < oS.aoColumns.length; i++) {
                if (oS.aoColumns[i].bVisible === true) {
                    iVis++
                }
            }
            return iVis
        }

        function _fnCalculateEnd(oSettings) {
            if (oSettings.oFeatures.bPaginate === false) {
                oSettings._iDisplayEnd = oSettings.aiDisplay.length
            } else {
                if (oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length || oSettings._iDisplayLength == -1) {
                    oSettings._iDisplayEnd = oSettings.aiDisplay.length
                } else {
                    oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength
                }
            }
        }

        function _fnConvertToWidth(sWidth, nParent) {
            if (!sWidth || sWidth === null || sWidth === "") {
                return 0
            }
            if (typeof nParent == "undefined") {
                nParent = document.getElementsByTagName("body")[0]
            }
            var iWidth;
            var nTmp = document.createElement("div");
            nTmp.style.width = _fnStringToCss(sWidth);
            nParent.appendChild(nTmp);
            iWidth = nTmp.offsetWidth;
            nParent.removeChild(nTmp);
            return (iWidth)
        }

        function _fnCalculateColumnWidths(oSettings) {
            var iTableWidth = oSettings.nTable.offsetWidth;
            var iUserInputs = 0;
            var iTmpWidth;
            var iVisibleColumns = 0;
            var iColums = oSettings.aoColumns.length;
            var i, iIndex, iCorrector, iWidth;
            var oHeaders = $("th", oSettings.nTHead);
            for (i = 0; i < iColums; i++) {
                if (oSettings.aoColumns[i].bVisible) {
                    iVisibleColumns++;
                    if (oSettings.aoColumns[i].sWidth !== null) {
                        iTmpWidth = _fnConvertToWidth(oSettings.aoColumns[i].sWidthOrig, oSettings.nTable.parentNode);
                        if (iTmpWidth !== null) {
                            oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth)
                        }
                        iUserInputs++
                    }
                }
            }
            if (iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums && oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "") {
                for (i = 0; i < oSettings.aoColumns.length; i++) {
                    iTmpWidth = $(oHeaders[i]).width();
                    if (iTmpWidth !== null) {
                        oSettings.aoColumns[i].sWidth = _fnStringToCss(iTmpWidth)
                    }
                }
            } else {
                var nCalcTmp = oSettings.nTable.cloneNode(false),
                    nTheadClone = oSettings.nTHead.cloneNode(true),
                    nBody = document.createElement("tbody"),
                    nTr = document.createElement("tr"),
                    nDivSizing;
                nCalcTmp.removeAttribute("id");
                nCalcTmp.appendChild(nTheadClone);
                if (oSettings.nTFoot !== null) {
                    nCalcTmp.appendChild(oSettings.nTFoot.cloneNode(true));
                    _fnApplyToChildren(function(n) {
                        n.style.width = ""
                    }, nCalcTmp.getElementsByTagName("tr"))
                }
                nCalcTmp.appendChild(nBody);
                nBody.appendChild(nTr);
                var jqColSizing = $("thead th", nCalcTmp);
                if (jqColSizing.length === 0) {
                    jqColSizing = $("tbody tr:eq(0)>td", nCalcTmp)
                }
                var nThs = _fnGetUniqueThs(oSettings, nTheadClone);
                iCorrector = 0;
                for (i = 0; i < iColums; i++) {
                    var oColumn = oSettings.aoColumns[i];
                    if (oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "") {
                        nThs[i - iCorrector].style.width = _fnStringToCss(oColumn.sWidthOrig)
                    } else {
                        if (oColumn.bVisible) {
                            nThs[i - iCorrector].style.width = ""
                        } else {
                            iCorrector++
                        }
                    }
                }
                for (i = 0; i < iColums; i++) {
                    if (oSettings.aoColumns[i].bVisible) {
                        var nTd = _fnGetWidestNode(oSettings, i);
                        if (nTd !== null) {
                            nTd = nTd.cloneNode(true);
                            if (oSettings.aoColumns[i].sContentPadding !== "") {
                                nTd.innerHTML += oSettings.aoColumns[i].sContentPadding
                            }
                            nTr.appendChild(nTd)
                        }
                    }
                }
                var nWrapper = oSettings.nTable.parentNode;
                nWrapper.appendChild(nCalcTmp);
                if (oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "") {
                    nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner)
                } else {
                    if (oSettings.oScroll.sX !== "") {
                        nCalcTmp.style.width = "";
                        if ($(nCalcTmp).width() < nWrapper.offsetWidth) {
                            nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth)
                        }
                    } else {
                        if (oSettings.oScroll.sY !== "") {
                            nCalcTmp.style.width = _fnStringToCss(nWrapper.offsetWidth)
                        }
                    }
                }
                nCalcTmp.style.visibility = "hidden";
                _fnScrollingWidthAdjust(oSettings, nCalcTmp);
                var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
                if (oNodes.length === 0) {
                    oNodes = _fnGetUniqueThs(oSettings, $("thead", nCalcTmp)[0])
                }
                if (oSettings.oScroll.sX !== "") {
                    var iTotal = 0;
                    iCorrector = 0;
                    for (i = 0; i < oSettings.aoColumns.length; i++) {
                        if (oSettings.aoColumns[i].bVisible) {
                            if (oSettings.aoColumns[i].sWidthOrig === null) {
                                iTotal += $(oNodes[iCorrector]).outerWidth()
                            } else {
                                iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace("px", ""), 10) + ($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width())
                            }
                            iCorrector++
                        }
                    }
                    nCalcTmp.style.width = _fnStringToCss(iTotal);
                    oSettings.nTable.style.width = _fnStringToCss(iTotal)
                }
                iCorrector = 0;
                for (i = 0; i < oSettings.aoColumns.length; i++) {
                    if (oSettings.aoColumns[i].bVisible) {
                        iWidth = $(oNodes[iCorrector]).width();
                        if (iWidth !== null && iWidth > 0) {
                            oSettings.aoColumns[i].sWidth = _fnStringToCss(iWidth)
                        }
                        iCorrector++
                    }
                }
                oSettings.nTable.style.width = _fnStringToCss($(nCalcTmp).outerWidth());
                nCalcTmp.parentNode.removeChild(nCalcTmp)
            }
        }

        function _fnScrollingWidthAdjust(oSettings, n) {
            if (oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "") {
                var iOrigWidth = $(n).width();
                n.style.width = _fnStringToCss($(n).outerWidth() - oSettings.oScroll.iBarWidth)
            } else {
                if (oSettings.oScroll.sX !== "") {
                    n.style.width = _fnStringToCss($(n).outerWidth())
                }
            }
        }

        function _fnGetWidestNode(oSettings, iCol) {
            var iMaxIndex = _fnGetMaxLenString(oSettings, iCol);
            if (iMaxIndex < 0) {
                return null
            }
            if (oSettings.aoData[iMaxIndex].nTr === null) {
                var n = document.createElement("td");
                n.innerHTML = _fnGetCellData(oSettings, iMaxIndex, iCol, "");
                return n
            }
            return _fnGetTdNodes(oSettings, iMaxIndex)[iCol]
        }

        function _fnGetMaxLenString(oSettings, iCol) {
            var iMax = -1;
            var iMaxIndex = -1;
            for (var i = 0; i < oSettings.aoData.length; i++) {
                var s = _fnGetCellData(oSettings, i, iCol, "display") + "";
                s = s.replace(/<.*?>/g, "");
                if (s.length > iMax) {
                    iMax = s.length;
                    iMaxIndex = i
                }
            }
            return iMaxIndex
        }

        function _fnStringToCss(s) {
            if (s === null) {
                return "0px"
            }
            if (typeof s == "number") {
                if (s < 0) {
                    return "0px"
                }
                return s + "px"
            }
            var c = s.charCodeAt(s.length - 1);
            if (c < 48 || c > 57) {
                return s
            }
            return s + "px"
        }

        function _fnArrayCmp(aArray1, aArray2) {
            if (aArray1.length != aArray2.length) {
                return 1
            }
            for (var i = 0; i < aArray1.length; i++) {
                if (aArray1[i] != aArray2[i]) {
                    return 2
                }
            }
            return 0
        }

        function _fnDetectType(sData) {
            var aTypes = _oExt.aTypes;
            var iLen = aTypes.length;
            for (var i = 0; i < iLen; i++) {
                var sType = aTypes[i](sData);
                if (sType !== null) {
                    return sType
                }
            }
            return "string"
        }

        function _fnSettingsFromNode(nTable) {
            for (var i = 0; i < _aoSettings.length; i++) {
                if (_aoSettings[i].nTable == nTable) {
                    return _aoSettings[i]
                }
            }
            return null
        }

        function _fnGetDataMaster(oSettings) {
            var aData = [];
            var iLen = oSettings.aoData.length;
            for (var i = 0; i < iLen; i++) {
                aData.push(oSettings.aoData[i]._aData)
            }
            return aData
        }

        function _fnGetTrNodes(oSettings) {
            var aNodes = [];
            for (var i = 0, iLen = oSettings.aoData.length; i < iLen; i++) {
                if (oSettings.aoData[i].nTr !== null) {
                    aNodes.push(oSettings.aoData[i].nTr)
                }
            }
            return aNodes
        }

        function _fnGetTdNodes(oSettings, iIndividualRow) {
            var anReturn = [];
            var iCorrector;
            var anTds;
            var iRow, iRows = oSettings.aoData.length,
                iColumn, iColumns, oData, sNodeName, iStart = 0,
                iEnd = iRows;
            if (typeof iIndividualRow != "undefined") {
                iStart = iIndividualRow;
                iEnd = iIndividualRow + 1
            }
            for (iRow = iStart; iRow < iEnd; iRow++) {
                oData = oSettings.aoData[iRow];
                if (oData.nTr !== null) {
                    anTds = [];
                    for (iColumn = 0, iColumns = oData.nTr.childNodes.length; iColumn < iColumns; iColumn++) {
                        sNodeName = oData.nTr.childNodes[iColumn].nodeName.toLowerCase();
                        if (sNodeName == "td" || sNodeName == "th") {
                            anTds.push(oData.nTr.childNodes[iColumn])
                        }
                    }
                    iCorrector = 0;
                    for (iColumn = 0, iColumns = oSettings.aoColumns.length; iColumn < iColumns; iColumn++) {
                        if (oSettings.aoColumns[iColumn].bVisible) {
                            anReturn.push(anTds[iColumn - iCorrector])
                        } else {
                            anReturn.push(oData._anHidden[iColumn]);
                            iCorrector++
                        }
                    }
                }
            }
            return anReturn
        }

        function _fnEscapeRegex(sVal) {
            var acEscape = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
            var reReplace = new RegExp("(\\" + acEscape.join("|\\") + ")", "g");
            return sVal.replace(reReplace, "\\$1")
        }

        function _fnUnescapeRegex(sVal) {
            return sVal.replace(/\\([-\/\\^$*+?.()|[\]{}])/g, "$1")
        }

        function _fnDeleteIndex(a, iTarget) {
            var iTargetIndex = -1;
            for (var i = 0, iLen = a.length; i < iLen; i++) {
                if (a[i] == iTarget) {
                    iTargetIndex = i
                } else {
                    if (a[i] > iTarget) {
                        a[i]--
                    }
                }
            }
            if (iTargetIndex != -1) {
                a.splice(iTargetIndex, 1)
            }
        }

        function _fnReOrderIndex(oSettings, sColumns) {
            var aColumns = sColumns.split(",");
            var aiReturn = [];
            for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                for (var j = 0; j < iLen; j++) {
                    if (oSettings.aoColumns[i].sName == aColumns[j]) {
                        aiReturn.push(j);
                        break
                    }
                }
            }
            return aiReturn
        }

        function _fnColumnOrdering(oSettings) {
            var sNames = "";
            for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                sNames += oSettings.aoColumns[i].sName + ","
            }
            if (sNames.length == iLen) {
                return ""
            }
            return sNames.slice(0, -1)
        }

        function _fnLog(oSettings, iLevel, sMesg) {
            var sAlert = oSettings.sTableId === "" ? "DataTables warning: " + sMesg : "DataTables warning (table id = '" + oSettings.sTableId + "'): " + sMesg;
            if (iLevel === 0) {
                if (_oExt.sErrMode == "alert") {
                    alert(sAlert)
                } else {
                    throw sAlert
                }
                return
            } else {
                if (typeof console != "undefined" && typeof console.log != "undefined") {
                    console.log(sAlert)
                }
            }
        }

        function _fnClearTable(oSettings) {
            oSettings.aoData.splice(0, oSettings.aoData.length);
            oSettings.aiDisplayMaster.splice(0, oSettings.aiDisplayMaster.length);
            oSettings.aiDisplay.splice(0, oSettings.aiDisplay.length);
            for (var i = 0; i < oSettings.aoColumns.length; i++) {
                oSettings.aoColumns[i].valueFreq = {};
                delete oSettings.aoColumns[i].mostFreq
            }
            _fnCalculateEnd(oSettings)
        }

        function _fnSaveState(oSettings) {
            if (!oSettings.oFeatures.bStateSave || typeof oSettings.bDestroying != "undefined") {
                return
            }
            var i, iLen, sTmp;
            var sValue = "{";
            sValue += '"iCreate":' + new Date().getTime() + ",";
            sValue += '"iStart":' + (oSettings.oScroll.bInfinite ? 0 : oSettings._iDisplayStart) + ",";
            sValue += '"iEnd":' + (oSettings.oScroll.bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd) + ",";
            sValue += '"iLength":' + oSettings._iDisplayLength + ",";
            sValue += '"sFilter":"' + encodeURIComponent(oSettings.oPreviousSearch.sSearch) + '",';
            sValue += '"sFilterEsc":' + !oSettings.oPreviousSearch.bRegex + ",";
            sValue += '"aaSorting":[ ';
            for (i = 0; i < oSettings.aaSorting.length; i++) {
                sValue += "[" + oSettings.aaSorting[i][0] + ',"' + oSettings.aaSorting[i][1] + '"],'
            }
            sValue = sValue.substring(0, sValue.length - 1);
            sValue += "],";
            sValue += '"aaSearchCols":[ ';
            for (i = 0; i < oSettings.aoPreSearchCols.length; i++) {
                sValue += '["' + encodeURIComponent(oSettings.aoPreSearchCols[i].sSearch) + '",' + !oSettings.aoPreSearchCols[i].bRegex + "],"
            }
            sValue = sValue.substring(0, sValue.length - 1);
            sValue += "],";
            sValue += '"abVisCols":[ ';
            for (i = 0; i < oSettings.aoColumns.length; i++) {
                sValue += oSettings.aoColumns[i].bVisible + ","
            }
            sValue = sValue.substring(0, sValue.length - 1);
            sValue += "]";
            for (i = 0, iLen = oSettings.aoStateSave.length; i < iLen; i++) {
                sTmp = oSettings.aoStateSave[i].fn(oSettings, sValue);
                if (sTmp !== "") {
                    sValue = sTmp
                }
            }
            sValue += "}";
            _fnCreateCookie(oSettings.sCookiePrefix + oSettings.sInstance, sValue, oSettings.iCookieDuration, oSettings.sCookiePrefix, oSettings.fnCookieCallback)
        }

        function _fnLoadState(oSettings, oInit) {
            if (!oSettings.oFeatures.bStateSave) {
                return
            }
            var oData, i, iLen;
            var sData = _fnReadCookie(oSettings.sCookiePrefix + oSettings.sInstance);
            if (sData !== null && sData !== "") {
                try {
                    oData = (typeof $.parseJSON == "function") ? $.parseJSON(sData.replace(/'/g, '"')) : eval("(" + sData + ")")
                } catch (e) {
                    return
                }
                for (i = 0, iLen = oSettings.aoStateLoad.length; i < iLen; i++) {
                    if (!oSettings.aoStateLoad[i].fn(oSettings, oData)) {
                        return
                    }
                }
                oSettings.oLoadedState = $.extend(true, {}, oData);
                oSettings._iDisplayStart = oData.iStart;
                oSettings.iInitDisplayStart = oData.iStart;
                oSettings._iDisplayEnd = oData.iEnd;
                oSettings._iDisplayLength = oData.iLength;
                oSettings.oPreviousSearch.sSearch = decodeURIComponent(oData.sFilter);
                oSettings.aaSorting = oData.aaSorting.slice();
                oSettings.saved_aaSorting = oData.aaSorting.slice();
                if (typeof oData.sFilterEsc != "undefined") {
                    oSettings.oPreviousSearch.bRegex = !oData.sFilterEsc
                }
                if (typeof oData.aaSearchCols != "undefined") {
                    for (i = 0; i < oData.aaSearchCols.length; i++) {
                        oSettings.aoPreSearchCols[i] = {
                            sSearch: decodeURIComponent(oData.aaSearchCols[i][0]),
                            bRegex: !oData.aaSearchCols[i][1]
                        }
                    }
                }
                if (typeof oData.abVisCols != "undefined") {
                    oInit.saved_aoColumns = [];
                    for (i = 0; i < oData.abVisCols.length; i++) {
                        oInit.saved_aoColumns[i] = {};
                        oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i]
                    }
                }
            }
        }

        function _fnCreateCookie(sName, sValue, iSecs, sBaseName, fnCallback) {
            var date = new Date();
            date.setTime(date.getTime() + (iSecs * 1000));
            var aParts = window.location.pathname.split("/");
            var sNameFile = sName + "_" + aParts.pop().replace(/[\/:]/g, "").toLowerCase();
            var sFullCookie, oData;
            if (fnCallback !== null) {
                oData = (typeof $.parseJSON == "function") ? $.parseJSON(sValue) : eval("(" + sValue + ")");
                sFullCookie = fnCallback(sNameFile, oData, date.toGMTString(), aParts.join("/") + "/")
            } else {
                sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) + "; expires=" + date.toGMTString() + "; path=" + aParts.join("/") + "/"
            }
            var sOldName = "",
                iOldTime = 9999999999999;
            var iLength = _fnReadCookie(sNameFile) !== null ? document.cookie.length : sFullCookie.length + document.cookie.length;
            if (iLength + 10 > 4096) {
                var aCookies = document.cookie.split(";");
                for (var i = 0, iLen = aCookies.length; i < iLen; i++) {
                    if (aCookies[i].indexOf(sBaseName) != -1) {
                        var aSplitCookie = aCookies[i].split("=");
                        try {
                            oData = eval("(" + decodeURIComponent(aSplitCookie[1]) + ")")
                        } catch (e) {
                            continue
                        }
                        if (typeof oData.iCreate != "undefined" && oData.iCreate < iOldTime) {
                            sOldName = aSplitCookie[0];
                            iOldTime = oData.iCreate
                        }
                    }
                }
                if (sOldName !== "") {
                    document.cookie = sOldName + "=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=" + aParts.join("/") + "/"
                }
            }
            document.cookie = sFullCookie
        }

        function _fnReadCookie(sName) {
            var aParts = window.location.pathname.split("/"),
                sNameEQ = sName + "_" + aParts[aParts.length - 1].replace(/[\/:]/g, "").toLowerCase() + "=",
                sCookieContents = document.cookie.split(";");
            for (var i = 0; i < sCookieContents.length; i++) {
                var c = sCookieContents[i];
                while (c.charAt(0) == " ") {
                    c = c.substring(1, c.length)
                }
                if (c.indexOf(sNameEQ) === 0) {
                    return decodeURIComponent(c.substring(sNameEQ.length, c.length))
                }
            }
            return null
        }

        function _fnDetectHeader(aLayout, nThead) {
            var nTrs = $(nThead).children("tr");
            var nCell;
            var i, j, k, l, iLen, jLen, iColShifted;
            var fnShiftCol = function(a, i, j) {
                while (typeof a[i][j] != "undefined") {
                    j++
                }
                return j
            };
            aLayout.splice(0, aLayout.length);
            for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                aLayout.push([])
            }
            for (i = 0, iLen = nTrs.length; i < iLen; i++) {
                var iColumn = 0;
                for (j = 0, jLen = nTrs[i].childNodes.length; j < jLen; j++) {
                    nCell = nTrs[i].childNodes[j];
                    if (nCell.nodeName.toUpperCase() == "TD" || nCell.nodeName.toUpperCase() == "TH") {
                        var iColspan = nCell.getAttribute("colspan") * 1;
                        var iRowspan = nCell.getAttribute("rowspan") * 1;
                        iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;
                        iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;
                        iColShifted = fnShiftCol(aLayout, i, iColumn);
                        for (l = 0; l < iColspan; l++) {
                            for (k = 0; k < iRowspan; k++) {
                                aLayout[i + k][iColShifted + l] = {
                                    cell: nCell,
                                    unique: iColspan == 1 ? true : false
                                };
                                aLayout[i + k].nTr = nTrs[i]
                            }
                        }
                    }
                }
            }
        }

        function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
            var aReturn = [];
            if (typeof aLayout == "undefined") {
                aLayout = oSettings.aoHeader;
                if (typeof nHeader != "undefined") {
                    aLayout = [];
                    _fnDetectHeader(aLayout, nHeader)
                }
            }
            for (var i = 0, iLen = aLayout.length; i < iLen; i++) {
                for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {
                    if (aLayout[i][j].unique && (typeof aReturn[j] == "undefined" || !oSettings.bSortCellsTop)) {
                        aReturn[j] = aLayout[i][j].cell
                    }
                }
            }
            return aReturn
        }

        function _fnScrollBarWidth() {
            var inner = document.createElement("p");
            var style = inner.style;
            style.width = "100%";
            style.height = "200px";
            style.padding = "0px";
            var outer = document.createElement("div");
            style = outer.style;
            style.position = "absolute";
            style.top = "0px";
            style.left = "0px";
            style.visibility = "hidden";
            style.width = "200px";
            style.height = "150px";
            style.padding = "0px";
            style.overflow = "hidden";
            outer.appendChild(inner);
            document.body.appendChild(outer);
            var w1 = inner.offsetWidth;
            outer.style.overflow = "scroll";
            var w2 = inner.offsetWidth;
            if (w1 == w2) {
                w2 = outer.clientWidth
            }
            document.body.removeChild(outer);
            return (w1 - w2)
        }

        function _fnApplyToChildren(fn, an1, an2) {
            for (var i = 0, iLen = an1.length; i < iLen; i++) {
                for (var j = 0, jLen = an1[i].childNodes.length; j < jLen; j++) {
                    if (an1[i].childNodes[j].nodeType == 1) {
                        if (typeof an2 != "undefined") {
                            fn(an1[i].childNodes[j], an2[i].childNodes[j])
                        } else {
                            fn(an1[i].childNodes[j])
                        }
                    }
                }
            }
        }

        function _fnMap(oRet, oSrc, sName, sMappedName) {
            if (typeof sMappedName == "undefined") {
                sMappedName = sName
            }
            if (typeof oSrc[sName] != "undefined") {
                oRet[sMappedName] = oSrc[sName]
            }
        }

        function _fnGetRowData(oSettings, iRow, sSpecific) {
            var out = [];
            for (var i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
                out.push(_fnGetCellData(oSettings, iRow, i, sSpecific))
            }
            return out
        }

        function _fnGetCellData(oSettings, iRow, iCol, sSpecific) {
            var sData;
            var oCol = oSettings.aoColumns[iCol];
            var oData = oSettings.aoData[iRow]._aData;
            if ((sData = oCol.fnGetData(oData)) === undefined) {
                if (oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null) {
                    _fnLog(oSettings, 0, "Requested unknown parameter '" + oCol.mDataProp + "' from the data source for row " + iRow);
                    oSettings.iDrawError = oSettings.iDraw
                }
                return oCol.sDefaultContent
            }
            if (sData === null && oCol.sDefaultContent !== null) {
                sData = oCol.sDefaultContent
            } else {
                if (typeof sData == "function") {
                    return sData()
                }
            }
            if (sSpecific == "display" && sData === null) {
                return ""
            }
            return sData
        }

        function _fnSetCellData(oSettings, iRow, iCol, val) {
            var oCol = oSettings.aoColumns[iCol];
            var oData = oSettings.aoData[iRow]._aData;
            oCol.fnSetData(oData, val)
        }

        function _fnGetObjectDataFn(mSource) {
            if (mSource === null) {
                return function(data) {
                    return null
                }
            } else {
                if (typeof mSource == "function") {
                    return function(data) {
                        return mSource(data)
                    }
                } else {
                    if (typeof mSource == "string" && mSource.indexOf(".") != -1) {
                        var a = mSource.split(".");
                        if (a.length == 2) {
                            return function(data) {
                                return data[a[0]][a[1]]
                            }
                        } else {
                            if (a.length == 3) {
                                return function(data) {
                                    return data[a[0]][a[1]][a[2]]
                                }
                            } else {
                                return function(data) {
                                    for (var i = 0, iLen = a.length; i < iLen; i++) {
                                        data = data[a[i]]
                                    }
                                    return data
                                }
                            }
                        }
                    } else {
                        return function(data) {
                            return data[mSource]
                        }
                    }
                }
            }
        }

        function _fnSetObjectDataFn(mSource) {
            if (mSource === null) {
                return function(data, val) {}
            } else {
                if (typeof mSource == "function") {
                    return function(data, val) {
                        return mSource(data, val)
                    }
                } else {
                    if (typeof mSource == "string" && mSource.indexOf(".") != -1) {
                        var a = mSource.split(".");
                        if (a.length == 2) {
                            return function(data, val) {
                                data[a[0]][a[1]] = val
                            }
                        } else {
                            if (a.length == 3) {
                                return function(data, val) {
                                    data[a[0]][a[1]][a[2]] = val
                                }
                            } else {
                                return function(data, val) {
                                    for (var i = 0, iLen = a.length - 1; i < iLen; i++) {
                                        data = data[a[i]]
                                    }
                                    data[a[a.length - 1]] = val
                                }
                            }
                        }
                    } else {
                        return function(data, val) {
                            data[mSource] = val
                        }
                    }
                }
            }
        }
        this.oApi._fnExternApiFunc = _fnExternApiFunc;
        this.oApi._fnInitialise = _fnInitialise;
        this.oApi._fnInitComplete = _fnInitComplete;
        this.oApi._fnLanguageProcess = _fnLanguageProcess;
        this.oApi._fnAddColumn = _fnAddColumn;
        this.oApi._fnColumnOptions = _fnColumnOptions;
        this.oApi._fnAddData = _fnAddData;
        this.oApi._fnCreateTr = _fnCreateTr;
        this.oApi._fnGatherData = _fnGatherData;
        this.oApi._fnBuildHead = _fnBuildHead;
        this.oApi._fnDrawHead = _fnDrawHead;
        this.oApi._fnDraw = _fnDraw;
        this.oApi._fnReDraw = _fnReDraw;
        this.oApi._fnAjaxUpdate = _fnAjaxUpdate;
        this.oApi._fnAjaxParameters = _fnAjaxParameters;
        this.oApi._fnAjaxUpdateDraw = _fnAjaxUpdateDraw;
        this.oApi._fnServerParams = _fnServerParams;
        this.oApi._fnAddOptionsHtml = _fnAddOptionsHtml;
        this.oApi._fnFeatureHtmlTable = _fnFeatureHtmlTable;
        this.oApi._fnScrollDraw = _fnScrollDraw;
        this.oApi._fnAdjustColumnSizing = _fnAdjustColumnSizing;
        this.oApi._fnFeatureHtmlFilter = _fnFeatureHtmlFilter;
        this.oApi._fnFilterComplete = _fnFilterComplete;
        this.oApi._fnFilterCustom = _fnFilterCustom;
        this.oApi._fnFilterColumn = _fnFilterColumn;
        this.oApi._fnFilter = _fnFilter;
        this.oApi._fnBuildSearchArray = _fnBuildSearchArray;
        this.oApi._fnBuildSearchRow = _fnBuildSearchRow;
        this.oApi._fnFilterCreateSearch = _fnFilterCreateSearch;
        this.oApi._fnDataToSearch = _fnDataToSearch;
        this.oApi._fnSort = _fnSort;
        this.oApi._fnSortAttachListener = _fnSortAttachListener;
        this.oApi._fnSortingClasses = _fnSortingClasses;
        this.oApi._fnFeatureHtmlPaginate = _fnFeatureHtmlPaginate;
        this.oApi._fnPageChange = _fnPageChange;
        this.oApi._fnFeatureHtmlInfo = _fnFeatureHtmlInfo;
        this.oApi._fnUpdateInfo = _fnUpdateInfo;
        this.oApi._fnFeatureHtmlLength = _fnFeatureHtmlLength;
        this.oApi._fnFeatureHtmlProcessing = _fnFeatureHtmlProcessing;
        this.oApi._fnProcessingDisplay = _fnProcessingDisplay;
        this.oApi._fnVisibleToColumnIndex = _fnVisibleToColumnIndex;
        this.oApi._fnColumnIndexToVisible = _fnColumnIndexToVisible;
        this.oApi._fnNodeToDataIndex = _fnNodeToDataIndex;
        this.oApi._fnVisbleColumns = _fnVisbleColumns;
        this.oApi._fnCalculateEnd = _fnCalculateEnd;
        this.oApi._fnConvertToWidth = _fnConvertToWidth;
        this.oApi._fnCalculateColumnWidths = _fnCalculateColumnWidths;
        this.oApi._fnScrollingWidthAdjust = _fnScrollingWidthAdjust;
        this.oApi._fnGetWidestNode = _fnGetWidestNode;
        this.oApi._fnGetMaxLenString = _fnGetMaxLenString;
        this.oApi._fnStringToCss = _fnStringToCss;
        this.oApi._fnArrayCmp = _fnArrayCmp;
        this.oApi._fnDetectType = _fnDetectType;
        this.oApi._fnSettingsFromNode = _fnSettingsFromNode;
        this.oApi._fnGetDataMaster = _fnGetDataMaster;
        this.oApi._fnGetTrNodes = _fnGetTrNodes;
        this.oApi._fnGetTdNodes = _fnGetTdNodes;
        this.oApi._fnEscapeRegex = _fnEscapeRegex;
        this.oApi._fnUnescapeRegex = _fnUnescapeRegex;
        this.oApi._fnDeleteIndex = _fnDeleteIndex;
        this.oApi._fnReOrderIndex = _fnReOrderIndex;
        this.oApi._fnColumnOrdering = _fnColumnOrdering;
        this.oApi._fnLog = _fnLog;
        this.oApi._fnClearTable = _fnClearTable;
        this.oApi._fnSaveState = _fnSaveState;
        this.oApi._fnLoadState = _fnLoadState;
        this.oApi._fnCreateCookie = _fnCreateCookie;
        this.oApi._fnReadCookie = _fnReadCookie;
        this.oApi._fnDetectHeader = _fnDetectHeader;
        this.oApi._fnGetUniqueThs = _fnGetUniqueThs;
        this.oApi._fnScrollBarWidth = _fnScrollBarWidth;
        this.oApi._fnApplyToChildren = _fnApplyToChildren;
        this.oApi._fnMap = _fnMap;
        this.oApi._fnGetRowData = _fnGetRowData;
        this.oApi._fnGetCellData = _fnGetCellData;
        this.oApi._fnSetCellData = _fnSetCellData;
        this.oApi._fnGetObjectDataFn = _fnGetObjectDataFn;
        this.oApi._fnSetObjectDataFn = _fnSetObjectDataFn;
        var _that = this;
        return this.each(function() {
            var i = 0,
                iLen, j, jLen, k, kLen;
            for (i = 0, iLen = _aoSettings.length; i < iLen; i++) {
                if (_aoSettings[i].nTable == this) {
                    if (typeof oInit == "undefined" || (typeof oInit.bRetrieve != "undefined" && oInit.bRetrieve === true)) {
                        return _aoSettings[i].oInstance
                    } else {
                        if (typeof oInit.bDestroy != "undefined" && oInit.bDestroy === true) {
                            _aoSettings[i].oInstance.fnDestroy();
                            break
                        } else {
                            _fnLog(_aoSettings[i], 0, "Cannot reinitialise DataTable.\n\nTo retrieve the DataTables object for this table, please pass either no arguments to the dataTable() function, or set bRetrieve to true. Alternatively, to destory the old table and create a new one, set bDestroy to true (note that a lot of changes to the configuration can be made through the API which is usually much faster).");
                            return
                        }
                    }
                }
                if (_aoSettings[i].sTableId !== "" && _aoSettings[i].sTableId == this.getAttribute("id")) {
                    _aoSettings.splice(i, 1);
                    break
                }
            }
            var oSettings = new classSettings();
            _aoSettings.push(oSettings);
            var bInitHandedOff = false;
            var bUsePassedData = false;
            var sId = this.getAttribute("id");
            if (sId !== null) {
                oSettings.sTableId = sId;
                oSettings.sInstance = sId
            } else {
                oSettings.sInstance = _oExt._oExternConfig.iNextUnique++
            }
            if (this.nodeName.toLowerCase() != "table") {
                _fnLog(oSettings, 0, "Attempted to initialise DataTables on a node which is not a table: " + this.nodeName);
                return
            }
            oSettings.nTable = this;
            oSettings.oInstance = _that.length == 1 ? _that : $(this).dataTable();
            oSettings.oApi = _that.oApi;
            oSettings.sDestroyWidth = $(this).width();
            if (typeof oInit != "undefined" && oInit !== null) {
                oSettings.oInit = oInit;
                _fnMap(oSettings.oFeatures, oInit, "oCriteria");
                _fnMap(oSettings.oFeatures, oInit, "sBasetype");
                _fnMap(oSettings, oInit, "fnFilterCallback");
                _fnMap(oSettings.oFeatures, oInit, "bPaginate");
                _fnMap(oSettings.oFeatures, oInit, "bLengthChange");
                _fnMap(oSettings.oFeatures, oInit, "bFilter");
                _fnMap(oSettings.oFeatures, oInit, "bSort");
                _fnMap(oSettings.oFeatures, oInit, "bInfo");
                _fnMap(oSettings.oFeatures, oInit, "bProcessing");
                _fnMap(oSettings.oFeatures, oInit, "bAutoWidth");
                _fnMap(oSettings.oFeatures, oInit, "bSortClasses");
                _fnMap(oSettings.oFeatures, oInit, "bServerSide");
                _fnMap(oSettings.oFeatures, oInit, "bDeferRender");
                _fnMap(oSettings.oScroll, oInit, "sScrollX", "sX");
                _fnMap(oSettings.oScroll, oInit, "sScrollXInner", "sXInner");
                _fnMap(oSettings.oScroll, oInit, "sScrollY", "sY");
                _fnMap(oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse");
                _fnMap(oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite");
                _fnMap(oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap");
                _fnMap(oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss");
                _fnMap(oSettings, oInit, "asStripClasses", "asStripeClasses");
                _fnMap(oSettings, oInit, "asStripeClasses");
                _fnMap(oSettings, oInit, "fnPreDrawCallback");
                _fnMap(oSettings, oInit, "fnRowCallback");
                _fnMap(oSettings, oInit, "fnHeaderCallback");
                _fnMap(oSettings, oInit, "fnFooterCallback");
                _fnMap(oSettings, oInit, "fnCookieCallback");
                _fnMap(oSettings, oInit, "fnInitComplete");
                _fnMap(oSettings, oInit, "fnServerData");
                _fnMap(oSettings, oInit, "fnFormatNumber");
                _fnMap(oSettings, oInit, "aaSorting");
                _fnMap(oSettings, oInit, "aaSortingFixed");
                _fnMap(oSettings, oInit, "aLengthMenu");
                _fnMap(oSettings, oInit, "sPaginationType");
                _fnMap(oSettings, oInit, "sAjaxSource");
                _fnMap(oSettings, oInit, "sAjaxDataProp");
                _fnMap(oSettings, oInit, "iCookieDuration");
                _fnMap(oSettings, oInit, "sCookiePrefix");
                _fnMap(oSettings, oInit, "sDom");
                _fnMap(oSettings, oInit, "bSortCellsTop");
                _fnMap(oSettings, oInit, "oSearch", "oPreviousSearch");
                _fnMap(oSettings, oInit, "aoSearchCols", "aoPreSearchCols");
                _fnMap(oSettings, oInit, "iDisplayLength", "_iDisplayLength");
                _fnMap(oSettings, oInit, "bJQueryUI", "bJUI");
                _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
                if (typeof oInit.fnDrawCallback == "function") {
                    oSettings.aoDrawCallback.push({
                        fn: oInit.fnDrawCallback,
                        sName: "user"
                    })
                }
                if (typeof oInit.fnServerParams == "function") {
                    oSettings.aoServerParams.push({
                        fn: oInit.fnServerParams,
                        sName: "user"
                    })
                }
                if (typeof oInit.fnStateSaveCallback == "function") {
                    oSettings.aoStateSave.push({
                        fn: oInit.fnStateSaveCallback,
                        sName: "user"
                    })
                }
                if (typeof oInit.fnStateLoadCallback == "function") {
                    oSettings.aoStateLoad.push({
                        fn: oInit.fnStateLoadCallback,
                        sName: "user"
                    })
                }
                if (oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses) {
                    oSettings.aoDrawCallback.push({
                        fn: _fnSortingClasses,
                        sName: "server_side_sort_classes"
                    })
                } else {
                    if (oSettings.oFeatures.bDeferRender) {
                        oSettings.aoDrawCallback.push({
                            fn: _fnSortingClasses,
                            sName: "defer_sort_classes"
                        })
                    }
                }
                if (typeof oInit.bJQueryUI != "undefined" && oInit.bJQueryUI) {
                    oSettings.oClasses = _oExt.oJUIClasses;
                    if (typeof oInit.sDom == "undefined") {
                        oSettings.sDom = '<"H"lfr>t<"F"ip>'
                    }
                }
                if (oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "") {
                    oSettings.oScroll.iBarWidth = _fnScrollBarWidth()
                }
                if (typeof oInit.iDisplayStart != "undefined" && typeof oSettings.iInitDisplayStart == "undefined") {
                    oSettings.iInitDisplayStart = oInit.iDisplayStart;
                    oSettings._iDisplayStart = oInit.iDisplayStart
                }
                if (typeof oInit.bStateSave != "undefined") {
                    oSettings.oFeatures.bStateSave = oInit.bStateSave;
                    _fnLoadState(oSettings, oInit);
                    oSettings.aoDrawCallback.push({
                        fn: _fnSaveState,
                        sName: "state_save"
                    })
                }
                if (typeof oInit.iDeferLoading != "undefined") {
                    oSettings.bDeferLoading = true;
                    oSettings._iRecordsTotal = oInit.iDeferLoading;
                    oSettings._iRecordsDisplay = oInit.iDeferLoading
                }
                if (typeof oInit.aaData != "undefined") {
                    bUsePassedData = true
                }
                if (typeof oInit != "undefined" && typeof oInit.aoData != "undefined") {
                    oInit.aoColumns = oInit.aoData
                }
                if (typeof oInit.oLanguage != "undefined") {
                    if (typeof oInit.oLanguage.sUrl != "undefined" && oInit.oLanguage.sUrl !== "") {
                        oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
                        $.getJSON(oSettings.oLanguage.sUrl, null, function(json) {
                            _fnLanguageProcess(oSettings, json, true)
                        });
                        bInitHandedOff = true
                    } else {
                        _fnLanguageProcess(oSettings, oInit.oLanguage, false)
                    }
                }
            } else {
                oInit = {}
            }
            if (typeof oInit.asStripClasses == "undefined" && typeof oInit.asStripeClasses == "undefined") {
                oSettings.asStripeClasses.push(oSettings.oClasses.sStripeOdd);
                oSettings.asStripeClasses.push(oSettings.oClasses.sStripeEven)
            }
            var bStripeRemove = false;
            var anRows = $(this).children("tbody").children("tr");
            for (i = 0, iLen = oSettings.asStripeClasses.length; i < iLen; i++) {
                if (anRows.filter(":lt(2)").hasClass(oSettings.asStripeClasses[i])) {
                    bStripeRemove = true;
                    break
                }
            }
            if (bStripeRemove) {
                oSettings.asDestroyStripes = ["", ""];
                if ($(anRows[0]).hasClass(oSettings.oClasses.sStripeOdd)) {
                    oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeOdd + " "
                }
                if ($(anRows[0]).hasClass(oSettings.oClasses.sStripeEven)) {
                    oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeEven
                }
                if ($(anRows[1]).hasClass(oSettings.oClasses.sStripeOdd)) {
                    oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeOdd + " "
                }
                if ($(anRows[1]).hasClass(oSettings.oClasses.sStripeEven)) {
                    oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeEven
                }
                anRows.removeClass(oSettings.asStripeClasses.join(" "))
            }
            var anThs = [];
            var aoColumnsInit;
            var nThead = this.getElementsByTagName("thead");
            if (nThead.length !== 0) {
                _fnDetectHeader(oSettings.aoHeader, nThead[0]);
                anThs = _fnGetUniqueThs(oSettings)
            }
            if (typeof oInit.aoColumns == "undefined") {
                aoColumnsInit = [];
                for (i = 0, iLen = anThs.length; i < iLen; i++) {
                    aoColumnsInit.push(null)
                }
            } else {
                aoColumnsInit = oInit.aoColumns
            }
            for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
                if (typeof oInit.saved_aoColumns != "undefined" && oInit.saved_aoColumns.length == iLen) {
                    if (aoColumnsInit[i] === null) {
                        aoColumnsInit[i] = {}
                    }
                    aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible
                }
                _fnAddColumn(oSettings, anThs ? anThs[i] : null)
            }
            if (typeof oInit.aoColumnDefs != "undefined") {
                for (i = oInit.aoColumnDefs.length - 1; i >= 0; i--) {
                    var aTargets = oInit.aoColumnDefs[i].aTargets;
                    if (!$.isArray(aTargets)) {
                        _fnLog(oSettings, 1, "aTargets must be an array of targets, not a " + (typeof aTargets))
                    }
                    for (j = 0, jLen = aTargets.length; j < jLen; j++) {
                        if (typeof aTargets[j] == "number" && aTargets[j] >= 0) {
                            while (oSettings.aoColumns.length <= aTargets[j]) {
                                _fnAddColumn(oSettings)
                            }
                            _fnColumnOptions(oSettings, aTargets[j], oInit.aoColumnDefs[i])
                        } else {
                            if (typeof aTargets[j] == "number" && aTargets[j] < 0) {
                                _fnColumnOptions(oSettings, oSettings.aoColumns.length + aTargets[j], oInit.aoColumnDefs[i])
                            } else {
                                if (typeof aTargets[j] == "string") {
                                    for (k = 0, kLen = oSettings.aoColumns.length; k < kLen; k++) {
                                        if (aTargets[j] == "_all" || $(oSettings.aoColumns[k].nTh).hasClass(aTargets[j])) {
                                            _fnColumnOptions(oSettings, k, oInit.aoColumnDefs[i])
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (typeof aoColumnsInit != "undefined") {
                for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {
                    _fnColumnOptions(oSettings, i, aoColumnsInit[i])
                }
            }
            for (i = 0, iLen = oSettings.aaSorting.length; i < iLen; i++) {
                if (oSettings.aaSorting[i][0] >= oSettings.aoColumns.length) {
                    oSettings.aaSorting[i][0] = 0
                }
                var oColumn = oSettings.aoColumns[oSettings.aaSorting[i][0]];
                if (typeof oSettings.aaSorting[i][2] == "undefined") {
                    oSettings.aaSorting[i][2] = 0
                }
                if (typeof oInit.aaSorting == "undefined" && typeof oSettings.saved_aaSorting == "undefined") {
                    oSettings.aaSorting[i][1] = oColumn.asSorting[0]
                }
                for (j = 0, jLen = oColumn.asSorting.length; j < jLen; j++) {
                    if (oSettings.aaSorting[i][1] == oColumn.asSorting[j]) {
                        oSettings.aaSorting[i][2] = j;
                        break
                    }
                }
            }
            _fnSortingClasses(oSettings);
            var thead = $(this).children("thead");
            if (thead.length === 0) {
                thead = [document.createElement("thead")];
                this.appendChild(thead[0])
            }
            oSettings.nTHead = thead[0];
            var tbody = $(this).children("tbody");
            if (tbody.length === 0) {
                tbody = [document.createElement("tbody")];
                this.appendChild(tbody[0])
            }
            oSettings.nTBody = tbody[0];
            var tfoot = $(this).children("tfoot");
            if (tfoot.length > 0) {
                oSettings.nTFoot = tfoot[0];
                _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)
            }
            if (bUsePassedData) {
                for (i = 0; i < oInit.aaData.length; i++) {
                    _fnAddData(oSettings, oInit.aaData[i])
                }
            } else {
                _fnGatherData(oSettings)
            }
            _fnCalculateMostFreq(oSettings);
            oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
            oSettings.bInitialised = true;
            if (bInitHandedOff === false) {
                _fnInitialise(oSettings)
            }
        })
    }
})(jQuery, window, document);
(function(G) {
    var O = {
        menu: "ContextMenu",
        item: "ContextItem",
        hoverItem: "ContextHoverItem",
        containerItem: "ContextContainerItem",
        separator: "ContextSeparator",
        disabled: "ContextDisabled"
    };
    G.fn.contextMenu = function(U, S, V, T) {
        if (typeof S == "function") {
            T = V;
            V = S;
            S = {}
        }
        var Q = G.extend(true, {}, O, S);
        var R = {
            menu: U,
            style: Q,
            onShow: V
        };
        this.bind("contextmenu", R, H);
        if (T) {
            this.bind("click", R, H)
        } else {
            this.bind("click", R, L)
        }
    };
    var D;

    function H(Q) {
        if (Q.ctrlKey) {
            return
        }
        C();
        if (Q.data.onShow && Q.data.onShow(Q.data.menu) == false) {
            return
        }
        D = Q.data.menu;
        G(document).bind("click", D, C);
        G(window).bind("blur", D, C);
        M(Q.data.menu);
        var R = Q.pageY;
        if (Q.pageY > G(window).height() - 350) {
            R = G(window).height() - 350
        }
        N(Q.data.menu, Q.data.style, Q.pageX, R);
        return false
    }

    function C() {
        if (!D) {
            return
        }
        G(document).unbind("click", D, C);
        G(window).unbind("blur", D, C);
        M(D);
        D = null
    }

    function L(Q) {
        if (Q.button == 0 && Q.ctrlKey) {
            return H(Q)
        }
    }

    function N(T, R, Q, U) {
        T = G(T);
        T.find("ul").addClass(R.menu).prev("li").addClass(R.containerItem).end().parent("li").addClass(R.containerItem);
        T.find("li").removeClass(R.hoverItem);
        if (T.is(":visible")) {
            return
        }
        T.find("li").bind("click", I).bind("mouseenter", R, F);
        T.find("li[separator]").addClass(R.separator);
        var S = P(T, E(T, R.menu), Q, U);
        T.addClass(R.menu).css("left", S.x).css("top", S.y).show()
    }

    function E(R, Q) {
        return G(R.parents("ul")).hasClass(Q)
    }

    function P(T, V, c, b) {
        var d = T.parent();
        var R = d.offset();
        var X = b;
        var a = c;
        if (!V) {
            X = X - R.top;
            a = a - R.left
        }
        var Z = T.width();
        var U = T.height();
        var Q = K(T);
        var Y = X + R.top + U;
        if (Y > Q.bottom) {
            X = X - U;
            if (V) {
                X = X + 12
            }
        }
        if (V) {
            var S = G(T.parents("ul")).get(0);
            if (S && G(S).offset().left + G(S).width() + Z > Q.right) {
                a = 0 - Z
            }
        } else {
            var W = a + R.left + Z;
            if (W > Q.right) {
                a = a - Z
            }
        }
        return {
            x: a,
            y: X
        }
    }

    function K(W) {
        var S = W.parents();
        var Q = S.length - 1;
        var V = S.length - 1;
        for (var T = 0; T < S.length; T++) {
            var X = G(S[T]).css("overflow-x");
            var U = G(S[T]).css("overflow-y");
            if (T < Q && (X == "hidden" || X == "auto")) {
                Q = T
            }
            if (T < V && (U == "hidden" || U == "auto")) {
                V = T
            }
        }
        var R = {};
        if (G(S[V]).is("body")) {
            R.top = 0;
            R.bottom = G(window).height()
        } else {
            R.top = G(S[V]).offset().top;
            R.bottom = R.top + G(S[V]).height()
        }
        if (G(S[Q]).is("body")) {
            R.left = 0;
            R.right = G(window).width()
        } else {
            R.left = G(S[Q]).offset().left;
            R.right = R.left + G(S[Q]).width()
        }
        return R
    }

    function M(R) {
        var Q = G(R).find("ul").get().reverse();
        G(Q).hide();
        G(R).hide()
    }

    function J(R) {
        R = G(R);
        var Q = R.next();
        if (!Q.is("ul")) {
            Q = R.children()
        }
        if (Q.is("ul")) {
            return Q
        }
    }

    function I(Q) {
        if (this == Q.target) {
            return !J(this)
        }
    }

    function F(S) {
        var Q = this;
        var R = S.data;
        var T = G(this).parent();
        T.children("li").each(function() {
            var W = G(this);
            var V = J(W);
            if (V) {
                var U = T.width();
                var X = W.position().top - 1;
                Q == this ? N(V, R, U, X) : M(V)
            }
            if ((Q == this) && (W.hasClass(R.item))) {
                W.addClass(S.data.hoverItem)
            } else {
                W.removeClass(S.data.hoverItem)
            }
        })
    }
})(jQuery);

function CommunicationLostHandling() {
    ShowActiveDialog({
        title: strings.lostComm.title,
        type: "message",
        message: strings.lostComm.confirmMsg,
        dialogOverride: true,
        okState: "hidden"
    })
}

function CommunicationFoundHandling() {
    HideActiveDialog()
}

function CommunicationSysDownHandling() {
    if (MC.inCodeLoad) {
        MC.sysDownDuringCodeload = true;
        return
    }
    if (!session || !session.authorized) {
        if (panels.welcomePanel && panels.welcomePanel.isVisible) {
            panels.welcomePanel.setSystemStateNotice()
        } else {
            if (panels.loginPanel && panels.loginPanel.isVisible) {
                panels.loginPanel.setSystemStateNotice()
            }
        }
    } else {
        if (MC.allDataSetsLoaded) {
            reloader.off();
            ShowActiveDialog({
                title: strings.sysDown.title,
                type: "message",
                message: strings.sysDown.confirmMsg,
                dialogOverride: true,
                okState: "hidden"
            })
        } else {
            session.logout(logoutComplete)
        }
    }
}

function CommunicationSysUpHandling() {
    if (MC.inCodeLoad) {
        return
    }
    if (connection.getLinkState() == "CONNECTED" && session && !(session.systemState == "initializing" || session.systemState == "down") && EXPR.needWelcome == "none") {
        location.reload()
    }
    if (!session || !session.authorized) {
        if (panels.welcomePanel && panels.welcomePanel.isVisible) {
            panels.welcomePanel.setSystemStateNotice()
        } else {
            if (panels.loginPanel && panels.loginPanel.isVisible) {
                panels.loginPanel.setSystemStateNotice()
            }
        }
    }
    if (MC.allDataSetsLoaded) {
        MC.reloadAllDataSets();
        reloader.on();
        HideActiveDialog()
    }
}

function LoginHandling() {
    if (EXPR.needWelcome == true) {
        new WelcomePanel({})
    } else {
        new LoginPanel({});
        document.getElementById("username").focus()
    }
}

function CommandConfirmHandling(E, C) {
    var D = {
        title: strings.activeDialog.confirmTitle,
        type: "confirm",
        message: C.confirmMsg,
        okLabel: C.okLabel || strings.okButtonText,
        cancelLabel: C.cancelLabel || strings.Cancel,
        dialogOverride: true
    };
    if (MC.cmdQueue && MC.cmdQueue.length) {
        D.ok = function() {
            MC.qcmdExec()
        };
        D.cancel = function() {
            MC.qcmdComplete({
                error: strings.commandlist.canceled
            })
        }
    } else {
        D.ok = createObjectCallback(MC, MC.execCommand1, E, C)
    }
    if (C.confirm2Msg) {
        D.confirmMsg = C.confirm2Msg
    }
    ShowActiveDialog(D)
}

function CommandProcessingHandling(C) {
    if (C.dialog) {
        var D = {
            title: strings.activeDialog.processingTitle,
            type: "processing",
            message: C.processingMsg,
            dialogOverride: C.dialogOverride
        };
        ShowActiveDialog(D)
    }
}

function CommandSuccessHandling(C) {
    if (C.closeActionOn == "any" || C.closeActionOn == "success") {
        panels.actionDialog.close(true)
    }
    if (C.dialog) {
        if (C.autoOK) {
            ActiveDialogOK()
        } else {
            if (!C.noSuccessDialog) {
                var D = {
                    type: "success",
                    message: strings.enhanceOn + C.successMsg + strings.enhanceOff,
                    dialogOverride: true
                };
                if (C.includeInfo) {
                    D.message += "<br>" + C.result.message
                }
                ShowActiveDialog(D)
            }
        }
    }
}

function CommandFailureHandling(C) {
    if (C.closeActionOn == "any" || C.closeActionOn == "failure") {
        panels.actionDialog.close(true)
    }
    if (C.dialog) {
        var D = {
            type: "failure",
            message: strings.enhanceOn + C.failureMsg + strings.enhanceOff + "<br>" + C.result.message,
            dialogOverride: true
        };
        ShowActiveDialog(D)
    }
}

function CommandWarningHandling(C) {
    if (C.closeActionOn == "any" || C.closeActionOn == "success") {
        panels.actionDialog.close(true)
    }
    if (C.dialog) {
        var D = {
            type: "warning",
            message: strings.enhanceOn + strings.warning + strings.enhanceOff + "<br>" + C.result.message,
            dialogOverride: true
        };
        ShowActiveDialog(D)
    }
}

function RedirectToIPHandling(C) {
    var D = {
        title: strings.redirectDialog.title(C),
        header: strings.redirectDialog.header(C),
        message: strings.redirectDialog.message(C),
        type: "processing",
        dialogOverride: true
    };
    ShowActiveDialog(D)
}

function ApplicationLoadingHandling() {
    ShowActiveDialog({
        title: strings.activeDialog.applicationTitle,
        processingMsg: strings.activeDialog.applicationTitle,
        dialogOverride: true,
        noButtons: true
    })
}

function ApplicationDoneLoadingHandling() {
    HideActiveDialog();
    setMenus()
}

function ApplicationStart() {
    EZStartManager.getUserInteractions();
    applicationPreInit()
}

function GetLogsProgress(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.getLogs,
        type: "processing",
        message: C,
        dialogOverride: true
    })
}

function FirmwareUpdateProgress(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.firmwareUpdate,
        type: "processing",
        message: C,
        dialogOverride: true
    })
}

function FirmwareUpdateSuccessReboot(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.firmwareUpdate,
        header: strings.updateFirmware.fwUpdateSucceededReboot,
        type: "processing",
        message: C,
        dialogOverride: true
    })
}

function FirmwareUpdateSuccessNoReboot(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.firmwareUpdate,
        header: strings.updateFirmware.fwUpdateSucceededNoReboot,
        type: "success",
        message: C,
        dialogOverride: true,
        ok: function() {
            panels.actionDialog.close(true)
        }
    })
}

function FirmwareUpdateFailureReboot(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.firmwareUpdate,
        header: strings.updateFirmware.fwUpdateFailedReboot,
        type: "failure",
        message: C,
        dialogOverride: true
    })
}

function FirmwareUpdateFailureNoReboot(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.firmwareUpdate,
        header: strings.updateFirmware.fwUpdateFailedNoReboot,
        type: "failure",
        message: C,
        dialogOverride: true
    })
}

function GetLogsFailureNoReboot(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.getLogs,
        header: strings.updateFirmware.saveLogs.failed,
        type: "failure",
        message: C,
        dialogOverride: true
    })
}

function GetLogsSuccess(C) {
    ShowActiveDialog({
        title: strings.progressOf + strings.getLogs,
        header: strings.saveLogs.succeeded,
        type: "success",
        message: C,
        dialogOverride: true
    });
    SaveLogsAction.inProcess = false;
    MC.saveLogsInProcess = false;
    SaveLogsAction.save()
}

function ProgressFinishedUnknown(C) {
    ShowActiveDialog({
        type: "error",
        message: C,
        dialogOverride: true
    })
}

function SessionWarningHandling() {
    ShowActiveDialog({
        title: strings.sessionWarning.title,
        type: "message",
        message: strings.sessionWarning.confirmMsg,
        dialogOverride: true,
        ok: SessionWarningOk
    })
}

function UnauthorizedAccessHandling() {
    ShowActiveDialog({
        title: strings.unauthorized.title,
        type: "message",
        message: strings.unauthorized.confirmMsg,
        dialogOverride: true,
        ok: UnauthorizedAccessOk
    })
}

function SessionTimeoutHandling() {
    ShowActiveDialog({
        title: strings.sessionTimeout.title,
        type: "message",
        message: strings.sessionTimeout.confirmMsg,
        dialogOverride: true,
        ok: SessionTimeoutOk
    })
}

function ApplicationLoadingMessage(C) {
    if (applicationLoading) {
        ActiveDialogUpdate({
            processingMsg: C
        })
    }
}

function compareVersions(G, F) {
    var E = G.split(".");
    var D = F.split(".");
    for (var C = 0; C < E.length; ++C) {
        if (D.length == C) {
            return 1
        }
        if (E[C] == D[C]) {
            continue
        } else {
            if (parseInt(E[C], 10) > parseInt(D[C], 10)) {
                return 1
            } else {
                return -1
            }
        }
    }
    if (E.length != D.length) {
        return -1
    }
    return 0
}

function detectBrowser() {
    var D = navigator.userAgent;
    var C = {};
    if (D.match("Firefox")) {
        C.mozilla = true
    } else {
        if (D.match("Safari") && D.match("Version")) {
            C.safari = true
        } else {
            if (D.match("Chrome")) {
                C.chrome = true
            } else {
                if (D.match("Trident")) {
                    C.ie = true;
                    if (D.match("rv")) {
                        C.isIE11 = true
                    }
                }
            }
        }
    }
    return C
}
if (navigator && navigator.platform && (navigator.platform.toLowerCase().indexOf("mac") == 0)) {
    onMac = true
} else {
    onMac = false
}

function decodeBooleanFlag(D) {
    if (D == undefined || D === null) {
        return false
    }
    var C = parseInt(D, 10);
    var F;
    if (typeof strings.Yes != "undefined") {
        F = strings.Yes.toLowerCase()
    } else {
        if (typeof strings.common.yesLabel != "undefined") {
            F = strings.common.yesLabel.toLowerCase()
        }
    }
    if (isNaN(C)) {
        if ((typeof D) == "string") {
            var E = D.toLowerCase();
            if (E == "true" || E == "on" || E == "enabled" || E == "yes" || E == F) {
                return (true)
            } else {
                return (false)
            }
        } else {
            if ((typeof D) == "boolean") {
                return D
            }
        }
    } else {
        if (C == 0) {
            return (false)
        } else {
            return true
        }
    }
}

function keys(E) {
    var D = [];
    for (var C in E) {
        if (E.hasOwnProperty(C) && typeof(E[C]) !== "function") {
            D.push(C)
        }
    }
    return D
}

function leadingZeros(E, C) {
    var D = "" + E;
    while (D.length < C) {
        D = "0" + D
    }
    return D
}
Array.prototype.find = function(F, C) {
    if (F == undefined) {
        return -1
    }
    var E = this.length;
    var G = false;
    for (var D = 0; D < E; D++) {
        if (C) {
            if (C(this[D], F)) {
                G = true
            }
        } else {
            if ($.isFunction(F.equals)) {
                if (F.equals(this[D])) {
                    G = true
                }
            } else {
                if (F === this[D]) {
                    G = true
                }
            }
        }
        if (G) {
            return D
        }
    }
    return -1
};
Array.prototype.remove = function(E, C) {
    var D = this.find(E, C);
    if (D == -1) {
        return false
    }
    this.splice(D, 1);
    return true
};
Array.prototype.empty = function() {
    this.splice(0, this.length)
};
Array.prototype.contains = function(D) {
    var C = this.length;
    while (C--) {
        if (this[C].get("name") == D) {
            return C
        }
    }
    return -1
};
Array.prototype.equals = function(E) {
    if (!E) {
        return false
    }
    if (this.length != E.length) {
        return false
    }
    for (var D = 0, C = this.length; D < C; D++) {
        if (this[D] instanceof Array && E[D] instanceof Array) {
            if (!this[D].equals(E[D])) {
                return false
            }
        } else {
            if (this[D] != E[D]) {
                return false
            }
        }
    }
    return true
};

function PersistedProperty(C) {
    if (arguments.length == 0 || C.name == undefined) {
        return
    }
    this.name = C.name;
    if (C.value != undefined) {
        this.set(C.value, C.options)
    } else {
        this.value = $.cookie(this.name)
    }
}
PersistedProperty.prototype.set = function(D, C) {
    if (this.name == undefined) {
        return
    }
    this.value = D;
    $.cookie(this.name, this.value, C)
};
PersistedProperty.prototype.get = function() {
    if (this.name == undefined) {
        return null
    }
    if (this.value == undefined) {
        this.value = $.cookie(this.name)
    }
    return this.value
};
PersistedProperty.prototype.getName = function() {
    return this.name
};

function ipv4ToIpv6(C) {
    var E = C.split(".");
    for (var D = 0; D < 4; D++) {
        E[D] = parseInt(E[D], 10).toString(16).toUpperCase();
        if (E[D].length == 1) {
            E[D] = "0" + E[D]
        }
    }
    var F = "0000:0000:0000:0000:0000:0000:" + E[0] + E[1] + ":" + E[2] + E[3];
    return (F)
}

function ipv6ToIpv4(C) {
    var D = C.split(":");
    if (D.length == 7) {
        var G = false;
        for (var E = 0; E < 5; E++) {
            if (parseInt(D[E], 10) != 0) {
                G = true;
                break
            }
        }
        if (!G && parseInt(D[5], 10) != 0 && D[5] != "FFFF") {
            G = true
        }
        if (!G) {
            var L = D[6];
            if (L.match(/^\d+\.\d+\.\d+\.\d+$/)) {
                return L
            } else {
                G = true
            }
        }
    } else {
        if (D.length == 3) {
            if (D[0] != "" || D[1] != "") {
                G = true
            } else {
                if (!(D[2].match(/^\d+\.\d+\.\d+\.\d+$/))) {
                    if (D[2] == "") {
                        return "0.0.0.0"
                    } else {
                        G = true
                    }
                } else {
                    return D[2]
                }
            }
        } else {
            if (D.length == 4) {
                if (D[0] != "" || D[1] != "" || D[2] != "FFFF") {
                    G = true
                } else {
                    if (!(D[3].match(/^\d+\.\d+\.\d+\.\d+$/))) {
                        G = true
                    } else {
                        return D[3]
                    }
                }
            } else {
                if (D.length == 8) {
                    for (var E = 0; E < 6; E++) {
                        if (parseInt(D[E], 10) != 0) {
                            G = true;
                            break
                        }
                    }
                    if (!G) {
                        var K = parseInt(D[6].substring(0, 2), 16);
                        var I = parseInt(D[6].substring(2, 4), 16);
                        var H = parseInt(D[7].substring(0, 2), 16);
                        var F = parseInt(D[7].substring(2, 4), 16);
                        var J = K + "." + I + "." + H + "." + F;
                        return (J)
                    }
                } else {
                    G = true
                }
            }
        }
    }
    if (G) {
        MC.warningOutput("Could not convert IPv6 address (%s) to IPv4!", C);
        return (C)
    }
}

function propertyCount(E, C) {
    if (!E || !(E instanceof Object)) {
        return 0
    }
    var D = 0;
    for (var F in E) {
        if (E.hasOwnProperty(F)) {
            if (!C || ((typeof E[F]) == C)) {
                D++
            }
        }
    }
    return D
}

function objectCount(E, F) {
    if (!E || !(E instanceof Object)) {
        return 0
    }
    var D = 0;
    for (var C in E) {
        if (E[C] instanceof Object) {
            if (F != undefined) {
                if (E[C] instanceof F) {
                    D++
                }
            } else {
                D++
            }
        }
    }
    return D
}

function cpsMode() {
    return (settings.inDev && !settings.memorex)
}
String.prototype.trim = function() {
    return this.replace(/^\s+|\s+$/g, "")
};
RelInfo.prototype.feature = function(D, C) {
    if (this[D] != undefined) {
        return this[D]
    } else {
        return C
    }
};
RelInfo.prototype.featureMatches = function(E, F, C) {
    var D = this[E];
    if (D == undefined) {
        if (C == undefined) {
            D = "false"
        } else {
            if ((typeof C) == "boolean") {
                D = (C ? "true" : "false")
            } else {
                D = C
            }
        }
    }
    if ((typeof F) == "boolean") {
        var G = (F ? "true" : "false")
    } else {
        var G = F
    }
    return (D === G)
};
RelInfo.prototype.hasFeature = function(C) {
    if (this[C] != undefined) {
        return decodeBooleanFlag(this[C])
    } else {
        return false
    }
};
RelInfo.prototype.getMaxNameLength = function() {
    var C = 20;
    if (this.hasFeature("32ByteNames")) {
        C = 32
    }
    return C
};
RelInfo.prototype.supportsLinear = function() {
    if (this.storageModel == "LINEAR" || this.storageModel == "HYBRID") {
        return true
    } else {
        return false
    }
};
RelInfo.prototype.supportsPaged = function() {
    if (this.storageModel == "PAGED" || this.storageModel == "HYBRID") {
        return true
    } else {
        return false
    }
};
RelInfo.prototype.pagedOnly = function() {
    return (RI.feature("storageModel") == "PAGED")
};
RelInfo.prototype.supportsSnaps = function() {
    if ((this.supportsLinear() && this.hasFeature("dms")) || (this.supportsPaged() && this.hasFeature("copyServices"))) {
        return true
    } else {
        return false
    }
};

function createCssRules(K, J, L) {
    if (!K || !J) {
        return
    }
    if (L == undefined) {
        var I = document
    } else {
        var I = L
    }
    if (!I.styleSheets) {
        return
    }
    if (I.getElementsByTagName("head").length == 0) {
        return
    }
    var H;
    for (var E = 0, F = I.styleSheets.length; E < F; E++) {
        if (I.styleSheets[E].href && I.styleSheets[E].href.indexOf(J) > 0) {
            H = I.styleSheets[E];
            break
        }
    }
    if (!H) {
        return
    }
    var D = typeof H.insertRule == "function";
    for (var C = 0, F = K.length; C < F; C++) {
        if (!K[C].selector || !K[C].style) {
            continue
        }
        if (D) {
            var G = K[C].selector + "{" + K[C].style + "}";
            H.insertRule(G, H.cssRules.length)
        } else {
            H.addRule(K[C].selector, K[C].style)
        }
    }
}

function getTextWidth(G, C) {
    var D = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
    if (D == undefined) {
        return 20
    }
    var E = D.getContext("2d");
    E.font = C;
    var F = E.measureText(G);
    return F.width
}

function isUserPrecisionPrefHigher() {
    var C = DC.users[session.userName.value];
    if (C && parseInt(C.prop.storage_size_precision.text) > 3) {
        return true
    } else {
        if (!EXPR.isLdapDisabled) {
            var D = session.sessionPreferences.usergroupname;
            if (DC.usergroups[D] != undefined && parseInt(DC.usergroups[D].prop.storage_size_precision.text) > 3) {
                return true
            }
        }
    }
    return false
}

function getControllerInfo() {
    var C = 4;
    if (DC.controllers.A) {
        C = APIPort.getPortCount("A")
    } else {
        if (DC.controllers.B) {
            C = APIPort.getPortCount("B")
        }
    }
    var D = {
        single: (DC.advSettings.getInt("single_controller_numeric") == 1),
        count: propertyCount(DC.controllers),
        local: system.local_controller,
        portsPer: C,
        isEX: (C == 2)
    };
    if (D.count == 1) {
        D.other = null;
        D.otherInstalled = false;
        D.otherUp = false
    } else {
        D.other = (D.local == "A" ? "B" : "A");
        D.otherInstalled = (DC.controllers[D.other].getInt("status_numeric") != CONTROLLER_STATUS.NOT_INSTALLED);
        D.otherUp = (DC.controllers[D.other].getInt("status_numeric") == CONTROLLER_STATUS.UP)
    }
    return D
}

function getHostPortMode() {
    var G = DC.ports;
    var E = [];
    var F;
    for (var C in G) {
        var D = G[C].get("media");
        if (D.match(/FC\(.*\)/)) {
            D = "FC"
        }
        if (E.find(D) == -1) {
            E.push(D)
        }
    }
    if (E.length > 1) {
        F = "HYBRID"
    } else {
        F = E[0]
    }
    return F
}

function getBaseLUN() {
    if (system && DC.ports && isHPsystem() && APIPort.hasPortType("SAS")) {
        return 1
    } else {
        return 0
    }
}

function hasUTF(D) {
    if (D == undefined || ((typeof D) != "string") || D.length == 0) {
        return false
    }
    var C = encodeURI(D);
    if (C.indexOf("%") != -1) {
        return true
    }
    return false
}

function utf8bytes(F) {
    if (F == undefined || ((typeof F) != "string") || F.length == 0) {
        return 0
    }
    var C = encodeURI(F);
    var E = 0;
    if (C.indexOf("%") == -1) {
        E = C.length
    } else {
        E = C.split("%").length - 1;
        if (E == 0) {
            E++
        }
        var D = C.length - (E * 3);
        E += D
    }
    return (E)
}

function userBasePreferenceIsDecimal() {
    var C = DC.users[session.userName.value];
    if (C && parseInt(C.prop.storage_size_base.text, 10) == 10) {
        return true
    } else {
        if (!EXPR.isLdapDisabled) {
            var D = session.sessionPreferences.usergroupname;
            if (DC.usergroups[D] != undefined && parseInt(DC.usergroups[D].prop.storage_size_base.text, 10) == 10) {
                return true
            }
        }
    }
    return false
}

function getRemovableSpareDisks(D, H) {
    var C = [];
    var F = D.disks;
    for (var G in F) {
        var E = F[G];
        if (parseInt(E.prop.usage_numeric.text) == DRIVE_USAGE.DEDICATED_SPARE && !isSpareExists(H, E)) {
            C.push(E)
        }
    }
    return C
}

function getRemovableGlobalSpareDisks(F) {
    var C = [];
    var E = DC.disks;
    for (var G in E) {
        var D = E[G];
        if (parseInt(D.prop.usage_numeric.text) == DRIVE_USAGE.GLOBAL_SPARE && !isSpareExists(F, D)) {
            C.push(D)
        }
    }
    return C
}

function removeExistingSpares(F) {
    var E = new APIData();
    for (var D = 0; D < F.objects.length; D++) {
        var C = F.objects[D];
        if (parseInt(C.prop.usage_numeric.text) != DRIVE_USAGE.DEDICATED_SPARE) {
            E.addObject(C)
        }
    }
    return E
}

function removeExistingGlobalSpares(F) {
    var E = new APIData();
    for (var D = 0; D < F.objects.length; D++) {
        var C = F.objects[D];
        if (parseInt(C.prop.usage_numeric.text) != DRIVE_USAGE.GLOBAL_SPARE) {
            E.addObject(C)
        }
    }
    return E
}

function isSpareExists(F, E) {
    for (var D = 0; D < F.objects.length; D++) {
        var C = F.objects[D];
        if (C.prop.durable_id.text == E.prop.durable_id.text) {
            return true
        }
    }
    return false
}

function getPortUsage(I) {
    var J = [false, false, false, false];
    var E = I.split(",");
    var H = system.physicalPositionOffset;
    for (var D = 0; D < E.length; D++) {
        var G = E[D];
        for (var C = 0, F = H; C < getControllerInfo().portsPer; C++, F++) {
            if (G == ("" + F) || G == ("A" + F) || G == ("B" + F)) {
                J[C] = true
            }
        }
    }
    return J
}

function getPorts(E) {
    var D = [];
    for (var C = 0; C < getControllerInfo().portsPer; C++) {
        if (E[C]) {
            D.push("A" + (C + system.physicalPositionOffset));
            D.push("B" + (C + system.physicalPositionOffset))
        }
    }
    return D
}

function IsLunUsed(J, I) {
    var F = null;
    var D = MC.mapsSet;
    var K = D.getData().objects;
    if (K === undefined || K.length == 0) {
        return false
    }
    var H = getDefaultMappingLuns(D);
    for (var G = 0; G < J.length; G++) {
        if (J[G].host == undefined) {
            continue
        } else {
            F = getExplicitMappingLun(D, J[G].host, J[G].volume_serial, J[G].volumeGroup_Serial)
        }
        if (F != null && F == parseInt(J[G].lun)) {
            continue
        }
        if (I != null && I.find(parseInt(J[G].lun)) != -1) {
            continue
        }
        var C = H.filter(function(L) {
            return L.lun == parseInt(J[G].lun) && L.volume_serial == J[G].volume_serial && L.access_numeric == J[G].access_numeric && J[G].ports.equals(L.ports)
        });
        if (C.length != 0) {
            continue
        }
        var E = H.filter(function(L) {
            return L.lun == parseInt(J[G].lun)
        });
        if (E.length != 0) {
            return true
        } else {
            continue
        }
    }
    return false
}

function getExplicitMappingLun(G, J, F, E) {
    var O = null;
    var M = G.getData();
    if (E !== null && E !== undefined) {
        O = M.getObject("serial_number", E)
    } else {
        O = M.getObject("volume_serial", F)
    }
    if (O == null) {
        return null
    }
    var N = MC.sessionParametersSet.getData().getObjectOfBasetype("cli-parameters");
    var I = {
        type: "AND",
        conditions: [{
            type: "prop",
            not: true,
            name: "mapped_id",
            value: "AOI"
        }, {
            type: "prop",
            not: true,
            name: "access_numeric",
            value: "0"
        }]
    };
    if (N.getPropertyValue("management_mode") === "v2") {
        I.conditions.push({
            type: "prop",
            name: "port_wwn",
            value: J
        });
        var C = O.select(I);
        if (C != null && C.getNthObject(0) != null) {
            if (C.getNthObject(0).getPropertyValue("access_numeric") == PORT_ACCESS.NO_ACCESS) {
                return getBaseLUN()
            } else {
                return parseInt(C.getNthObject(0).getPropertyValue("lun"))
            }
        }
    } else {
        var C = O.select(I);
        var D = null;
        if (C != null && C.objects.length != 0) {
            for (var H = 0; H < C.objects.length; H++) {
                if (C.objects[H] instanceof APIVolumeViewMappings) {
                    hostname = C.objects[H].getHostName() == " " ? C.objects[H].getPropertyValue("identifier") : C.objects[H].getHostName();
                    var K = getInitiatorIds(hostname);
                    if (K != null && K.find(J) != -1) {
                        if (C.objects[H].getPropertyValue("access_numeric") == PORT_ACCESS.NO_ACCESS) {
                            return getBaseLUN()
                        } else {
                            return C.objects[H].getPropertyValue("lun")
                        }
                    }
                } else {
                    var L = C.objects[H].select({
                        type: "prop",
                        name: "volume_serial",
                        value: F
                    });
                    if (L != null && L.getNthObject(0) != null) {
                        if (C.objects[H].getPropertyValue("access_numeric") == PORT_ACCESS.NO_ACCESS) {
                            return getBaseLUN()
                        } else {
                            return L.getNthObject(0).getPropertyValue("lun")
                        }
                    }
                }
            }
        }
    }
    return null
}

function getDefaultMappingLuns(F) {
    var C = [];
    var I = {
        type: "AND",
        conditions: [{
            type: "prop",
            name: "mapped_id",
            value: "AOI"
        }, {
            type: "prop",
            not: true,
            name: "access_numeric",
            value: "0"
        }]
    };
    for (var E = 0; E < F.getData().objects.length; E++) {
        var G = F.getData().objects[E];
        var H = G.select(I);
        if (H != null && H.objects.length != 0) {
            for (var D = 0; D < H.objects.length; D++) {
                mapSet = H.objects[D];
                if (G instanceof APIVolumeGroupView) {
                    $.each(mapSet.objects, function() {
                        C.push({
                            volume_name: this.getPropertyValue("volume_name"),
                            volume_serial: this.getPropertyValue("volume_serial"),
                            lun: parseInt(this.getPropertyValue("lun")),
                            access_numeric: parseInt(this.parentObject.getPropertyValue("access_numeric")),
                            ports: this.parentObject.getPropertyValue("ports") == "" ? [] : getPorts(getPortUsage(this.parentObject.getPropertyValue("ports")))
                        })
                    })
                } else {
                    if (mapSet.getPropertyValue("access_numeric") == PORT_ACCESS.NO_ACCESS) {
                        C.push({
                            volume_name: G.getPropertyValue("volume_name"),
                            volume_serial: G.getPropertyValue("volume_serial"),
                            lun: getBaseLUN(),
                            access_numeric: parseInt(mapSet.getPropertyValue("access_numeric")),
                            ports: mapSet.getPropertyValue("ports") == "" ? [] : getPorts(getPortUsage(mapSet.getPropertyValue("ports")))
                        })
                    } else {
                        C.push({
                            volume_name: G.getPropertyValue("volume_name"),
                            volume_serial: G.getPropertyValue("volume_serial"),
                            lun: parseInt(mapSet.getPropertyValue("lun")),
                            access_numeric: parseInt(mapSet.getPropertyValue("access_numeric")),
                            ports: mapSet.getPropertyValue("ports") == "" ? [] : getPorts(getPortUsage(mapSet.getPropertyValue("ports")))
                        })
                    }
                }
            }
        }
    }
    return C
}

function getInitiatorIds(D) {
    var F = [];
    if (D.indexOf(".*.*") != -1) {
        var C = D.replace(".*.*", "");
        $.each(DC.hostGroups[C].hosts, function() {
            $.each(DC.hosts[this.getPropertyValue("name")].initiators, function() {
                F.push(this.getPropertyValue("id"))
            })
        })
    } else {
        if (D.indexOf(".*") != -1) {
            var E = D.replace(".*", "");
            $.each(DC.hosts[E].initiators, function() {
                F.push(this.getPropertyValue("id"))
            })
        } else {
            if (DC.initiators[D] !== undefined) {
                F.push(DC.initiators[D].getPropertyValue("id"))
            } else {
                if (DC.findInitiatorByNickname(D) != null) {
                    F.push(DC.findInitiatorByNickname(D).getPropertyValue("id"))
                }
            }
        }
    }
    return F
}

function replicationSetup() {
    if (decodeBooleanFlag(DC.systemParameters.get("linear_replication_configured_numeric"))) {
        return "rsr"
    } else {
        if (decodeBooleanFlag(DC.systemParameters.get("virtual_replication_configured_numeric"))) {
            return "ar"
        } else {
            return "none"
        }
    }
}

function isHPsystem() {
    var C = MC.systemInfoSet.data.objects[0].getPropertyValue("vendor_name");
    MC.debugOutput("isHpSystem: vendor " + C);
    if (C.indexOf("HP") != -1) {
        return true
    } else {
        return false
    }
}

function isIndysystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    if (C == 12) {
        return true
    } else {
        return false
    }
}

function isQuantumSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 16) ? true : false
}

function isStratusSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 3) ? true : false
}

function isVistaSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 17) ? true : false
}

function downloadData(C, E) {
    function D() {
        if (this.readyState === this.DONE) {
            if (this.status === 200) {
                if (window.navigator && window.navigator.msSaveOrOpenBlob) {
                    var I = [this.response];
                    var G = new Blob(I);
                    window.navigator.msSaveOrOpenBlob(G, C)
                } else {
                    var J = window.URL.createObjectURL(this.response);
                    var H = document.createElement("a");
                    H.style = "display: none";
                    document.body.appendChild(H);
                    H.href = J;
                    H.download = C;
                    H.click();
                    window.URL.revokeObjectURL(J)
                }
                panels.actionDialog.close(true)
            }
        }
    }
    var F = new XMLHttpRequest();
    F.open("GET", "/api/" + E);
    F.onreadystatechange = D;
    F.responseType = "blob";
    F.setRequestHeader("sessionkey", session.getSessionKey());
    F.send()
}
var MCDEBUG_ENABLED = settings.inDev;
var mcDebugs = {
    ajax: false,
    backChannel: false,
    bcUpdate: false,
    jsonUpdate: false,
    map: false
};
var mcDebugDescription = {
    ajax: "Logs details about dataset and other ajax requests, no parameter.",
    backChannel: "Logs details of backchannel requests, no parameter.",
    bcUpdate: "Logs all backchannel data updates, or those with optional object name, key, or basetype.",
    jsonUpdate: "Logs all json cache updates, or those with optional object name, key, or basetype.",
    map: "Logs details of map action operation"
};
if (settings.debugFlags) {
    for (var flag in settings.debugFlags) {
        if (mcDebugs[flag] != undefined) {
            mcDebugs[flag] = settings.debugFlags[flag]
        }
    }
}
var ENCLOSURE_TYPE = {
    XYRATEX12: 9,
    XYRATEX24: 10,
    TITAN: 12
};
var REDUNDANCY_MODE = {
    UNKNOWN: 0,
    STANDALONE_SINGLE_PORT: 1,
    STANDALONE_DUAL_PORT: 2,
    ACTIVE_ACTIVE_SINGLE_PORT: 3,
    ACTIVE_ACTIVE_DUAL_PORT: 4,
    ACTIVE_PASSIVE_DUAL_PORT: 5,
    ACTIVE_ACTIVE_DUAL_PORT_MULTI_ID: 6,
    ACTIVE_ACTIVE_DUAL_PORT_NO_MIRROR: 7,
    ACTGIVE_ACTIVE_DUAP_PORT_ULP: 8,
    SINGLE_CONTROLLER: 9,
    FAIL_OVER: 10,
    DOWN: 11
};
var SECOND = 1000;
var TIERS = {
    PERFORMANCE: 1,
    STANDARD: 2,
    ARCHIVE: 4,
    READCACHE: 8
};
var TIER_AFFINITY = {
    NOAFFINITY: 0,
    ARCHIVE: 1,
    PERFORMANCE: 2
};
var DISK_TYPES = {
    UNKNOWN: 0,
    MIXED: 1,
    FC: 2,
    SATA: 3,
    SAS: 4,
    SATA_SINGLE_PORT: 5,
    SAS_SINGLE_PORT: 6,
    SSD_SATA: 7,
    SSD_SAS: 8,
    SSD_SATA_SINGLE_PORT: 9,
    SSD_SAS_SINGLE_PORT: 10,
    NL: 11,
    NL_SINGLE_PORT: 12
};
var DISK_ARCH = {
    SSD: 0,
    HDD: 1,
    UNKNOWN: 2
};
var DISK_IF = {
    SAS: 0,
    SATA: 1,
    FC: 2,
    UNKNOWN: 3
};
var PI_TYPES = {
    T0: "0",
    T1: "1",
    T2: "2",
    T3: "3",
    UNSUPPORTED: "4"
};
var DISK_TYPE_LABELS = ["???", "???", "FC", "SATA", "SAS", "SATA-S", "SAS-S", "SSD", "SSD", "SSD-S", "SSD-S", "MDL", "MDL"];
var VOLUME_CLASS = {
    LINEAR: 0,
    VIRTUAL: 1
};
var VOLUME_TYPES = {
    VOLUME: 0,
    BACKING_STORE: 1,
    MASTER_VOLUME: 2,
    SNAPSHOT: 3,
    ROLLOFF: 4,
    SCOREBOARD_STORE: 5,
    MIRROR_COMPONENT: 6,
    SCOREBOARD_STORE_MIRROR_SET: 7,
    RSR_SOURCE: 8,
    PAGED_STORAGE_COMP: 9,
    PAGED_STORAGE_POOL: 10,
    PAGED_STORAGE_MULTIWRITE: 11,
    METADATA: 12,
    PAGED_SNAPSHOT: 13,
    UNDEFINED: 14,
    BASE: 15,
    VOLUME_COPY: 16
};
var REP_STATUS = {
    SYNC_ACTIVE: 1,
    UNSYNC: 2,
    RUNNING: 3,
    READY: 4,
    SUSPENDED: 5,
    FAILEDOVER: 6,
    NOTCOMMUNICATING: 7
};
var REPSET_DIRECTION = {
    INBOUND: 0,
    OUTBOUND: 1
};
var STANDARD_VOLUME_TYPES = {
    "0": true,
    "2": true,
    "4": true,
    "8": true,
    "15": true,
    "16": true
};
var READ_AHEAD_SIZE = {
    "0": "disabled",
    "-1": "adaptive",
    "-2": "stripe",
    "65536": "512KB",
    "131072": "512KB",
    "262144": "512KB",
    "524288": "512KB",
    "1048576": "1MB",
    "2097152": "2MB",
    "4194304": "4MB",
    "8388608": "8MB",
    "16777216": "16MB",
    "33554432": "32MB"
};
var VOLUME_GROUP_TYPES = {
    VOLUME: 3648,
    CONSISTENCY: 5861
};
var REMOTE_INTERFACE_TYPES = {
    FC: 0,
    iSCSI: 1,
    SAS: 2,
    Hybrid: 3,
    FCoE: 4
};
TREETYPES = {
    ROOT: "Sr_",
    LOGICAL: "Sl_",
    PHYSICAL: "Sp_",
    CONTROLLER_SET: "Sc_",
    VDISK_SET: "Sv_",
    HOST_SET: "Sh_",
    SNAP_SET: "Sss_",
    SNAPPOOL_SET: "Ssp_",
    VDISK_FREE: "Svf_",
    REPIMAGE_SET: "Sri_",
    SYSTEM: "s_",
    ENCLOSURE: "e_",
    CONTROLLER: "c_",
    VDISK: "vd_",
    VOLUME: "vo_",
    SNAPSHOT: "sn_",
    SNAPPOOL: "sp_",
    HOST: "hn_",
    VOLUME_MAP: "vm_",
    REMOTE_SYSTEM: "rs_",
    REPLICATION_VOLUME: "rv_",
    REPLICATION_IMAGE: "ri_",
    HELP: "he_"
};
PAGEBLOCKS = {
    A: 8192,
    B: 8192,
    set: false
};
HEALTH_CLASS = {
    "0": "healthOk",
    "1": "healthDegraded",
    "2": "healthBad",
    "3": "healthUnknown",
    "4": "healthNA"
};
HEALTH = {
    OK: 0,
    DEGRADED: 1,
    FAULT: 2,
    UNKNOWN: 3,
    NA: 4
};
EVENT_TYPES = {
    "0": "info",
    "1": "warning",
    "2": "error",
    "3": "critical"
};
STORAGE_TYPES = {
    R: "read-cache",
    "0": "linear",
    "1": "virtual"
};
STORAGE_CLASS = {
    LINEAR: "0",
    VIRTUAL: "1"
};
STORAGE_MODELS = {
    LINEAR: 0,
    PAGED: 1
};
FDE_STATES = {
    FDE_RESERVED: 0,
    UNSECURED: 1,
    SECURED: 2,
    SECURED_LOCK_READY: 3,
    SECURED_LOCKED: 4
};
FDE_DRIVE_STATES = {
    UNKNOWN: 0,
    NOT_CAPABLE: 1,
    UNSECURED: 2,
    SECURED_UNLOCKED: 3,
    SECURED_LOCKED: 4,
    PROTOCOL_FAILURE: 5
};
DISK_GROUP_STATE = {
    OFF: 3,
    QTOF: 5
};
DRIVE_USAGE = {
    AVAILABLE: 0,
    MEMBER_OF_ARRAY: 1,
    LINEAR_POOL: 1,
    DEDICATED_SPARE: 2,
    VDISK_SPARE: 2,
    POOL_SPARE: 3,
    GLOBAL_SPARE: 3,
    SINGLE: 4,
    LEFTOVER: 5,
    UNDER_TEST: 6,
    FAILED: 7,
    UNUSABLE: 8,
    VIRTUAL_POOL: 9
};
PORT_STATES = {
    GOOD: 0,
    WARNING: 1,
    ERROR: 2,
    NOT_PRESENT: 3,
    UNKNOWN: 4,
    STOPPED: 5,
    DISCONNECTED: 6
};
MAX_FC_SPEED = {
    EIGHTGIG: 3,
    SIXTEENGIG: 4
};
CONTROLLER_STATUS = {
    UP: 0,
    DOWN: 1,
    NOT_INSTALLED: 2,
    UNKNOWN: 3
};
PORT_STATUS = {
    UP: 0,
    WARNING: 1,
    ERROR: 2,
    MISSING: 3,
    UNKNOWN: 4,
    STOPPED: 5,
    DISCONNECTED: 6
};
PORT_TYPES = {
    FC: 6,
    SAS: 8,
    ISCSI: 9
};
SAS_PORT_TYPES = {
    DRAWER_EGRESS: 1,
    DRAWER_INGRESS: 2,
    EXP_EGRESS: 3,
    EXP_INGRESS: 4,
    EXP_UNIVERSAL: 5
};
PORT_ACCESS = {
    NOT_MAPPED: 0,
    NO_ACCESS: 1,
    READ_ONLY: 2,
    READ_WRITE: 3,
    CLI: {
        0: "not-mapped",
        1: "no-access",
        2: "read-only",
        3: "read-write"
    }
};
CMD_RESP_TYPE = {
    SUCCESS: 0,
    ERROR: 1,
    INFO: 2
};
FRU_POSITION = {
    LEFT: 0,
    RIGHT: 1,
    TOP: 2,
    BOTTOM: 3,
    MIDDLE: 4
};
SECTOR_FORMAT = {
    FMT_512_NATIVE: 0,
    FMT_512_EMULATION: 1,
    FMT_4K_NATIVE: 2,
    FMT_MIXED: 3,
    FMT_NA: 4
};
PRI_VOL_LOCATION = {
    REMOTE: 0,
    LOCAL: 1
};
HOST_PROFILES = {
    STANDARD: 0,
    HPUX: 1,
    OPENVMS: 2
};
NOTIFICATION_LEVEL = {
    INFO: 0,
    RESOLVED: 1,
    WARNING: 2,
    ERROR: 3,
    CRITICAL: 4,
    NONE: 5
};
REPLICATION_STATE = {
    LAST: 0,
    CURRENT: 1
};
MANAGEMENT_MODE = {
    LINEAR: 2,
    VIRTUAL: 3
};
RETENTION_PRIORITY = {
    NEVERDELETE: 0,
    LOW: 3,
    MEDIUM: 2,
    HIGH: 1
};
REPSNAPHIST = {
    DISABLED: 0,
    SECONDARY: 1,
    BOTH: 2
};
PEERSTATUS = {
    OFFLINE: 0,
    ONLINE: 1,
    SUSPENDED: 2
};
SECURITYPROTOCOL = {
    NONE: 0,
    TLS: 1,
    SSL: 2
};
SYNC_CACHE_MODE = {
    "0": "immediate",
    "1": "flush"
};
MISSING_LUN_RESPONSE = {
    "0": "notready",
    "1": "illegal"
};
DATAPROTECTIONLEVEL = {
    RAID0: 0,
    RAID1: 1,
    ADAPT: 2,
    RAID3: 3,
    RAID4: 4,
    RAID5: 5,
    NRAID: 6,
    RAID30: 7,
    RAID50: 8,
    RAID10: 10,
    RAID6: 11
};
ADVANCED_SETTING = {
    DISABLED: 0,
    ENABLED: 1
};
var meta = {};

function APIObjectContainer() {
    this.objects = []
}
APIObjectContainer.prototype.markSubsDeleted = function(D) {
    for (var C = 0; C < this.objects.length; C++) {
        var F = this.objects[C];
        var E = true;
        if (!D) {
            E = F.deleteOnUpdate()
        }
        if (E) {
            F.deleted = true;
            if (F.objects.length > 0) {
                F.markSubsDeleted(D)
            }
        }
    }
};
APIObjectContainer.prototype.normalizeAll = function() {
    if (this.normalize) {
        this.normalize()
    }
    for (var C = 0; C < this.objects.length; C++) {
        this.objects[C].normalizeAll()
    }
};
APIObjectContainer.prototype._updateData = function(H) {
    if (!H) {
        return
    }
    for (var F = 0; F < H.objects.length; F++) {
        var I = H.objects[F];
        var E = null;
        if (DC.base[I.basetype]) {
            E = DC.base[I.basetype][I.getKeyValue()]
        }
        if (E) {
            mcDebug("jsonUpdate", I, "_updateData: Found existing object in cache for %s:%s", I.basetype, I.getName());
            if (E.deleted) {
                E.deleted = false
            } else {
                E.markSubsDeleted()
            }
            E.attr = I.attr;
            E.numAttr = I.numAttr;
            E.prop = I.prop;
            E.numProp = I.numProp;
            E.text = I.text;
            var G = I.getLinkedParent();
            if (G && G != E.parentObject) {
                mcDebug("jsonUpdate", I, "_updateData: Reparenting existing object.");
                DC.removeObject(E);
                E.parentObject.objects.remove(E);
                G.objects.push(E);
                E.parentObject = G
            }
            DC.updateReferences(E);
            for (var D = 0; D < E.updateListeners.length; D++) {
                E.updateListeners[D](E)
            }
            E._updateData(I)
        } else {
            mcDebug("jsonUpdate", I, "_updateData: No object in cache for %s:%s, ADDING!", I.basetype, I.getName());
            var C = I.getLinkedParent() || this;
            C.addObject(I, true);
            E = I;
            E.normalizeAll()
        }
        if (E.normalize != undefined) {
            E.normalize()
        }
    }
};
APIObjectContainer.prototype.removeObject = function(F, C) {
    if (!(F instanceof APIObject)) {
        return
    }
    if (this.objects.remove(F)) {
        F.parentObject = null
    }
    if (C) {
        DC.removeObject(F);
        if (APIObject.listeners[F.basetype]) {
            var E = APIObject.listeners[F.basetype];
            for (var D = 0; D < E.length; D++) {
                E[D]("remove", F)
            }
        }
        F.removeTreeNodes()
    }
};
APIObjectContainer.prototype.removeDeleted = function() {
    for (var C = 0; C < this.objects.length; C++) {
        var D = this.objects[C];
        if (D.deleted) {
            this.removeObject(D, true);
            C--
        } else {
            D.removeDeleted()
        }
    }
};
APIObjectContainer.prototype.refreshData = function(C) {
    if (!C) {
        MC.errorOutput("APIObjectContainer.refreshData called with null source!");
        return false
    }
    this.markSubsDeleted(true);
    this._updateData(C);
    this.removeDeleted();
    return true
};
APIObjectContainer.prototype.updateData = function(C) {
    if (!C) {
        MC.errorOutput("APIObjectContainer.updateData called with null source!");
        return
    }
    this._updateData(C);
    this.removeDeleted()
};
APIObjectContainer.prototype.removeObjects = function(E) {
    if (!E) {
        return
    }
    for (var D = 0; D < E.objects.length; D++) {
        var F = E.objects[D];
        var C = null;
        if (DC.base[F.basetype]) {
            C = DC.base[F.basetype][F.getKeyValue()]
        }
        if (C) {
            C.parentObject.removeObject(C, true)
        }
    }
};
APIObjectContainer.prototype.select = function(F) {
    if (!F) {
        return (this)
    }
    var C = new APIData();
    var E = this.objects.length;
    for (var D = 0; D < E; D++) {
        if (this.objects[D].matches(F)) {
            C.addObject(this.objects[D])
        }
    }
    return C
};
APIObjectContainer.prototype.addObject = function(F, C) {
    if (!(F instanceof APIObject)) {
        return
    }
    this.objects.push(F);
    if (C) {
        F.parentObject = this;
        DC.addObject(F);
        if (APIObject.listeners[F.basetype]) {
            var E = APIObject.listeners[F.basetype];
            for (var D = 0; D < E.length; D++) {
                E[D]("add", F)
            }
        }
    } else {
        if (F.parentObject == undefined) {
            F.parentObject = this
        }
    }
};
APIObjectContainer.prototype.objectCount = function() {
    if (this.objects && this.objects.length) {
        return this.objects.length
    }
    return 0
};
APIObjectContainer.prototype.getObject = function(E, D) {
    if (E != undefined && D != undefined) {
        for (var C = 0; C < this.objects.length; C++) {
            var F = this.objects[C];
            if (F.prop[E] != undefined && F.prop[E].text == D) {
                return F
            }
        }
    }
    return null
};
APIObjectContainer.prototype.getObjectOfBasetype = function(E) {
    if (E != undefined) {
        for (var C = 0; C < this.objects.length; C++) {
            var D = this.objects[C];
            if (D.basetype == E) {
                return D
            }
        }
    }
    return null
};
APIObjectContainer.prototype.getObjectIndex = function(E, D) {
    if (E != undefined && D != undefined) {
        for (var C = 0; C < this.objects.length; C++) {
            var F = this.objects[C];
            if (F.prop[E] != undefined && F.prop[E].text == D) {
                return C
            }
        }
    }
    return -1
};
APIObjectContainer.prototype.getNthObject = function(C) {
    if (C >= 0 && C < this.objects.length) {
        return this.objects[C]
    }
    return null
};
APIObjectContainer.prototype.getPropList = function(C) {
    return getPropList(this.objects, C)
};
getPropList = function(G, F) {
    var E;
    if (F == undefined) {
        E = null
    } else {
        for (var C = 0; C < G.length; C++) {
            var D = G[C].prop[F];
            if (D != undefined) {
                if (!E) {
                    E = D.text
                } else {
                    E += ",";
                    E += D.text
                }
            }
        }
    }
    return E
};
APIObjectContainer.prototype.getPropArray = function(C) {
    return getPropArray(this.objects, C)
};
getPropArray = function(G, F) {
    var C = new Array();
    if (F != undefined) {
        for (var D = 0; D < G.length; D++) {
            var E = G[D].prop[F];
            if (E != undefined) {
                C[C.length] = E.text
            }
        }
    }
    return C
};

function APIData(H) {
    APIObjectContainer.call(this);
    this.statusObjects = [];
    this.class_name = "APIData";
    if (arguments.length == 0) {
        return
    }
    if (H instanceof Array) {
        for (var C = 0; C < H.length; C++) {
            if (H[C] instanceof APIStatus) {
                this.statusObjects.push(H[C]);
                this.statusObject = this.statusObjects[this.statusObjects.length - 1]
            } else {
                if (H[C] instanceof APIObject) {
                    if (typeof inTesting != "undefined" && H[C].name != "meta") {
                        this.addObject(H[C], true)
                    } else {
                        this.addObject(H[C])
                    }
                } else {
                    if (H[C] instanceof DCRef) {
                        var G = H[C].getObject();
                        if (G) {
                            this.addObject(G)
                        }
                    } else {
                        MC.errorOutput("APIData: unable to add object from set, object: %o", H[C])
                    }
                }
            }
        }
        return
    }
    if (!H) {
        return
    }
    if (H.nodeType == 3 || H.nodeType == 4) {
        MC.errorOutput("APIData ERROR: invalid document node type: " + H.nodeType);
        return
    }
    var E = (H.nodeType == 9) ? H.documentElement : H;
    if (E.nodeType != 1 || E.tagName != "RESPONSE") {
        MC.errorOutput("APIData ERROR: Expected RESPONSE node, got other.");
        return
    }
    for (var C = 0; C < E.childNodes.length; C++) {
        var D = E.childNodes[C];
        if (D.nodeType == 1) {
            var F = APIObject.createObjectFromNode(D);
            if (F instanceof APIStatus) {
                this.statusObjects.push(F);
                this.statusObject = this.statusObjects[this.statusObjects.length - 1]
            } else {
                if (F instanceof APIObject) {
                    this.addObject(F)
                } else {
                    MC.warningOutput("Invalid object returned from createObjectFromNode()", "%s")
                }
            }
        }
    }
}
APIData.prototype = new APIObjectContainer();
APIData.prototype.constructor = APIData;
APIData.prototype.getSizes = function(E) {
    if (E) {
        var C = new Size();
        var H = new Size();
        var G = new Size();
        var F = new Size();
        for (var D = 0; D < this.objects.length; D++) {
            this.objects[D].accumulateSizes(C, H, F, G)
        }
        if (E.total && E.total instanceof Size) {
            E.total.set(C)
        } else {
            E.total = C
        }
        if (E.used && E.used instanceof Size) {
            E.used.set(H)
        } else {
            E.used = H
        }
        if (E.free && E.free instanceof Size) {
            E.free.set(G)
        } else {
            E.free = G
        }
        if (E.reserved && E.reserved instanceof Size) {
            E.reserved.set(F)
        } else {
            E.reserved = F
        }
    }
};
APIData.prototype.toJson = function(C) {
    var F = "";
    var E = this.objects.length;
    for (var D = 0; D < E; D++) {
        if (D > 0) {
            F += ",\n"
        } else {
            F += "\n"
        }
        F += this.objects[D].toJson(C + 4)
    }
    return indentString(C) + "new APIData([" + F + ",\n" + this.statusObject.toJson(C + 4) + "])"
};

function APIObject(H, C, E) {
    APIObjectContainer.call(this);
    this.dcParents = [];
    this.treeNodes = {};
    this.updateListeners = [];
    this.attr = C || {};
    if (E != undefined) {
        this.numAttr = E
    } else {
        this.numAttr = 0;
        for (var D in this.attr) {
            this.numAttr++
        }
    }
    this.prop = {};
    this.numProp = 0;
    this.text = "";
    this.class_name = "APIObject";
    this.name = this.attr.name;
    this.basetype = this.attr.basetype;
    if (!H) {
        return
    }
    if (H instanceof Array) {
        for (var G = 0; G < H.length; G++) {
            if (H[G] instanceof APIObject) {
                this.addObject(H[G])
            } else {
                this.addProp(H[G])
            }
        }
        return
    } else {
        if (H.childNodes) {
            for (var G = 0; G < H.childNodes.length; G++) {
                var F = H.childNodes[G];
                if (F.nodeType == 1) {
                    var I = APIObject.createObjectFromNode(F);
                    if (I instanceof APIObject) {
                        this.addObject(I)
                    } else {
                        if (I instanceof APIProp) {
                            this.addProp(I)
                        }
                    }
                } else {
                    if (F.nodeType == 3) {
                        this.text += $.trim(F.nodeValue)
                    } else {
                        if (F.nodeType == 4) {
                            this.text += (F.text) ? $.trim(F.text) : $.trim(F.nodeValue)
                        }
                    }
                }
            }
        } else {
            if (H instanceof Object) {
                this.prop = H
            }
        }
    }
}
APIObject.prototype = new APIObjectContainer();
APIObject.prototype.constructor = APIObject;
APIObject.prototype.hasName = function(C) {
    if (this.get("name") == C) {
        return true
    }
    if (this.get("volume_name") == C) {
        return true
    }
    if (this.get("durable_id") == C) {
        return true
    }
    if (this.getKeyValue() == C) {
        return true
    }
    return false
};
APIObject.prototype.getName = function() {
    return this.get("name") || this.get("volume_name") || this.get("durable_id") || this.getKeyValue()
};
APIObject.listeners = {};
APIObject.prototype.deleteOnUpdate = function() {
    return true
};
APIObject.pendingNodes = {};
APIObject.classes = {
    "advanced-settings-table": APIAdvancedSettingsTable,
    "cache-settings": APICacheSettings,
    "controller-cache-parameters": APIControllerCacheParameters,
    "certificate-status": APICertificateStatus,
    "chap-records": APIChapRecords,
    "cli-parameters": APICliParameters,
    "compact-flash": APICompactFlash,
    "communication-ports": APICommunicationPorts,
    controllers: APIControllers,
    "controller-statistics": APIControllerStatistics,
    "copy-volumes": APICopyVolumes,
    "cs-replication": APICsReplication,
    "cs-replication-set": APICsReplicationSet,
    "cs-replicate-tasks": APICsReplicateTasks,
    "disk-affinity": APIDiskAffinity,
    "disk-groups": APIDiskGroups,
    "disk-group-statistics": APIDiskGroupStatistics,
    "disk-group-statistics-paged": APIDiskGroupStatisticsPaged,
    "disk-statistics": APIDiskStatistics,
    "disk-hist-statistics": APIDiskHistStatistics,
    drawers: APIDrawers,
    drives: APIDrives,
    "drive-summary": APIDriveSummary,
    "email-parameters": APIEmailParameters,
    "enclosure-components": APIEnclosureComponents,
    "enclosure-fru": APIEnclosureFru,
    enclosures: APIEnclosures,
    events: APIEvents,
    expanders: APIExpanders,
    "expander-ports": APIExpanderPorts,
    fan: APIFan,
    "fan-modules": APIFanModules,
    "fc-port": APIFcPort,
    "fde-state": APIFdeState,
    heatmaps: APIHeatmaps,
    "host-port-statistics": APIHostPortStatistics,
    "host-group": APIHostGroup,
    host: APIHost,
    hosts: APIHosts,
    initiator: APIInitiator,
    "io-modules": APIIoModules,
    "iscsi-port": APIIscsiPort,
    "iscsi-parameters": APIIscsiParameters,
    "ldap-parameters": APILdapParameters,
    "IB-port": APIIBPort,
    "infiniband-parameters": APIInfinibandParameters,
    "infiniband-error-statistics": APIInfinibandErrorStatistics,
    license: APILicense,
    "local-ports": APILocalPorts,
    "network-parameters": APINetworkParameters,
    "paged-storage-statistics": APIPagedStorageStatistics,
    "peer-connections": APIPeerConnections,
    "policy-threshold": APIPolicyThreshold,
    pools: APIPools,
    port: APIPort,
    "power-supplies": APIPowerSupplies,
    profiles: APIProfiles,
    "profile-volumes": APIProfileVolumes,
    "pool-summary": APIPoolSummary,
    "pool-hist-statistics": APIPoolHistStatistics,
    "pool-statistics": APIPoolStatistics,
    redundancy: APIRedundancy,
    "refresh-counters": APIRefreshCounters,
    "remote-addresses": APIRemoteAddresses,
    "remote-links-table": APIRemoteLinksTable,
    "remote-ports": APIRemotePorts,
    "remote-system": APIRemoteSystem,
    "replicate-volume-tasks": APIReplicateVolumeTasks,
    "replication-image": APIReplicationImage,
    "replication-image-params": APIReplicationImageParams,
    "replication-set": APIReplicationSet,
    "replication-volume": APIReplicationVolume,
    "reset-snapshot-tasks": APIResetSnapshotTasks,
    "resettable-statistics": APIResettableStatistics,
    "readcache-hist-statistics": APIReadcacheHistStatistics,
    "sas-port": APISasPort,
    schedules: APISchedules,
    "security-communications-protocols": APISecurityCommunicationsProtocols,
    ses: APISes,
    sideplanes: APISideplanes,
    "snap-pools": APISnapPools,
    "snap-tasks": APISnapTasks,
    "snapshot-with-retention-tasks": APISnapshotWithRetentionTasks,
    snapshots: APISnapshots,
    "snmp-parameters": APISnmpParameters,
    status: APIStatus,
    "storage-pools": APIStoragePools,
    "storage-pool-components": APIStoragePoolComponents,
    "storage-pool-status": APIStoragePoolStatus,
    "storage-status": APIStorageStatus,
    "storage-tier-status": APIStorageTierStatus,
    "syslog-parameters": APISyslogParameters,
    "system-parameters-table": APISystemParametersTable,
    system: APISystem,
    tasks: APITasks,
    "time-settings-table": APITimeSettingsTable,
    tiers: APITiers,
    "tier-summary": APITierSummary,
    "tier-hist-statistics": APITierHistStatistics,
    "tier-statistics": APITierStatistics,
    "unhealthy-component": APIUnhealthyComponent,
    users: APIUsers,
    usergroups: APIUsergroups,
    "vdisk-hist-statistics": APIVdiskHistStatistics,
    versions: APIVersions,
    "virtual-disks": APIVirtualDisks,
    "virtual-disk-summary": APIVirtualDiskSummary,
    "volume-copy-tasks": APIVolumeCopyTasks,
    "volume-group-view": APIVolumeGroupView,
    "volume-group-view-mappings": APIVolumeGroupViewMappings,
    "volume-group-view-mappings-luns": APIVolumeGroupViewMappingsLuns,
    "volume-groups": APIVolumeGroups,
    "volume-view-mappings": APIVolumeViewMappings,
    "volume-view": APIVolumeView,
    volumes: APIVolumes,
    "volume-statistics": APIVolumeStatistics,
    workload: APIWorkload
};
APIObject.keys = {};
APIObject.createObjectFromNode = function(G) {
    if (arguments.length == 0) {
        return null
    }
    var C = {};
    var D = 0;
    var I = null;
    if (G.nodeType && G.nodeType == 1 && G.attributes) {
        var H, F;
        for (var E = 0; E < G.attributes.length; E++) {
            H = G.attributes[E];
            F = H.name.replace(/-/g, "_");
            C[F] = H.value;
            D++
        }
    }
    if (G.tagName == "OBJECT") {
        var J = "";
        if (C.basetype) {
            if (APIObject.classes[C.basetype]) {
                I = new APIObject.classes[C.basetype](G, C, D)
            } else {
                MC.warningOutput("Unknown basetype encountered: %s", C.basetype)
            }
        } else {
            if (C.name && C.name == "status") {
                I = new APIStatus(G, C, D)
            } else {
                MC.warningOutput("OBJECT with no basetype encountered: %o ", G)
            }
        }
    } else {
        if (G.tagName == "PROPERTY") {
            I = new APIProp(G, C, D)
        } else {
            MC.warningOutput("Unrecognized xml node encountered: %o", G)
        }
    }
    return I
};
APIObject.setMeta = function(D, C) {
    APIObject.classes[D].meta = C;
    APIObject.classes[D].prototype.meta = C;
    meta[D] = C;
    C.meta = undefined;
    C.attr.parentKeyProp = C.attr.parentKeyProp.replace(/-/g, "_");
    if (C.attr.primaryKey != "none") {
        APIObject.keys[D] = C.attr.primaryKey.replace(/-/g, "_");
        DC.addBasetype(D)
    }
};
APIObject.compare = function(F, E, K) {
    if (!F || !E) {
        return false
    }
    if (!(F instanceof APIObject)) {
        K && MC.debugOutput("APIObject.compare: obj1 not an APIObject");
        return false
    }
    if (!(E instanceof APIObject)) {
        K && MC.debugOutput("APIObject.compare: obj2 not an APIObject");
        return false
    }
    if (F.basetype != E.basetype) {
        K && MC.debugOutput("APIObject.compare: basetypes differ: '%s' vs '%s'", F.basetype, E.basetype);
        return false
    }
    var D = F.basetype;
    var M = F.getKeyName();
    var O = null;
    var N = null;
    if (M) {
        O = F.get(M);
        N = E.get(M);
        if (O != N) {
            K && MC.debugOutput("APIObject.compare: primary keys differ: '%s' vs '%s'", O, N);
            return false
        }
    }
    var J = keys(F.prop);
    var C;
    var I = [];
    for (var G = 0, H = J.length; G < H; G++) {
        C = J[G];
        if (F.get(C) != E.get(C)) {
            I.push({
                key: C,
                val1: F.get(C),
                val2: E.get(C)
            })
        }
    }
    var L;
    if (I.length > 0) {
        if (K) {
            MC.debugOutput("APIObject.compare: properties differ:");
            for (var G = 0, H = I.length; G < H; G++) {
                L = I[G];
                MC.debugOutput("     %s : '%s' vs '%s'", L.key, L.val1, L.val2)
            }
        }
        return false
    }
    K && MC.debugOutput("APIObject.compare: objects MATCH");
    return true
};
APIObject.setHover = function(D, C) {
    APIObject.classes[D].hover = C;
    APIObject.classes[D].prototype.hover = C
};
APIObject.getHover = function(C) {
    if (APIObject.classes[C] && APIObject.classes[C].hover) {
        return APIObject.classes[C].hover
    } else {
        return null
    }
};
APIObject.getMeta = function(C) {
    if (APIObject.classes[C]) {
        return APIObject.classes[C].meta
    }
    return undefined
};
APIObject.getKeyName = function(C) {
    if (C && APIObject.keys[C]) {
        return (APIObject.keys[C])
    }
    return undefined
};
APIObject.joinObjects = function(F) {
    var C = new APIObject();
    if (F instanceof Array) {
        for (var D = 0; D < F.length; D++) {
            if (F[D] instanceof APIObject) {
                for (var E in F[D].prop) {
                    if (C.prop[E] == undefined) {
                        C.addProp(F[D].prop[E])
                    }
                }
            }
        }
    }
    return C
};
APIObject.prototype.addProp = function(C) {
    if (C && C.attr && C.attr.name) {
        C.parentObject = this;
        this.prop[C.attr.name.replace(/-/g, "_")] = C;
        this.numProp++
    }
};
APIObject.prototype.getKeyName = function() {
    return (APIObject.getKeyName(this.basetype))
};
APIObject.prototype.getKeyValue = function() {
    var C = APIObject.keys[this.basetype];
    if (C) {
        if (C == "singleton") {
            return "singleton"
        } else {
            return this.prop[C].text
        }
    }
    return null
};
APIObject.prototype.getLinkedParent = function() {
    var D = null;
    if (this.meta) {
        var E = this.meta.attr.parentBasetype;
        if (E && E != "none") {
            if ($.isFunction(this.parentObject.getKeyValue)) {
                var C = this.parentObject.getKeyValue();
                D = DC.base[E][C]
            } else {
                var F = this.meta.attr.parentKeyProp;
                var C = this.getPropertyValue(F);
                D = DC.base[E][C]
            }
        }
    }
    return D
};
APIObject.prototype.matches = function(I) {
    if (!I) {
        return true
    }
    if ($.isFunction(I)) {
        return I(this)
    }
    if (!I.type || (I.type != "OR" && I.type != "AND" && I.type != "attr" && I.type != "prop")) {
        return (I.not ? false : true)
    }
    var E = false;
    if (I.conditions) {
        var C = false;
        if (I.type == "AND") {
            C = true;
            E = true
        }
        var D;
        for (var F = 0; F < I.conditions.length; F++) {
            D = false;
            D = this.matches(I.conditions[F]);
            if (D && !C) {
                E = true;
                break
            } else {
                if (!D && C) {
                    E = false;
                    break
                }
            }
        }
    } else {
        if (this[I.type][I.name] != undefined) {
            if (I.type == "prop") {
                var H = this.prop[I.name].text
            } else {
                var H = this.attr[I.name]
            }
            if (I.value != undefined) {
                if (H == I.value) {
                    E = true
                }
            } else {
                if (I.expr != undefined) {
                    var G = I.expr;
                    if (!(G instanceof RegExp)) {
                        G = new RegExp(I.expr)
                    }
                    if (G.test(H)) {
                        E = true
                    }
                }
            }
        }
    }
    return (I.not ? (!E) : E)
};
APIObject.prototype.getProperty = function(C) {
    if (C) {
        var D = this.prop[C];
        if (D) {
            return D
        }
    }
    return null
};
APIObject.prototype.addNormalizedProperties = function(E, C) {
    if (this.meta && this.meta[C.basetype + "_isNormalized"] == undefined && C.meta) {
        var F = this.meta;
        for (var G in C.meta.prop) {
            var D = C.meta.prop[G];
            F.addProp(APIProp.cloneProp(E + G, D))
        }
        F[C.basetype + "_isNormalized"] = true
    }
    for (var G in C.prop) {
        var D = C.prop[G];
        this.addProp(APIProp.cloneProp(E + G, D))
    }
};
APIObject.prototype.getPropertyValue = function(C) {
    var D = null;
    if (C) {
        var E = this.prop[C];
        if (E) {
            D = E.text
        }
    }
    return D
};
APIObject.prototype.get = function(C) {
    var D = null;
    if (C) {
        var E = this.prop[C];
        if (E) {
            D = E.text
        }
    }
    return D
};
APIObject.prototype.getInt = function(C) {
    var D = null;
    if (C) {
        var E = this.prop[C];
        if (E) {
            D = parseInt(E.text, 10)
        }
    }
    return D
};
APIObject.prototype.getBool = function(C) {
    var D = null;
    if (C) {
        var E = this.prop[C];
        return decodeBooleanFlag(E.text)
    }
    return false
};
APIObject.prototype.getTotalBlocks = function() {
    return 0
};
APIObject.prototype.getUsedBlocks = function() {
    return 0
};
APIObject.prototype.getFreeBlocks = function() {
    return 0
};
APIObject.prototype.getReservedBlocks = function() {
    return 0
};
APIObject.prototype.getSizes = function(C) {
    if (C) {
        if (C.total && C.totalSpace instanceof Size) {
            C.total.set(this.getTotalBlocks(), "blocks")
        } else {
            C.total = new Size(this.getTotalBlocks(), "blocks")
        }
        if (C.used && C.usedSpace instanceof Size) {
            C.used.set(this.getUsedBlocks(), "blocks")
        } else {
            C.used = new Size(this.getUsedBlocks(), "blocks")
        }
        if (C.free && C.freeSpace instanceof Size) {
            C.free.set(this.getFreeBlocks(), "blocks")
        } else {
            C.free = new Size(this.getFreeBlocks(), "blocks")
        }
        if (C.reserved && C.reservedSpace instanceof Size) {
            C.reserved.set(this.getReservedBlocks(), "blocks")
        } else {
            C.reserved = new Size(this.getReservedBlocks(), "blocks")
        }
    }
};
APIObject.prototype.accumulateSizes = function(E, D, C, F) {
    E.add(this.getTotalBlocks(), "blocks");
    D.add(this.getUsedBlocks(), "blocks");
    F.add(this.getFreeBlocks(), "blocks");
    C.add(this.getReservedBlocks(), "blocks")
};
APIObject.prototype.removeTreeNodes = function() {
    for (var D = 0, C = this.objects.length; D < C; D++) {
        this.objects[D].removeTreeNodes()
    }
    for (var F in this.treeNodes) {
        var E = this.treeNodes[F];
        E.parent.removeNode(E);
        delete this.treeNodes[F]
    }
};
APIObject.prototype.toJson = function(E) {
    var K = "";
    var G = true;
    for (var H in this.prop) {
        var C = this.prop[H];
        if (G) {
            G = false;
            K += "\n"
        } else {
            K += ",\n"
        }
        K += C.toJson(E + 4)
    }
    var D = this.objects.length;
    for (var F = 0; F < D; F++) {
        if (G) {
            G = false;
            K += "\n"
        } else {
            K += ",\n"
        }
        K += this.objects[F].toJson(E + 4)
    }
    var L = "";
    var G = true;
    for (var J in this.attr) {
        var I = this.attr[J];
        if (G) {
            G = false
        } else {
            L += ","
        }
        L += J + ':"' + I + '"'
    }
    return indentString(E) + "new " + this.class_name + "([" + K + "],\n" + indentString(E + 4) + "{" + L + "}," + this.numAttr + ")"
};

function APIProp(G, C, E) {
    if (G instanceof Object && !G.childNodes) {
        if (G.name && (G.value != undefined)) {
            G.name = G.name.replace(/-/g, "_");
            this.name = G.name;
            this.text = G.value;
            delete G.value;
            this.attr = G;
            this.numAttr = 0;
            for (var D in this.attr) {
                this.numAttr++
            }
        }
        return
    }
    this.attr = C || {};
    if (E != undefined) {
        this.numAttr = E
    } else {
        this.numAttr = 0;
        for (var D in this.attr) {
            this.numAttr++
        }
    }
    this.text = "";
    this.class_name = "APIProp";
    this.name = this.attr.name;
    if (!G) {
        return
    }
    for (var F = 0; F < G.childNodes.length; F++) {
        var H = G.childNodes[F];
        if (H.nodeType == 3) {
            this.text += $.trim(H.nodeValue)
        } else {
            if (H.nodeType == 4) {
                this.text += (H.text) ? $.trim(H.text) : $.trim(H.nodeValue)
            }
        }
    }
}
APIProp.cloneProp = function(C, E) {
    var D = $.extend({
        value: E.text
    }, E.attr);
    D.name = C;
    return new APIProp(D)
};
APIProp.prototype.getAttribute = function(D) {
    if (D) {
        var C = this.attr[D];
        if (C) {
            return C
        }
    }
    return null
};
APIProp.fromObject = function(D) {
    if (arguments.length == 0) {
        return null
    }
    var E = new APIProp();
    if (D instanceof Object && D.name && D.value != undefined) {
        D.name = D.name.replace(/-/g, "_");
        E.text = D.value;
        delete D.value;
        E.attr = D;
        E.numAttr = 0;
        for (var C in E.attr) {
            E.numAttr++
        }
    }
    return E
};
APIProp.prototype.filter = function(D) {
    var C = false;
    if (D != undefined) {
        if (D.fields) {
            for (var E = 0; E < D.fields.length; E++) {
                if (this.attr.name == D.fields[E]) {
                    if (this.attr.name == "health_numeric") {
                        C = true
                    } else {
                        if (D.draw) {
                            if (this.attr.draw == "true") {
                                C = true
                            }
                        } else {
                            C = true
                        }
                    }
                }
            }
        } else {
            if (D.draw) {
                if (this.attr.draw == "true") {
                    C = true
                }
            }
        }
    }
    return C
};
APIProp.prototype.toJson = function(D) {
    var E = "";
    var G = true;
    for (var F in this.attr) {
        var C = this.attr[F];
        if (G) {
            G = false
        } else {
            E += ","
        }
        E += F + ':"' + C + '"'
    }
    return indentString(D) + "new APIProp({" + E + ',value:"' + this.text + '"})'
};

function APIAdaptExpandPreview(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIAdaptExpandPreview"
}
APIAdaptExpandPreview.prototype = new APIObject();
APIAdaptExpandPreview.prototype.constructor = APIAdaptExpandPreview;

function APICacheParameter(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICacheParameter"
}
APICacheParameter.prototype = new APIObject();
APICacheParameter.prototype.constructor = APICacheParameter;

function APIControllerCacheParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIControllerCacheParameters"
}
APIControllerCacheParameters.prototype = new APIObject();
APIControllerCacheParameters.prototype.constructor = APIControllerCacheParameters;

function APICacheSettings(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICacheSettings"
}
APICacheSettings.prototype = new APIObject();
APICacheSettings.prototype.constructor = APICacheSettings;

function APIChapRecords(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIChapRecords"
}
APIChapRecords.prototype = new APIObject();
APIChapRecords.prototype.constructor = APIChapRecords;

function APICompactFlash(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICompactFlash"
}
APICompactFlash.prototype = new APIObject();
APICompactFlash.prototype.constructor = APICompactFlash;

function APIControllers(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIControllers"
}
APIControllers.prototype = new APIObject();
APIControllers.prototype.constructor = APIControllers;

function APIControllerStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIControllerStatistics"
}
APIControllerStatistics.prototype = new APIObject();
APIControllerStatistics.prototype.constructor = APIControllerStatistics;

function APICopyVolumes(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICopyVolumes"
}
APICopyVolumes.prototype = new APIObject();
APICopyVolumes.prototype.constructor = APICopyVolumes;

function APIDiskGroups(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskGroups"
}
APIDiskGroups.prototype = new APIObject();
APIDiskGroups.prototype.constructor = APIDiskGroups;

function APIDiskAffinity(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskAffinity"
}
APIDiskAffinity.prototype = new APIObject();
APIDiskAffinity.prototype.constructor = APIDiskAffinity;
APIDiskGroups.prototype.sectorFormatMatches = function(C) {
    var E = this.getInt("pool_sector_format_numeric");
    var D = E != findSectorFormat(C);
    return D
};
APIDiskGroups.prototype.selectedDrivesWillResultInMixedFormat = function(D) {
    var C = false;
    var F = this.getInt("pool_sector_format_numeric");
    if (F == SECTOR_FORMAT.FMT_MIXED) {
        return C
    }
    var E = findSectorFormat(D);
    if (E != SECTOR_FORMAT.FMT_NA) {
        C = F != E
    }
    return C
};
APIDiskGroups.prototype.isShutdown = function() {
    if (this.prop.status_numeric.text == "7") {
        return true
    }
    return false
};

function findSectorFormat(H) {
    var E = {};
    if (H.disks != undefined) {
        E.disks = H.disks
    }
    if (H.spares != undefined) {
        E.spares = H.spares
    }
    for (F = 1; F <= 10; F++) {
        var J = "sub" + F;
        if (H[J] != undefined) {
            E[J] = H[J]
        }
    }
    var I = SECTOR_FORMAT.FMT_NA;
    for (var C in E) {
        var G = E[C];
        for (var F = 0; F < G.objects.length; F++) {
            var D = G.objects[F].getInt("sector_format_numeric");
            if (I == SECTOR_FORMAT.FMT_NA) {
                I = D
            } else {
                if (D != I) {
                    I = SECTOR_FORMAT.FMT_MIXED;
                    break
                }
            }
        }
    }
    return I
}

function hasDegradedDisk(F) {
    for (var E = 0; E < F.length; E++) {
        var D = DC.disks[F[E].key];
        var C = D.getInt("health_numeric");
        if ((C == HEALTH.DEGRADED) || (C == HEALTH.FAULT)) {
            return true
        }
    }
    return false
}

function APIUnusedDisksPreview(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIUnusedDisksPreview"
}
APIUnusedDisksPreview.prototype = new APIObject();
APIUnusedDisksPreview.prototype.constructor = APIUnusedDisksPreview;

function APIDiskGroupsPreview(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskGroupsPreview"
}
APIDiskGroupsPreview.prototype = new APIObject();
APIDiskGroupsPreview.prototype.constructor = APIDiskGroupsPreview;

function APISparesPreview(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISparesPreview"
}
APISparesPreview.prototype = new APIObject();
APISparesPreview.prototype.constructor = APISparesPreview;

function APIDiskGroupStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskGroupStatistics"
}
APIDiskGroupStatistics.prototype = new APIObject();
APIDiskGroupStatistics.prototype.constructor = APIDiskGroupStatistics;

function APIDiskGroupStatisticsPaged(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskGroupStatisticsPaged"
}
APIDiskGroupStatisticsPaged.prototype = new APIObject();
APIDiskGroupStatisticsPaged.prototype.constructor = APIDiskGroupStatisticsPaged;

function APIDiskStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskStatistics"
}
APIDiskStatistics.prototype = new APIObject();
APIDiskStatistics.prototype.constructor = APIDiskStatistics;

function APIDiskHistStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDiskPerformance"
}
APIDiskHistStatistics.prototype = new APIObject();
APIDiskHistStatistics.prototype.constructor = APIDiskHistStatistics;

function APIDrawers(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDrawers"
}
APIDrawers.prototype = new APIObject();
APIDrawers.prototype.constructor = APIDrawers;

function APIDrives(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDrives"
}
APIDrives.prototype = new APIObject();
APIDrives.prototype.constructor = APIDrives;
APIDrives.compareLocation = function(E, C) {
    var K = 0;
    var I = E.indexOf(".");
    var F = C.indexOf(".");
    if (I == -1 || F == -1) {
        return E.localeCompare(C)
    }
    var D = parseInt(E.substring(0, I), 10);
    var H = parseInt(E.substring(I + 1), 10);
    var J = parseInt(C.substring(0, F), 10);
    var G = parseInt(C.substring(F + 1), 10);
    if (isNaN(D) || isNaN(H) || isNaN(J) || isNaN(G)) {
        return E.localeCompare(C)
    }
    if (D < J) {
        return -1
    } else {
        if (D > J) {
            return 1
        } else {
            if (H < G) {
                return -1
            } else {
                if (H > G) {
                    return 1
                } else {
                    return 0
                }
            }
        }
    }
};
APIDrives.prototype.getTotalBlocks = function() {
    if (this.prop.blocks) {
        return parseInt(this.prop.blocks.text)
    }
    return 0
};
APIDrives.prototype.getUsedBlocks = function() {
    if (this.prop.blocks && this.prop.state && this.prop.state.text != "AVAIL") {
        return parseInt(this.prop.blocks.text)
    }
    return 0
};
APIDrives.prototype.getFreeBlocks = function() {
    if (this.prop.blocks && this.prop.state && this.prop.state.text == "AVAIL") {
        return parseInt(this.prop.blocks.text)
    }
    return 0
};

function APIDriveSummary(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDriveSummary"
}
APIDriveSummary.prototype = new APIObject();
APIDriveSummary.prototype.constructor = APIDriveSummary;

function APIVdiskHistStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVdiskHistStatistics"
}
APIVdiskHistStatistics.prototype = new APIObject();
APIVdiskHistStatistics.prototype.constructor = APIVdiskHistStatistics;

function APIVirtualDiskSummary(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVirtualDiskSummary"
}
APIVirtualDiskSummary.prototype = new APIObject();
APIVirtualDiskSummary.prototype.constructor = APIVirtualDiskSummary;

function APIEnclosureComponents(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEnclosureComponents"
}
APIEnclosureComponents.prototype = new APIObject();
APIEnclosureComponents.prototype.constructor = APIEnclosureComponents;

function APIEnclosureFru(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEnclosureFru"
}
APIEnclosureFru.prototype = new APIObject();
APIEnclosureFru.prototype.constructor = APIEnclosureFru;

function APIEnclosureFruSecrets(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEnclosureFruSecrets"
}
APIEnclosureFruSecrets.prototype = new APIObject();
APIEnclosureFruSecrets.prototype.constructor = APIEnclosureFruSecrets;

function APIEnclosures(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEnclosures"
}
APIEnclosures.prototype = new APIObject();
APIEnclosures.prototype.constructor = APIEnclosures;
APIEnclosures.prototype.getTreeNodeOptions = function() {
    var C = {
        parentType: TREETYPES.SYSTEM,
        parentName: "system",
        type: TREETYPES.ENCLOSURE,
        name: this.getPropertyValue("enclosure_wwn"),
        nodeConstructor: EnclosureNode
    };
    return C
};

function APIEvents(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEvents"
}
APIEvents.prototype = new APIObject();
APIEvents.prototype.constructor = APIEvents;
APIEvents.MAX_EVENTS = {
    paged: 1000,
    linear: 100
};

function APIExpanderPorts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIExpanderPorts"
}
APIExpanderPorts.prototype = new APIObject();
APIExpanderPorts.prototype.constructor = APIExpanderPorts;

function APISideplanes(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISideplanes"
}
APISideplanes.prototype = new APIObject();
APISideplanes.prototype.constructor = APISideplanes;

function APIFan(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIFan"
}
APIFan.prototype = new APIObject();
APIFan.prototype.constructor = APIFan;

function APIFanModules(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIFanModules"
}
APIFanModules.prototype = new APIObject();
APIFanModules.prototype.constructor = APIFanModules;

function APIFcPort(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIFcPort"
}
APIFcPort.prototype = new APIObject();
APIFcPort.prototype.constructor = APIFcPort;

function APIFdeState(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIFdeState"
}
APIFdeState.prototype = new APIObject();
APIFdeState.prototype.constructor = APIFdeState;

function APIHostGroup(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIHostGroup"
}
APIHostGroup.prototype = new APIObject();
APIHostGroup.prototype.constructor = APIHostGroup;

function APIHost(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIHost"
}
APIHost.prototype = new APIObject();
APIHost.prototype.constructor = APIHost;

function APIHostPortStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIHostPortStatistics"
}
APIHostPortStatistics.prototype = new APIObject();
APIHostPortStatistics.prototype.constructor = APIHostPortStatistics;

function APIHosts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIHosts"
}
APIHosts.prototype = new APIObject();
APIHosts.prototype.constructor = APIHosts;

function APIVolumeStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeStatistics"
}
APIVolumeStatistics.prototype = new APIObject();
APIVolumeStatistics.prototype.constructor = APIVolumeStatistics;
APIHosts.prototype.getTreeNodeOptions = function() {
    var C = {
        parentType: TREETYPES.SYSTEM,
        parentName: "system",
        type: TREETYPES.HOST,
        name: this.getPropertyValue("host_id"),
        nodeConstructor: HostNode
    };
    return C
};

function APIInitiator(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIInitiator"
}
APIInitiator.prototype = new APIObject();
APIInitiator.prototype.constructor = APIInitiator;

function APILdapParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APILdapParameters"
}
APILdapParameters.prototype = new APIObject();
APILdapParameters.prototype.constructor = APILdapParameters;
APIInitiator.selectedHosts = function(K, F, J) {
    var H = {};
    var I = [];
    var G = 0;
    for (var E = 0; E < K.length; E++) {
        if (K[E].basetype != "initiator") {
            continue
        }
        var M = K[E].getObject();
        if (M) {
            var D = M.get("host_id");
            if (!D || D == "NOHOST") {
                if (F) {
                    return null
                } else {
                    continue
                }
            }
            var L = DC.hostsSerial[D];
            if (!L) {
                continue
            }
            var C = L.getKeyValue();
            if (!H[C]) {
                H[C] = true;
                I.push(new DCRef("host", C));
                G++
            }
        }
    }
    if (G == 0) {
        return null
    } else {
        if (J && G > J) {
            return null
        } else {
            return I
        }
    }
};
APIInitiator.selectedHostGroups = function(K, H, I) {
    var D = {};
    var C = [];
    var G = 0;
    for (var F = 0; F < K.length; F++) {
        if (K[F].basetype != "initiator") {
            continue
        }
        var N = K[F].getObject();
        if (N) {
            var E = N.get("host_id");
            if (!E || E == "NOHOST") {
                if (H) {
                    return null
                } else {
                    continue
                }
            }
            var M = DC.hostsSerial[E];
            if (!M) {
                continue
            }
            var O = M.get("host_group");
            if (!O || O == "UNGROUPEDHOSTS") {
                if (H) {
                    return null
                } else {
                    continue
                }
            }
            var L = DC.hostGroupsSerial[O];
            if (!L) {
                continue
            }
            var J = L.getKeyValue();
            if (!D[J]) {
                D[J] = true;
                C.push(new DCRef("host-group", J));
                G++
            }
        }
    }
    if (G == 0) {
        return null
    } else {
        if (I && G > I) {
            return null
        } else {
            return C
        }
    }
};

function APIIoModules(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIIoModules"
}
APIIoModules.prototype = new APIObject();
APIIoModules.prototype.constructor = APIIoModules;

function APIIscsiPort(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIIscsiPort"
}
APIIscsiPort.prototype = new APIObject();
APIIscsiPort.prototype.constructor = APIIscsiPort;

function APINetworkParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APINetworkParameters"
}
APINetworkParameters.prototype = new APIObject();
APINetworkParameters.prototype.constructor = APINetworkParameters;

function APIPagedStorageStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPagedStorageStatistics"
}
APIPagedStorageStatistics.prototype = new APIObject();
APIPagedStorageStatistics.prototype.constructor = APIPagedStorageStatistics;

function APIPools(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPools"
}
APIPools.prototype = new APIObject();
APIPools.prototype.constructor = APIPools;
APIPools.prototype.getTotalBlocks = function() {
    if (this.prop.total_size_numeric) {
        return parseInt(this.prop.total_size_numeric.text)
    }
    return 0
};
APIPools.prototype.getUsedBlocks = function() {
    if (this.prop.total_size_numeric && this.prop.total_avail_numeric) {
        return parseInt(this.prop.total_size_numeric.text) - parseInt(this.prop.total_avail_numeric.text)
    }
    return 0
};
APIPools.prototype.getFreeBlocks = function() {
    if (this.prop.total_avail_numeric) {
        return parseInt(this.prop.total_avail_numeric.text)
    }
    return 0
};
APIPools.prototype.hasReadCache = function() {
    for (var C in this.diskGroups) {
        if (this.diskGroups[C].getInt("storage_tier_numeric") == TIERS.READCACHE) {
            return true
        }
    }
    return false
};
APIPools.prototype.getNumDiskGroups = function(C) {
    var E = 0;
    for (var D in this.diskGroups) {
        if (C || this.diskGroups[D].getInt("storage_tier_numeric") != TIERS.READCACHE) {
            E++
        }
    }
    return E
};

function APIPort(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPort"
}
APIPort.prototype = new APIObject();
APIPort.prototype.constructor = APIPort;
APIPort.hasPortType = function(D) {
    var E = false;
    var C;
    var F;
    for (C in DC.ports) {
        F = DC.ports[C];
        if (F && F.basetype == "port") {
            if (F.getPropertyValue("port_type") == D) {
                E = true;
                break
            }
        }
    }
    return E
};
APIPort.getPortCount = function(C) {
    var D = 0;
    if (C) {
        for (port in DC.controllers[C.toUpperCase()].ports) {
            D++
        }
    } else {
        for (port in DC.ports) {
            D++
        }
    }
    return D
};
APIPort.prototype.normalize = function() {
    if (this.objects.length) {
        for (var C = 0; C < this.objects.length; C++) {
            if (!this.objects[C].deleted) {
                this.addNormalizedProperties("_", this.objects[C]);
                break
            }
        }
    }
};

function APIPowerSupplies(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPowerSupplies"
}
APIPowerSupplies.prototype = new APIObject();
APIPowerSupplies.prototype.constructor = APIPowerSupplies;

function APIPoolSummary(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPoolSummary"
}
APIPoolSummary.prototype = new APIObject();
APIPoolSummary.prototype.constructor = APIPoolSummary;

function APIPoolHistStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPoolHistStatistics"
}
APIPoolHistStatistics.prototype = new APIObject();
APIPoolHistStatistics.prototype.constructor = APIPoolHistStatistics;

function APIPoolStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPoolStatistics"
}
APIPoolStatistics.prototype = new APIObject();
APIPoolStatistics.prototype.constructor = APIPoolStatistics;

function APIRemoteAddresses(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRemoteAddresses"
}
APIRemoteAddresses.prototype = new APIObject();
APIRemoteAddresses.prototype.constructor = APIRemoteAddresses;

function APIRemoteLinksTable(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRemoteLinksTable"
}
APIRemoteLinksTable.prototype = new APIObject();
APIRemoteLinksTable.prototype.constructor = APIRemoteLinksTable;

function APIReplicationImage(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIReplicationImage"
}
APIReplicationImage.prototype = new APIObject();
APIReplicationImage.prototype.constructor = APIReplicationImage;
APIReplicationImage.prototype.deleteOnUpdate = function() {
    return false
};
APIReplicationImage.prototype.getTreeNodeOptions = function() {
    var F = this.getPropertyValue("image_key");
    var E = this.parentObject;
    var G = E.getPropertyValue("serial_number");
    var H = E.parentObject;
    var D = DC.volumesSerial[G];
    if (!D) {
        return null
    }
    var C = {
        repVolume: E,
        repSet: H,
        volParentObj: D,
        parentType: TREETYPES.VOLUME,
        parentName: G,
        type: TREETYPES.REPLICATION_IMAGE,
        name: F,
        nodeConstructor: ReplicationImageNode
    };
    return C
};
APIReplicationImage.prototype.getParams = function() {
    if (this.objects.length > 0) {
        return this.objects[this.objects.length - 1]
    }
    return null
};
APIReplicationImage.prototype.isSource = function() {
    if (this.prop.replication_image_source.text == this.prop.snapshot_name.text) {
        return true
    } else {
        return false
    }
};
APIReplicationImage.prototype.isLocal = function() {
    var C = this.parentObject;
    if (C.isLocal()) {
        return true
    } else {
        return false
    }
};
APIReplicationImage.prototype.getSourceImage = function() {
    if (this.isSource()) {
        return this
    } else {
        var D = this.parentObject;
        var F = D.parentObject;
        for (var C = 0; C < F.objects.length; C++) {
            var D = F.objects[C];
            if (D.repImagesSerial) {
                var E = D.repImagesSerial[this.prop.image_serial_number.text];
                if (E && E.isSource()) {
                    return E
                }
            }
        }
        return null
    }
};
APIReplicationImage.prototype.getDestImage = function() {
    if (!this.isSource()) {
        return this
    } else {
        var D = this.parentObject;
        var F = D.parentObject;
        for (var C = 0; C < F.objects.length; C++) {
            var D = F.objects[C];
            if (D.repImagesSerial) {
                var E = D.repImagesSerial[this.prop.image_serial_number.text];
                if (E && !E.isSource()) {
                    return E
                }
            }
        }
        return null
    }
};
APIReplicationImage.prototype.getLocalImage = function() {
    if (this.isLocal()) {
        return this
    } else {
        var D = this.parentObject;
        var F = D.parentObject;
        for (var C = 0; C < F.objects.length; C++) {
            var D = F.objects[C];
            if (D.repImagesSerial) {
                var E = D.repImagesSerial[this.prop.image_serial_number.text];
                if (E && D.isLocal()) {
                    return E
                }
            }
        }
        return null
    }
};
APIReplicationImage.prototype.getImagePair = function() {
    var C = [];
    var E = this.parentObject;
    var G = E.parentObject;
    for (var D = 0; D < G.objects.length; D++) {
        var E = G.objects[D];
        if (E.repImagesSerial) {
            var F = E.repImagesSerial[this.prop.image_serial_number.text];
            if (F != undefined) {
                C.push(F)
            }
        }
    }
    return C
};

function APIReplicationImageParams(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIReplicationImageParams"
}
APIReplicationImageParams.prototype = new APIObject();
APIReplicationImageParams.prototype.constructor = APIReplicationImageParams;

function APIDnsParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIDnsParameters"
}
APIDnsParameters.prototype = new APIObject();
APIDnsParameters.prototype.constructor = APIDnsParameters;

function APIReplicationSet(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIReplicationSet"
}
APIReplicationSet.prototype = new APIObject();
APIReplicationSet.prototype.constructor = APIReplicationSet;
APIReplicationSet.prototype.isDestDetached = function() {
    var E = this.objects;
    if (this.objects) {
        for (var D = 0; D < this.objects.length; D++) {
            var C = this.objects[D];
            if (C.isRSRDestination()) {
                if (C.prop.status_numeric.text == "8") {
                    return true
                } else {
                    return false
                }
            }
        }
    }
    return false
};
APIReplicationSet.prototype.getPrimaryVolume = function() {
    var E = this.objects;
    if (this.objects) {
        for (var D = 0; D < this.objects.length; D++) {
            var C = this.objects[D];
            if (C.isRSRSource()) {
                return C
            }
        }
    }
    return null
};
APIReplicationSet.prototype.getSecondaryVolume = function() {
    var E = this.objects;
    if (this.objects) {
        for (var D = 0; D < this.objects.length; D++) {
            var C = this.objects[D];
            if (C.isRSRDestination()) {
                return C
            }
        }
    }
    return null
};

function APIReplicationVolume(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIReplicationVolume"
}
APIReplicationVolume.prototype = new APIObject();
APIReplicationVolume.prototype.constructor = APIReplicationVolume;
APIReplicationVolume.prototype.deleteOnUpdate = function() {
    return false
};
APIReplicationVolume.prototype.getTreeNodeOptions = function() {
    if (this.isLocal()) {
        return null
    }
    var E = this.getPropertyValue("serial_number");
    var D = this.getPropertyValue("local_volume_serial_number");
    var C = {
        parentType: TREETYPES.VOLUME,
        parentName: D,
        type: TREETYPES.REPLICATION_VOLUME,
        name: E,
        nodeConstructor: ReplicationVolumeNode
    };
    return C
};
APIReplicationVolume.prototype.isRSRSource = function() {
    var C = (this.prop.primary_volume_serial.text == this.prop.serial_number.text);
    return C
};
APIReplicationVolume.prototype.isRSRDestination = function() {
    var C = (this.prop.primary_volume_serial.text != this.prop.serial_number.text);
    return C
};
APIReplicationVolume.prototype.isRSRExternalView = function() {
    var C = this.isRSRSource();
    return C
};
APIReplicationVolume.prototype.isLocal = function() {
    return (parseInt(this.prop.location_numeric.text) == 0)
};

function APICurrentReplicationSnapshots(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICurrentReplicationSnapshots"
}
APICurrentReplicationSnapshots.prototype = new APIObject();
APICurrentReplicationSnapshots.prototype.constructor = APICurrentReplicationSnapshots;

function APIResettableStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIResettableStatistics"
}
APIResettableStatistics.prototype = new APIObject();
APIResettableStatistics.prototype.constructor = APIResettableStatistics;

function APIReadcacheHistStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIReadcacheHistStatistics"
}
APIReadcacheHistStatistics.prototype = new APIObject();
APIReadcacheHistStatistics.prototype.constructor = APIReadcacheHistStatistics;

function APISasPort(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISasPort"
}
APISasPort.prototype = new APIObject();
APISasPort.prototype.constructor = APISasPort;

function APISchedules(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISchedules";
    if (!APISchedules.metaNormalized && this.meta) {
        APISchedules.addNormalizedTaskMeta();
        this.meta.addProp(new APIProp({
            name: "associated_volume",
            value: strings.scheduleMeta.associated_volume
        }));
        this.meta.addProp(new APIProp({
            name: "associated_volume_serial",
            value: strings.scheduleMeta.associated_volume_serial
        }));
        APISchedules.metaNormalized = true
    }
}
APISchedules.prototype = new APIObject();
APISchedules.prototype.constructor = APISchedules;
APISchedules.addNormalizedTaskMeta = function() {
    var C;
    var D;
    if (APISchedules.meta && APISchedules.metaNormalized == undefined && APITasks.meta) {
        for (D in APITasks.meta.prop) {
            C = APITasks.meta.prop[D];
            APISchedules.meta.addProp(APIProp.cloneProp("task_" + D, C))
        }
        APISchedules.metaNormalized = true
    }
};
APISchedules.prototype.normalize = function() {
    var E = false;
    if (this.objects.length) {
        for (var D = 0; D < this.objects.length; D++) {
            if (!this.objects[D].deleted && (this.objects[D] instanceof APITasks)) {
                var C = this.objects[D];
                this.addNormalizedProperties("task_", C);
                if (C.objects.length) {
                    var F = this.findCurrentSubtask(C.objects);
                    this.addNormalizedProperties("task_", F);
                    F.addExtendedProperties(this)
                }
                E = true;
                break
            }
        }
    }
    if (!E) {
        this.addProp(new APIProp({
            name: "task_type",
            value: "No Task"
        }))
    }
};
APISchedules.prototype.findCurrentSubtask = function(D) {
    var C = 0;
    while (D[C].deleted) {
        C++
    }
    return D[C]
};

function APISes(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISes"
}
APISes.prototype = new APIObject();
APISes.prototype.constructor = APISes;

function APICliParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICliParameters"
}
APICliParameters.prototype = new APIObject();
APICliParameters.prototype.constructor = APICliParameters;

function APIStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStatus"
}

function APIStoragePreview(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStoragePreview"
}
APIStoragePreview.prototype = new APIObject();
APIStoragePreview.prototype.constructor = APIStoragePreview;

function APICertificateStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICertificateStatus"
}
APICertificateStatus.prototype = new APIObject();
APICertificateStatus.prototype.constructor = APICertificateStatus;
APIStatus.prototype = new APIObject();
APIStatus.prototype.constructor = APIStatus;

function APIStoragePools(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStoragePools"
}
APIStoragePools.prototype = new APIObject();
APIStoragePools.prototype.constructor = APIStoragePools;

function APIStoragePoolComponents(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStoragePoolComponents"
}
APIStoragePoolComponents.prototype = new APIObject();
APIStoragePoolComponents.prototype.constructor = APIStoragePoolComponents;

function APIStoragePoolStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStoragePoolStatus"
}
APIStoragePoolStatus.prototype = new APIObject();
APIStoragePoolStatus.prototype.constructor = APIStoragePoolStatus;

function APIStorageStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStorageStatus"
}
APIStorageStatus.prototype = new APIObject();
APIStorageStatus.prototype.constructor = APIStorageStatus;

function APIStorageTierStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIStorageTierStatus"
}
APIStorageTierStatus.prototype = new APIObject();
APIStorageTierStatus.prototype.constructor = APIStorageTierStatus;

function APISyslogParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISyslogParameters"
}
APISyslogParameters.prototype = new APIObject();
APISyslogParameters.prototype.constructor = APISyslogParameters;

function APISystem(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISystem"
}
APISystem.prototype = new APIObject();
APISystem.prototype.constructor = APISystem;
APISystem.prototype.getTreeNodeOptions = function() {
    var C = {
        parentType: TREETYPES.ROOT,
        parentName: "root",
        type: TREETYPES.SYSTEM,
        name: "system",
        nodeConstructor: SystemNode
    };
    return C
};

function APISystemParametersTable(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISystemParametersTable"
}
APISystemParametersTable.prototype = new APIObject();
APISystemParametersTable.prototype.constructor = APISystemParametersTable;

function APITasks(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITasks"
}
APITasks.prototype = new APIObject();
APITasks.prototype.constructor = APITasks;
APITasks.prototype.addExtendedProperties = function(C) {};

function APIReplicateVolumeTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APIReplicateVolumeTasks"
}
APIReplicateVolumeTasks.prototype = new APITasks();
APIReplicateVolumeTasks.prototype.constructor = APIReplicateVolumeTasks;
APIReplicateVolumeTasks.prototype.addExtendedProperties = function(C) {
    C.addProp(APIProp.cloneProp("associated_volume", this.prop.primary_volume_name));
    C.addProp(APIProp.cloneProp("associated_volume_serial", this.prop.primary_volume_serial))
};

function APIResetSnapshotTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APIResetSnapshotTasks"
}
APIResetSnapshotTasks.prototype = new APITasks();
APIResetSnapshotTasks.prototype.constructor = APIResetSnapshotTasks;
APIResetSnapshotTasks.prototype.addExtendedProperties = function(C) {
    C.addProp(APIProp.cloneProp("associated_volume", this.prop.snapshot_name));
    C.addProp(APIProp.cloneProp("associated_volume_serial", this.prop.snapshot_serial))
};

function APISnapTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APISnapTasks"
}
APISnapTasks.prototype = new APITasks();
APISnapTasks.prototype.constructor = APISnapTasks;

function APISnapshotWithRetentionTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APISnapshotWithRetentionTasks"
}
APISnapshotWithRetentionTasks.prototype = new APITasks();
APISnapshotWithRetentionTasks.prototype.constructor = APISnapshotWithRetentionTasks;
APISnapshotWithRetentionTasks.prototype.addExtendedProperties = function(C) {
    C.addProp(APIProp.cloneProp("associated_volume", this.prop.master_volume_name));
    C.addProp(APIProp.cloneProp("associated_volume_serial", this.prop.master_volume_serial))
};

function APITimeSettingsTable(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITimeSettingsTable"
}
APITimeSettingsTable.prototype = new APIObject();
APITimeSettingsTable.prototype.constructor = APITimeSettingsTable;

function APITiers(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITiers"
}
APITiers.prototype = new APIObject();
APITiers.prototype.constructor = APITiers;

function APITierSummary(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITierSummary"
}
APITierSummary.prototype = new APIObject();
APITierSummary.prototype.constructor = APITierSummary;

function APITierHistStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITierHistStatistics"
}
APITierHistStatistics.prototype = new APIObject();
APITierHistStatistics.prototype.constructor = APITierHistStatistics;

function APITierStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APITierStatistics"
}
APITierStatistics.prototype = new APIObject();
APITierStatistics.prototype.constructor = APITierStatistics;

function APIUnhealthyComponent(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIUnhealthyComponent"
}
APIUnhealthyComponent.prototype = new APIObject();
APIUnhealthyComponent.prototype.constructor = APIUnhealthyComponent;

function APIVersions(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVersions"
}
APIVersions.prototype = new APIObject();
APIVersions.prototype.constructor = APIVersions;

function APIVdiskStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVdiskStatistics"
}
APIVdiskStatistics.prototype = new APIObject();
APIVdiskStatistics.prototype.constructor = APIVdiskStatistics;

function APIVirtualDisks(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVirtualDisks"
}
APIVirtualDisks.prototype = new APIObject();
APIVirtualDisks.prototype.constructor = APIVirtualDisks;
APIVirtualDisks.prototype.getTreeNodeOptions = function() {
    var C = {
        parentType: TREETYPES.SYSTEM,
        parentName: "system",
        type: TREETYPES.VDISK,
        name: this.getPropertyValue("serial_number"),
        nodeConstructor: VdiskNode
    };
    return C
};
APIVirtualDisks.prototype.getTotalBlocks = function() {
    if (this.prop.blocks) {
        return parseInt(this.prop.blocks.text)
    }
    return 0
};
APIVirtualDisks.prototype.getUsedBlocks = function() {
    if (this.prop.blocks && this.prop.freespace_numeric) {
        return parseInt(this.prop.blocks.text) - parseInt(this.prop.freespace_numeric.text)
    }
    return 0
};
APIVirtualDisks.prototype.getFreeBlocks = function() {
    if (this.prop.freespace_numeric) {
        return parseInt(this.prop.freespace_numeric.text)
    }
    return 0
};
APIVirtualDisks.prototype.isShutdown = function() {
    if (this.prop.status_numeric.text == "7") {
        return true
    }
    return false
};
APIVirtualDisks.prototype.getDisksLocation = function() {
    var C = [];
    var E = DC.disksSerial;
    for (var F in E) {
        var D = E[F];
        if (D.prop.virtual_disk_serial.text == this.prop.serial_number.text) {
            C.push(D.prop.location.text)
        }
    }
    return C
};
APIVirtualDisks.prototype.sectorFormatMatches = function(C) {
    var E = this.getInt("pool_sector_format_numeric");
    var D = E != findSectorFormat(C);
    return D
};
APIVirtualDisks.prototype.selectedDrivesWillResultInMixedFormat = function(D) {
    var C = false;
    var F = this.getInt("pool_sector_format_numeric");
    if (F == SECTOR_FORMAT.FMT_MIXED) {
        return C
    }
    var E = findSectorFormat(D);
    if (E != SECTOR_FORMAT.FMT_NA) {
        C = F != E
    }
    return C
};

function APIVolumeCopyTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APIVolumeCopyTasks"
}
APIVolumeCopyTasks.prototype = new APITasks();
APIVolumeCopyTasks.prototype.constructor = APIVolumeCopyTasks;
APIVolumeCopyTasks.prototype.addExtendedProperties = function(C) {
    C.addProp(APIProp.cloneProp("associated_volume", this.prop.source_volume_name));
    C.addProp(APIProp.cloneProp("associated_volume_serial", this.prop.source_volume_serial))
};

function APIVolumeGroups(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeGroups"
}
APIVolumeGroups.prototype = new APIObject();
APIVolumeGroups.prototype.constructor = APIVolumeGroups;

function APIVolumeGroupView(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeGroupView"
}
APIVolumeGroupView.prototype = new APIObject();
APIVolumeGroupView.prototype.constructor = APIVolumeGroupView;

function APIVolumeGroupViewMappings(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeGroupViewMappings"
}
APIVolumeGroupViewMappings.prototype = new APIObject();
APIVolumeGroupViewMappings.prototype.constructor = APIVolumeGroupViewMappings;
APIVolumeGroupViewMappings.prototype.getHostName = function() {
    var D = this.get("mapped_id");
    var C = (D == "AOI" ? strings.allOtherInits : this.get("nickname"));
    if ((!C || C == " ") && D.indexOf("I") == 0) {
        var E = DC.initiatorsId[D];
        if (E) {
            C = E.get("id")
        }
    }
    return C
};

function APIVolumeGroupViewMappingsLuns(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeGroupViewMappingsLuns"
}
APIVolumeGroupViewMappingsLuns.prototype = new APIObject();
APIVolumeGroupViewMappingsLuns.prototype.constructor = APIVolumeGroupViewMappingsLuns;

function APIVolumeView(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeView"
}
APIVolumeView.prototype = new APIObject();
APIVolumeView.prototype.constructor = APIVolumeView;

function APIVolumeViewMappings(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumeViewMappings"
}
APIVolumeViewMappings.prototype = new APIObject();
APIVolumeViewMappings.prototype.constructor = APIVolumeViewMappings;
APIVolumeViewMappings.prototype.getHostName = function() {
    var D = this.get("mapped_id");
    var C = (D == "AOI" ? strings.allOtherInits : this.get("nickname"));
    if ((!C || C == " ") && D.indexOf("I") == 0) {
        var E = DC.initiatorsId[D];
        if (E) {
            C = E.get("id")
        }
    }
    return C
};

function APIVolumes(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIVolumes"
}
APIVolumes.prototype = new APIObject();
APIVolumes.prototype.constructor = APIVolumes;
APIVolumes.selectedGroups = function(J, H, I) {
    var D = {};
    var C = [];
    var G = 0;
    for (var F = 0; F < J.length; F++) {
        if (J[F].basetype != "volumes") {
            continue
        }
        var E = J[F].getObject();
        if (E) {
            var K = E.get("volume_group");
            if (!K || K == "UNGROUPEDVOLUMES") {
                if (H) {
                    return null
                } else {
                    continue
                }
            }
            if (!D[K]) {
                D[K] = true;
                C.push(new DCRef("volume-groups", K));
                G++
            }
        }
    }
    if (G == 0) {
        return null
    } else {
        if (I && G > I) {
            return null
        } else {
            return C
        }
    }
};
APIVolumes.prototype.isVirtual = function() {
    var C = parseInt(this.get("storage_type_numeric"), 10);
    if (C == VOLUME_CLASS.VIRTUAL) {
        return true
    } else {
        return false
    }
};
APIVolumes.prototype.getMaps = function() {
    var I = [];
    var H = this.get("serial_number");
    var E = this.get("volume_group");
    if (E && E != "UNGROUPEDVOLUMES") {
        var G = DC.volGroupViewsSerial[E];
        if (G) {
            for (var F = 0; F < G.objects.length; F++) {
                if (G.objects[F] instanceof APIVolumeGroupViewMappings) {
                    var C = G.objects[F];
                    if (C.get("mapped_id") != "AOI" || C.getInt("access_numeric") != 0) {
                        I.push(G.objects[F])
                    }
                }
            }
        }
    }
    var D = DC.volViewsSerial[this.get("serial_number")];
    if (D) {
        for (var F = 0; F < D.objects.length; F++) {
            if (D.objects[F] instanceof APIVolumeViewMappings) {
                var C = D.objects[F];
                if (C.get("mapped_id") != "AOI" || C.getInt("access_numeric") != 0) {
                    I.push(D.objects[F])
                }
            }
        }
    }
    return I
};
APIVolumes.prototype.getMapsCount = function() {
    var D = this.getMaps();
    var C = D.length;
    return C
};
APIVolumes.prototype.getTreeNodeOptions = function() {
    var F = {
        name: this.getPropertyValue("serial_number")
    };
    var H = parseInt(this.getPropertyValue("volume_type_numeric"));
    var E = this.getPropertyValue("virtual_disk_serial");
    var D = DC.vdisksSerial[E];
    if (D && D.isShutdown()) {
        return null
    }
    switch (H) {
        case VOLUME_TYPES.VOLUME:
        case VOLUME_TYPES.MASTER_VOLUME:
        case VOLUME_TYPES.ROLLOFF:
        case VOLUME_TYPES.RSR_SOURCE:
            F.parentType = TREETYPES.VDISK;
            F.parentName = E;
            F.type = TREETYPES.VOLUME;
            F.nodeConstructor = VolumeNode;
            break;
        case VOLUME_TYPES.BACKING_STORE:
            F.parentType = TREETYPES.VDISK;
            F.parentName = E;
            F.type = TREETYPES.SNAPPOOL;
            F.nodeConstructor = SnapPoolNode;
            break;
        case VOLUME_TYPES.SNAPSHOT:
            var G = null;
            if (DC.snapshotsSerial) {
                G = DC.snapshotsSerial[F.name]
            }
            if (G) {
                var C = parseInt(G.getPropertyValue("snapshot_type_numeric"));
                if ((C & 16384) != 0) {
                    F.parentType = TREETYPES.VOLUME;
                    F.parentName = this.getPropertyValue("volume_parent");
                    F.type = TREETYPES.SNAPSHOT;
                    F.nodeConstructor = SnapNode
                } else {
                    F = null
                }
            } else {
                F = null
            }
            break;
        default:
            MC.errorOutput("Invalid volume type for tree node construction: %d", H);
            F = null;
            break
    }
    return F
};
APIVolumes.prototype.getTotalBlocks = function() {
    if (this.prop.blocks) {
        return parseInt(this.prop.blocks.text)
    }
    return 0
};
APIVolumes.prototype.getPages = function() {
    if (this.getInt("storage_type_numeric") != STORAGE_CLASS.VIRTUAL) {
        return 0
    } else {
        return Math.ceil(this.getInt("blocks") / PAGEBLOCKS[this.get("storage_pool_name")])
    }
};
APIVolumes.prototype.occupiesSpace = function() {
    return (this.prop.capabilities.text.indexOf("d") >= 0)
};
APIVolumes.prototype.isCopyable = function() {
    var C = (this.prop.capabilities.text.indexOf("c") >= 0);
    return C
};
APIVolumes.prototype.isMappable = function() {
    var C = (this.prop.capabilities.text.indexOf("m") >= 0);
    return C
};
APIVolumes.prototype.isSnappable = function() {
    var C = (this.prop.capabilities.text.indexOf("s") >= 0);
    return C
};
APIVolumes.prototype.isExpandable = function() {
    var C = (this.prop.capabilities.text.indexOf("e") >= 0);
    return C
};
APIVolumes.prototype.isReplicatable = function() {
    return (this.prop.capabilities.text.indexOf("r") >= 0)
};
APIVolumes.prototype.isRSRSource = function() {
    var C = (this.prop.attributes.text.indexOf("s") >= 0);
    return C
};
APIVolumes.prototype.isRSRDestination = function() {
    var C = (this.prop.attributes.text.indexOf("d") >= 0);
    return C
};
APIVolumes.prototype.isRSRExternalView = function() {
    var C = (this.prop.attributes.text.indexOf("x") >= 0);
    return C
};
APIVolumes.prototype.isRSRPrepared = function() {
    var C = (this.prop.attributes.text.indexOf("p") >= 0);
    return C
};
APIVolumes.prototype.isStandard = function() {
    var C = (parseInt(this.prop.volume_type_numeric.text) == 0);
    return C
};
APIVolumes.prototype.isMaster = function() {
    var C = (parseInt(this.prop.volume_type_numeric.text) == 2);
    return C
};
APIVolumes.prototype.isGroupable = function() {
    var C = this.getInt("volume_type_numeric");
    switch (C) {
        case VOLUME_TYPES.BASE:
        case VOLUME_TYPES.PAGED_SNAPSHOT:
        case VOLUME_TYPES.VOLUME_COPY:
            return true;
            break;
        case VOLUME_TYPES.VOLUME:
        case VOLUME_TYPES.MASTER_VOLUME:
        case VOLUME_TYPES.SNAPSHOT:
        case VOLUME_TYPES.RSR_SOURCE:
        case VOLUME_TYPES.PAGED_STORAGE_COMP:
        case VOLUME_TYPES.PAGED_STORAGE_POOL:
        case VOLUME_TYPES.PAGED_STORAGE_MULTIWRITE:
        case VOLUME_TYPES.METADATA:
        case VOLUME_TYPES.SCOREBOARD_STORE:
        case VOLUME_TYPES.MIRROR_COMPONENT:
        case VOLUME_TYPES.SCOREBOARD_STORE_MIRROR_SET:
        case VOLUME_TYPES.ROLLOFF:
        case VOLUME_TYPES.BACKING_STORE:
        default:
            return false;
            break
    }
    return false
};

function APIUsers(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIUsers"
}
APIUsers.prototype = new APIObject();
APIUsers.prototype.constructor = APIUsers;

function APIUsergroups(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIUsergroups"
}
APIUsergroups.prototype = new APIObject();
APIUsergroups.prototype.constructor = APIUsergroups;

function APIUserInteractions(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIUserInteractions"
}
APIUserInteractions.prototype = new APIObject();
APIUserInteractions.prototype.constructor = APIUserInteractions;

function APISecurityCommunicationsProtocols(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISecurityCommunicationsProtocols"
}
APISecurityCommunicationsProtocols.prototype = new APIObject();
APISecurityCommunicationsProtocols.prototype.constructor = APISecurityCommunicationsProtocols;

function APICommunicationPorts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICommunicationPorts"
}
APICommunicationPorts.prototype = new APIObject();
APICommunicationPorts.prototype.constructor = APICommunicationPorts;

function APIIscsiParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIIscsiParameters"
}
APIIscsiParameters.prototype = new APIObject();
APIIscsiParameters.prototype.constructor = APIIscsiParameters;

function APIIBPort(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIIBPort"
}
APIIBPort.prototype = new APIObject();
APIIBPort.prototype.constructor = APIIBPort;

function APIInfinibandParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIInfinibandParameters"
}
APIInfinibandParameters.prototype = new APIObject();
APIInfinibandParameters.prototype.constructor = APIInfinibandParameters;

function APIInfinibandErrorStatistics(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIInfinibandErrorStatistics"
}
APIInfinibandErrorStatistics.prototype = new APIObject();
APIInfinibandErrorStatistics.prototype.constructor = APIInfinibandErrorStatistics;

function APIAdvancedSettingsTable(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIAdvancedSettingsTable"
}
APIAdvancedSettingsTable.prototype = new APIObject();
APIAdvancedSettingsTable.prototype.constructor = APIAdvancedSettingsTable;

function APIRefreshCounters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRefreshCounters"
}
APIRefreshCounters.prototype = new APIObject();
APIRefreshCounters.prototype.constructor = APIRefreshCounters;

function APIProfiles(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIProfiles"
}
APIProfiles.prototype = new APIObject();
APIProfiles.prototype.constructor = APIProfiles;

function APIProfileVolumes(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIProfileVolumes"
}
APIProfileVolumes.prototype = new APIObject();
APIProfileVolumes.prototype.constructor = APIProfileVolumes;

function APILicense(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APILicense"
}
APILicense.prototype = new APIObject();
APILicense.prototype.constructor = APILicense;

function APIEmailParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIEmailParameters"
}
APIEmailParameters.prototype = new APIObject();
APIEmailParameters.prototype.constructor = APIEmailParameters;

function APIRedundancy(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRedundancy"
}
APIRedundancy.prototype = new APIObject();
APIRedundancy.prototype.constructor = APIRedundancy;

function APISnmpParameters(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISnmpParameters"
}
APISnmpParameters.prototype = new APIObject();
APISnmpParameters.prototype.constructor = APISnmpParameters;

function APISnapPools(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISnapPools"
}
APISnapPools.prototype = new APIObject();
APISnapPools.prototype.constructor = APISnapPools;
APISnapPools.prototype.getTotalBlocks = function() {
    if (this.prop.size_numeric) {
        return parseInt(this.prop.size_numeric.text)
    }
    return 0
};
APISnapPools.prototype.getUsedBlocks = function() {
    if (this.prop.size_numeric && this.prop.free_numeric) {
        return parseInt(this.prop.size_numeric.text) - parseInt(this.prop.free_numeric.text)
    }
    return 0
};
APISnapPools.prototype.getFreeBlocks = function() {
    if (this.prop.free_numeric) {
        return parseInt(this.prop.free_numeric.text)
    }
    return 0
};

function APIPolicyThreshold(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPolicyThreshold"
}
APIPolicyThreshold.prototype = new APIObject();
APIPolicyThreshold.prototype.constructor = APIPolicyThreshold;

function APISnapshots(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APISnapshots"
}
APISnapshots.prototype = new APIObject();
APISnapshots.prototype.constructor = APISnapshots;
APISnapshots.prototype.getTreeNodeOptions = function() {
    var E = null;
    var D = this.getPropertyValue("serial_number");
    var C = parseInt(this.getPropertyValue("snapshot_type_numeric"));
    if (DC.volumesSerial) {
        var H = DC.volumesSerial[D]
    }
    if (H && ((C & 16384) != 0)) {
        E = {
            name: D
        };
        var G = H.getPropertyValue("volume_parent");
        var F = TREETYPES.VOLUME + G;
        if (!H.treeNodes[F]) {
            E = {
                name: D,
                jsonObject: H,
                parentType: TREETYPES.VOLUME,
                parentName: G,
                type: TREETYPES.SNAPSHOT,
                nodeConstructor: SnapNode
            }
        }
    }
    return E
};
APISnapshots.prototype.getUsedBlocks = function() {
    if (this.prop.snap_data_numeric) {
        return parseInt(this.prop.snap_data_numeric.text)
    }
    return 0
};
APISnapshots.prototype.isStandard = function() {
    var C = parseInt(this.get("snapshot_type_numeric"));
    if ((C & 16384) != 0) {
        return true
    }
    return false
};

function APIPeerConnectionInfo(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPeerConnectionInfo"
}
APIPeerConnectionInfo.prototype = new APIObject();
APIPeerConnectionInfo.prototype.constructor = APIPeerConnectionInfo;

function APIPeerControllers(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPeerControllers"
}
APIPeerControllers.prototype = new APIObject();
APIPeerControllers.prototype.constructor = APIPeerControllers;

function APIPeerPorts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPeerPorts"
}
APIPeerPorts.prototype = new APIObject();
APIPeerPorts.prototype.constructor = APIPeerPorts;

function APIPeerConnections(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIPeerConnections"
}
APIPeerConnections.prototype = new APIObject();
APIPeerConnections.prototype.constructor = APIPeerConnections;
APIPeerConnections.prototype.getPortLabelsAddrs = function(C, F, H, I) {
    var D = [];
    var L = "";
    var E = {};
    var K = undefined;
    var J = undefined;
    if (C == undefined) {
        return null
    }
    if (H == undefined) {
        H = true
    }
    if (F == undefined) {
        F = true
    }
    if (I == undefined) {
        I = " - "
    }
    for (var G = 0; G < this.objects.length; G++) {
        E = this.objects[G];
        if (E instanceof((C) ? APIRemotePorts : APILocalPorts)) {
            K = E.get((C) ? "remote_host_port" : "local_host_port");
            J = E.get("port_address");
            if (K != undefined) {
                L = ((F) ? K : "") + ((F && H) ? I : "") + ((H) ? J : "");
                D.push(L)
            }
        }
    }
    return D
};
APIPeerConnections.prototype.getRepSet = function() {
    return null
};

function APICsReplicationSet(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICsReplicationSet"
}
APICsReplicationSet.prototype = new APIObject();
APICsReplicationSet.prototype.constructor = APICsReplicationSet;
APICsReplicationSet.prototype.getRepObjProp = function(C, F) {
    var E;
    if (C == undefined || F == undefined) {
        return null
    }
    var D = this.getObject("replication_state_numeric", C);
    if (D.prop[F] != undefined && D.prop[F].text) {
        E = D.prop[F].text;
        return E
    }
    return null
};
APICsReplicationSet.prototype.getAssociatedSchedules = function() {
    var C = this.get("serial_number");
    var E = [];
    for (var D in DC.schedules) {
        if (DC.schedules[D].get("task_replication_set_serialnum") == C) {
            E.push(D)
        }
    }
    return E
};

function APICsReplication(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APICsReplication"
}
APICsReplication.prototype = new APIObject();
APICsReplication.prototype.constructor = APICsReplication;

function APICsReplicateTasks(E, C, D) {
    APITasks.call(this, E, C, D);
    this.class_name = "APICsReplicateTasks"
}
APICsReplicateTasks.prototype = new APITasks();
APICsReplicateTasks.prototype.constructor = APICsReplicateTasks;

function APILocalPorts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APILocalPorts"
}
APILocalPorts.prototype = new APIObject();
APILocalPorts.prototype.constructor = APILocalPorts;

function APIRemotePorts(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRemotePorts"
}
APIRemotePorts.prototype = new APIObject();
APIRemotePorts.prototype.constructor = APIRemotePorts;

function APILocalPortsDetail(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APILocalPortsDetail"
}
APILocalPortsDetail.prototype = new APIObject();
APILocalPortsDetail.prototype.constructor = APILocalPortsDetail;

function APIRemotePortsDetail(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRemotePortsDetail"
}
APIRemotePortsDetail.prototype = new APIObject();
APIRemotePortsDetail.prototype.constructor = APIRemotePortsDetail;

function APIRemoteSystem(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIRemoteSystem"
}
APIRemoteSystem.prototype = new APIObject();
APIRemoteSystem.prototype.constructor = APIRemoteSystem;

function APIExpanders(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIExpanders"
}
APIExpanders.prototype = new APIObject();
APIExpanders.prototype.constructor = APIExpanders;

function APIHeatmaps(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIHeatmaps"
}
APIHeatmaps.prototype = new APIObject();
APIHeatmaps.prototype.constructor = APIHeatmaps;

function APIWorkload(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIWorkload"
}
APIWorkload.prototype = new APIObject();
APIWorkload.prototype.constructor = APIWorkload;

function Message(C) {
    this.class_name = "Message"
}
Message.prototype.process = function() {
    MC.warningOutput(this.class_name + ".process() called!")
};

function MsgState(C) {
    Message.call(this, C);
    this.class_name = "MsgState";
    if (C) {
        this.systemName = C.systemName;
        this.ipAddr = C.ipAddr;
        this.controller = C.controller;
        this.state = C.state
    }
}
MsgState.prototype = new Message();
MsgState.prototype.constructor = MsgState;
MsgState.prototype.process = function() {
    mcDebug("backChannel", "MsgState.process() called: systemName: %s: ipAddr: %s, controller: %s, state: %s", this.systemName, this.ipAddr, this.controller, this.state);
    if (typeof(session) != "undefined") {
        session.handleID(this.systemName, this.ipAddr, this.controller, this.state)
    }
};

function MsgProgress(C) {
    Message.call(this, C);
    this.class_name = "MsgProgress";
    if (C) {
        this.type = C.type;
        this.state = C.state;
        this.status = C.status;
        this.message = C.message;
        this.returnCode = C.returnCode
    }
}
MsgProgress.prototype = new Message();
MsgProgress.prototype.constructor = MsgProgress;
MsgProgress.typesActive = {};
MsgProgress.prototype.process = function() {
    var J = true;
    var H = false;
    var M = false;
    var D = false;
    var L = (typeof panels != "undefined" && panels.ActivityBarPanel) ? panels.ActivityBarPanel : null;
    var E = (typeof MC.saveLogsInProcess != "undefined" && MC.saveLogsInProcess);
    if (this.state == "Active") {
        if (!MsgProgress.typesActive[this.type]) {
            M = true;
            MsgProgress.typesActive[this.type] = true
        }
    } else {
        if (MsgProgress.typesActive[this.type]) {
            D = true;
            MsgProgress.typesActive[this.type] = false
        }
    }
    switch (this.type) {
        case "codeload":
            H = true;
            if (!MC.inCodeLoad) {
                MC.inCodeLoad = true
            }
            break;
        case "getlogs":
            if (E) {
                H = true
            } else {
                if (!L) {
                    J = true
                }
            }
            break;
        default:
            break
    }
    if (!H) {
        if (L) {
            if (M) {
                L.display("info", new MCDate(), strings.progressStarting(this.type))
            } else {
                if (D) {
                    L.display("info", new MCDate(), strings.progressFinished(this.type))
                }
            }
        }
        return
    }
    var C = this.message.split(/<br\s*\/>/);
    var F = "";
    for (var G = 0, I = C.length; G < I; G++) {
        var K = C[G];
        if (K.charAt(0) == "[") {
            K = K.substring(K.indexOf("]") + 1)
        }
        F += "<br />" + K
    }
    if (this.state == "Active") {
        if (this.type == "getlogs") {
            GetLogsProgress(F)
        } else {
            FirmwareUpdateProgress(F)
        }
    } else {
        if (this.state == "Inactive") {
            MC.warningOutput("Progress messsage received with Inactive state!")
        } else {
            if (this.state == "Finished") {
                if (this.returnCode == undefined) {
                    ProgressFinishedUnknown(F);
                    return
                }
                switch (parseInt(this.returnCode, 10)) {
                    case 8:
                        FirmwareUpdateSuccessReboot(F);
                        BC.off();
                        setTimeout("session.mcRestart()", 210 * SECOND);
                        break;
                    case 9:
                        FirmwareUpdateSuccessNoReboot(F);
                        MC.inCodeLoad = false;
                        if (MC.sysDownDuringCodeload) {
                            delete MC.sysDownDuringCodeload;
                            MC.reloadAllDataSets()
                        }
                        reloader.on();
                        break;
                    case 10:
                        FirmwareUpdateFailureReboot(F);
                        BC.off();
                        setTimeout("session.mcRestart()", 210 * SECOND);
                        break;
                    case 11:
                        if (this.type == "getlogs") {
                            GetLogsFailureNoReboot(F)
                        } else {
                            FirmwareUpdateFailureNoReboot(F)
                        }
                        MC.inCodeLoad = false;
                        if (MC.sysDownDuringCodeload) {
                            delete MC.sysDownDuringCodeload;
                            MC.reloadAllDataSets()
                        }
                        reloader.on();
                        break;
                    case 12:
                        GetLogsSuccess(F);
                        reloader.on();
                        break;
                    default:
                        ProgressFinishedUnknown(F);
                        if (MC.inCodeLoad) {
                            MC.inCodeLoad = false;
                            if (MC.sysDownDuringCodeload) {
                                delete MC.sysDownDuringCodeload;
                                MC.reloadAllDataSets()
                            }
                        }
                        reloader.on();
                        break
                }
            }
        }
    }
};

function MsgStatus(C) {
    Message.call(this, C);
    this.class_name = "MsgStatus";
    if (C) {
        this.type = C.type;
        this.message = C.message
    }
}
MsgStatus.prototype = new Message();
MsgStatus.prototype.constructor = MsgStatus;
MsgStatus.prototype.process = function() {
    MC.warningOutput("MsgStatus.process() called: Type: %s Message: %s", this.type, this.message);
    if (this.type == "webStop") {
        BC.webStop = true;
        reloader.off()
    }
};

function MsgDataUpdate(C) {
    Message.call(this, C);
    this.class_name = "MsgDataUpdate";
    if (C) {
        this.type = C.type;
        this.dataSet = C.dataSet;
        this.object = C.object
    }
}
MsgDataUpdate.prototype = new Message();
MsgDataUpdate.prototype.constructor = MsgDataUpdate;
MsgDataUpdate.prototype.process = function() {
    mcDebug("bcUpdate", "Delta Update: type: %s, dataset: %s, count: %d, object: %o", this.type, this.dataSet, (this.object.objects ? this.object.objects.length : 0), this.object);
    var D = new Date();
    if (!MC[this.dataSet]) {
        mcDebug("bcUpdate", "MsgDataUpdate: unrecognized dataset: %s", this.dataSet);
        return
    }
    if (MC[this.dataSet].access.method != DataSet.METHOD.BACKCHANNEL) {
        return
    }
    if (!MC[this.dataSet].data) {
        return
    }
    if (mcDebugs.bcUpdate) {
        for (var F = 0, C = this.object.objects.length; F < C; F++) {
            var G = this.object.objects[F];
            mcDebug("bcUpdate", G, "BC: %s of %s - Object: %o", this.type, G.basetype, G)
        }
    }
    if (this.type == "update") {
        MC[this.dataSet].data.updateData(this.object)
    } else {
        if (this.type == "delete") {
            MC[this.dataSet].data.removeObjects(this.object)
        }
    }
    var H = new Date();
    if (this.object.objects.length > 0) {
        MC[this.dataSet].notify()
    }
    var E = new Date();
    MC.infoOutput("Delta Update Finished: data update: " + (H.getTime() - D.getTime()) + " ms, notification: " + (E.getTime() - H.getTime()) + " ms, Total: " + (E.getTime() - D.getTime()) + " ms")
};

function MsgCommand(C) {
    Message.call(this, C);
    this.class_name = "MsgCommand";
    if (C) {
        this.command = C.command;
        this.data = C.data || {}
    }
}
MsgCommand.prototype = new Message();
MsgCommand.prototype.constructor = MsgCommand;
MsgCommand.prototype.process = function() {
    switch (this.command) {
        case "reload":
            MC.infoOutput("Would process reload msgCommand here.");
            break;
        default:
            MC.warningOutput("Got unknown MsgCommand from server: %s", this.command);
            break
    }
};

function Messages(C) {
    this.messages = C
}
Messages.prototype.process = function() {
    if (this.messages) {
        for (var C = 0; C < this.messages.length; C++) {
            var D = this.messages[C];
            if (D instanceof Message) {
                D.process()
            }
        }
    }
};

function isHPsystem() {
    var C = MC.systemInfoSet.data.objects[0].getPropertyValue("vendor_name");
    MC.debugOutput("isHpSystem: vendor " + C);
    if (C.indexOf("HP") != -1) {
        return true
    } else {
        return false
    }
}

function isIndysystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    if (C == 12) {
        return true
    } else {
        return false
    }
}

function isQuantumSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 16) ? true : false
}

function isStratusSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 3) ? true : false
}

function isVistaSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 17) ? true : false
}

function isDellSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    if ((C == 22) || (C == 23)) {
        return true
    }
    return false
}

function isDellBBSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 23) ? true : false
}

function isDellBBSystem() {
    var C = MC.systemInfoSet.data.objects[0].getInt("platform_brand_numeric");
    return (C == 23) ? true : false
}

function APIShowOtherMCStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIShowOtherMCStatus"
}
APIShowOtherMCStatus.prototype = new APIObject();
APIShowOtherMCStatus.prototype.constructor = APIShowOtherMCStatus;

function APIShutdownStatus(E, C, D) {
    APIObject.call(this, E, C, D);
    this.class_name = "APIShutdownStatus"
}
APIShutdownStatus.prototype = new APIObject();
APIShutdownStatus.prototype.constructor = APIShutdownStatus;
MCDate = function() {
    var C = 0;
    this._usingBrowserTZO = true;
    if (arguments[0] instanceof TimezoneOffset) {
        this._timezoneOffset = arguments[0]._minutes;
        this._usingBrowserTZO = false;
        C = 1
    }
    var D = true;
    switch (arguments.length - C) {
        case 0:
            this._date = new Date();
            this._timezoneOffset = MCDate.arrayTimezoneOffset;
            this._usingBrowserTZO = false;
            this._date.setTime(this._date.getTime() - MCDate.browserOffset);
            D = false;
            break;
        case 1:
            if (typeof arguments[C + 0] === "number") {
                D = false;
                this._date = new Date(arguments[C + 0])
            } else {
                this._renderingDate = new Date(arguments[C + 0])
            }
            break;
        case 2:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1]);
            break;
        case 3:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2]);
            break;
        case 4:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2], arguments[C + 3]);
            break;
        case 5:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2], arguments[C + 3], arguments[C + 4]);
            break;
        case 6:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2], arguments[C + 3], arguments[C + 4], arguments[C + 5]);
            break;
        case 7:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2], arguments[C + 3], arguments[C + 4], arguments[C + 5], arguments[C + 6]);
            break;
        default:
            this._renderingDate = new Date(arguments[C + 0], arguments[C + 1], arguments[C + 2], arguments[C + 3], arguments[C + 4], arguments[C + 5], arguments[C + 6]);
            break
    }
    if (this._usingBrowserTZO) {
        if (D) {
            this._timezoneOffset = this._renderingDate.getTimezoneOffset()
        } else {
            this._timezoneOffset = this._date.getTimezoneOffset()
        }
    }
    if (D) {
        this._renderToUTC()
    } else {
        this._UTCToRender()
    }
};
MCDate.arrayTimezoneOffset = 0;
MCDate.browserOffset = 0;
MCDate.runningCPSmode = false;
MCDate.prototype = new Object();
MCDate.prototype.constructor = MCDate;
MCDate.syncToArray = function() {
    var D = MC.timeSettingsSet.getData().getObjectOfBasetype("time-settings-table");
    var C = new Date().getTime();
    var F = 0;
    if (D) {
        F = D.getPropertyValue("date_time_numeric") * 1000;
        if (MCDate.runningCPSmode) {
            F = MCDate.stringToEpoch(D.getPropertyValue("date_time"))
        }
        if (decodeBooleanFlag(D.getPropertyValue("ntp_state"))) {
            MCDate.arrayTimezoneOffset = -TimezoneOffset.stringToMinutes(D.getPropertyValue("time_zone_offset"))
        } else {
            MCDate.arrayTimezoneOffset = 60 * Math.round((C - F) / (1000 * 60 * 60))
        }
        var E = F + (MCDate.arrayTimezoneOffset * 60000);
        MCDate.browserOffset = C - E
    }
};
MCDate.prototype._renderToUTC = function() {
    var C = this._renderingDate.getTimezoneOffset();
    var D = (this._timezoneOffset - C) * 60 * 1000;
    if (this._date) {
        this._date.setTime(this._renderingDate.getTime() + D)
    } else {
        this._date = new Date(this._renderingDate.getTime() + D)
    }
    this._UTC = this.toUTCString()
};
MCDate.prototype._UTCToRender = function() {
    var C = this._date.getTimezoneOffset();
    var D = (this._timezoneOffset - C) * 60 * 1000;
    if (this._renderingDate) {
        this._renderingDate.setTime(this._date.getTime() - D)
    } else {
        this._renderingDate = new Date(this._date.getTime() - D)
    }
    this._UTC = this.toUTCString()
};
MCDate.prototype.getDate = function() {
    return this._renderingDate.getDate()
};
MCDate.prototype.getUTCDate = function() {
    return this._date.getUTCDate()
};
MCDate.prototype.getDay = function() {
    return this._renderingDate.getDay()
};
MCDate.prototype.getUTCDay = function() {
    return this._date.getUTCDay()
};
MCDate.prototype.getFullYear = function() {
    return this._renderingDate.getFullYear()
};
MCDate.prototype.getUTCFullYear = function() {
    return this._date.getUTCFullYear()
};
MCDate.prototype.getHours = function() {
    return this._renderingDate.getHours()
};
MCDate.prototype.getUTCHours = function() {
    return this._date.getUTCHours()
};
MCDate.prototype.getMilliseconds = function() {
    return this._renderingDate.getMilliseconds()
};
MCDate.prototype.getUTCMilliseconds = function() {
    return this._date.getUTCMilliseconds()
};
MCDate.prototype.getMinutes = function() {
    return this._renderingDate.getMinutes()
};
MCDate.prototype.getUTCMinutes = function() {
    return this._date.getUTCMinutes()
};
MCDate.prototype.getMonth = function() {
    return this._renderingDate.getMonth()
};
MCDate.prototype.getUTCMonth = function() {
    return this._date.getUTCMonth()
};
MCDate.prototype.getSeconds = function() {
    return this._renderingDate.getSeconds()
};
MCDate.prototype.getUTCSeconds = function() {
    return this._date.getUTCSeconds()
};
MCDate.prototype.getTime = function() {
    return this._date.getTime()
};
MCDate.prototype.getTimezoneOffset = function() {
    if (this._usingBrowserTZO) {
        return this._date.getTimezoneOffset()
    }
    return this._timezoneOffset
};
MCDate.prototype.getYear = function() {
    return this.getFullYear()
};
MCDate.prototype.getUTCYear = function() {
    return this.getUTCFullYear()
};
MCDate.prototype.setDate = function(C) {
    this._renderingDate.setDate(C);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._renderingDate.getTimezoneOffset()
    }
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCDate = function(C) {
    this._date.setUTCDate(C);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setFullYear = function(D, E, C) {
    Date.prototype.setFullYear.apply(this._renderingDate, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._renderingDate.getTimezoneOffset()
    }
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCFullYear = function(D, E, C) {
    Date.prototype.setUTCFullYear.apply(this._date, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setHours = function(C, E, F, D) {
    Date.prototype.setHours.apply(this._renderingDate, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._renderingDate.getTimezoneOffset()
    }
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCHours = function(C, E, F, D) {
    Date.prototype.setUTCHours.apply(this._date, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setMilliseconds = function(C) {
    this._renderingDate.setMilliseconds(C);
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCMilliseconds = function(C) {
    this._date.setUTCMilliseconds(C);
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setMinutes = function(D, E, C) {
    Date.prototype.setMinutes.apply(this._renderingDate, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._renderingDate.getTimezoneOffset()
    }
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCMinutes = function(D, E, C) {
    Date.prototype.setUTCMinutes.apply(this._date, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setMonth = function(D, C) {
    Date.prototype.setMonth.apply(this._renderingDate, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._renderingDate.getTimezoneOffset()
    }
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCMonth = function(D, C) {
    Date.prototype.setUTCMonth.apply(this._date, arguments);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setSeconds = function(D, C) {
    Date.prototype.setSeconds.apply(this._renderingDate, arguments);
    this._renderToUTC();
    return this.getTime()
};
MCDate.prototype.setUTCSeconds = function(D, C) {
    Date.prototype.setUTCSeconds.apply(this._date, arguments);
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setTime = function(C) {
    this._date.setTime(C);
    if (this._usingBrowserTZO) {
        this._timezoneOffset = this._date.getTimezoneOffset()
    }
    this._UTCToRender();
    return this._date.getTime()
};
MCDate.prototype.setTimezoneOffset = function(C) {
    if (typeof C === "number") {
        this._timezoneOffset = C
    } else {
        if (C instanceof TimezoneOffset) {
            this._timezoneOffset = C._minutes
        }
    }
    this._usingBrowserTZO = false;
    this._UTCToRender();
    return this._timezoneOffset
};
MCDate.prototype.toDateString = function() {
    return this._renderingDate.toDateString()
};
MCDate.prototype.toUTCString = function() {
    return this._date.toUTCString()
};
MCDate.prototype.toISOString = function() {
    return this._date.toISOString()
};
MCDate.prototype.toJSON = function() {
    return this._date.toJSON()
};
MCDate.prototype.toLocaleDateString = function() {
    return this._renderingDate.toLocaleDateString()
};
MCDate.prototype.toLocaleTimeString = function() {
    return this._renderingDate.toLocaleTimeString()
};
MCDate.prototype.toLocaleString = function() {
    return this._renderingDate.toLocaleString()
};
MCDate.prototype.toString = function() {
    return (this.toDateString() + " " + this.toTimeString())
};
MCDate.prototype.toTimeString = function() {
    return (MCDate.toISOTimeString(this) + this._timezoneString())
};
MCDate.toISODateString = function(C) {
    return (leadingZeros(C.getFullYear(), 4) + "-" + leadingZeros(C.getMonth() + 1, 2) + "-" + leadingZeros(C.getDate(), 2))
};
MCDate.toISOTimeString = function(C) {
    return (leadingZeros(C.getHours(), 2) + ":" + leadingZeros(C.getMinutes(), 2) + ":" + leadingZeros(C.getSeconds(), 2))
};
MCDate.toUTCDateString = function(C) {
    return (leadingZeros(C.getUTCFullYear(), 4) + "-" + leadingZeros(C.getUTCMonth() + 1, 2) + "-" + leadingZeros(C.getUTCDate(), 2))
};
MCDate.toUTCTimeString = function(C) {
    return (leadingZeros(C.getUTCHours(), 2) + ":" + leadingZeros(C.getUTCMinutes(), 2) + ":" + leadingZeros(C.getUTCSeconds(), 2))
};
MCDate.prototype.valueOf = function() {
    return this._date.getTime()
};
MCDate.parse = function(C) {
    return Date.parse(C)
};
MCDate.UTC = function(H, I, E, D, G, J, F) {
    var C = NaN;
    switch (arguments.length) {
        case 0:
            C = Date.UTC();
            break;
        case 1:
            C = Date.UTC(arguments[0]);
            break;
        case 2:
            C = Date.UTC(arguments[0], arguments[1]);
            break;
        case 3:
            C = Date.UTC(arguments[0], arguments[1], arguments[2]);
            break;
        case 4:
            C = Date.UTC(arguments[0], arguments[1], arguments[2], arguments[3]);
            break;
        case 5:
            C = Date.UTC(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
            break;
        case 6:
            C = Date.UTC(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
            break;
        case 7:
        default:
            C = Date.UTC(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]);
            break
    }
    return C
};
MCDate.now = function() {
    return (new Date()).getTime()
};
MCDate.clone = function(C) {
    return (new MCDate(new TimezoneOffset(C.getTimezoneOffset()), C.getTime()))
};
MCDate.toArrayDate = function(C) {
    if (MCDate.runningCPSmode) {
        return new MCDate((new TimezoneOffset(MCDate.arrayTimezoneOffset)), C)
    } else {
        return new MCDate((new TimezoneOffset(MCDate.arrayTimezoneOffset)), C + (MCDate.arrayTimezoneOffset * 60000))
    }
};
MCDate.fromArrayTimestamp = function(C) {
    return MCDate.toArrayDate(C * 1000)
};
MCDate.prototype._timezoneString = function() {
    var E;
    var C;
    var D = "GMT";
    if (this._timezoneOffset < 0) {
        D += "+";
        E = -this._timezoneOffset
    } else {
        D += "-";
        E = this._timezoneOffset
    }
    D += ((new Number(100 + Math.floor(E / 60))).toString()).substring(1);
    D += ((new Number(100 + (E % 60))).toString()).substring(1);
    return D
};
MCDate.stringToTimezoneOffset = function(E) {
    var D = E.match(/(GMT)([+-]*)(\d{2})(\d{2})/);
    if (D.length < 5) {
        return 0
    }
    var C = (D[3] * 60 + D[4] * 1);
    if (D[2] == "+") {
        C = -C
    }
    return C
};
MCDate.stringToEpoch = function(D) {
    var C = D.match(/(\d{4,4})-(\d{2,2})-(\d{2,2}) (\d{2,2}):(\d{2,2}):(\d{2,2})/);
    var E = new Date();
    E.setUTCFullYear(parseInt(C[1], 10));
    E.setUTCMonth(parseInt(C[2], 10) - 1);
    E.setUTCDate(parseInt(C[3], 10));
    E.setUTCHours(parseInt(C[4], 10));
    E.setUTCMinutes(parseInt(C[5], 10));
    E.setUTCSeconds(parseInt(C[6], 10));
    E.setUTCMilliseconds(0);
    return (E.getTime())
};
MCDate.getDate = function(D, E) {
    var C = new MCDate();
    if (D) {
        dateData = D.split("-");
        if (dateData.length == 3) {
            C.setFullYear(dateData[0], dateData[1] - 1, dateData[2])
        }
    }
    if (E) {
        timeData = E.split(":");
        if (timeData.length == 2) {
            C.setHours(timeData[0], timeData[1], 0)
        } else {
            if (timeData.length == 3) {
                C.setHours(timeData[0], timeData[1], timeData[2])
            }
        }
    }
    return C
};
TimezoneOffset = function(C) {
    if (typeof C === "string") {
        this._minutes = -TimezoneOffset.stringToMinutes(C)
    } else {
        if (typeof C === "number") {
            this._minutes = C
        } else {
            this._minutes = (new Date).getTimezoneOffset()
        }
    }
    if ((isNaN(this._minutes)) || (this._minutes > (14 * 60)) || (this._minutes < (-14 * 60))) {
        this._minutes = 0
    }
};
TimezoneOffset.stringToMinutes = function(E) {
    var D = 0;
    var C = E.match(/([+-]*)(\d{1,2}):(\d{1,2})/);
    if (C) {
        D = (parseInt(C[2], 10) * 60 + parseInt(C[3], 10));
        if (C[1] === "-") {
            D *= -1
        } else {
            if (C[1] != "+") {
                D = undefined
            }
        }
    }
    return D
};
MCDate.compareDates = function(R, D, P) {
    var O = new Date(D.getTime() + ((D.getTimezoneOffset() - R.getTimezoneOffset()) * 60000));
    var G = "";
    var J;
    var F;
    var L = R.toUTCString();
    var K = R.toString();
    var I = R.getTimezoneOffset();
    var E = D.toUTCString();
    var N = D.toString();
    var H = D.getTimezoneOffset();
    var M = O.toUTCString();
    var Q = O.toString();
    var C = O.getTimezoneOffset();
    mcval = R.getDay();
    dval = O.getDay();
    if (mcval != dval) {
        G += ("Case " + P + "a, ")
    }
    if (R.getUTCDay() != D.getUTCDay()) {
        G += ("Case " + P + "b, ")
    }
    if (R.getFullYear() != O.getFullYear()) {
        G += ("Case " + P + "c, ")
    }
    if (R.getUTCFullYear() != D.getUTCFullYear()) {
        G += ("Case " + P + "d, ")
    }
    if (R.getHours() != O.getHours()) {
        G += ("Case " + P + "e, ")
    }
    if (R.getUTCHours() != D.getUTCHours()) {
        G += ("Case " + P + "f, ")
    }
    if (R.getMilliseconds() != O.getMilliseconds()) {
        G += ("Case " + P + "g, ")
    }
    if (R.getUTCMilliseconds() != D.getUTCMilliseconds()) {
        G += ("Case " + P + "h, ")
    }
    if (R.getMinutes() != O.getMinutes()) {
        G += ("Case " + P + "i, ")
    }
    if (R.getUTCMinutes() != D.getUTCMinutes()) {
        G += ("Case " + P + "j, ")
    }
    if (R.getMonth() != O.getMonth()) {
        G += ("Case " + P + "k, ")
    }
    if (R.getUTCMonth() != D.getUTCMonth()) {
        G += ("Case " + P + "m, ")
    }
    if (R.getSeconds() != O.getSeconds()) {
        G += ("Case " + P + "n, ")
    }
    if (R.getUTCSeconds() != D.getUTCSeconds()) {
        G += ("Case " + P + "o, ")
    }
    if (R.getTime() != D.getTime()) {
        G += ("Case " + P + "p, ")
    }
    J = R.toDateString();
    F = O.toDateString();
    if (J != F) {
        G += ("Case " + P + "q, ")
    }
    J = R.toUTCString();
    F = D.toUTCString();
    if (J != F) {
        G += ("Case " + P + "r, ")
    }
    J = R.toISOString();
    F = D.toISOString();
    if (J != F) {
        G += ("Case " + P + "s, ")
    }
    J = R.toJSON();
    F = D.toJSON();
    if (J != F) {
        G += ("Case " + P + "t, ")
    }
    J = R.toString();
    F = O.toString();
    if (R.getTimezoneOffset() != MCDate.stringToTimezoneOffset(J)) {
        G += ("Case " + P + "u1, ")
    }
    if (J.substring(0, J.indexOf(" GMT")) != F.substring(0, F.indexOf(" GMT"))) {
        G += ("Case " + P + "u2, ")
    }
    J = R.toLocaleDateString();
    F = O.toLocaleDateString();
    if (J != F) {
        G += ("Case " + P + "v, ")
    }
    J = R.toLocaleTimeString();
    F = O.toLocaleTimeString();
    if (J != F) {
        G += ("Case " + P + "w, ")
    }
    J = R.toLocaleString();
    F = O.toLocaleString();
    if (J != F) {
        G += ("Case " + P + "x, ")
    }
    J = R.toTimeString();
    F = O.toTimeString();
    if (R.getTimezoneOffset() != MCDate.stringToTimezoneOffset(J)) {
        G += ("Case " + P + "y1, ")
    }
    if (J.substring(0, J.indexOf(" GMT")) != F.substring(0, F.indexOf(" GMT"))) {
        G += ("Case " + P + "y2, ")
    }
    if (R.valueOf() != D.valueOf()) {
        G += ("Case " + P + "z, ")
    }
    return G
};

function testMCDate() {
    var F = "";
    var M = new TimezoneOffset("+01:00");
    if (M._minutes != -60) {
        F += 'TimezoneOffset Failure: <"+01:00">,'
    }
    var J = new TimezoneOffset("+04:00");
    if (J._minutes != -240) {
        F += 'TimezoneOffset Failure: <"+04:00">,'
    }
    var H = new TimezoneOffset("+04:30");
    if (H._minutes != -270) {
        F += 'TimezoneOffset Failure: <"+04:00">,'
    }
    var G = new TimezoneOffset(-6 * 60);
    if (G._minutes != -360) {
        F += "TimezoneOffset Failure: <-6*60>,"
    }
    var E = new TimezoneOffset(-8 * 60);
    if (E._minutes != -480) {
        F += "TimezoneOffset Failure: <-8*60>,"
    }
    var P = new TimezoneOffset("+x4:00");
    if (P._minutes != 0) {
        F += 'TimezoneOffset Failure: <"+x4:00">,'
    }
    P = new TimezoneOffset("+15:00");
    if (P._minutes != 0) {
        F += 'TimezoneOffset Failure: <"+15:00">,'
    }
    P = new TimezoneOffset("-14:01");
    if (P._minutes != 0) {
        F += 'TimezoneOffset Failure: <"-14:01">,'
    }
    P = new TimezoneOffset("4:00");
    if (P._minutes != 0) {
        F += 'TimezoneOffset Failure: <"4:00">,'
    }
    var I = new TimezoneOffset("-4:0");
    if (I._minutes != 240) {
        F += 'TimezoneOffset Failure: <"-4:0">,'
    }
    var D = new TimezoneOffset("-14:0");
    if (D._minutes != 840) {
        F += 'TimezoneOffset Failure: <"-14:00">,'
    }
    var O = new TimezoneOffset("+14:0");
    if (O._minutes != -840) {
        F += 'TimezoneOffset Failure: <"+14:0">,'
    }
    var C = new TimezoneOffset();
    if (C._minutes != ((new Date()).getTimezoneOffset())) {
        F += "TimezoneOffset Failure: <>,"
    }
    var Q = new TimezoneOffset(-11 * 60);
    if (Q._minutes != -660) {
        F += "TimezoneOffset Failure: <-11*60>,"
    }
    var N = new MCDate(C);
    if (N.getTimezoneOffset() != (new Date).getTimezoneOffset()) {
        F += "Case 0a, "
    }
    var L = 1;
    var K = new Date(1941, 11, 7, 13, 15, 5, 999);
    N = new MCDate(1941, 11, 7, 13, 15, 5, 999);
    if (N.getTimezoneOffset() != K.getTimezoneOffset()) {
        F += "Case 0b, "
    }
    F += MCDate.compareDates(N, K, L++);
    N = new MCDate(J, 1941, 11, 7, 13, 15, 5, 999);
    K.setTime(N.getTime());
    if (N.getTimezoneOffset() != -240) {
        F += "Case 0c, "
    }
    F += MCDate.compareDates(N, K, L++);
    K = new Date();
    N = new MCDate(K.getTime());
    F += MCDate.compareDates(N, K, L++);
    K = new Date();
    N = new MCDate(D, K.getTime());
    F += MCDate.compareDates(N, K, L++);
    K = new Date("December 21, 1941 02:17:44");
    N = new MCDate("December 21, 1941 02:17:44");
    F += MCDate.compareDates(N, K, L++);
    K = new Date("July 20, 1969 22:05:00");
    N = new MCDate(G, "July 20, 1969 22:05:00");
    K.setTime(K.getTime() + (N.getTimezoneOffset() - K.getTimezoneOffset()) * 60000);
    F += MCDate.compareDates(N, K, L++);
    K = new Date(-2010401280000);
    N = new MCDate(-2010401280000);
    F += MCDate.compareDates(N, K, L++);
    N = new MCDate(E, K.getTime());
    F += MCDate.compareDates(N, K, L++);
    K = new Date(1980, 4, 18);
    N = new MCDate(1980, 4, 18);
    if (N.getTimezoneOffset() != K.getTimezoneOffset()) {
        F += "Case 0b, "
    }
    F += MCDate.compareDates(N, K, L++);
    N = new MCDate(J, 1980, 4, 18);
    K.setTime(K.getTime() + (N.getTimezoneOffset() - K.getTimezoneOffset()) * 60000);
    if (N.getTimezoneOffset() != -240) {
        F += "Case 0c, "
    }
    F += MCDate.compareDates(N, K, L++);
    N = new MCDate("August 24, 1959");
    K = new Date("August 24, 1959");
    N.setDate(19);
    K.setDate(19);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCDate(29);
    K.setUTCDate(29);
    F += MCDate.compareDates(N, K, L++);
    N.setFullYear(1958);
    K.setFullYear(1958);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCFullYear(2022);
    K.setUTCFullYear(2022);
    F += MCDate.compareDates(N, K, L++);
    N.setHours(17);
    K.setHours(17);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCHours(21);
    K.setUTCHours(21);
    F += MCDate.compareDates(N, K, L++);
    N.setMilliseconds(989);
    K.setMilliseconds(989);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCMilliseconds(1);
    K.setUTCMilliseconds(1);
    F += MCDate.compareDates(N, K, L++);
    N.setMinutes(57);
    K.setMinutes(57);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCMinutes(43);
    K.setUTCMinutes(43);
    F += MCDate.compareDates(N, K, L++);
    N.setMonth(0);
    K.setMonth(0);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCMonth(2);
    K.setUTCMonth(2);
    F += MCDate.compareDates(N, K, L++);
    N.setSeconds(56);
    K.setSeconds(56);
    F += MCDate.compareDates(N, K, L++);
    N.setUTCSeconds(4);
    K.setUTCSeconds(4);
    F += MCDate.compareDates(N, K, L++);
    N = new MCDate(MCDate.UTC(2001, 2, 3, 4, 30));
    K.setTime(N.getTime());
    N.setTimezoneOffset(60 + 15);
    F += MCDate.compareDates(N, K, L++);
    if ((Date.now() - MCDate.now()) < -2 * 1000) {
        F += "now() test,"
    }
}
AA = function() {
    this.b = BB.sub()
};
AA.prototype = new Object();
AA.prototype.constructor = AA;
BB = function() {
    this.a = AA.sub()
};
BB.prototype = new Object();
BB.prototype.constructor = BB;
applicationLoading = true;
$.ajaxSetup({
    converters: {
        "text wbi": function(textValue) {
            var obj = null;
            try {
                obj = eval(textValue)
            } catch (e) {
                var errorObject = {
                    text: textValue,
                    exception: e
                };
                MC.errorOutput("Exception during eval of json text: %o", errorObject);
                return new APIData()
            }
            return obj
        }
    }
});
ajaxID = 0;

function getAjaxID() {
    ajaxID++;
    if (ajaxID > 999) {
        ajaxID = 1
    }
    return ajaxID
}

function timeDiff(C, H) {
    var E = C.getTime();
    var D = H.getTime();
    var L = D - E;
    var J = Math.floor(L / 3600000);
    var M = (L % 3600000);
    var G = Math.floor(M / 60000);
    M = M % 60000;
    var K = Math.floor(M / 1000);
    var F = L % 1000;
    var I = "" + leadingZeros(J, 2) + ":" + leadingZeros(G, 2) + ":" + leadingZeros(K, 2) + "." + leadingZeros(F, 3);
    return I
}

function indentString(E) {
    var D = "";
    for (var C = 0; C < E; C++) {
        D += " "
    }
    return D
}

function dynamicCSS(D) {
    var C = $("<link>");
    C.attr({
        type: "text/css",
        rel: "stylesheet",
        media: "screen",
        href: D
    });
    var E = $("head").get(0);
    $(E).append(C)
}

function namedFormat(E, D) {
    var C = null;
    if (E != undefined) {
        C = E.replace(/{(\w+)}/g, function(G, F) {
            var H = D[F];
            if (H != undefined) {
                return H
            } else {
                return F
            }
        })
    }
    return C
}

function checkforconsole() {
    if (typeof console != "undefined") {
        if (typeof console.log != "undefined") {
            return true
        }
    }
    return false
}

function getConsoleInfo() {
    var D = detectBrowser();
    var C = {
        hasLog: false,
        hasDebug: false,
        hasInfo: false,
        hasWarning: false,
        hasError: false,
        hasPrintf: false
    };
    if (!window.console) {
        return C
    }
    if (window.console.log) {
        C.hasLog = true
    }
    if (window.console.debug) {
        C.hasDebug = true
    }
    if (window.console.info) {
        C.hasInfo = true
    }
    if (window.console.warn) {
        C.hasWarn = true
    }
    if (window.console.error) {
        C.hasError = true
    }
    if (D.mozilla) {
        C.hasPrintf = true
    }
    return C
}
DHSObject = function() {};
DHSObject.prototype.__timeStamp = function() {
    var D = new Date();
    var C = this.lastDate;
    this.lastDate = D;
    if (!C) {
        C = D
    }
    return sprintf("%02d:%02d:%02d.%03d {%d}", D.getHours(), D.getMinutes(), D.getSeconds(), D.getMilliseconds(), (D.getTime() - C.getTime()))
};
DHSObject.prototype.debugOutput = function() {
    if (!MCDEBUG_ENABLED) {
        return
    }
    var C = getConsoleInfo();
    if ((!C.hasDebug && !C.hasLog) || !arguments[0]) {
        return
    }
    arguments[0] = DHSObject.prototype.__timeStamp() + ": " + arguments[0];
    if (C.hasDebug) {
        if (C.hasPrintf) {
            console.debug.apply(console, Array.prototype.slice.call(arguments))
        } else {
            console.debug(sprintf(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]))
        }
    } else {
        if (C.hasLog) {
            if (C.hasPrintf) {
                console.log.apply(console, Array.prototype.slice.call(arguments))
            } else {
                console.log(sprintf(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]))
            }
        }
    }
};
DHSObject.prototype.infoOutput = function() {
    if (!MCDEBUG_ENABLED) {
        return
    }
    var C = getConsoleInfo();
    if (!C.hasInfo || !arguments[0]) {
        return
    }
    arguments[0] = DHSObject.prototype.__timeStamp() + ": " + arguments[0];
    if (C.hasPrintf) {
        console.info.apply(console, Array.prototype.slice.call(arguments))
    } else {
        console.info(sprintf(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]))
    }
};
DHSObject.prototype.warningOutput = function() {
    if (!MCDEBUG_ENABLED) {
        return
    }
    var C = getConsoleInfo();
    if (!C.hasWarn || !arguments[0]) {
        return
    }
    arguments[0] = DHSObject.prototype.__timeStamp() + ": " + arguments[0];
    if (C.hasPrintf) {
        console.warn.apply(console, Array.prototype.slice.call(arguments))
    } else {
        console.warn(sprintf(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]))
    }
};
DHSObject.prototype.errorOutput = function() {
    var C = getConsoleInfo();
    if (!C.hasError || !arguments[0]) {
        return
    }
    arguments[0] = DHSObject.prototype.__timeStamp() + ": " + arguments[0];
    if (C.hasPrintf) {
        console.error.apply(console, Array.prototype.slice.call(arguments))
    } else {
        console.error(sprintf(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8]))
    }
};

function mcDebug() {
    if (!MCDEBUG_ENABLED) {
        return
    }
    if (arguments.length < 2 || !arguments[0] || !mcDebugs[arguments[0]]) {
        return
    }
    var C = arguments[0];
    if (!C || !mcDebugs[C]) {
        return
    }
    var G = mcDebugs[C];
    var E = 1;
    if (arguments[1] instanceof APIObject) {
        var I = arguments[1];
        E = 2
    }
    if (arguments.length < 3 || (typeof arguments[E]) != "string") {
        return
    }
    var F = false;
    if (G === true) {
        F = true
    } else {
        if (I && (I.hasName(G) || I.basetype == G)) {
            F = true
        }
    }
    if (!F) {
        return
    }
    if (I) {
        var H = C + "[" + G + ":" + I.getName() + "]: " + arguments[E]
    } else {
        var H = C + "[" + G + "]: " + arguments[E]
    }
    var D = Array.prototype.slice.call(arguments);
    D = D.slice(E + 1);
    D.unshift(H);
    MC.warningOutput.apply(MC, D)
}

function Connection() {
    this.securityTS = new Date();
    this.linkTS = this.securityTS;
    this.systemTS = this.securityTS;
    this.securityState = this._UNKNOWN;
    this.linkState = this._CONNECTED;
    this.systemState = this._SYSUP;
    this.linkConnected = false;
    this.indicatorState = "none"
}
Connection.prototype._UNKNOWN = "UNKNOWN";
Connection.prototype._AUTHENTICATING = "AUTHENTICATING";
Connection.prototype._UNAUTHORIZED = "UNAUTHORIZED";
Connection.prototype._AUTHORIZED = "AUTHORIZED";
Connection.prototype._CONNECTED = "CONNECTED";
Connection.prototype._DISCONNECTED = "DISCONNECTED";
Connection.prototype._SYSUP = "SYSUP";
Connection.prototype._SYSDOWN = "SYSDOWN";
Connection.prototype._outputStateChange = function(F, H, E, G) {
    var D = new Date();
    var C = (D.getTime() - H.getTime()) / 1000;
    MC.debugOutput("CONNECTION (" + F + ") - from " + E + " to " + G + " interval: " + C);
    return D
};
Connection.prototype._changeSecurityState = function(C) {
    this.securityTS = this._outputStateChange("security", this.securityTS, this.securityState, C);
    this.securityState = C
};
Connection.prototype._changeLinkState = function(C) {
    this.linkTS = this._outputStateChange("link", this.linkTS, this.linkState, C);
    this.linkState = C
};
Connection.prototype._changeSystemState = function(C) {
    this.systemTS = this._outputStateChange("system", this.systemTS, this.systemState, C);
    this.systemState = C
};
Connection.prototype.authenticating = function() {
    this._changeSecurityState(this._AUTHENTICATING)
};
Connection.prototype.unauthorized = function() {
    this._changeSecurityState(this._UNAUTHORIZED)
};
Connection.prototype.authorized = function() {
    this._changeSecurityState(this._AUTHORIZED)
};
Connection.prototype.connected = function() {
    if (this.linkConnected) {
        return
    }
    this._changeLinkState(this._CONNECTED);
    this.linkConnected = true;
    setTimeout(CommunicationFoundHandling, 100);
    this.displayConnection()
};
Connection.prototype.disconnected = function() {
    if (!this.linkConnected) {
        return
    }
    this._changeLinkState(this._DISCONNECTED);
    this.linkConnected = false;
    setTimeout(CommunicationLostHandling, 100);
    this.displayConnection()
};
Connection.prototype.sysdown = function() {
    if (typeof this.systemUp != "undefined" && !this.systemUp) {
        return
    }
    this._changeSystemState(this._SYSDOWN);
    this.systemUp = false;
    setTimeout(CommunicationSysDownHandling, 100);
    this.displayConnection()
};
Connection.prototype.sysup = function() {
    if (typeof this.systemUp != "undefined" && this.systemUp) {
        return
    }
    this._changeSystemState(this._SYSUP);
    this.systemUp = true;
    setTimeout(CommunicationSysUpHandling, 100);
    this.displayConnection()
};
Connection.prototype.getSecurityState = function() {
    return this.securityState
};
Connection.prototype.getLinkState = function() {
    return this.linkState
};
Connection.prototype.getSystemState = function() {
    return this.systemState
};
Connection.prototype.displayConnection = function() {
    if (!this.indicator$) {
        this.indicator$ = $(".linkState");
        if (this.indicator$.length == 0) {
            this.indicator$ = null
        }
    }
    if (!this.indicator$) {
        return
    }
    if (settings.memorex && !settings.emulator) {
        var C = "linkMEM" + this.systemState
    } else {
        var C = "link" + this.linkState + this.systemState
    }
    if (C == "linkCONNECTEDSYSUP") {
        if (RB.indicatorisOn) {
            C = C + "TRAFFIC"
        }
    }
    if (this.indicatorState != C) {
        this.indicator$.removeClass(this.indicatorState);
        this.indicator$.addClass(C);
        this.indicatorState = C
    }
};
connection = new Connection();
RequestObject = function(C) {
    this.class_name = "RequestObject";
    C = C || {};
    this.url = C.url || "";
    this.dataType = C.dataType || "wbi";
    this.xmlToJson = ((C.xmlToJson != undefined) ? C.xmlToJson : true);
    this.httpReqType = C.httpReqType || "POST";
    this.payload = C.payload || "";
    this.handler = C.handler || null;
    this.dataset = C.dataset || null;
    this.callback = C.callback || null;
    this.successHandler = createObjectCallback(this, this.__successHandler);
    this.errorHandler = createObjectCallback(this, this.__errorHandler);
    this.beforeSendCallback = createObjectCallback(this, this.__beforeSend);
    this.req_state = "PREPARING";
    this.submit_time = new Date();
    this.start_time = 0;
    this.request_object = null;
    for (var D in C) {
        if (this[D] == undefined) {
            this[D] = C[D]
        }
    }
};
RequestObject.prototype = new DHSObject();
RequestObject.prototype.constructor = RequestObject;
RequestObject.prototype.__debugRequestDetails = function() {
    console.log("--URL: %s", this.url);
    console.log("--Data Type: %s", this.dataType);
    console.log("--HTTP Request Type: %s", this.httpReqType);
    console.log("--Payload: %o", this.payload);
    console.log("--Handler: %o", this.handler);
    console.log("--Callback: %o", this.callback);
    console.log("--Time since submitted (sec): %d", (new Date().getTime() - this.submit_time.getTime()) / 1000);
    console.log("--Request in Flight: %s", this.req_state);
    if (this.start_time != 0) {
        console.log("--Request in Flight Time (sec): %d", (new Date().getTime() - this.start_time.getTime()) / 1000)
    }
};
RequestObject.prototype.makeRequest = function() {
    if (this.req_state == "IN-FLIGHT") {
        mcDebug("ajax", "RequestObject[%s]: already in-flight for: %s", this.ajaxID, this.getCmd());
        return
    }
    this.req_state = "IN-FLIGHT";
    this.start_time = new Date();
    var C = this;
    this.ajaxID = getAjaxID();
    mcDebug("ajax", "RequestObject[%s]: initiating new request: %s", this.ajaxID, this.getCmd());
    this.request_object = $.ajax({
        type: this.httpReqType,
        url: this.url,
        data: this.payload,
        cache: false,
        dataType: this.dataType,
        ajaxID: this.ajaxID,
        success: this.successHandler,
        error: this.errorHandler,
        beforeSend: this.beforeSendCallback,
        jsonp: false
    })
};
RequestObject.prototype.__beforeSend = function(C) {
    if ((typeof(session) != "undefined") && (session.getSessionKey())) {
        C.setRequestHeader("sessionkey", session.getSessionKey())
    }
    C.setRequestHeader("datatype", this.dataType);
    C.setRequestHeader("ajaxid", this.ajaxID);
    if (this.payload.indexOf("api/login") != -1) {
        C.setRequestHeader("Authorization", "Basic " + session.base64Value);
        C.setRequestHeader("legacy-username", session.pendingUser)
    }
};
RequestObject.prototype.__successHandler = function(D, F, E) {
    var C = E.ajaxID || "NoID";
    this.req_state = "COMPLETE";
    this.end_time = new Date();
    this.textStatus = F;
    mcDebug("ajax", "RequestObject[%s]: %s request completed for [%s]: textStatus: %s, time: %s, xhr: %o, data: %o", this.ajaxID, this.getCmd(), C, F, timeDiff(this.start_time, this.end_time), E, D);
    if (D && this.dataType == "xml" && this.xmlToJson) {
        D = new APIData(D)
    }
    if (this.handler) {
        this.handler(D, this, F)
    } else {
        MC.errorOutput("RequestObject[%s]: ajax request completed: %s, but no valid handler present!", this.ajaxID, this.getCmd())
    }
};
RequestObject.prototype.__errorHandler = function(D, E, C) {
    if (!D) {
        MC.errorOutput("No xhr for %s", this.getCmd())
    }
    if (D.aborting) {
        MC.warningOutput("RequestObject.errorHandler called while aborting [%s]: %s, xhr: %o", D.ajaxID, this.getCmd(), D);
        return
    }
    this.req_state = "COMPLETE";
    this.end_time = new Date();
    this.textStatus = E;
    MC.warningOutput("RequestObject[%s]: %s request failed for [%s]: textStatus: %s, time: %s, xhr: %o, exception: %o", this.ajaxID, this.getCmd(), D.ajaxID, E, timeDiff(this.start_time, this.end_time), D, C);
    if (this.handler) {
        this.handler(null, this, E)
    }
};
RequestObject.prototype.abort = function() {
    if (this.request_object) {
        this.handler = null;
        this.request_object.abort();
        this.req_state = "ABORTED"
    }
};
RequestObject.prototype.getCmd = function() {
    if (this.url == "/api/") {
        var C = this.payload.substr(0, 40);
        if (C != this.payload) {
            C += "..."
        }
        return C
    }
    return this.url
};

function createObjectCallback(E, D) {
    var C = Array.prototype.slice.call(arguments).slice(2);
    return function() {
        var F = Array.prototype.slice.call(arguments);
        var G = C.concat(F);
        return D.apply(E, G)
    }
}
RequestBroker = function() {
    this.class_name = "RequestBroker";
    this.requests = [];
    this.queuedRequests = [];
    this.maxConcurrent = 1;
    this.requestsCount = 0
};
RequestBroker.prototype = new DHSObject();
RequestBroker.prototype.constructor = RequestBroker;
RequestBroker.prototype.abortAll = function() {
    this.queuedRequests = [];
    var E = this.requests.length;
    for (var C = 0; C < E; C++) {
        var D = this.requests[C];
        if (D) {
            MC.warningOutput("ABORT: " + D.getCmd());
            D.abort()
        }
    }
    this.requests = [];
    this.requestsCount = 0;
    clearInterval(this.monitorInterval);
    this.indicatorOff()
};
RequestBroker.prototype.abort = function(E) {
    var D = this.requests.length;
    for (var C = 0; C < D; C++) {
        if (E == this.requests[C]) {
            found = true;
            MC.warningOutput("ABORT: " + E.getCmd());
            E.abort();
            this.requestsCount--;
            if (this.requestsCount == 0) {
                clearInterval(this.monitorInterval);
                this.indicatorOff()
            }
            return
        }
    }
    D = this.queuedRequests.length;
    for (var C = 0; C < D; C++) {
        if (this.queuedRequests[C] == E) {}
    }
    while (this.queuedRequests.length > 0 && this.requests.length < this.maxConcurrent) {
        this.requests = []
    }
    this.indicatorOff()
};
RequestBroker.prototype.__requestsUp = function() {
    if (this.requestsCount == 0) {
        this.monitorInterval = setInterval(createObjectCallback(this, this.__monitor), 10 * SECOND)
    }
    this.requestsCount++;
    this.indicatorOn()
};
RequestBroker.prototype.__requestsDown = function() {
    this.requestsCount--;
    if (this.requestsCount == 0) {
        clearInterval(this.monitorInterval);
        this.indicatorOff()
    }
};
RequestBroker.prototype.__monitor = function() {
    for (var D = 0; D < this.requests.length; D++) {
        var E = this.requests[D];
        var F = E.getCmd();
        var C = (new Date().getTime() - E.start_time.getTime()) / 1000;
        if (E) {
            mcDebug("ajax", "Request " + D + ": " + F + ", readyState: " + (E.request_object ? E.request_object.readyState : "NO REQUEST_OBJECT") + " time: " + C + " secs")
        }
    }
};
RequestBroker.prototype.__addRequest = function(C) {
    RL.addRequest(C);
    this.requests.push(C);
    this.__requestsUp()
};
RequestBroker.prototype.__removeRequest = function(C) {
    if (this.requests.remove(C)) {
        this.__requestsDown()
    }
    this.__processQueue()
};
RequestBroker.prototype.__processQueue = function() {
    while (this.queuedRequests.length > 0 && this.requests.length < this.maxConcurrent) {
        this._processRequest(this.queuedRequests.shift())
    }
};
RequestBroker.prototype.__handleResponse = function(F, D, H) {
    var C = ((D.request_object && D.request_object.status != undefined) ? D.request_object.status : 0);
    if (!(C == 200 || (MC.memorex && C == 0)) || (!F && H == "parsererror")) {
        MC.warningOutput("RB::handleResponse: " + D.getCmd() + " status=" + C + " textStatus=" + H);
        if (C == 0) {
            connection.disconnected();
            F = undefined
        } else {
            if (C == 403 && !settings.memorex) {
                session.logout(logoutComplete)
            } else {
                if (C == 401 && !settings.memorex) {
                    session.logout(logoutComplete)
                } else {
                    if (D.retries > 0) {
                        D.tried++;
                        MC.warningOutput("RB::handleResponse: re-issuing (" + D.tried + ") request: ", D);
                        if (settings.memorex) {
                            var G = D.dataset;
                            if (MC[G].secondMemorexFile) {
                                D.url = "data/" + settings.memorex + "/" + MC[G].secondMemorexFile + ".json"
                            }
                        }
                        D.makeRequest();
                        D.retries--;
                        return
                    } else {
                        MC.errorOutput("RB: Response for " + D.getCmd() + " failed, after " + D.tried + " attempts");
                        F = undefined
                    }
                }
            }
        }
    } else {
        var E = D.getCmd();
        if (settings.testwbi) {
            E = "/api/meta/wbi"
        }
        mcDebug("ajax", "RB::handleResponse: " + E + " status=" + C + " textStatus=" + H);
        if (E.indexOf("meta/wbi") == -1 && F && F.statusObject && parseInt(F.statusObject.get("response_type_numeric")) != 0) {
            MC.errorOutput("Error in json response data: %d : %s: command %s", F.statusObject.get("return_code"), F.statusObject.get("response"), E);
            switch (parseInt(F.statusObject.get("return_code"))) {
                case -10027:
                    if (session) {
                        session.lostAuthorization()
                    }
                    break;
                default:
                    break
            }
        }
    }
    this.__removeRequest(D);
    if (D.callback) {
        D.callback(F, D)
    }
};
RequestBroker.prototype.makeRequest = function(D) {
    D = D || {};
    D.tried = 1;
    D.handler = createObjectCallback(this, this.__handleResponse);
    var C = new RequestObject(D);
    if (this.requests.length >= this.maxConcurrent) {
        this.queuedRequests.push(C);
        mcDebug("ajax", "RB: Queued request %s, current: %d, queued: %d", C.getCmd(), this.requests.length, this.queuedRequests.length)
    } else {
        this._processRequest(C)
    }
    return C
};
RequestBroker.prototype._processRequest = function(D) {
    if (D.sending && $.isFunction(D.sending)) {
        if (D.sending(D) === false) {
            MC.infoOutput("RB: Cancelled request %s.", D.getCmd());
            return
        }
    }
    this.__addRequest(D);
    D.makeRequest();
    mcDebug("ajax", "RB: Processing request %s, current: %d, queued: %d", D.getCmd(), this.requests.length, this.queuedRequests.length);
    if (applicationLoading && D.dataset && !settings.externalUI) {
        var C = strings.datasets[D.dataset] || D.dataset;
        ApplicationLoadingMessage(strings.setLoading(C))
    }
};
RequestBroker.prototype.showRequests = function() {
    if (checkforconsole()) {
        console.info("------------- REQUEST BROKER REQUEST TRACE ----------------");
        console.info("Current requests (" + this.requests.length + "):");
        for (var C = 0; C < this.requests.length; C++) {
            console.log("%d ------", C);
            this.requests[C].__debugRequestDetails()
        }
        console.info("Queued requests (" + this.queuedRequests.length + "):");
        for (var C = 0; C < this.queuedRequests.length; C++) {
            console.log("%d ------", C);
            this.queuedRequests[C].__debugRequestDetails()
        }
        console.info("------------ /REQUEST BROKER REQUEST TRACE ----------------")
    }
};
RequestBroker.prototype.getRequestCount = function() {
    return this.requestsCount
};
RequestBroker.prototype.indicatorOn = function() {
    if (this.indicatorisOn) {
        return
    }
    this.indicatorisOn = true;
    connection.displayConnection()
};
RequestBroker.prototype.indicatorOff = function() {
    if (!this.indicatorisOn) {
        return
    }
    this.indicatorisOn = false;
    connection.displayConnection()
};
var RB = new RequestBroker();
RequestLog = function() {
    this.__maxRequests = 100;
    this.requests = new Array
};
RequestLog.prototype = new DHSObject();
RequestLog.prototype.constructor = RequestLog;
RequestLog.prototype.addRequest = function(C) {
    if (this.requests.length < this.__maxRequests) {
        this.requests.push(C)
    } else {
        this.requests.shift();
        this.requests.push(C)
    }
};
RequestLog.prototype.showLog = function(C) {
    var C = C || 10;
    if (C > this.__maxRequests) {
        C = this.__maxRequests
    }
    if (C > this.requests.length) {
        C = this.requests.length
    }
    if (checkforconsole()) {
        console.info("------------- REQUEST OBJECT LOG ----------------");
        var E = this.requests.length - C;
        for (var D = E; D < this.requests.length; D++) {
            console.log("--> %o", this.requests[D])
        }
        console.info("------------- /REQUEST OBJECT LOG ----------------")
    }
};
var RL = new RequestLog();

function help() {
    if (checkforconsole()) {
        console.log("------------- SHELL HELP ----------------\n    Available Commands:\n        RB.showRequests()                     - show currently active/queued ajax requests\n        RL.showLog(n)                         - show last n ajax requests.\n        MC.showInfo()                         - show status of all DataSets\n        MC.<dataset>.showInfo()               - show status of a DataSet\n        BC.on() | BC.off()                    - start/stop the BackChannel requests\n        reloader.on() | reloader.off()        - start/stop the DataSet reloader\n        reloader.logOn() | reloader.logOff()  - start/stop verbose Reloader logging\n        debugOn('flag')                       - turn on verbose logging for flag\n        debugOn('flag', 'value')              - turn on logging for flag when logged object matches value\n        debugOff('flag')                      - turn off verbose logging for flag\n        debugList()                           - list all defined verbose debug logging flags\n        startall() | stopall()                - start/stop all background I/O activity\n------------ /SHELL HELP ----------------\n")
    }
}

function startall() {
    BC.on();
    reloader.on()
}

function stopall() {
    reloader.off();
    BC.off()
}

function debugOn(C, D) {
    if (!MCDEBUG_ENABLED) {
        MCDEBUG_ENABLED = true
    }
    if (mcDebugs[C] != undefined) {
        mcDebugs[C] = D || true;
        return "Debug enabled for " + C + (D ? ": " + D : "")
    }
    return "Debug flag " + C + " not found."
}

function debugOff(C) {
    if (mcDebugs[C] != undefined) {
        mcDebugs[C] = false;
        return "Debug disabled for " + C
    }
    return "Debug flag " + C + " not found."
}

function debugList() {
    for (var C in mcDebugs) {
        console.log("    " + C + ": " + mcDebugs[C] + " - " + mcDebugDescription[C])
    }
}

function ResponseSet(C) {
    if (arguments.length == 0) {
        return
    }
    this.class_name = "ResponseSet";
    this.name = C.name;
    this.dataType = ((C.dataType) ? C.dataType : "wbi");
    this.data = null;
    this.responseData = null;
    this.url = C.url;
    this.httpReqType = ((C.httpReqType) ? C.httpReqType : "GET");
    this.postData = ((C.postData) ? C.postData : "");
    this.dataInProcess = false;
    this.dataValid = false;
    this.dataChanged = false;
    this.handlers = new Array();
    this.subscriptionsCount = 0;
    this.registrationSequence = 0;
    this.classification = "idle"
}
ResponseSet.prototype = new DHSObject();
ResponseSet.prototype.constructor = ResponseSet;
ResponseSet.prototype.getName = function() {
    return this.name
};
ResponseSet.prototype.isDataValid = function() {
    return this.dataValid
};
ResponseSet.prototype.isDataInProcess = function() {
    return this.dataInProcess
};
ResponseSet.prototype.requestData = function(F) {
    var D = {
        classification: "foreground",
        requestor: "anonymous"
    };
    F = F || {};
    $.extend(D, F);
    if (!this.dataValid) {
        if (D.force || this.loadOrder == undefined || this.loadOrder == MCObject.NOLOAD) {
            D.update = true
        } else {
            D.update = false
        }
    } else {
        if (this.access.method == DataSet.METHOD.BACKCHANNEL && !D.force) {
            D.update = false
        }
    }
    MC.infoOutput("Request for %s from %s", this.name, D.requestor);
    var E = (D.update || D.durable || (!this.dataValid) || this.dataInProcess) ? this.__register(D) : null;
    if (D.update || F.update) {
        var C = this.classification;
        this.classification = (this.classification == "foreground") ? this.classification : D.classification;
        if (C == "foreground" && this.classification != "foreground") {
            MC.errorOutput("" + this.name + " classification was: " + C + " now: " + this.classification)
        }
        this.__makeDataRequest()
    } else {
        if (this.dataValid && (!this.dataInProcess)) {
            if (E) {
                E.handler(this);
                E.unconditional = false
            } else {
                if (D.handler && $.isFunction(D.handler)) {
                    D.handler(this)
                }
            }
        } else {}
    }
    return (E) ? E.name : null
};
ResponseSet.prototype.__shouldNotify = function(D, E) {
    var C = false;
    if (D.unconditional || (E && ((this.classification == "foreground") || D.durable == "all"))) {
        C = true
    } else {
        if (D.durable == true && this.access.method == DataSet.METHOD.BACKCHANNEL) {
            if (this.commandInProcess) {
                C = true
            } else {
                if (D.waitingForDelta) {
                    C = true
                }
            }
        }
    }
    if (C && D.waitingForDelta) {
        delete D.waitingForDelta
    }
    return C
};
ResponseSet.prototype.pendingNotification = function(E) {
    if (!E) {
        return false
    }
    if (!this.dataInProcess) {
        return false
    }
    if (this.subscriptionsCount) {
        var D = this.handlers.length;
        for (var C = 0; C < D; C++) {
            if (this.handlers[C] && this.handlers[C].name == E) {
                if (this.__shouldNotify(this.handlers[C], true)) {
                    return true
                }
                return false
            }
        }
    }
    return false
};
ResponseSet.prototype.__register = function(C) {
    if (C.handler && $.isFunction(C.handler)) {
        var F = {
            name: (this.name + this.registrationSequence++),
            requestor: C.requestor,
            handler: C.handler,
            durable: ((C.durable) ? C.durable : false),
            unconditional: true
        };
        var E = this.handlers.length;
        for (var D = 0; D < E; D++) {
            if (this.handlers[D] == null) {
                this.handlers[D] = F;
                this.subscriptionsCount++;
                return F
            }
        }
        this.handlers[E] = F;
        this.subscriptionsCount++;
        return F
    }
    return null
};
ResponseSet.prototype.unregister = function(E) {
    if (E) {
        var D = this.handlers.length;
        for (var C = 0; C < D; C++) {
            if ((this.handlers[C] != null) && (this.handlers[C].name == E)) {
                this.handlers[C] = null;
                this.subscriptionsCount--;
                return
            }
        }
    }
};
ResponseSet.prototype.notify = function() {
    if ((this instanceof DataSet) && this.preNotifyHandler) {
        this.preNotifyHandler()
    }
    var C = this.handlers.concat();
    var E = C.length;
    for (var D = 0; D < E; D++) {
        if (C[D] != null) {
            var F = C[D];
            if (this.__shouldNotify(F, this.dataChanged)) {
                try {
                    F.handler(this)
                } catch (G) {
                    MC.errorOutput("Exception %o in response set handler %s from requester: %s, error: %s, message: %s", G, F.name, (F.requestor ? F.requestor : "unknown"), G.name, G.message)
                }
                F.unconditional = false
            } else {}
            if (!F.durable) {
                this.unregister(F.name)
            }
        }
    }
};
ResponseSet.prototype.__responseReceived = function(D, C) {
    if (C.textStatus == "error" || !D) {
        this.dataInProcess = false
    } else {
        this.dataChanged = true;
        this.responseData = D;
        this.dataInProcess = false;
        this.__handleDataResponse()
    }
};
ResponseSet.prototype.__handleDataResponse = function() {
    mcDebug("ajax", "Refreshing data for non-DataSet ResponseSet: %s", this.name);
    this.data = this.responseData;
    delete this.responseData;
    this.dataValid = true;
    this.notify();
    this.classification = "idle"
};
ResponseSet.prototype.simulateCompletion = function() {
    if (!this.dataValid) {
        return
    }
    this.classification = "background";
    this.__handleDataResponse()
};
ResponseSet.prototype.__makeDataRequest = function() {
    if (this.dataInProcess) {
        return
    }
    this.dataChanged = false;
    this.dataInProcess = true;
    RB.makeRequest({
        url: this.url,
        httpReqType: this.httpReqType,
        payload: this.postData,
        dataType: this.dataType,
        callback: createObjectCallback(this, this.__responseReceived),
        dataset: ((this instanceof DataSet) ? this.name : null),
        retries: 5
    })
};
ResponseSet.prototype.SubscriptionsInfo = function(C) {
    var D = "";
    if (this.subscriptionsCount == 0) {
        return D
    }
    if (C) {
        D += "                     subscriber                     handle              durable unconditional\n";
        D += "                     ------------------------------ ------------------- ------- -------------\n"
    }
    for (var E = 0; E < this.handlers.length; E++) {
        if (this.handlers[E] != null) {
            var F = this.handlers[E];
            D += sprintf("                     %-30s %-20s %-6s %s\n", F.requestor, F.name, (typeof F.durable == "string") ? F.durable : (F.durable) ? "true" : "false", (F.unconditional) ? "true" : "false")
        }
    }
    D += " \n";
    return D
};
ResponseSet.prototype.showSubscriptionsInfo = function() {
    if (checkforconsole()) {
        console.log(this.SubscriptionsInfo(true))
    }
};

function DataSet(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.memorexFile != undefined) {
        if (settings.memorex) {
            C.url = "data/" + settings.memorex + "/" + C.memorexFile + ".json"
        } else {
            if (settings.testwbi) {
                C.url = settings.testData + "/" + C.memorexFile + ".js"
            }
        }
    }
    if (C.memorexFile2 != undefined) {
        this.secondMemorexFile = C.memorexFile2
    }
    ResponseSet.call(this, C);
    this.class_name = "DataSet";
    this.basetypes = C.basetypes;
    this.data = null;
    this.prerequisites = C.prerequisites;
    this.access = C.access || {
        method: DataSet.METHOD.COUNTER,
        interval: 30
    };
    if (C.accessMethod != undefined) {
        this.access.method = C.accessMethod
    }
    if ((typeof C.pollInterval) == "number") {
        this.access.interval = C.pollInterval
    }
    this.preNotifyHandler = C.preNotifyHandler;
    this.loadOrder = C.loadOrder || MCObject.LATE_LOAD;
    this.setsWaiting = {}
}
DataSet.prototype = new ResponseSet();
DataSet.prototype.constructor = DataSet;
DataSet.METHOD = {
    BACKCHANNEL: 1,
    COUNTER: 2,
    POLL: 3,
    ONDEMAND: 4
};
DataSet.prototype.getData = function() {
    return this.data
};
DataSet.prototype._pollForData = function() {
    this.requestData({
        update: true,
        durable: false,
        classification: "background",
        requestor: "POLL"
    })
};
DataSet.prototype.__makeDataRequest = function() {
    ResponseSet.prototype.__makeDataRequest.call(this)
};
DataSet.prototype.__handleDataResponse = function() {
    this.lastLoaded = new Date();
    this.__processNewData()
};
DataSet.prototype.setCommandActive = function() {
    this.commandInProcess = true;
    if (this.access.method == DataSet.METHOD.BACKCHANNEL) {
        for (var C = 0; C < this.handlers.length; C++) {
            if (this.handlers[C]) {
                this.handlers[C].waitingForDelta = true
            }
        }
    }
};
DataSet.prototype.setCommandComplete = function() {
    delete this.commandInProcess
};
DataSet.prototype.changeAccess = function(D, C) {
    if (D != DataSet.METHOD.BACKCHANNEL && D != DataSet.METHOD.COUNTER && D != DataSet.METHOD.POLL && D != DataSet.METHOD.ONDEMAND) {
        MC.errorOutput("DataSet.changeAccess: invalid accessMethod: " + D);
        return
    }
    var F = this.access.method;
    var E = false;
    if (D != this.access.method) {
        this.access.method = D;
        E = true
    }
    if (C != undefined && (typeof C) == "number") {
        if (!this.access.interval || C != this.access.interval) {
            if (this.access.interval < 5) {
                this.access.interval = 5
            }
            if (this.access.interval > 300) {
                this.access.interval = 300
            }
            this.access.interval = C;
            E = true
        }
    }
    if (E) {
        if (F != this.access.method) {
            if (F == DataSet.METHOD.POLL && this.pollTimeoutID) {
                clearInterval(this.pollTimeoutID)
            }
        }
        if (this.access.method == DataSet.METHOD.POLL) {
            if (this.pollTimeoutID) {
                clearInterval(this.pollTimeoutID)
            }
            this.pollTimeoutID = setTimeout(createObjectCallback(this, this._pollForData), this.pollInterval * 1000)
        }
    }
};
DataSet.prototype.__processNewData = function() {
    if (this.prerequisites) {
        var F = true;
        for (var E = 0; E < this.prerequisites.length; E++) {
            var G = this.prerequisites[E];
            if (!MC[G].data) {
                MC.debugOutput("%s waiting on %s", this.name, G);
                MC[G].setsWaiting[this.name] = 1;
                F = false
            }
        }
        if (!F) {
            return
        }
    }
    if (!this.data) {
        this.data = new APIData()
    }
    mcDebug("dataset", "DataSet Refresh: %s", this.name);
    var C = new Date();
    if (this.name == "eventsSet") {
        this.dataChanged = MC.addEvents(this.responseData)
    } else {
        this.dataChanged = this.data.refreshData(this.responseData)
    }
    delete this.responseData;
    this.dataValid = true;
    var J = new Date();
    this.notify();
    var D = new Date();
    this.classification = "idle";
    for (var I in this.setsWaiting) {
        MC.debugOutput("%s processing waiting dataset: %s", this.name, I);
        MC[I].__handleDataResponse();
        delete this.setsWaiting[I]
    }
    var H = new Date();
    MC.infoOutput("DataSet Refresh: Finished, data update: " + (J.getTime() - C.getTime()) + " ms, notification: " + (D.getTime() - J.getTime()) + " ms, waitingSets: " + (H.getTime() - D.getTime()) + " ms, Total: " + (H.getTime() - C.getTime()) + " ms");
    if (this.access.method == DataSet.METHOD.POLL) {
        this.pollTimeoutID = setTimeout(createObjectCallback(this, this._pollForData), this.access.interval * 1000)
    }
};
DataSet.padZeros = function(C, E) {
    var D = C + "";
    while (D.length < E) {
        D = "0" + D
    }
    return D
};
DataSet.generateVolumeName = function(E) {
    var F = E || "vol";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_v" + DataSet.padZeros(D, 3);
        var G = MC.volumesSet.dataSelect({
            type: "prop",
            name: "volume_name",
            value: C
        });
        if (G.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateVolumeSetName = function(C) {
    var D = C || "vol";
    return genName = D + "_v"
};
DataSet.generateVdiskName = function() {
    for (var D = 1; D < 100; D++) {
        var C = "vd" + DataSet.padZeros(D, 2);
        var E = MC.vdisksSet.dataSelect({
            type: "prop",
            name: "name",
            value: C
        });
        if (E.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateSnapshotName = function(E) {
    var F = E || "s";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_s" + DataSet.padZeros(D, 3);
        var G = MC.volumesSet.dataSelect({
            type: "prop",
            name: "volume_name",
            value: C
        });
        if (G.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateSnapshotPrefixName = function(H) {
    var I = H || "SnapSet";
    for (var G = 1; G < 1000; G++) {
        var F = I + DataSet.padZeros(G, 3);
        var E = false;
        for (var C in DC.tasks) {
            var D = DC.tasks[C];
            if ((D.objects.length > 0) && (D.objects[0].prop.snapshot_prefix) && (D.objects[0].prop.snapshot_prefix.text == F)) {
                E = true;
                break
            }
        }
        if (!E) {
            return F
        }
    }
    return ""
};
DataSet.generateTaskPrefix = function(J, E) {
    for (var I = 1; I < 100; I++) {
        var H = J + "_" + DataSet.padZeros(I, 2);
        var G = false;
        for (var C in DC.tasks) {
            var D = DC.tasks[C];
            if (D.prop.type.text == E) {
                var F;
                if (D.objects[0].prop.snapshot_prefix) {
                    F = D.objects[0].prop.snapshot_prefix.text
                } else {
                    if (D.objects[0].prop.destination_volume_prefix) {
                        F = D.objects[0].prop.destination_volume_prefix.text
                    }
                }
                if (F == H) {
                    G = true;
                    break
                }
            }
        }
        if (!G) {
            return H
        }
    }
    return ""
};
DataSet.generateSnapshotNameFromSet = function(H) {
    var G = "";
    var E = H.objects.length;
    if (E > 0) {
        var C = [];
        for (var D = 0; D < E; D++) {
            var F = H.objects[D].getPropertyValue("volume_name");
            G += DC.getUnusedKey("snapshots", F + "_s", C);
            if (D < (E - 1)) {
                G += ","
            }
        }
    }
    return G
};
DataSet.generateSnapPoolName = function(E) {
    var F = E || "sp";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_sp" + DataSet.padZeros(D, 3);
        var G = MC.volumesSet.dataSelect({
            type: "prop",
            name: "volume_name",
            value: C
        });
        if (G.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateVolCopyName = function(E) {
    var F = E || "c";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_c" + DataSet.padZeros(D, 3);
        var G = MC.volumesSet.dataSelect({
            type: "prop",
            name: "volume_name",
            value: C
        });
        if (G.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateTaskName = function(E) {
    var F = E || "task";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_task" + DataSet.padZeros(D, 3);
        if (DC.tasks[C] == undefined) {
            return C
        }
    }
    return ""
};
DataSet.generateScheduleName = function(E) {
    var F = E || "sched";
    for (var D = 1; D < 1024; D++) {
        var C = F + "_sched" + D;
        var G = MC.schedulesSet.dataSelect({
            type: "prop",
            name: "name",
            value: C
        });
        if (G.objects.length == 0) {
            return C
        }
    }
    return ""
};
DataSet.generateRepImageName = function(J) {
    var F = J || "";
    for (var H = 1; H < 1024; H++) {
        var L = F + "_i" + DataSet.padZeros(H, 2);
        var C = DC.repSets;
        var I = false;
        for (var K in C) {
            var G = C[K].repVolumesSerial;
            if (G) {
                for (var D in G) {
                    var M = G[D].images;
                    if (M) {
                        for (var N in M) {
                            var E = M[N];
                            if (E.prop.snapshot_name.text == L) {
                                I = true
                            }
                        }
                    }
                }
            }
        }
        if (!I) {
            return L
        }
    }
    return ""
};

function toJson(G, F) {
    if (!(G instanceof Array)) {
        G = [G]
    }
    var C = new Array();
    for (var E = 0; E < G.length; E++) {
        C[C.length] = F
    }
    var D = {
        typeOf: "JSXBObject",
        _children: C
    };
    D[F] = G;
    return D
}
DataSet.prototype.select = function(C) {
    if (this.data) {
        return this.data.select(C)
    } else {
        return (new APIData())
    }
};
DataSet.prototype.dataSelect = function(C) {
    if (this.data) {
        return this.data.select(C)
    } else {
        return (new APIData())
    }
};
DataSet.prototype.Info = function(C) {
    var D = "";
    if (C) {
        D += "DataSet Info\n";
        D += "------------\n"
    }
    D += sprintf("%-20s %s %s\n", this.name, (this.dataValid) ? "DATA: valid" : "DATA: invalid", (this.dataInProcess) ? "INPROCESS: yes(" + this.classification + ")" : "INPROCESS: no");
    D += this.SubscriptionsInfo(true);
    return D
};
DataSet.prototype.showInfo = function() {
    if (checkforconsole()) {
        console.log(this.Info(true))
    }
};
MCObject = function() {
    this.class_name = "MCObject";
    this.numDataSets = 0;
    this.memorex = settings.memorex;
    this.fakeTranslations = settings.fakeTranslations;
    this.memorexMeta = settings.memorexMeta;
    this.dataSets = {};
    this.baseMap = {}
};
MCObject.prototype = new DHSObject();
MCObject.ALL = 0;
MCObject.PRELOAD = 1;
MCObject.INITIAL_LOAD = 2;
MCObject.LATE_LOAD = 3;
MCObject.NOLOAD = 4;
MCObject.prototype.load = function() {
    this.systemInfoSet = this.register(new DataSet({
        name: "systemInfoSet",
        url: "/api/show/system",
        memorexFile: "showSystem",
        basetypes: ["system", "redundancy"],
        preNotifyHandler: this._addBrandCss,
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.PRELOAD
    }));
    this.cacheParametersSet = this.register(new DataSet({
        name: "cacheParametersSet",
        url: "/api/show/cache-parameters",
        memorexFile: "showCacheParameters",
        basetypes: ["cache-settings"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.disksSet = this.register(new DataSet({
        name: "disksSet",
        url: "/api/show/disks",
        memorexFile: "showDisks",
        basetypes: ["drives"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        preNotifyHandler: this._disksPreprocess,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.poolsSet = this.register(new DataSet({
        name: "poolsSet",
        url: "/api/show/pools",
        memorexFile: "showPools",
        basetypes: ["pools", "disk-groups"],
        accessMethod: DataSet.METHOD.BACKCHANNEL,
        pollInterval: 30,
        preNotifyHandler: this._poolsPreprocess,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.poolStatisticsSet = this.register(new DataSet({
        name: "poolStatisticsSet",
        url: "/api/show/pool-statistics",
        memorexFile: "showPoolStatistics",
        basetypes: ["pool-statistics", "tier-statistics", "resettable-statistics"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.hostPortStatsSet = this.register(new DataSet({
        name: "hostPortStatsSet",
        url: "/api/show/host-port-statistics",
        memorexFile: "showHostPortStatistics",
        basetypes: ["host-port-statistics"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        preNotifyHandler: this._hostPortStatsPreprocess,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.diskStatSet = this.register(new DataSet({
        name: "diskStatSet",
        url: "/api/show/disk-statistics",
        memorexFile: "showDiskStatistics",
        basetypes: ["disk-statistics"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 30,
        loadOrder: MCObject.NOLOAD
    }));
    this.certSet = this.register(new DataSet({
        name: "certSet",
        url: "/api/show/certificate",
        memorexFile: "showCertificate",
        basetypes: ["certificate-status"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 30,
        loadOrder: MCObject.NOLOAD
    }));
    this.controllerStatSet = this.register(new DataSet({
        name: "controllerStatSet",
        url: "/api/show/controller-statistics",
        memorexFile: "showControllerStatistics",
        basetypes: ["controller-statistics"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 30,
        loadOrder: MCObject.NOLOAD
    }));
    this.volumeStatSet = this.register(new DataSet({
        name: "volumeStatSet",
        url: "/api/show/volume-statistics",
        memorexFile: "showVolumeStatistics",
        basetypes: ["volume-statistics"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 30,
        loadOrder: MCObject.NOLOAD
    }));
    if (RI.hasFeature("copyServices")) {
        this.volumeCopySet = this.register(new DataSet({
            name: "volumeCopySet",
            url: "/api/show/volume-copies",
            memorexFile: "showVolumeCopies",
            basetypes: ["copy-volumes"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.LATE_LOAD
        }))
    }
    this.volumeGroupsSet = this.register(new DataSet({
        name: "volumeGroupsSet",
        url: "/api/show/volume-groups",
        memorexFile: "showVolumeGroups",
        basetypes: ["volume-groups", "volumes"],
        accessMethod: DataSet.METHOD.BACKCHANNEL,
        pollInterval: 30,
        preNotifyHandler: this._volumeGroupsPreprocess,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.hostGroupsSet = this.register(new DataSet({
        name: "hostGroupsSet",
        url: "/api/show/host-groups",
        memorexFile: "showHostGroups",
        basetypes: ["host-group", "host", "initiator"],
        accessMethod: DataSet.METHOD.BACKCHANNEL,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    if (RI.hasFeature("asyncRep") && !EXPR.isSasPortType) {
        this.peerConnectionsSet = this.register(new DataSet({
            name: "peerConnectionsSet",
            url: "/api/show/peer-connections",
            memorexFile: "showPeerConnections",
            basetypes: ["peer-connections", "local-ports", "remote-ports"],
            accessMethod: DataSet.METHOD.BACKCHANNEL,
            pollInterval: 30,
            loadOrder: MCObject.INITIAL_LOAD
        }));
        this.virtualReplicationSets = this.register(new DataSet({
            name: "virtualReplicationSets",
            url: "/api/show/replication-sets",
            memorexFile: "showReplicationSets",
            basetypes: ["cs-replication-set", "cs-replication"],
            accessMethod: DataSet.METHOD.BACKCHANNEL,
            pollInterval: 30,
            loadOrder: MCObject.INITIAL_LOAD
        }))
    }
    this.volumeStatSet = this.register(new DataSet({
        name: "volumeStatSet",
        url: "/api/show/volume-statistics",
        memorexFile: "showVolumeStatistics",
        basetypes: ["volume-statistics"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 30,
        loadOrder: MCObject.NOLOAD
    }));
    this.enclosuresSet = this.register(new DataSet({
        name: "enclosuresSet",
        url: "/api/show/enclosures",
        memorexFile: "showEnclosures",
        basetypes: ["enclosures", "compact-flash", "controllers", "network-parameters", "port", "fc-port", "IB-port", "sas-port", "iscsi-port", "power-supplies", "fan", "enclosure-fru", "expander-ports", "ses", "io-modules", "unhealthy-component"],
        accessMethod: DataSet.METHOD.COUNTER,
        preNotifyHandler: this._savePortTypes,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    if (RI.supportsSnaps()) {
        this.snapshotsSet = this.register(new DataSet({
            name: "snapshotsSet",
            url: "/api/show/snapshots",
            memorexFile: "showSnapshots",
            memorexFile2: "showSnapshotsType",
            basetypes: ["snapshots"],
            accessMethod: DataSet.METHOD.BACKCHANNEL,
            loadOrder: MCObject.INITIAL_LOAD
        }))
    }
    if (RI.supportsLinear() && RI.hasFeature("dms")) {
        this.snapPoolsSet = this.register(new DataSet({
            name: "snapPoolsSet",
            url: "/api/show/snap-pools",
            memorexFile: "showSnapPools",
            basetypes: ["snap-pools", "policy-threshold"],
            accessMethod: DataSet.METHOD.BACKCHANNEL,
            loadOrder: MCObject.INITIAL_LOAD
        }))
    }
    this.versionsSet = this.register(new DataSet({
        name: "versionsSet",
        url: "/api/show/versions",
        memorexFile: "showVersions",
        memorexFile2: "showVersionsDetail",
        basetypes: ["versions"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.schedulesSet = this.register(new DataSet({
        name: "schedulesSet",
        url: "/api/show/schedules",
        memorexFile: "showSchedules",
        memorexFile2: "showSchedulesDetail",
        basetypes: ["schedules", "tasks", "snapshot-with-retention-tasks", "reset-snapshot-tasks", "volume-copy-tasks", "snap-tasks", "replicate-volume-tasks"],
        accessMethod: DataSet.METHOD.BACKCHANNEL,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.mapsSet = this.register(new DataSet({
        name: "mapsSet",
        url: "/api/show/maps",
        memorexFile: "showMaps",
        basetypes: ["volume-view", "volume-view-mappings", "volume-group-view", "volume-group-view-mappings", "volume-group-view-mappings-lun"],
        accessMethod: DataSet.METHOD.BACKCHANNEL,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.eventsSet = this.register(new DataSet({
        name: "eventsSet",
        url: "/api/show/events/last/" + APIEvents.MAX_EVENTS.paged,
        memorexFile: "showEventsLast",
        basetypes: ["events"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.protocolsSet = this.register(new DataSet({
        name: "protocolsSet",
        url: "/api/show/protocols",
        memorexFile: "showProtocols",
        basetypes: ["security-communications-protocols", "communication-ports"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.timeSettingsSet = this.register(new DataSet({
        name: "timeSettingsSet",
        url: "/api/show/controller-date",
        memorexFile: "showControllerDate",
        basetypes: ["time-settings-table"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        preNotifyHandler: MCDate.syncToArray,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    this.advancedSettingsSet = this.register(new DataSet({
        name: "advancedSettingsSet",
        url: "/api/show/advanced-settings",
        memorexFile: "showAdvancedSettings",
        basetypes: ["advanced-settings-table"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    if (RI.hasFeature("fde")) {
        this.fdeStateSet = this.register(new DataSet({
            name: "fdeStateSet",
            url: "/api/show/fde-state",
            memorexFile: "showFdeState",
            basetypes: ["fde-state"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.LATE_LOAD
        }))
    }
    this.refreshCountersSet = this.register(new DataSet({
        name: "refreshCountersSet",
        url: "/api/show/refresh-counters",
        memorexFile: "showRefreshCounters",
        basetypes: [],
        accessMethod: DataSet.METHOD.ONDEMAND,
        pollInterval: 10,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.emailParametersSet = this.register(new DataSet({
        name: "emailParametersSet",
        url: "/api/show/email-parameters",
        memorexFile: "showEmailParameters",
        basetypes: ["email-parameters"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.INITIAL_LOAD
    }));
    if (RI.hasFeature("DNS")) {
        this.dnsParametersSet = this.register(new DataSet({
            name: "dnsParametersSet",
            url: "/api/show/dns-parameters",
            memorexFile: "showDnsParameters",
            basetypes: ["dns-parameters"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.INITIAL_LOAD
        }))
    }
    this.snmpParametersSet = this.register(new DataSet({
        name: "snmpParametersSet",
        url: "/api/show/snmp-parameters",
        memorexFile: "showSnmpParameters",
        basetypes: ["snmp-parameters"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.syslogParametersSet = this.register(new DataSet({
        name: "syslogParametersSet",
        url: "/api/show/syslog-parameters",
        memorexFile: "showSyslogParameters",
        basetypes: ["syslog-parameters"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.LATE_LOAD
    }));
    this.licenseSet = this.register(new DataSet({
        name: "licenseSet",
        url: "/api/show/license",
        memorexFile: "showLicense",
        basetypes: ["license"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.PRELOAD
    }));
    this.systemParametersSet = this.register(new DataSet({
        name: "systemParametersSet",
        url: "/api/show/system-parameters",
        memorexFile: "showSystemParameters",
        basetypes: ["system-parameters-table"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.PRELOAD
    }));
    this.sessionParametersSet = this.register(new DataSet({
        name: "sessionParametersSet",
        url: "/api/show/cli-parameters",
        memorexFile: "showCliParameters",
        basetypes: ["cli-parameters"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.PRELOAD
    }));
    this.diskGroupsSet = this.register(new DataSet({
        name: "diskGroupsSet",
        url: "/api/show/disk-groups",
        memorexFile: "showDiskGroups",
        basetypes: ["disk-groups"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.LATE_LOAD
    }));
    if (RI.hasFeature("oneButtonProvision")) {
        this.showProfiles = this.register(new DataSet({
            name: "showProfiles",
            url: "/api/show/profiles",
            memorexFile: "showProfiles",
            basetypes: ["profiles"],
            accessMethod: DataSet.METHOD.ONDEMAND,
            pollInterval: 30,
            loadOrder: MCObject.NOLOAD
        }))
    }
    this.usersSet = this.register(new DataSet({
        name: "usersSet",
        url: "/api/show/users",
        memorexFile: "showUsers",
        basetypes: ["users"],
        accessMethod: DataSet.METHOD.COUNTER,
        pollInterval: 30,
        loadOrder: MCObject.PRELOAD
    }));
    if (RI.hasFeature("ldap")) {
        this.usergroupssSet = this.register(new DataSet({
            name: "usergroupssSet",
            url: "api/show/user-groups",
            memorexFile: "showsUserGroups",
            basetypes: ["usergroups"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.PRELOAD
        }));
        this.ldapParameterSet = this.register(new DataSet({
            name: "ldapParameterSet",
            url: "api/show/ldap-parameters",
            memorexFile: "showsLdapParameters",
            basetypes: ["ldap-parameters"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.INITIAL_LOAD
        }))
    }
    this.userInteractionsSet = this.register(new DataSet({
        name: "userInteractionsSet",
        url: "/api/show/user-interactions",
        memorexFile: "showUserInteractions",
        basetypes: ["user-interactions"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        loadOrder: MCObject.NOLOAD
    }));
    this.shutdownStatusSet = this.register(new DataSet({
        name: "shutdownStatusSet",
        url: "/api/show/shutdown-status",
        memorexFile: "showsShutdownStatus",
        basetypes: ["shutdown-status", "show-other-MC-status"],
        accessMethod: DataSet.METHOD.ONDEMAND,
        loadOrder: MCObject.NOLOAD
    }));
    session._subscribe()
};
MCObject.prototype._addBrandCss = function() {
    if (settings.isV3 && Help) {
        Help.addBrandCss();
        MC.systemInfoSet.preNotifyHandler = null
    }
};
MCObject.prototype._savePortTypes = function() {
    if (settings.isV3 && Help) {
        DC.savePortTypes();
        Help.addPortCss();
        MC.enclosuresSet.preNotifyHandler = null
    }
};
MCObject.prototype._disksPreprocess = function() {
    if (!MC.poolsSet.data) {
        return
    }
    if (!this.size) {
        this.size = new Size();
        this.sizeVirtualOwner = {
            A: new Size(),
            B: new Size()
        };
        this.sizeVirtual = new Size();
        this.sizeLinearOwner = {
            A: new Size(),
            B: new Size()
        };
        this.sizeLinear = new Size();
        this.sizeSpares = new Size();
        this.sizeSparesDedicated = new Size();
        this.sizeSparesGlobal = new Size();
        this.sizeAvail = new Size()
    } else {
        this.size.set(0, "blocks");
        this.sizeVirtualOwner.A.set(0, "blocks");
        this.sizeVirtualOwner.B.set(0, "blocks");
        this.sizeVirtual.set(0, "blocks");
        this.sizeLinearOwner.A.set(0, "blocks");
        this.sizeLinearOwner.B.set(0, "blocks");
        this.sizeLinear.set(0, "blocks");
        this.sizeSpares.set(0, "blocks");
        this.sizeSparesDedicated.set(0, "blocks");
        this.sizeSparesGlobal.set(0, "blocks");
        this.sizeAvail.set(0, "blocks")
    }
    this.numDisks = 0;
    this.numDisksVirtual = 0;
    this.numDisksLinear = 0;
    this.numSpares = 0;
    this.numSparesDedicated = 0;
    this.numSparesGlobal = 0;
    this.numSparesStandard = 0;
    this.numSparesArchive = 0;
    this.numSparesSSD = 0;
    this.numAvail = 0;
    for (var C in DC.disks) {
        var F = DC.disks[C];
        var D = F.getInt("usage_numeric");
        var G = F.getTotalBlocks();
        this.numDisks++;
        this.size.add(G, "blocks");
        switch (D) {
            case DRIVE_USAGE.AVAILABLE:
                this.numAvail++;
                this.sizeAvail.add(G, "blocks");
                break;
            case DRIVE_USAGE.LINEAR_POOL:
                this.numDisksLinear++;
                var E = F.get("owner");
                if (F.get("virtual_disk_serial") && DC.diskGroupsSerial[F.get("virtual_disk_serial")]) {
                    E = DC.diskGroupsSerial[F.get("virtual_disk_serial")].get("preferred_owner")
                }
                this.sizeLinearOwner[E].add(G, "blocks");
                this.sizeLinear.add(G, "blocks");
                break;
            case DRIVE_USAGE.VIRTUAL_POOL:
                this.numDisksVirtual++;
                var E = F.get("owner");
                if (F.get("virtual_disk_serial") && DC.diskGroupsSerial[F.get("virtual_disk_serial")]) {
                    E = DC.diskGroupsSerial[F.get("virtual_disk_serial")].get("preferred_owner")
                }
                this.sizeVirtualOwner[E].add(G, "blocks");
                this.sizeVirtual.add(G, "blocks");
                break;
            case DRIVE_USAGE.DEDICATED_SPARE:
                this.numSpares++;
                this.numSparesDedicated++;
                this.sizeSpares.add(G, "blocks");
                this.sizeSparesDedicated.add(G, "blocks");
                break;
            case DRIVE_USAGE.GLOBAL_SPARE:
                this.numSpares++;
                this.numSparesGlobal++;
                this.sizeSpares.add(G, "blocks");
                this.sizeSparesGlobal.add(G, "blocks");
                if (F.getInt("architecture_numeric") == DISK_ARCH.HDD) {
                    if (F.getInt("interface_numeric") == DISK_IF.SAS && parseInt(F.get("rpm"), 10) >= 10) {
                        this.numSparesStandard++
                    } else {
                        this.numSparesArchive++
                    }
                } else {
                    if (F.getInt("architecture_numeric") == DISK_ARCH.SSD) {
                        this.numSparesSSD++
                    }
                }
                break;
            case DRIVE_USAGE.SINGLE:
            case DRIVE_USAGE.LEFTOVER:
            case DRIVE_USAGE.UNDER_TEST:
            case DRIVE_USAGE.FAILED:
            case DRIVE_USAGE.UNUSABLE:
            default:
                break
        }
    }
};
MCObject.prototype._volumeGroupsPreprocess = function() {
    if (!this.size) {
        this.numVols = {
            A: 0,
            B: 0
        };
        this.numVolsVirtual = {
            A: 0,
            B: 0
        };
        this.numVolsLinear = {
            A: 0,
            B: 0
        };
        this.numSnaps = {
            A: 0,
            B: 0
        };
        this.numSnapsVirtual = {
            A: 0,
            B: 0
        };
        this.numSnapsLinear = {
            A: 0,
            B: 0
        };
        this.pages = {
            A: 0,
            B: 0
        };
        this.size = {
            A: new Size(),
            B: new Size()
        };
        this.sizeVirtual = {
            A: new Size(),
            B: new Size()
        };
        this.sizeLinear = {
            A: new Size(),
            B: new Size()
        };
        this.totalSize = new Size()
    }
    this.numVols.A = 0;
    this.numVols.B = 0;
    this.numVolsVirtual.A = 0;
    this.numVolsVirtual.B = 0;
    this.numVolsLinear.A = 0;
    this.numVolsLinear.B = 0;
    this.numSnaps.A = 0;
    this.numSnaps.B = 0;
    this.numSnapsVirtual.A = 0;
    this.numSnapsVirtual.B = 0;
    this.numSnapsLinear.A = 0;
    this.numSnapsLinear.B = 0;
    this.pages.A = 0;
    this.pages.B = 0;
    this.sizeLinear.A.set(0, "blocks");
    this.sizeLinear.B.set(0, "blocks");
    var H;
    var G;
    var D;
    var F;
    var C;
    for (var E in DC.volumes) {
        H = DC.volumes[E].isVirtual();
        G = DC.volumes[E].getInt("volume_type_numeric");
        D = DC.volumes[E].getInt("size_numeric");
        F = DC.volumes[E].getInt("allocated_size_numeric");
        if (H) {
            C = DC.volumes[E].get("storage_pool_name")
        } else {
            C = DC.volumes[E].get("preferred_owner")
        }
        if (G in STANDARD_VOLUME_TYPES) {
            this.numVols[C]++;
            if (H) {
                this.numVolsVirtual[C]++;
                this.pages[C] += Math.ceil(D / PAGEBLOCKS[C])
            } else {
                this.numVolsLinear[C]++;
                this.sizeLinear[C].add(D, "blocks")
            }
        } else {
            if (G == VOLUME_TYPES.SNAPSHOT) {
                this.numSnaps[C]++;
                this.numSnapsLinear[C]++
            } else {
                if (G == VOLUME_TYPES.PAGED_SNAPSHOT) {
                    this.numSnaps[C]++;
                    this.numSnapsVirtual[C]++;
                    this.pages[C] += Math.ceil(D / PAGEBLOCKS[C])
                }
            }
        }
    }
    this.sizeVirtual.A.set(this.pages.A, "pages");
    this.sizeVirtual.B.set(this.pages.B, "pages");
    this.size.A.set(this.sizeVirtual.A);
    this.size.A.add(this.sizeLinear.A);
    this.size.B.set(this.sizeVirtual.B);
    this.size.B.add(this.sizeLinear.B);
    this.totalSize.set(this.size.A);
    this.totalSize.add(this.size.B);
    this.totalVols = this.numVols.A + this.numVols.B;
    this.totalSnaps = this.numSnaps.A + this.numSnaps.B;
    MC._calcSizes()
};
MCObject.prototype._poolsPreprocess = function() {
    if (!MC.disksSet.sizeVirtualOwner && MC.disksSet.data) {
        MC.disksSet.preNotifyHandler()
    }
    if (!PAGEBLOCKS.set) {
        PAGEBLOCKS.A = (DC.pools.A ? parseInt(DC.pools.A.prop.page_size_numeric.text, 10) : 8192);
        PAGEBLOCKS.B = (DC.pools.B ? parseInt(DC.pools.B.prop.page_size_numeric.text, 10) : 8192);
        PAGEBLOCKS.set = true
    }
    if (!this.virtPoolSize) {
        this.virtPoolSize = {
            A: new Size(),
            B: new Size()
        };
        this.virtPages = {
            A: 0,
            B: 0
        };
        this.virtPoolReservedSize = {
            A: new Size(),
            B: new Size()
        };
        this.virtPoolAllocPages = {
            A: 0,
            B: 0
        };
        this.virtPoolAllocSize = {
            A: new Size(),
            B: new Size()
        };
        this.virtPoolAvailSize = {
            A: new Size(),
            B: new Size()
        };
        this.virtPoolSnapSizeUsed = {
            A: new Size(),
            B: new Size()
        };
        this.virtPoolSizeTotal = new Size();
        this.virtPoolAllocSizeTotal = new Size();
        this.virtPoolAvailSizeTotal = new Size();
        this.virtTotalReserved = new Size();
        this.linearSize = {
            A: new Size(),
            B: new Size()
        };
        this.linearSizeReserved = {
            A: new Size(),
            B: new Size()
        };
        this.linearSizeUsed = {
            A: new Size(),
            B: new Size()
        };
        this.linearSizeFree = {
            A: new Size(),
            B: new Size()
        };
        this.linearTotalSize = new Size();
        this.linearSnapSizeUsed = {
            A: new Size(),
            B: new Size()
        };
        this.linearTotalSizeReserved = new Size();
        this.linearTotalSizeUsed = new Size();
        this.linearTotalSizeFree = new Size();
        this.linearTotalReserved = new Size()
    }
    var K = 0;
    var I = 0;
    var F = 0;
    if (DC.pools.A) {
        K = parseInt(DC.pools.A.prop.total_size_numeric.text, 10);
        this.virtPages.A = Math.floor(parseInt(DC.pools.A.prop.total_size_numeric.text, 10) / PAGEBLOCKS.A);
        this.virtPoolAllocPages.A = parseInt(DC.pools.A.prop.allocated_pages.text, 10);
        I = this.virtPoolAllocPages.A * PAGEBLOCKS.A;
        F = parseInt(DC.pools.A.prop.available_pages.text, 10) * PAGEBLOCKS.A;
        this.virtPoolSnapSizeUsed.A.set(DC.pools.A.get("snap_size"))
    }
    this.virtPoolSize.A.set(K, "blocks");
    this.virtPoolAllocSize.A.set(I, "blocks");
    this.virtPoolAvailSize.A.set(F, "blocks");
    var J = 0;
    var H = 0;
    var E = 0;
    if (DC.pools.B) {
        J = parseInt(DC.pools.B.prop.total_size_numeric.text, 10);
        this.virtPages.B = Math.floor(parseInt(DC.pools.B.prop.total_size_numeric.text, 10) / PAGEBLOCKS.A);
        this.virtPoolAllocPages.B = parseInt(DC.pools.B.prop.allocated_pages.text, 10);
        H = this.virtPoolAllocPages.B * PAGEBLOCKS.B;
        E = parseInt(DC.pools.B.prop.available_pages.text, 10) * PAGEBLOCKS.B;
        this.virtPoolSnapSizeUsed.B.set(DC.pools.B.get("snap_size"))
    }
    this.virtPoolSize.B.set(J, "blocks");
    this.virtPoolAllocSize.B.set(H, "blocks");
    this.virtPoolAvailSize.B.set(E, "blocks");
    this.virtPoolSizeTotal.set(this.virtPoolSize.A);
    this.virtPoolSizeTotal.add(this.virtPoolSize.B);
    this.virtPoolAllocSizeTotal.set(this.virtPoolAllocSize.A);
    this.virtPoolAllocSizeTotal.add(this.virtPoolAllocSize.B);
    this.virtPoolAvailSizeTotal.set(this.virtPoolAvailSize.A);
    this.virtPoolAvailSizeTotal.add(this.virtPoolAvailSize.B);
    if (MC.disksSet.sizeVirtual) {
        this.virtPoolReservedSize.A.set(MC.disksSet.sizeVirtualOwner.A);
        this.virtPoolReservedSize.A.subtract(this.virtPoolSize.A);
        this.virtPoolReservedSize.B.set(MC.disksSet.sizeVirtualOwner.B);
        this.virtPoolReservedSize.B.subtract(this.virtPoolSize.B);
        this.virtTotalReserved.set(MC.disksSet.sizeVirtual);
        this.virtTotalReserved.subtract(this.virtPoolSizeTotal)
    }
    MC._calcSizes();
    this.linearSize.A.set(0, "blocks");
    this.linearSize.B.set(0, "blocks");
    this.linearSizeReserved.A.set(0, "blocks");
    this.linearSizeReserved.B.set(0, "blocks");
    this.linearSizeUsed.A.set(0, "blocks");
    this.linearSizeUsed.B.set(0, "blocks");
    this.linearSizeFree.A.set(0, "blocks");
    this.linearSizeFree.B.set(0, "blocks");
    for (var D in DC.pools) {
        var G = DC.pools[D];
        if (parseInt(G.get("storage_type_numeric")) != STORAGE_CLASS.LINEAR) {
            continue
        }
        var C = G.get("preferred_owner");
        G.accumulateSizes(this.linearSize[C], this.linearSizeUsed[C], this.linearSizeReserved[C], this.linearSizeFree[C]);
        this.linearSnapSizeUsed[C].set(G.get("snap_size"))
    }
    this.linearTotalSize.set(this.linearSize.A);
    this.linearTotalSize.add(this.linearSize.B);
    this.linearTotalSizeReserved.set(this.linearSizeReserved.A);
    this.linearTotalSizeReserved.add(this.linearSizeReserved.B);
    this.linearTotalSizeFree.set(this.linearSizeFree.A);
    this.linearTotalSizeFree.add(this.linearSizeFree.B);
    this.linearTotalSizeUsed.set(this.linearSizeUsed.A);
    this.linearTotalSizeUsed.add(this.linearSizeUsed.B);
    if (MC.disksSet.sizeLinear) {
        this.linearSizeReserved.A.set(MC.disksSet.sizeLinearOwner.A);
        this.linearSizeReserved.A.subtract(this.linearSize.A);
        if (this.linearSizeReserved.A.getRawValue() < 0) {
            this.linearSizeReserved.A.set(0, "blocks")
        }
        this.linearSizeReserved.B.set(MC.disksSet.sizeLinearOwner.B);
        this.linearSizeReserved.B.subtract(this.linearSize.B);
        if (this.linearSizeReserved.B.getRawValue() < 0) {
            this.linearSizeReserved.B.set(0, "blocks")
        }
        this.linearTotalReserved.set(MC.disksSet.sizeLinear);
        this.linearTotalReserved.subtract(this.linearTotalSize);
        if (this.linearTotalReserved.getRawValue() < 0) {
            this.linearTotalReserved.set(0, "blocks")
        }
    }
};
MCObject.prototype._calcSizes = function() {
    if (!this.poolsSet.virtUncommittedPages) {
        this.poolsSet.virtUncommittedPages = {
            A: 0,
            B: 0
        };
        this.poolsSet.virtUncommittedSize = {
            A: new Size(),
            B: new Size()
        };
        this.poolsSet.virtUncommittedSizeTotal = new Size()
    }
    if (!this.volumeGroupsSet.virtUnallocPages) {
        this.volumeGroupsSet.virtUnallocPages = {
            A: 0,
            B: 0
        };
        this.volumeGroupsSet.virtUnallocSize = {
            A: new Size(),
            B: new Size()
        };
        this.volumeGroupsSet.virtUnallocSizeTotal = new Size()
    }
    if (this.poolsSet.virtPages && this.volumeGroupsSet.pages) {
        this.poolsSet.virtUncommittedPages.A = this.poolsSet.virtPages.A - this.volumeGroupsSet.pages.A;
        if (this.poolsSet.virtUncommittedPages.A < 0) {
            this.poolsSet.virtUncommittedPages.A = 0
        }
        this.poolsSet.virtUncommittedSize.A.set(this.poolsSet.virtUncommittedPages.A, "pages");
        this.poolsSet.virtUncommittedPages.B = this.poolsSet.virtPages.B - this.volumeGroupsSet.pages.B;
        if (this.poolsSet.virtUncommittedPages.B < 0) {
            this.poolsSet.virtUncommittedPages.B = 0
        }
        this.poolsSet.virtUncommittedSize.B.set(this.poolsSet.virtUncommittedPages.B, "pages");
        this.poolsSet.virtUncommittedSizeTotal.set(this.poolsSet.virtUncommittedSize.A);
        this.poolsSet.virtUncommittedSizeTotal.add(this.poolsSet.virtUncommittedSize.B);
        this.volumeGroupsSet.virtUnallocPages.A = this.volumeGroupsSet.pages.A - this.poolsSet.virtPoolAllocPages.A;
        if (this.volumeGroupsSet.virtUnallocPages.A < 0) {
            this.volumeGroupsSet.virtUnallocPages.A = 0
        }
        this.volumeGroupsSet.virtUnallocSize.A.set(this.volumeGroupsSet.virtUnallocPages.A, "pages");
        this.volumeGroupsSet.virtUnallocPages.B = this.volumeGroupsSet.pages.B - this.poolsSet.virtPoolAllocPages.B;
        if (this.volumeGroupsSet.virtUnallocPages.B < 0) {
            this.volumeGroupsSet.virtUnallocPages.B = 0
        }
        this.volumeGroupsSet.virtUnallocSize.B.set(this.volumeGroupsSet.virtUnallocPages.B, "pages");
        this.volumeGroupsSet.virtUnallocSizeTotal.set(this.volumeGroupsSet.virtUnallocSize.A);
        this.volumeGroupsSet.virtUnallocSizeTotal.add(this.volumeGroupsSet.virtUnallocSize.B)
    }
};
MCObject.prototype.toISODate = function(C) {
    if (C == undefined) {
        C = new Date()
    }
    var D = {
        date: C.getFullYear() + "-" + leadingZeros((C.getMonth() + 1), 2) + "-" + leadingZeros(C.getDate(), 2),
        time: leadingZeros(C.getHours(), 2) + ":" + leadingZeros(C.getMinutes(), 2) + ":" + leadingZeros(C.getSeconds(), 2)
    };
    return D
};
MCObject.prototype._hostPortStatsPreprocess = function() {
    this.iops = {
        A: 0,
        B: 0
    };
    this.mbps = {
        A: 0,
        B: 0
    };
    this.iopsTotal = 0;
    this.mbpsTotal = 0;
    this.maxIops = 0;
    this.maxMbps = 0;
    var D = {
        A: 0,
        B: 0
    };
    var F = this.getData();
    var G = F.objects.length;
    for (var E = 0; E < G; E++) {
        var H = F.objects[E];
        if (H.basetype != "host-port-statistics") {
            MC.warningOutput("Unrecognized object from show host-port-parameters: %o", H);
            continue
        }
        var I = H.getPropertyValue("durable_id");
        var C = I.substr(I.length - 2, 1).toUpperCase();
        this.iops[C] += parseInt(H.getPropertyValue("iops"), 10);
        D[C] += parseInt(H.getPropertyValue("bytes_per_second_numeric"), 10)
    }
    this.mbps.A = Math.round(D.A / 1000000);
    this.mbps.B = Math.round(D.B / 1000000);
    this.iopsTotal = this.iops.A + this.iops.B;
    this.mbpsTotal = this.mbps.A + this.mbps.B;
    if (this.iops.A > this.maxIops) {
        this.maxIops = this.iops.A
    }
    if (this.iops.B > this.maxIops) {
        this.maxIops = this.iops.B
    }
    if (this.mbps.A > this.maxMbps) {
        this.maxMbps = this.mbps.A
    }
    if (this.mbps.B > this.maxMbps) {
        this.maxMbps = this.mbps.B
    }
};
MCObject.prototype.setAllLEDsOff = function() {
    var C = DC.disks;
    if (C) {
        for (var E in C) {
            var D = C[E];
            D.blinkState = false
        }
    }
    this.scheduleLEDRefresh()
};
MCObject.prototype.setLEDstate = function(E, D) {
    var C = DC.disks[E];
    if (C) {
        C.blinkState = D
    }
    this.scheduleLEDRefresh()
};
MCObject.prototype.scheduleLEDRefresh = function() {
    if (this.LEDRefreshTimeout) {
        clearTimeout(this.LEDRefreshTimeout)
    }
    this.LEDRefreshTimeout = setTimeout(createObjectCallback(this, this.doLEDRefresh), 1000)
};
MCObject.prototype.doLEDRefresh = function() {
    var E = [];
    var C = DC.disks;
    if (C) {
        for (var G in C) {
            var F = C[G];
            if (F.blinkState) {
                E.push(F.prop.location.text)
            }
        }
    }
    var D = E.join(",");
    this.setLed({
        target: "disk",
        id: "all",
        state: "off"
    }, {
        dialog: false
    });
    if (D) {
        this.setLed({
            target: "disk",
            id: D,
            state: "on"
        }, {
            dialog: false
        })
    }
};
MCObject.prototype.getItemList = function(J, H, C) {
    if (J instanceof Array) {
        if (H != undefined && (typeof H) == "number") {
            if (H < J.length) {
                var G = J.slice(0, H).join(", ");
                G += strings.truncatedList(J.length - H);
                return G
            } else {
                return J.join(", ")
            }
        } else {
            if (H === true) {
                return J.join(", ")
            } else {
                if (H === "quoted") {
                    for (var D = 0; D < J.length; D++) {
                        if ((J[D].indexOf(" ") != -1) && (J[D].indexOf('"') == -1)) {
                            J[D] = '"' + J[D] + '"'
                        }
                    }
                    return J.join(",")
                } else {
                    return J.join(",")
                }
            }
        }
    } else {
        if (J instanceof APIData) {
            var G = "";
            var I = J.objects.length;
            var E = I;
            if (C != undefined && C < I) {
                E = C
            }
            if (E > 0) {
                for (var D = 0; D < E; D++) {
                    var F = J.objects[D].getPropertyValue(H);
                    if (F) {
                        G += F;
                        if (D < (E - 1)) {
                            if (C != undefined) {
                                G += ", "
                            } else {
                                G += ","
                            }
                        }
                    }
                }
            }
            if (E < I) {
                G += strings.truncatedList(I - E)
            }
            return G
        }
    }
    MC.errorOutput("AAAarrrggggg! I'm a pirate! isn't anything valid? Am I InValid?");
    return ""
};
MCObject.prototype.countItemList = function(D, C) {
    if (D instanceof Array) {
        return D.length
    } else {
        if (D instanceof APIData) {
            return D.objects.length
        }
    }
    return 0
};
MCObject.prototype.argsMissing = function(D, E) {
    for (var C = 0; C < E.length; C++) {
        if (typeof(D[E[C]]) == "undefined") {
            return true
        }
    }
    return false
};
MCObject.prototype.getfunctionOutput = function(D, C) {
    RB.makeRequest({
        httpReqType: "GET",
        url: D,
        dataType: "wbi",
        xmlToJson: true,
        callback: C
    })
};
MCObject.prototype.showFrus = function(C) {
    RB.makeRequest({
        httpReqType: "GET",
        url: "/api/show/frus/secrets",
        dataType: "wbi",
        callback: C
    })
};
MCObject.prototype.showServiceTagInfo = function(C) {
    RB.makeRequest({
        httpReqType: "GET",
        url: "/api/show/service-tag-info",
        dataType: "wbi",
        callback: C
    })
};
MCObject.prototype.addBaseMaps = function(D) {
    for (var C = 0; C < D.basetypes.length; C++) {
        var E = D.basetypes[C];
        if (!this.baseMap[E]) {
            this.baseMap[E] = {}
        }
        this.baseMap[E][D.name] = D
    }
};
MCObject.prototype.getDataSetsForLoad = function(C) {
    var E = [];
    for (var D in this.dataSets) {
        if (C === MCObject.ALL || this.dataSets[D].loadOrder == C) {
            E.push(D)
        }
    }
    return E
};
MCObject.prototype.reloadAllDataSets = function() {
    if (applicationLoading) {
        return
    }
    applicationLoading = true;
    ApplicationLoadingHandling();
    this.confirmLoadSets(this.getDataSetsForLoad(MCObject.ALL), "applicationReload", MC.reloadFinished, false, true)
};
MCObject.prototype.reloadFinished = function() {
    applicationLoading = false;
    ApplicationDoneLoadingHandling()
};
MCObject.prototype.getDataSetsForBase = function(C) {
    if (C) {
        return this.baseMap[C]
    }
    return {}
};
MCObject.prototype.metaPreLoad = function(D) {
    var C = "/api/meta/wbi";
    if (settings.memorexMeta) {
        if (settings.emulator) {
            if (session.requestedLocale == "default") {
                C = "meta/English/wbi.json"
            } else {
                if (getCookie("language") != null) {
                    C = "meta/" + getCookie("language") + "/wbi.json"
                }
            }
        } else {
            C = "meta/wbi.json"
        }
    } else {
        if (settings.testwbi) {
            C = settings.testwbiUrl
        }
    }
    RB.makeRequest({
        url: C,
        httpReqType: "GET",
        callback: createObjectCallback(this, this.__handleMetaPreLoad),
        retries: 3,
        metaCallback: D
    })
};
MCObject.prototype.__handleMetaPreLoad = function(F, E) {
    if (!F || E.textStatus != "success") {
        MC.errorOutput("handleMetaPreLoad: Error getting metadata!")
    }
    if (F && F.objects) {
        var D = F.objects.length;
        for (var C = 0; C < D; C++) {
            var H = F.objects[C];
            if (H) {
                var G = H.basetype;
                if (APIObject.classes[G]) {
                    APIObject.setMeta(G, H)
                }
            }
        }
    }
    if (settings.isV3) {
        meta.volumes.prop.health_numeric.renderer = TableInator.healthIntercept;
        meta.pools.prop.health_numeric.renderer = TableInator.healthIntercept;
        meta["disk-groups"].prop.health_numeric.renderer = TableInator.healthIntercept;
        meta.volumes.prop.volume_group.renderer = TableInator.volumeGroupIntercept;
        APISchedules.addNormalizedTaskMeta()
    }
    if (E.metaCallback) {
        E.metaCallback()
    }
};
MCObject.prototype.register = function(C) {
    this.dataSets[C.name] = C;
    this.addBaseMaps(C);
    this.numDataSets++;
    return C
};
MCObject.prototype.updateAllSets = function(C) {
    for (_a in this.dataSets) {
        MC[_a].requestData({
            update: true
        })
    }
};
MCObject.prototype.updateSets = function(F, D) {
    if (F) {
        var E = D || "execCommand";
        if (F == "all") {
            this.updateAllSets()
        } else {
            if (F instanceof Array && F.length > 0) {
                if (F[0] == "all") {
                    this.updateAllSets()
                } else {
                    for (var C = 0; C < F.length; C++) {
                        if (MC[F[C]] != undefined && MC[F[C]].access.method != DataSet.METHOD.BACKCHANNEL) {
                            MC[F[C]].requestData({
                                update: true,
                                requestor: E
                            })
                        }
                    }
                }
            }
        }
    }
};
MCObject.prototype.confirmLoadSets = function(F, D, G, C, E) {
    if (!F || F.length == 0 || !D || !G || C == undefined) {
        this.errorOutput("MC.confirmLoadSets called with bad parameters!");
        return
    }
    if (this.setsToLoad != undefined) {
        this.errorOutput("Attempt to load sets while previous load pending!");
        return
    }
    this.setsToLoad = F.slice(0);
    this.setsLoaded = [];
    this.setsLoadingRequestor = D;
    this.setsLoadingCallback = G;
    this.setsLoadingSequential = C;
    this.setsLoadingForce = E;
    MC.debugOutput("confirmLoadSets: called with %o", F);
    if (this.setsLoadingSequential) {
        this._setLoadNext()
    } else {
        this._setLoadAll()
    }
};
MCObject.prototype._setTestDone = function() {
    if (!this.setsToLoad || !this.setsLoaded) {
        return true
    }
    if (this.setsLoaded.length == this.setsToLoad.length) {
        delete this.setsToLoad;
        delete this.setsLoaded;
        MC.infoOutput("confirmLoadSets: %s: All done loading, executing callback.", this.setsLoadingRequestor);
        this.setsLoadingCallback();
        return true
    }
    return false
};
MCObject.prototype._setLoaded = function(C) {
    if (C) {
        this.setsLoaded.push(C.name)
    }
    if (!this._setTestDone() && this.setsLoadingSequential) {
        this._setLoadNext()
    }
};
MCObject.prototype._setLoadAll = function() {
    if (!this.setsToLoad || this.setsToLoad.length == 0) {
        return
    }
    for (var C = 0; C < this.setsToLoad.length; C++) {
        if (this.setsLoadingForce || !MC[this.setsToLoad[C]].dataValid) {
            MC[this.setsToLoad[C]].requestData({
                update: this.setsLoadingForce,
                force: true,
                handler: createObjectCallback(this, this._setLoaded),
                requestor: this.setsLoadingRequestor
            })
        } else {
            this.setsLoaded.push(this.setsToLoad[C])
        }
    }
    this._setTestDone()
};
MCObject.prototype._setLoadNext = function() {
    for (var C = 0; C < this.setsToLoad.length; C++) {
        if (this.setsLoaded.find(this.setsToLoad[C]) == -1) {
            if (this.setsLoadingForce || !MC[this.setsToLoad[C]].dataValid) {
                MC[this.setsToLoad[C]].requestData({
                    update: this.setsLoadingForce,
                    force: true,
                    handler: createObjectCallback(this, this._setLoaded),
                    requestor: this.setsLoadingRequestor
                });
                return
            } else {
                this.setsLoaded.push(this.setsToLoad[C])
            }
        }
    }
    this._setTestDone()
};
MCObject.prototype.addDiskGroup = function(E, G) {
    if (E.type == undefined) {
        G.fail = true
    } else {
        if (E.type == "linear") {
            G.fail = this.argsMissing(E, ["level", "name"])
        } else {
            if (E.type == "virtual") {
                G.fail = this.argsMissing(E, ["pool", "level"])
            } else {
                if (E.type == "read-cache") {
                    G.fail = this.argsMissing(E, ["disks", "pool"])
                } else {
                    G.fail = true
                }
            }
        }
    }
    if (!G.fail && (E.type == "linear" || E.type == "virtual")) {
        if (E.level == "raid10" || E.level == "raid50") {
            if (!E.sub1) {
                G.fail = true
            }
        } else {
            if (!E.disks) {
                G.fail = true
            }
        }
    }
    var D = "add/disk-group";
    if (E.type) {
        D += "/type/" + E.type
    }
    if (E.pool) {
        D += "/pool/" + E.pool
    }
    if (E.level) {
        D += "/level/" + E.level
    }
    if (E.level && ((E.level == "raid10") || (E.level == "raid50"))) {
        D += "/disks/";
        var F = "";
        for (i = 1; i <= 10; i++) {
            if (E["sub" + i]) {
                D += F + this.getItemList(E["sub" + i], "location");
                F = ":"
            } else {
                break
            }
        }
    } else {
        if (E.disks) {
            D += "/disks/" + this.getItemList(E.disks, "location")
        }
    }
    if (E.spares) {
        var C = this.getItemList(E.spares, "location");
        if (C.length) {
            D += "/spare/" + C
        }
    }
    if (E.assignedTo) {
        D += "/assigned-to/" + E.assignedTo
    }
    if (E.chunkSize) {
        D += "/chunk-size/" + E.chunkSize
    }
    if (E.mode) {
        D += "/mode/" + E.mode
    }
    if (E.name) {
        D += '/"' + E.name + '"'
    }
    if ((E.diskType == "SATA-S") || (E.diskType == "SAS-S")) {
        G.confirmMsg = strings.driveSelection.singlePorted;
        G.okLabel = strings.okButtonText;
        G.cancelLabel = strings.cancelButtonText
    }
    G.dataRefresh = ["poolsSet", "disksSet"];
    this.execCommand(D, G)
};
MCObject.prototype.expandDiskGroup = function(D, E) {
    var C = "expand/disk-group/" + D.vdisk;
    if (D.disks) {
        C += "/disks/" + this.getItemList(D.disks, "location")
    }
    E.dataRefresh = ["poolsSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.clearMetadata = function(D, E) {
    if (!D || !D.disks) {
        return
    }
    var C = "clear/disk-metadata";
    C += "/" + this.getItemList(D.disks, "location");
    E.dataRefresh = ["disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setStorage = function(D, E) {
    if (!D || D.overcommit == undefined) {
        return
    }
    var C = "set/storage/overcommit/" + (D.overcommit ? "enabled" : "disabled");
    E.dataRefresh = ["systemParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setPool = function(D, E) {
    if (!D || !D.pool) {
        return
    }
    var C = "set/pool/" + D.pool;
    if (D.lowThreshold) {
        C += "/low-threshold/" + D.lowThreshold + "%"
    }
    if (D.midThreshold) {
        C += "/middle-threshold/" + D.midThreshold + "%"
    }
    if (D.overcommit != undefined) {
        C += "/overcommit/" + (D.overcommit == true ? "enabled" : "disabled")
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setDiskGroup = function(D, E) {
    if (!D.dgSerial) {
        E.fail = true
    }
    var C = "set/disk-group/" + D.dgSerial;
    if (D.dgName) {
        C += "/name/" + D.dgName
    }
    if (D.dgOwner) {
        C += "/owner/" + D.dgOwner
    }
    if (typeof D.dgSpinEnabled != "undefined") {
        if (D.dgSpinEnabled) {
            if (D.dgSpinDelay) {
                C += "/spin-down-delay/" + D.dgSpinDelay
            } else {
                C += "/spin-down-delay/15"
            }
        } else {
            C += "/spin-down-delay/0"
        }
    }
    if (D.dgScrubDurationGoal) {
        C += "/scrub-duration-goal/" + D.dgScrubDurationGoal
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setVolume = function(D, E) {
    var C = "set/volume/" + D.serial;
    if (D.name) {
        C += "/name/" + D.name
    }
    if (D.preference) {
        C += "/tier-affinity/" + D.preference
    }
    E.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setVolumeName = function(D, E) {
    E.fail = this.argsMissing(D, ["volumeName", "volumeSerial"]);
    var C = "set/volume/" + D.volumeSerial + '/name/"' + D.volumeName + '"';
    E.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.modifyVdiskSpareSet = function(D, E) {
    E.fail = this.argsMissing(D, ["vdiskSerial", "spares"]);
    var C = "add/spares/" + this.getItemList(D.spares, "location") + "/vdisk/" + D.vdiskSerial;
    E.dataRefresh = ["poolsSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.removeDiskSpareSet = function(D, E) {
    E.fail = this.argsMissing(D, ["spares"]);
    var C = "remove/spares/" + this.getItemList(D.spares, "location");
    E.dataRefresh = ["poolsSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.modifyGlobalSpareSet = function(D, E) {
    E.fail = this.argsMissing(D, ["spares"]);
    var C = "add/spares/" + this.getItemList(D.spares, "location");
    E.dataRefresh = ["poolsSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.expandVolume = function(D, E) {
    E.fail = this.argsMissing(D, ["volumeSerial", "volumeSize"]);
    var C = "expand/volume/" + D.volumeSerial + "/size/" + D.volumeSize;
    E.dataRefresh = ["poolsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.modifyVolumeCache = function(D, E) {
    E.fail = this.argsMissing(D, ["volumeSerial"]);
    var C = "set/cache-parameters/" + D.volumeSerial;
    if (D.writePolicy) {
        C += "/write-policy/" + D.writePolicy
    }
    if (D.optimization) {
        C += "/optimization/" + D.optimization
    }
    if (D.readAhead) {
        C += "/read-ahead-size/" + D.readAhead
    }
    E.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createVolume = function(D, E) {
    E.fail = this.argsMissing(D, ["size", "name"]);
    if (!D.pool && !D.vdisk) {
        E.fail = true
    }
    var C = "create/volume";
    if (D.pool) {
        C += '/pool/"' + D.pool + '"'
    } else {
        if (D.vdisk) {
            C += '/vdisk/"' + D.vdisk + '"'
        }
    }
    if (D.size) {
        C += "/size/" + D.size
    }
    if (RI.hasFeature("e2ePi") && D.piSetting != undefined) {
        C += "/host-pi-type/" + (D.piSetting ? "T1" : "T0")
    }
    if (RI.hasFeature("dms") && D.snappable) {
        C += "/snappable"
    }
    if (RI.hasFeature("dms") && D.snapPool) {
        C += '/snap-pool/"' + D.snapPool + '"'
    } else {
        if (RI.hasFeature("dms") && D.reserve) {
            C += "/reserve/" + D.reserve
        }
    }
    if (RI.hasFeature("rsr") && D.prepareReplication) {
        C += "/prepare-replication-volume"
    }
    if (RI.hasFeature("volumeGroups") && D.group) {
        C += '/volume-group/"' + D.group + '"'
    }
    if (D.access) {
        C += "/access/" + D.access
    }
    if (RI.hasFeature("volTierPreference") && D.preference) {
        C += "/tier-affinity/" + D.preference
    }
    if (D.ports) {
        C += "/ports/" + D.ports.join(",")
    }
    if (D.lun) {
        C += "/lun/" + D.lun
    }
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createVolumeSet = function(D, E) {
    E.fail = this.argsMissing(D, ["size", "baseName", "count"]);
    if (!D.pool && !D.vdisk) {
        E.fail = true
    }
    var C = "create/volume-set";
    if (D.pool) {
        C += '/pool/"' + D.pool + '"'
    } else {
        if (D.vdisk) {
            C += '/vdisk/"' + D.vdisk + '"'
        }
    }
    if (D.baseName) {
        C += '/basename/"' + D.baseName + '"'
    }
    if (D.size) {
        C += "/size/" + D.size
    }
    if (D.count) {
        C += "/count/" + D.count
    }
    if (RI.hasFeature("e2ePi") && D.piSetting != undefined) {
        C += "/host-pi-type/" + (D.piSetting ? "T1" : "T0")
    }
    if (RI.hasFeature("volumeGroups") && D.group) {
        C += '/volume-group/"' + D.group + '"'
    }
    if (RI.hasFeature("volTierPreference") && D.preference) {
        C += "/tier-affinity/" + D.preference
    }
    if (D.access) {
        C += "/access/" + D.access;
        if (D.access != "no-access") {
            if (D.baseLun) {
                C += "/baselun/" + D.baseLun
            }
            if (D.ports) {
                C += "/ports/" + D.ports.join(",")
            }
        }
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteVolumes = function(D, E) {
    var C = "delete/volumes/";
    if (D.volumes) {
        C += this.getItemList(D.volumes, "serial_number")
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "mapsSet", "schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteSnapshot = function(D, E) {
    var C = "delete/snapshot/force/";
    if (D.volumes) {
        C += this.getItemList(D.volumes, "serial_number")
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "mapsSet", "schedulesSet", "snapshotsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.removeDiskGroups = function(D, E) {
    E.fail = this.argsMissing(D, ["diskGroups"]);
    var C = "remove/disk-groups/" + D.diskGroups + "/prompt/yes";
    E.dataRefresh = ["volumeGroupsSet", "poolsSet", "poolStatisticsSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.unmapVolumes = function(D, E) {
    var C = "unmap/volume/";
    if (D.volumes) {
        C += this.getItemList(D.volumes, "serial_number")
    }
    if (D.volumeList) {
        C += D.volumeList
    }
    C += "/host/ALL";
    E.dataRefresh = ["mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.mapVolumes = function(D, E) {
    var C = "map/volume/";
    if (D.volumes) {
        C += this.getItemList(D.volumes, "serial_number") + "/"
    }
    if (D.ports && D.ports.length > 0) {
        C += "port/" + D.ports.join(",") + "/"
    }
    if (D.lun) {
        C += "lun/" + D.lun + "/"
    }
    if (D.access) {
        C += "access/" + D.access + "/"
    }
    if (D.host) {
        C += "host/" + D.host + "/"
    }
    E.dataRefresh = ["mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createSnapshots = function(D, E) {
    var C;
    C = 'create/snapshots/volumes/"';
    if (D.volumeNames) {
        C += this.getItemList(D.volumeNames)
    }
    C += '"/"';
    if (D.snapshotNames) {
        C += this.getItemList(D.snapshotNames)
    }
    C += '"/';
    E.dataRefresh = ["licenseSet", "volumeGroupsSet", "mapsSet", "snapshotsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createSnapshotSet = function(D, E) {
    E.fail = this.argsMissing(D, ["volumes"]);
    var C = "create/snapshots";
    C += "/volumes/" + this.getItemList(D.volumes, "serial_number");
    C += "/" + DataSet.generateSnapshotNameFromSet(D.volumes);
    E.dataRefresh = ["volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.copyVolume = function(D, E) {
    var C = "volumecopy";
    if (D.useNewCommand) {
        C = "copy/volume/";
        if (D.volumeName) {
            C += D.volumeName
        }
        if (D.destPool) {
            C += '/destination-pool/"' + D.destPool + '"'
        }
        if (D.volcopyName) {
            C += '/name/"' + D.volcopyName + '"'
        }
    } else {
        if (D.volumeName) {
            C += '/source-volume/"' + D.volumeName + '"'
        }
        if (D.vdiskName) {
            C += '/dest-vdisk/"' + D.vdiskName + '"'
        }
        if (D.modifiedSnapshot == true) {
            C += "/modified-snapshot/yes"
        }
        if (D.volcopyName) {
            C += '/"' + D.volcopyName + '"'
        }
    }
    E.dataRefresh = ["volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.abortCopyVolume = function(D, E) {
    var C = "abort";
    if (D.type == "virtual") {
        if (D.volume) {
            C += '/copy/"' + D.volume + '"'
        }
    } else {
        if (D.volumeName) {
            C += '/volumecopy/"' + D.volumeName + '"'
        }
    }
    E.dataRefresh = ["volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.rollbackVolume = function(D, E) {
    E.fail = this.argsMissing(D, ["volumeName", "snapshotName"]);
    var C = "rollback";
    if (D.volumeName) {
        C += '/volume/"' + D.volumeName + '"'
    }
    if (D.snapshotName) {
        C += '/snapshot/"' + D.snapshotName + '"'
    }
    if (D.modifiedSnapshot == true) {
        C += "/modifiedsnapshot/yes"
    }
    E.dataRefresh = ["volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.resetSnapshot = function(D, E) {
    var C = "reset";
    if (D.snapshotName) {
        C += '/snapshot/"' + D.snapshotName + '"'
    }
    C += "/prompt/yes";
    E.dataRefresh = ["volumeGroupsSet", "mapsSet", "snapshotsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createHostName = function(D, E) {
    var C = "create/host";
    if (D.hostId) {
        C += '/id/"' + D.hostId + '"'
    }
    if (D.profile) {
        C += '/profile/"' + D.profile + '"'
    }
    if (D.hostName) {
        C += '/"' + D.hostName + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createHost = function(D, E) {
    var C = "create/host";
    if (D.hostGroup) {
        C += '/host-group/"' + D.hostGroup + '"'
    }
    if (D.hostName) {
        C += '/"' + D.hostName + '"'
    }
    if (D.initiators) {
        C += '/initiators/"' + D.initiators + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createHostGroup = function(D, E) {
    var C = "create/host-group";
    if (D.hostGroupName) {
        C += '/"' + D.hostGroupName + '"'
    }
    if (D.hosts) {
        C += '/hosts/"' + D.hosts + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.addHostMembers = function(D, E) {
    var C = "add/host-members";
    if (D.hostName) {
        C += '/"' + D.hostName + '"'
    }
    if (D.initiators) {
        C += '/initiators/"' + D.initiators + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.addHostGroupMembers = function(D, E) {
    var C = "add/host-group-members";
    if (D.hostGroupName) {
        C += '/"' + D.hostGroupName + '"'
    }
    if (D.hosts) {
        C += '/hosts/"' + D.hosts + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.removeHostGroupMembers = function(D, E) {
    var C = "remove/host-group-members";
    if (D.hostGroupName) {
        C += '/"' + D.hostGroupName + '"'
    }
    if (D.hosts) {
        C += '/hosts/"' + D.hosts + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.removeHostMembers = function(D, E) {
    var C = "remove/host-members";
    if (D.hostName) {
        C += '/"' + D.hostName + '"'
    }
    if (D.initiators) {
        C += '/initiators/"' + D.initiators + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.renameHostNickname = function(D, E) {
    E.fail = this.argsMissing(D, ["hostName", "hostId"]);
    var C = 'set/host-name/id/"' + D.hostId + '"';
    if (D.profile) {
        C += '/profile/"' + D.profile + '"'
    }
    C += '/"' + D.hostName + '"';
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteHostName = function(D, E) {
    var C = "delete/host/";
    if (D.hosts) {
        C += this.getItemList(D.hosts, "host_id")
    }
    E.dataRefresh = ["hostGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteHost = function(D, E) {
    var C = "delete/hosts";
    if (D.list) {
        C += '/"' + this.getItemList(D.list) + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setHost = function(D, E) {
    var C = "set/host";
    if (D.newName) {
        C += '/name/"' + D.newName + '"'
    }
    if (D.profile) {
        C += '/profile/"' + D.profile + '"'
    }
    if (D.nickname) {
        C += '/"' + D.nickname + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteHostGroups = function(D, E) {
    var C = "delete/host-groups";
    if (D.groupList) {
        C += '/"' + this.getItemList(D.groupList) + '"'
    }
    if (D.allHosts) {
        C += "/all-hosts"
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setHostGroup = function(D, E) {
    var C = "set/host-group/";
    if (D.newName) {
        C += '"' + D.name + '"'
    }
    if (D.newName) {
        C += '/name/"' + D.newName + '"'
    }
    E.dataRefresh = ["hostGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.configureCHAPEntry = function(D, E) {
    var C = "create/chap-record";
    if (D.hostId) {
        C += '/name/"' + D.hostId + '"'
    }
    if (D.hostSecret) {
        C += '/secret/"' + D.hostSecret + '"'
    }
    if (D.mutualId) {
        C += '/mutual-name/"' + D.mutualId + '"'
    }
    if (D.mutualSecret) {
        C += '/mutual-secret/"' + D.mutualSecret + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "chapRecordsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteCHAPEntry = function(D, E) {
    var C = "delete/chap-record";
    if (D.hostId) {
        C += '/name/"' + D.hostId + '"'
    }
    E.dataRefresh = ["hostGroupsSet", "chapRecordsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.mapVolume = function(D, E) {
    var C = "map/volume";
    if (D.volumeName) {
        C += '/"' + D.volumeName + '"'
    }
    if (D.ports && D.ports.length > 0) {
        C += "/port/" + D.ports.join(",")
    }
    if (D.lun != undefined) {
        C += "/lun/" + D.lun
    }
    if (D.access) {
        C += "/access/" + D.access
    }
    if (D.host) {
        C += '/host/"' + D.host + '"'
    }
    E.dataRefresh = ["mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.unmapVolume = function(D, E) {
    var C = "unmap/volume";
    if (D.volumeName) {
        C += '/"' + D.volumeName + '"'
    }
    if (D.host) {
        C += '/host/"' + D.host + '"'
    }
    E.dataRefresh = ["mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setNetworkParameters = function(D, E) {
    var C = "set/network-parameters";
    if (D.dhcp) {
        C += "/dhcp"
    } else {
        if (D.ipv) {
            C += "/ipv " + D.ipv
        }
        C += "/ip/" + D.ip;
        C += "/gateway/" + D.gateway;
        C += "/netmask/" + D.netmask;
        C += "/controller/" + D.controller
    }
    E.dataRefresh = ["enclosuresSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSystemInfo = function(H, I) {
    var D = ((H.siName instanceof Object) ? H.siName.value : H.siName);
    var C = ((H.siContact instanceof Object) ? H.siContact.value : H.siContact);
    var E = ((H.siLocation instanceof Object) ? H.siLocation.value : H.siLocation);
    var F = ((H.siInfo instanceof Object) ? H.siInfo.value : H.siInfo);
    var G = "set/system";
    if (D == undefined && C == undefined && E == undefined && F == undefined) {
        return
    }
    if (D != undefined) {
        G += (D.length == 0) ? '/name/" "' : '/name/"' + D + '"'
    }
    if (C != undefined) {
        G += (C.length == 0) ? '/contact/" "' : '/contact/"' + C + '"'
    }
    if (E != undefined) {
        G += (E.length == 0) ? '/location/" "' : '/location/"' + E + '"'
    }
    if (F != undefined) {
        G += (F.length == 0) ? '/info/" "' : '/info/"' + F + '"'
    }
    I.dataRefresh = ["systemInfoSet"];
    this.execCommand(G, I)
};
MCObject.prototype.setPassphrase = function(F, G) {
    var D = ((F.passphrase instanceof Object) ? F.passphrase.value : F.passphrase);
    var C = ((F.currentPphrase instanceof Object) ? F.currentPphrase.value : F.currentPphrase);
    if (!D) {
        return
    }
    var E = 'set/fde-lock-key/passphrase/"';
    E += D + '"';
    if (C) {
        E += '/current-passphrase/"' + C + '"'
    }
    E += "/noprompt";
    G.dataRefresh = ["fdeStateSet"];
    this.execCommand(E, G)
};
MCObject.prototype.secureFdeSystem = function(E, F) {
    var C = ((E.currentPphrase instanceof Object) ? E.currentPphrase.value : E.currentPphrase);
    if (!C) {
        return
    }
    var D = 'set/fde-state/secure/passphrase/"' + C + '"/noprompt';
    F.dataRefresh = ["fdeStateSet", "disksSet"];
    this.execCommand(D, F)
};
MCObject.prototype.repurposeFdeSystem = function(D, E) {
    var C = "set/fde-state/repurpose/noprompt";
    E.dataRefresh = ["fdeStateSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.importLockKeyId = function(E, F) {
    var C = ((E.importPphrase instanceof Object) ? E.importPphrase.value : E.importPphrase);
    var D = "set/fde-import-key";
    if (!C) {
        return
    }
    D += '/passphrase/"' + C + '"/noprompt';
    F.dataRefresh = ["fdeStateSet", "disksSet"];
    this.execCommand(D, F)
};
MCObject.prototype.repurposeFDEDisks = function(D, E) {
    var C = "set/disk/repurpose";
    if (!D.disks) {
        return
    }
    C += "/" + this.getItemList(D.disks, "location");
    E.dataRefresh = ["fdeStateSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.clearFDEKeys = function(E, F) {
    var C = E.currentPphrase.value;
    if (!C && !E.noPass) {
        F.fail = true
    }
    var D = "clear/fde-keys";
    if (!E.noPass) {
        D += '/current-passphrase/"' + C + '"'
    }
    F.dataRefresh = ["fdeStateSet"];
    this.execCommand(D, F)
};
MCObject.prototype.setProtocols = function(G, J) {
    if ((RI.feature("storageModel") == "HYBRID") && G && G.managementVersion) {
        G["management-mode"] = G.managementVersion
    }
    var C = {
        debug: true,
        ftp: true,
        sftp: true,
        http: true,
        https: true,
        "management-mode": true,
        service: true,
        ses: true,
        smis: true,
        usmis: true,
        snmp: true,
        ssh: true,
        telnet: true,
        activity: true,
        slp: true,
        "ssh-port": true,
        "sftp-port": true
    };
    if (G.sshPort) {
        G["ssh-port"] = G.sshPort
    }
    if (G.sftpPort) {
        G["sftp-port"] = G.sftpPort
    }
    var F = "set/protocols";
    var E = false;
    for (var D in G) {
        var I;
        if (C[D]) {
            var H;
            if ((typeof G[D]) != "object") {
                H = G[D]
            } else {
                H = G[D].value
            }
            if ((typeof H) == "boolean") {
                I = H ? "enabled" : "disabled"
            } else {
                I = H
            }
            if (I == "enabled" || I == "disabled" || D == "management-mode" || D == "ssh-port" || D == "sftp-port") {
                E = true;
                F += ("/" + D + "/" + I)
            }
        }
    }
    if (E) {
        MC.debugOutput("Executing setProtocols command: %s", F);
        J.dataRefresh = ["protocolsSet"];
        this.execCommand(F, J)
    }
};
MCObject.prototype.setUserInteraction = function(D, E) {
    var C = "set/user-interactions";
    if (D.bypassLicense) {
        C += "/bypass-license-config/" + D.bypassLicense
    }
    if (D.bypassPort) {
        C += "/bypass-port-config/" + D.bypassPort
    }
    if (D.bypassEasyStart) {
        C += "/bypass-easy-start/" + D.bypassEasyStart
    }
    if (D.bypassFirmware) {
        C += "/bypass-firmware/" + D.bypassFirmware
    }
    if (D.bypassNotifications) {
        C += "/bypass-notifications/" + D.bypassNotifications
    }
    this.execCommand(C, E)
};
MCObject.prototype.setIscsiParameters = function(F, I) {
    var E = {
        iscsi_chap: "chap",
        iscsi_jumbo: "jumbo-frame",
        iscsi_speed: "speed",
        iscsi_isns: "isns",
        iscsi_isns_ip: "isns-ip",
        iscsi_isns_alt_ip: "isns-alt-ip",
        iscsi_ip_version: "iscsi-ip-version"
    };
    var D = "set/iscsi-parameters";
    var C = false;
    for (var H in F) {
        var G;
        if (E[H]) {
            if ((typeof F[H]) == "object") {
                G = F[H].value
            } else {
                G = F[H]
            }
            if (typeof(G) == "boolean") {
                D += "/" + E[H] + "/" + (G ? "enabled" : "disabled")
            } else {
                D += "/" + E[H] + "/" + G
            }
            C = true
        }
    }
    if (C) {
        MC.debugOutput("Executing setIscsiParameters command: %s", D);
        I.dataRefresh = ["iscsiParametersSet"];
        this.execCommand(D, I)
    }
};
MCObject.prototype.setIBParameters = function(F, I) {
    var E = {
        IB_chap: "chap"
    };
    var D = "set/infiniband-parameters";
    var C = false;
    for (var H in F) {
        var G;
        if (E[H]) {
            if ((typeof F[H]) == "object") {
                G = F[H].value
            } else {
                G = F[H]
            }
            if (typeof(G) == "boolean") {
                D += "/" + E[H] + "/" + (G ? "enabled" : "disabled")
            } else {
                D += "/" + E[H] + "/" + G
            }
            C = true
        }
    }
    if (C) {
        MC.debugOutput("Executing setIBParameters command: %s", D);
        I.dataRefresh = ["infiniBandParametersSet"];
        this.execCommand(D, I)
    }
};
MCObject.prototype.setPort = function(H, D) {
    var I = {
        speed: true,
        mode: true,
        IP: true,
        netmask: true,
        gateway: true,
        iscsi_ip_version: true,
        defaultRouter: true
    };
    var G = "set/host-parameters";
    var C = false;
    if (H.port && H.params) {
        G += ("/channel/" + H.port);
        for (var J in H.params) {
            var F = J;
            if (I[F]) {
                if (F == "mode") {
                    F = "fibre-connection-mode"
                }
                if (F == "defaultRouter") {
                    F = "default-router"
                }
                var E = H.params[J];
                G += ("/" + F + "/" + E);
                C = true
            }
        }
        if (H.params.ipVersion) {
            G += "/iscsi-ip-version/" + H.params.ipVersion
        }
    }
    if (H.fanout) {
        var K = (H.fanout.value == true) ? "enable" : "disable";
        G += "/fan-out/" + K
    }
    MC.debugOutput("Executing setPort command: %s", G);
    D.dataRefresh = ["enclosuresSet"];
    this.execCommand(G, D)
};
MCObject.prototype.setAdvancedSettings = function(J, E) {
    var K = {
        background_scrub: "background-scrub",
        background_scrub_interval: "background-scrub-interval",
        partner_firmware_upgrade: "partner-firmware-upgrade",
        utility_priority: "utility-priority",
        smart: "smart",
        dynamic_spares: "dynamic-spares",
        emp_poll_rate: "emp-poll-rate",
        host_cache_control: "host-cache-control",
        sync_cache_mode: "sync-cache-mode",
        missing_lun_response: "missing-lun-response",
        controller_failure: "controller-failure",
        super_cap_failure: "super-cap-failure",
        compact_flash_failure: "compact-flash-failure",
        power_supply_failure: "power-supply-failure",
        fan_failure: "fan-failure",
        temperature_exceeded: "temperature-exceeded",
        partner_notify: "partner-notify",
        auto_write_back: "auto-write-back",
        disk_dsd_enable: "spin-down",
        disk_dsd_delay: "spin-down-delay",
        background_disk_scrub: "background-disk-scrub",
        managed_logs: "managed-logs",
        independent_cache: "independent-cache"
    };
    var I = "set/advanced-settings";
    var C = false;
    for (var H in J) {
        var F;
        if (K[H]) {
            var D;
            var G;
            if ((typeof J[H]) == "object") {
                G = J[H].value
            } else {
                G = J[H]
            }
            if (K[H] == "spin-down-delay") {
                if (G == "") {
                    G = "15"
                }
                D = G
            } else {
                if (K[H] == "background-scrub-interval") {
                    if (G == "") {
                        G = "24"
                    }
                    D = G
                } else {
                    if ((K[H] == "emp-poll-rate") || (K[H] == "utility-priority")) {
                        D = G
                    } else {
                        if (G == true) {
                            D = "enabled"
                        } else {
                            if (G == false) {
                                D = "disabled"
                            } else {
                                D = G
                            }
                        }
                    }
                }
            }
            I += ("/" + K[H] + "/" + D);
            C = true
        }
    }
    if (C) {
        MC.debugOutput("Executing setAdvancedSettings command: %s", I);
        E.dataRefresh = ["advancedSettingsSet"];
        this.execCommand(I, E)
    }
};
MCObject.prototype.login = function(D) {
    var C = "login/";
    D.dataRefresh = [];
    D.dataType = "wbi";
    this.execCommand(C, D)
};
MCObject.prototype.logout = function(D, E) {
    var C = "logout/";
    if (D.key) {
        C += D.key
    }
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.validate = function(D, E) {
    var C = "validate/";
    if (D.key) {
        C += D.key
    }
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.locales = function(D, E) {
    var C = "locales/";
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.id = function(D, E) {
    var C = "id/";
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.collectDebugData = function(D, E) {
    MC.saveLogsInProcess = true;
    var C = "collectDebugData/" + D;
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.restoreSystemDefaults = function(D, E) {
    var C = "restore/defaults/noprompt";
    E.dataRefresh = ["all"];
    this.execCommand(C, E)
};
MCObject.prototype.verifyVdisk = function(D, E) {
    var C = "verify/disk-groups/";
    if (D.vdiskSerial) {
        C += D.vdiskSerial
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.abortVerifyVdisk = function(D, E) {
    var C = "abort/verify/disk-group/";
    if (D.vdiskSerial) {
        C += D.vdiskSerial
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.mediaScrubVdisk = function(D, E) {
    var C = "scrub/disk-groups/";
    if (D.vdiskSerial) {
        C += D.vdiskSerial
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.abortMediaScrubVdisk = function(D, E) {
    var C = "abort/scrub/disk-group/";
    if (D.vdiskSerial) {
        C += D.vdiskSerial
    }
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setTimeValues = function(F, H) {
    var D = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
    var E = "set/controller-date";
    if (F.ntp_state != undefined) {
        E += "/ntp/" + ((F.ntp_state == true) ? "Enabled" : "Disabled")
    }
    if (F.date) {
        E += "/" + D[F.date.getMonth()] + "/" + F.date.getDate() + "/" + F.date.getHours() + ":" + F.date.getMinutes() + ":" + F.date.getSeconds() + "/" + F.date.getFullYear()
    }
    if (F.time_zone_offset) {
        var C = ((typeof F.time_zone_offset) == "object") ? F.time_zone_offset.value : F.time_zone_offset;
        E += "/timezone/" + C
    }
    if (F.ntp_address) {
        var G = ((typeof F.ntp_address) == "object") ? F.ntp_address.value : F.ntp_address;
        E += "/ntpaddress/" + G
    }
    H.dataRefresh = ["timeSettingsSet"];
    this.execCommand(E, H)
};
MCObject.prototype.setIpVersion = function(E, F) {
    var C = E.ipVersionOption;
    var D = "set/iscsi-version/";
    D += C;
    this.execCommand(D, F)
};
MCObject.prototype.createSystemUser = function(E, F) {
    F.fail = this.argsMissing(E, ["username"]);
    var C = false;
    var D = "create/user/";
    if (E.roles && E.roles.length > 0) {
        D += "roles/" + this.getItemList(E.roles) + "/"
    }
    if (E.type) {
        D += "type/" + E.type + "/"
    }
    if (!E.doSnmp || E.doSnmp == "false") {
        if (E.interfaces) {
            D += "interfaces/" + E.interfaces + "/"
        }
    } else {
        C = true;
        D += (E.snmp_user_or_target == "user" ? "interfaces/snmpuser/" : "interfaces/snmptarget/")
    }
    if (E.base) {
        D += "base/" + E.base + "/"
    }
    if (E.precision) {
        D += "precision/" + E.precision + "/"
    }
    if (E.units) {
        D += "units/" + E.units + "/"
    }
    if (E.temperatureScale) {
        D += "temperature-scale/" + E.temperatureScale + "/"
    }
    if (E.timeout) {
        D += "timeout/" + E.timeout + "/"
    }
    if (E.locale) {
        D += "locale/" + E.locale + "/"
    }
    if (C) {
        if (E.authentication) {
            D += "authentication-type/" + E.authentication + "/"
        }
        if (E.encryption) {
            D += "privacy-type/" + E.encryption + "/"
        }
        if (E.privacyPwdInput) {
            D += 'privacy-password/"' + E.privacyPwdInput + '"/'
        }
        if (E.destination) {
            D += "trap-host/" + E.destination + "/"
        }
    }
    D += (E.password) ? 'password/"' + E.password + '"/' : 'password/""/';
    if (E.username) {
        D += E.username + "/"
    }
    if (session.userName.get() != "setup") {
        F.dataRefresh = ["usersSet"]
    }
    this.execCommand(D, F)
};
MCObject.prototype.modifySystemUser = function(D, E) {
    E.fail = this.argsMissing(D, ["username"]);
    var C = "set/user/";
    if (D.username != "manage" && D.roles && D.roles.length > 0) {
        C += "roles/" + this.getItemList(D.roles) + "/"
    }
    if (D.type) {
        C += "type/" + D.type + "/"
    }
    if (!D.doSnmp) {
        if (D.interfaces) {
            C += "interfaces/" + D.interfaces + "/"
        }
    } else {
        if (D.snmp_user_or_target) {
            C += (D.snmp_user_or_target == "user" ? "interfaces/snmpuser/" : "interfaces/snmptarget/")
        }
    }
    if (D.base) {
        C += "base/" + D.base + "/"
    }
    if (D.precision) {
        C += "precision/" + D.precision + "/"
    }
    if (D.units) {
        C += "units/" + D.units + "/"
    }
    if (D.temperatureScale) {
        C += "temperature-scale/" + D.temperatureScale + "/"
    }
    if (D.timeout) {
        C += "timeout/" + D.timeout + "/"
    }
    if (D.locale) {
        C += "locale/" + D.locale + "/"
    }
    if (D.authentication) {
        C += "authentication-type/" + D.authentication + "/"
    }
    if (D.encryption) {
        C += "privacy-type/" + D.encryption + "/"
    }
    if (D.privacyPwdInput) {
        C += "privacy-password/" + D.privacyPwdInput + "/"
    }
    if (D.destination) {
        C += "trap-host/" + D.destination + "/"
    }
    if (D.password) {
        C += 'password/"' + D.password + '"/'
    }
    if (D.username) {
        C += D.username + "/"
    }
    E.dataRefresh = ["usersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteSystemUser = function(D, E) {
    E.fail = this.argsMissing(D, ["username"]);
    var C = "delete/user/" + D.username;
    E.dataRefresh = ["usersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.dequarantineVdisk = function(D, E) {
    E.fail = this.argsMissing(D, ["vdiskSerial"]);
    var C = "dequarantine/disk-group/" + D.vdiskSerial;
    E.dataRefresh = ["poolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.resetHostChannel = function(D, E) {
    E.fail = this.argsMissing(D, ["ports"]);
    var C = "reset/host-link/ports/" + D.ports;
    this.execCommand(C, E)
};
MCObject.prototype.setHostPortMode = function(D, E) {
    var C = "set/host-port-mode/" + D.mode;
    this.execCommand(C, E)
};
MCObject.prototype.rescanDiskChannel = function(D, E) {
    var C = "rescan";
    this.execCommand(C, E)
};
MCObject.prototype.setEmailParameters = function(D, E) {
    var C = "set/email-parameters";
    if (D.server) {
        C += "/server/" + D.server
    }
    if (D.domain) {
        C += "/domain/" + D.domain
    }
    if (D.sender) {
        C += "/sender/" + D.sender
    }
    if (D.emails) {
        C += '/email-list/"' + D.emails + '"'
    }
    if (D.level) {
        C += "/notification-level/" + D.level
    }
    if (typeof D.persistentAlerts != "undefined") {
        C += "/persistent-alerts/" + (D.persistentAlerts ? "enabled" : "disabled")
    }
    if (typeof D.includeLogs != "undefined") {
        C += "/include-logs/" + (D.includeLogs ? "enabled" : "disabled")
    }
    if (typeof D.port != "undefined" && D.port) {
        C += "/port/" + D.port
    }
    if (typeof D.senderPassword != "undefined") {
        C += "/sender-password/" + D.senderPassword
    }
    C += "/security-protocol/" + D.protocol;
    E.dataRefresh = ["emailParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSnmpParameters = function(D, E) {
    var C = "set/snmp-parameters";
    if (D.level) {
        C += "/enable/" + D.level
    }
    if (D.readCommunity) {
        C += '/read-community/"' + D.readCommunity + '"'
    }
    if (D.writeCommunity) {
        C += '/write-community/"' + D.writeCommunity + '"'
    }
    if (D.hosts) {
        C += '/trap-host-list/"' + D.hosts + '"'
    }
    E.dataRefresh = ["snmpParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSyslogParameters = function(D, E) {
    var C = "set/syslog-parameters";
    if (D.level) {
        C += "/notification-level/" + D.level
    }
    if (D.hostIP) {
        C += "/host-ip/" + D.hostIP
    }
    if (D.hostPort) {
        C += "/host-port/" + D.hostPort
    }
    E.dataRefresh = ["syslogParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.clearDnsParameters = function(D, E) {
    var C = "clear/dns-parameters";
    E.dataRefresh = ["dnsParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setDnsParameters = function(D, E) {
    var C = "set/dns-parameters";
    if (D.nameServers) {
        C += "/nameservers/" + D.nameServers
    }
    if (D.searchDomains) {
        C += "/search-domains/" + D.searchDomains
    }
    E.dataRefresh = ["dnsParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSystemCacheParameters = function(D, E) {
    var C = "set/system-cache-parameters";
    if (D.pi_status) {
        C += "/pi-mode/" + D.pi_status.value
    }
    if (D.cache_block_size) {
        C += "/cache-block-size/" + D.cache_block_size.value
    }
    E.dataRefresh = ["cacheParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.testNotification = function(D, E) {
    var C = "test/notification";
    this.execCommand(C, E)
};
MCObject.prototype.testManagedLogs = function(D, E) {
    var C;
    if (D.managedtype.value == "managedlogs") {
        C = "test/managedlogs region"
    } else {
        if (D.managedtype.value == "managedlogswarn") {
            C = "test/managedlogswarn region"
        } else {
            if (D.managedtype.value == "managedlogswrap") {
                C = "test/managedlogswrap region"
            }
        }
    }
    if (D.region) {
        C += '/"' + D.region.value + '"'
    }
    this.execCommand(C, E)
};
MCObject.prototype.testSysLogs = function(D, E) {
    var C = "test/syslog";
    this.execCommand(C, E)
};
MCObject.prototype.createTask = function(D, E) {
    var C = "create/task";
    if (D.type) {
        C += "/type/" + D.type
    }
    if (D.replicationSet) {
        C += "/replication-set/" + D.replicationSet
    }
    if (D.masterVolume) {
        C += '/master-volume/"' + D.masterVolume + '"'
    }
    if (D.snapshotPrefix) {
        C += '/snapshot-prefix/"' + D.snapshotPrefix + '"'
    }
    if (D.retentionCount) {
        C += "/retention-count/" + D.retentionCount
    }
    if (D.snapshotVolume) {
        C += '/snapshot-volume/"' + D.snapshotVolume + '"'
    }
    if (D.sourceVolume) {
        C += '/source-volume/"' + D.sourceVolume + '"'
    }
    if (D.destVdisk) {
        C += '/dest-vdisk/"' + D.destVdisk + '"'
    }
    if (D.destPrefix) {
        C += '/dest-prefix/"' + D.destPrefix + '"'
    }
    if (D.modifiedSnapshot) {
        C += "/modified-snapshot/" + D.modifiedSnapshot
    }
    if (D.replicationMode) {
        C += "/replication-mode/" + D.replicationMode
    }
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    if (D.lastSnapshot) {
        C += '/"' + D.lastSnapshot + '"'
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setTask = function(D, E) {
    var C = "set/task";
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    if (D.replicationSet) {
        C += "/replication-set/" + D.replicationSet
    }
    if (D.snapshotPrefix) {
        C += '/snapshot-prefix/"' + D.snapshotPrefix + '"'
    }
    if (D.retentionCount) {
        C += "/retention-count/" + D.retentionCount
    }
    if (D.destVdisk) {
        C += '/dest-vdisk/"' + D.destVdisk + '"'
    }
    if (D.destPrefix) {
        C += '/dest-prefix/"' + D.destPrefix + '"'
    }
    if (D.modifiedSnapshot) {
        C += "/modified-snapshot/" + D.modifiedSnapshot
    }
    if (D.replicationMode) {
        C += "/replication-mode/" + D.replicationMode
    }
    if (D.lastSnapshot) {
        C += "/last-snapshot/" + D.lastSnapshot
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createSchedule = function(D, E) {
    var C = "create/schedule";
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    if (D.scheduleSpecification) {
        C += '/schedule-specification/"' + D.scheduleSpecification + '"'
    }
    if (D.taskName) {
        C += '/task-name/"' + D.taskName + '"'
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSchedule = function(D, E) {
    var C = "set/schedule";
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    if (D.scheduleSpecification) {
        C += '/schedule-specification/"' + D.scheduleSpecification + '"'
    }
    if (D.taskName) {
        C += '/task-name/"' + D.taskName + '"'
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteTask = function(D, E) {
    var C = "delete/task";
    if (D.name) {
        C += '/"' + D.name + '"'
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteSchedule = function(D, E) {
    var C = "delete/schedule";
    if (D.name) {
        C += '/"' + D.name + '"/prompt/yes'
    }
    E.dataRefresh = ["schedulesSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setLed = function(D, E) {
    var C = "set/led";
    if (D.target) {
        C += "/" + D.target
    }
    if (D.id) {
        C += "/" + D.id
    }
    if (D.state) {
        C += "/" + D.state
    }
    E.dataRefresh = ["enclosuresSet", "disksSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setSessionParameters = function(D, E) {
    var C = "set/cli-parameters";
    if (D.base) {
        C += "/base/" + D.base
    }
    if (D.locale) {
        C += "/locale/" + D.locale
    }
    if (D.precision) {
        C += "/precision/" + D.precision
    }
    if (D.temperatureScale) {
        C += "/temperature-scale/" + D.temperatureScale
    }
    if (D.timeout) {
        C += "/timeout/" + D.timeout
    }
    if (D.units) {
        C += "/units/" + D.units
    }
    if (D.managementMode) {
        C += "/management-mode/" + D.managementMode
    }
    E.dataRefresh = ["sessionParametersSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deletePeer = function(D, E) {
    var C = "delete/peer-connection/";
    if (D.list) {
        C += '"' + this.getItemList(D.list) + '"'
    }
    E.dataRefresh = ["peerConnectionsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.queryPeerConnection = function(D, E) {
    var C = "query/peer-connection/";
    if (D.remotePort) {
        C += D.remotePort
    }
    this.execCommand(C, E)
};
MCObject.prototype.createPeer = function(D, E) {
    var C = "create/peer-connection/";
    if (D.name) {
        C += '"' + D.name + '"'
    }
    if (D.remotePortAddr) {
        C += "/remote-port-address/" + D.remotePortAddr
    }
    if (D.remoteUsername) {
        C += "/remote-username/" + D.remoteUsername
    }
    if (D.remotePassword) {
        C += "/remote-password/" + D.remotePassword
    }
    E.dataRefresh = ["peerConnectionsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setPeer = function(D, E) {
    var C = "set/peer-connection/";
    if (D.name) {
        C += D.name
    }
    if (D.newPeerName) {
        C += '/name/"' + D.newPeerName + '"'
    }
    if (D.newRemoteAddress) {
        C += "/remote-port-address/" + D.newRemoteAddress
    }
    if (D.localPorts) {
        C += "/local-ports/" + this.getItemList(D.localPorts, "quoted")
    }
    if (D.remotePorts) {
        C += "/remote-ports/" + this.getItemList(D.remotePorts, "quoted") + "/"
    }
    if (D.remoteUsername) {
        C += '/remote-username/"' + D.remoteUsername + '"'
    }
    if (D.remotePassword) {
        C += '/remote-password/"' + D.remotePassword + '"'
    }
    E.dataRefresh = ["peerConnectionsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteRemoteSystem = function(D, E) {
    var C = "delete/remote-system/";
    if (D.systems instanceof APIData) {
        if (D.systems) {
            C += this.getItemList(D.systems, "system_name")
        }
    } else {
        if (D.systems.indexOf(" ") >= 0) {
            D.systems = '"' + D.systems + '"'
        } else {
            if (D.systems) {
                C += D.systems
            }
        }
    }
    E.dataRefresh = ["remoteSystemsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createRemoteSystem = function(D, E) {
    var C = "create/remote-system/";
    if (D.ip) {
        C += D.ip
    }
    if (D.username) {
        C += "/username/" + D.username
    }
    if (D.password) {
        C += "/password/" + D.password
    }
    E.dataRefresh = ["remoteSystemsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setRemoteSystem = function(D, E) {
    var C = "set/remote-system/";
    if (D.ip) {
        C += D.ip
    }
    if (D.username) {
        C += "/username/" + D.username
    }
    if (D.password) {
        C += "/password/" + D.password
    }
    E.dataRefresh = ["remoteSystemsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.verifyLinks = function(D, E) {
    if (this.memorex) {
        var C = "showRemoteLinks";
        E.useMemorex = true
    } else {
        var C = "verify/links";
        if (D.rmtSys) {
            C += '/remote-system/"' + D.rmtSys + '"'
        }
        if (D.linkType) {
            C += "/link-type/" + D.linkType
        }
    }
    this.execCommand(C, E)
};
MCObject.prototype.createReplicationSet = function(D, E) {
    var C = "create/replication-set";
    if (D.repSetName) {
        C += '/"' + D.repSetName + '"'
    }
    if (D.peerConnection) {
        C += '/peer-connection/"' + D.peerConnection + '"'
    }
    if (D.primaryVol) {
        C += '/primary-volume/"' + D.primaryVol + '"'
    }
    if (D.secondaryVolName) {
        C += '/secondary-volume-name/"' + D.secondaryVolName + '"'
    }
    if (D.destinationPool) {
        C += '/secondary-pool/"' + D.destinationPool + '"'
    }
    if (D.queuePolicy) {
        C += '/queue-policy/"' + D.queuePolicy + '"'
    }
    if (D.snapHistory) {
        C += '/snapshot-history/"' + D.snapHistory + '"'
    }
    if (D.retentionCount) {
        C += '/snapshot-count/"' + D.retentionCount + '"'
    }
    if (D.snapBasename) {
        C += '/snapshot-basename/"' + D.snapBasename + '"'
    }
    if (D.retentionPriority) {
        C += '/snapshot-retention-priority/"' + D.retentionPriority + '"'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.removeReplicationVolume = function(D, E) {
    var C = "remove/replication-volume/";
    if (D.volume) {
        C += '"' + D.volume + '"/'
    }
    if (D.set) {
        C += 'set/"' + D.set + '"/'
    }
    if (D.extView) {
        C += 'primary-volume/"' + D.extView + '"/'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteReplicationSet = function(D, E) {
    var C = "delete/replication-set";
    if (D.volume) {
        C += '/"' + D.volume + '"'
    }
    if (D.set) {
        C += '/"' + D.set + '"'
    }
    if (D.repSet) {
        C += '/"' + D.repSet + '"'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.modifyReplicationSet = function(D, E) {
    var C = "set/replication-set";
    if (D.repSet) {
        C += '/"' + D.repSet + '"'
    }
    if (D.name) {
        C += '/name/"' + D.name + '"'
    }
    if (D.queuePolicy) {
        C += '/queue-policy/"' + D.queuePolicy + '"'
    }
    if (D.snapHistory) {
        C += '/snapshot-history/"' + D.snapHistory + '"'
    }
    if (D.retentionCount) {
        C += '/snapshot-count/"' + D.retentionCount + '"'
    }
    if (D.snapBasename) {
        C += '/snapshot-basename/"' + D.snapBasename + '"'
    }
    if (D.retentionPriority) {
        C += '/snapshot-retention-priority/"' + D.retentionPriority + '"'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.recoverReplicationSet = function(D, E) {
    var C = "recover/replication-set";
    if (D.repSet) {
        C += '/"' + D.repSet + '"'
    }
    if (D.operation) {
        C += "/operation/" + D.operation
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.replicateVolume = function(D, E) {
    var C = "replicate/";
    if (D.repSet) {
        C += '"' + D.repSet + '"/'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.replicateSnapshot = function(D, E) {
    var C = "replicate/snapshot/";
    if (D.snapshot) {
        C += '"' + D.snapshot + '"/'
    }
    if (D.set) {
        C += 'set/"' + D.set + '"/'
    }
    if (D.name) {
        C += 'name/"' + D.name + '"/'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.exportSnapshot = function(D, E) {
    var C = "export/snapshot/";
    if (D.snapshot) {
        C += '"' + D.snapshot + '"/'
    }
    if (D.set) {
        C += 'set/"' + D.set + '"/'
    }
    if (D.name) {
        C += 'name/"' + D.name + '"/'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.suspendReplication = function(D, E) {
    if (D.repSet) {
        var C = "suspend/replication-set/";
        C += '"' + D.repSet + '"/'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.resumeReplication = function(D, E) {
    if (D.repSet) {
        var C = "resume/replication-set/";
        C += '"' + D.repSet + '"/'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.abortReplication = function(D, E) {
    var C = "abort/replication/";
    if (D.repSet) {
        C += '"' + D.repSet + '"/'
    }
    E.dataRefresh = ["virtualReplicationSets", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.stopVdisk = function(D, E) {
    var C = "stop/vdisk/";
    if (D.vdisk) {
        C += '"' + D.vdisk + '"/'
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "snapPoolsSet", "replicationSetsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.startVdisk = function(D, E) {
    var C = "start/vdisk/";
    if (D.vdisk) {
        C += '"' + D.vdisk + '"/'
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "snapPoolsSet", "replicationSetsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.detachReplicationVolume = function(D, E) {
    var C = "detach/replication-volume/";
    if (D.volume) {
        C += '"' + D.volume + '"/'
    }
    if (D.set) {
        C += 'set/"' + D.set + '"/'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.reattachReplicationVolume = function(D, E) {
    var C = "reattach/replication-volume";
    if (D.volume) {
        C += '/"' + D.volume + '"'
    }
    if (D.set) {
        C += '/set/"' + D.set + '"'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.setReplicationPrimaryVolume = function(D, E) {
    var C = "set/replication-primary-volume";
    if (D.volume) {
        C += '/volume/"' + D.volume + '"'
    }
    if (D.set) {
        C += '/set/"' + D.set + '"'
    }
    if (D.extView) {
        C += '/primary-volume/"' + D.extView + '"'
    }
    if (D.snapshot) {
        C += '/snapshot/"' + D.snapshot + '"'
    }
    E.dataRefresh = ["replicationSetsSet", "volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.remote = function(D, E) {
    var C = "remote/";
    if (D.remoteSystem) {
        C += '"' + D.remoteSystem + '"/'
    }
    if (D.command) {
        C += D.command
    }
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.createSnapPool = function(D, E) {
    var C = "create/snap-pool";
    if (D.vdiskName) {
        C += '/vdisk/"' + D.vdiskName + '"'
    }
    if (D.snapPoolSize) {
        C += "/size/" + D.snapPoolSize
    }
    if (D.snapPoolName) {
        C += '/"' + D.snapPoolName + '"'
    }
    E.dataRefresh = ["volumeGroupsSet", "snapPoolsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createTempLicense = function(D, E) {
    var C = "create/temp-license";
    E.dataRefresh = ["licenseSet"];
    this.execCommand(C, E)
};
MCObject.prototype.restartController = function(D, E) {
    E.fail = this.argsMissing(D, ["type", "controller"]);
    var C = "restart/" + D.type + "/" + D.controller + "/noprompt";
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.shutdownSC = function(D, E) {
    E.fail = this.argsMissing(D, ["controller"]);
    var C = "shutdown/" + D.controller;
    E.dataRefresh = [];
    this.execCommand(C, E)
};
MCObject.prototype.remoteLink = function(D, E) {
    E.fail = this.argsMissing(D, ["remoteLinkType", "targetAddress"]);
    var C = "verify/remote-link/" + D.remoteLinkType + "/" + D.targetAddress;
    E.dataRefresh = [];
    MC.infoOutput("In MC.prototype.remoteLink execute call");
    this.execCommand(C, E)
};
MCObject.prototype.resetAllStatistics = function(D, E) {
    var C = "reset/all-statistics ";
    if (D.historical) {
        C += "/historical"
    }
    C += "/prompt/yes";
    this.execCommand(C, E)
};
MCObject.prototype.showVdiskStatistics = function(D, E) {
    if (this.memorex) {
        var C = "showVdiskStatistics";
        E.useMemorex = true
    } else {
        var C = "show/vdisk-statistics";
        if (D.historical) {
            C += "/historical"
        }
        if (D.count) {
            C += "/count/" + D.count
        }
        if (D.timeRange) {
            C += '/time-range/"' + D.timeRange + '"'
        }
        if (D.vdisk) {
            C += "/" + D.vdisk
        }
    }
    this.execCommand(C, E)
};
MCObject.prototype.showDiskStatistics = function(D, E) {
    if (this.memorex) {
        var C = "showDiskStatistics";
        if (D.historical) {
            C = "showDiskStatsHist"
        }
        if (D.disk.indexOf(",") >= 0) {
            C = "showMultiDiskHistStatistics"
        }
        E.useMemorex = true
    } else {
        var C = "show/disk-statistics";
        if (D.historical) {
            C += "/historical"
        }
        if (D.count) {
            C += "/count/" + D.count
        }
        if (D.timeRange) {
            C += '/time-range/"' + D.timeRange + '"'
        }
        if (D.fileName) {
            C += "/filename/" + D.fileName
        }
        if (D.disk) {
            C += "/" + D.disk
        }
    }
    this.execCommand(C, E)
};
MCObject.prototype.showPoolStatistics = function(D, E) {
    if (this.memorex) {
        var C = "showPoolStatistics";
        if (D.historical) {
            C = "showPoolStatsHist"
        }
        E.useMemorex = true
    } else {
        var C = "show/pool-statistics";
        if (D.historical) {
            C += "/historical"
        }
        if (D.count) {
            C += "/count/" + D.count
        }
        if (D.timeRange) {
            C += '/time-range/"' + D.timeRange + '"'
        }
        if (D.fileName) {
            C += "/filename/" + D.fileName
        }
    }
    this.execCommand(C, E)
};
MCObject.prototype.showWorkload = function(D, E) {
    if (this.memorex) {
        var C = "showWorkload";
        E.useMemorex = true
    } else {
        C = "show/workload";
        if (D.pool) {
            C += "/pool/" + D.pool
        }
        if (D.calcType) {
            C += "/calc-type/" + D.calcType
        }
        if (D.outputType) {
            C += "/io-type/" + D.outputType
        }
        if (D.textInput_percent) {
            C += "/target-pct/" + D.textInput_percent
        }
    }
    this.execCommand(C, E)
};
MCObject.prototype.showHostPortStatistics = function(D) {
    if (this.memorex) {
        var C = "showHostPortStatistics";
        D.useMemorex = true
    } else {
        var C = "show/host-port-statistics"
    }
    this.execCommand(C, D)
};
MCObject.prototype.setInitiator = function(D, E) {
    if (D.id) {
        var C = "set/initiator/id/" + D.id + "/";
        if (D.nickname) {
            C += 'nickname/"' + D.nickname + '"/'
        }
        if (D.profile) {
            C += 'profile/"' + D.profile + '"'
        }
        E.dataRefresh = ["hostGroupsSet"];
        this.execCommand(C, E)
    }
};
MCObject.prototype.deleteInitiatorNickname = function(D, E) {
    if (D.target) {
        var C = 'delete/initiator-nickname/"' + D.target + '"';
        E.dataRefresh = ["hostGroupsSet"];
        this.execCommand(C, E)
    }
};
MCObject.prototype.createVolumeGroup = function(E, F) {
    var D = "create/volume-group";
    var C = this.getItemList(E.volNames, "quoted");
    D += "/volumes/" + C;
    if (E.consistencyGroup) {
        D += "/consistency-group"
    }
    D += '/"' + E.groupName + '"';
    F.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(D, F)
};
MCObject.prototype.addVolumeGroupMembers = function(E, F) {
    var D = "add/volume-group-members";
    var C = this.getItemList(E.volNames, "quoted");
    D += "/volumes/" + C;
    D += '/"' + E.groupName + '"';
    F.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(D, F)
};
MCObject.prototype.removeVolumeGroupMembers = function(E, F) {
    var D = "remove/volume-group-members";
    var C = this.getItemList(E.volNames, "quoted");
    D += "/volumes/" + C;
    D += '/"' + E.groupName + '"';
    F.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(D, F)
};
MCObject.prototype.setVolumeGroup = function(D, E) {
    var C = "set/volume-group";
    C += '/name/"' + D.newName + '"';
    C += '/"' + D.currentName + '"';
    E.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.deleteVolumeGroups = function(E, F) {
    var D = "delete/volume-groups";
    if (E.allVolumes.value) {
        D += "/delete-volumes"
    }
    var C = this.getItemList(E.groups, "quoted");
    D += "/" + C;
    F.dataRefresh = ["volumeGroupsSet"];
    this.execCommand(D, F)
};
MCObject.prototype.addStorageByProfile = function(D, E) {
    if (!D || D.profile == undefined) {
        return
    }
    var C = "add/storage/profile/" + D.profile;
    if (D.enclosure != undefined && D.enclosure != "" && D.enclosure != "next_available") {
        C += "/enclosure/" + D.enclosure
    }
    E.dataRefresh = ["poolsSet", "volumeGroupsSet", "mapsSet"];
    this.execCommand(C, E)
};
MCObject.prototype.addStorage = function(D, E) {
    var C = "add/storage";
    if (D.preview) {
        C += "/preview"
    }
    this.execCommand(C, E)
};
MCObject.prototype.modifyLDAPSettings = function(D, E) {
    var C = "set/ldap-parameters";
    if (D.ldap) {
        C += "/ldap/" + D.ldap
    }
    if (D.server) {
        C += "/server/" + D.server
    }
    if (D.port) {
        C += "/port/" + D.port
    }
    if (D.altServer) {
        C += "/alt-server/" + D.altServer
    }
    if (D.altPort) {
        C += "/alt-port/" + D.altPort
    }
    if (D.userSearchBase) {
        C += "/user-search-base/" + D.userSearchBase
    }
    E.dataRefresh = ["ldapParameterSet"];
    this.execCommand(C, E)
};
MCObject.prototype.createUserGroup = function(E, F) {
    F.fail = this.argsMissing(E, ["usergroupname"]);
    var C = false;
    var D = "create/user-group/";
    if (E.roles && E.roles.length > 0) {
        D += "roles/" + this.getItemList(E.roles) + "/"
    }
    if (E.type) {
        D += "type/" + E.type + "/"
    }
    if (E.interfaces) {
        D += "interfaces/" + E.interfaces + "/"
    }
    if (E.base) {
        D += "base/" + E.base + "/"
    }
    if (E.precision) {
        D += "precision/" + E.precision + "/"
    }
    if (E.units) {
        D += "units/" + E.units + "/"
    }
    if (E.temperatureScale) {
        D += "temperature-scale/" + E.temperatureScale + "/"
    }
    if (E.timeout) {
        D += "timeout/" + E.timeout + "/"
    }
    if (E.locale) {
        D += "locale/" + E.locale + "/"
    }
    if (E.usergroupname) {
        D += E.usergroupname + "/"
    }
    F.dataRefresh = ["usergroupssSet"];
    this.execCommand(D, F)
};
MCObject.prototype.deleteUserGroup = function(D, E) {
    E.fail = this.argsMissing(D, ["usergroupname"]);
    var C = "delete/user-group/";
    if (D.usergroupname) {
        C += D.usergroupname + "/"
    }
    E.dataRefresh = ["usergroupssSet"];
    this.execCommand(C, E)
};
MCObject.prototype.modifyUserGroup = function(D, E) {
    E.fail = this.argsMissing(D, ["usergroupname"]);
    var C = "set/user-group/";
    if (D.roles) {
        C += "roles/" + D.roles + "/"
    }
    if (D.interfaces) {
        C += "interfaces/" + D.interfaces + "/"
    }
    if (D.base) {
        C += "base/" + D.base + "/"
    }
    if (D.precision) {
        C += "precision/" + D.precision + "/"
    }
    if (D.units) {
        C += "units/" + D.units + "/"
    }
    if (D.temperatureScale) {
        C += "temperature-scale/" + D.temperatureScale + "/"
    }
    if (D.timeout) {
        C += "timeout/" + D.timeout + "/"
    }
    if (D.locale) {
        C += "locale/" + D.locale + "/"
    }
    if (D.authentication) {
        C += "authentication-type/" + D.authentication + "/"
    }
    if (D.encryption) {
        C += "privacy-type/" + D.encryption + "/"
    }
    if (D.privacyPwdInput) {
        C += "privacy-password/" + D.privacyPwdInput + "/"
    }
    if (D.destination) {
        C += "trap-host/" + D.destination + "/"
    }
    if (D.usergroupname) {
        C += D.usergroupname + "/"
    }
    E.dataRefresh = ["usergroupssSet"];
    this.execCommand(C, E)
};
MCObject.prototype.execCommand = function(D, C) {
    applicationAccessed();
    if (C.fail) {
        MC.errorOutput("Command not properly formed: %s", D);
        return
    }
    C.closeActionOn = C.closeActionOn || "none";
    if (C.confirmMsg) {
        CommandConfirmHandling(D, C)
    } else {
        this.execCommand1(D, C)
    }
};
MCObject.prototype.execCommand1 = function(G, D) {
    if (this.memorex && !D.useMemorex) {
        MC.warningOutput("Offline, would have executed command: " + G);
        CommandProcessingHandling(D);
        var F = {
            mc: this,
            o: D
        };
        setTimeout(createObjectCallback(F, this.simulateSuccess), 1000);
        return
    } else {
        MC.warningOutput("executing command: " + G)
    }
    if (D.useMemorex) {
        var C = {
            url: "data/" + settings.memorex + "/" + G + ".json",
            httpReqType: "GET",
            sending: D.sending,
            callback: createObjectCallback(D, this.execComplete)
        }
    } else {
        var C = {
            url: "/api/",
            payload: "/api/" + G,
            sending: D.sending,
            callback: createObjectCallback(D, this.execComplete)
        }
    }
    if (D.dataType) {
        C.dataType = D.dataType
    }
    if (D.dataRefresh) {
        for (var E = 0; E < D.dataRefresh.length; E++) {
            MC[D.dataRefresh[E]].setCommandActive()
        }
    }
    RB.makeRequest(C);
    CommandProcessingHandling(D)
};
MCObject.prototype.simulateSuccess = function() {
    var D = this.mc;
    var C = this.o;
    D.execComplete.call(C, new APIData([new APIStatus([APIProp.fromObject({
        name: "response",
        value: "Command completed successfully"
    }), APIProp.fromObject({
        name: "response_type",
        value: "Success"
    }), APIProp.fromObject({
        name: "response_type_numeric",
        value: "0"
    }), APIProp.fromObject({
        name: "return_code",
        value: 0
    })], {
        basetype: "status",
        name: "status"
    }, 2)]), {})
};
MCObject.prototype.execComplete = function(F, E) {
    var K = this;
    var L = {};
    L.success = false;
    L.code = 0;
    L.message = strings.noResponse;
    if (F) {
        L.json = F;
        if (!L.json.statusObject) {
            L.message = strings.noScResponse;
            L.success = false
        } else {
            L.message = "";
            var I = L.json.statusObjects;
            for (var G = 0; G < (I.length - 1); G++) {
                var J = I[G].getInt("response_type_numeric");
                if (J == CMD_RESP_TYPE.ERROR || (K.includeInfo && J == CMD_RESP_TYPE.INFO)) {
                    L.message += (I[G].getPropertyValue("response") + "<br />")
                }
            }
            var D = L.json.statusObject;
            if (D) {
                L.message += D.getPropertyValue("response");
                var H = parseInt(D.getPropertyValue("response_type_numeric"));
                if (H) {
                    L.success = false
                } else {
                    L.success = true
                }
                var C = D.getPropertyValue("return_code");
                L.code = parseInt(C)
            }
        }
    }
    K.result = L;
    MC.delayedExecComplete.call(K)
};
MCObject.prototype.delayedExecComplete = function() {
    var C = this;
    MC.updateSets(C.dataRefresh);
    if (C.callback) {
        C.callback(C.result)
    }
    if (C.secondaryCallback) {
        C.secondaryCallback(C.result)
    }
    if (C.dataRefresh) {
        for (var D = 0; D < C.dataRefresh.length; D++) {
            MC[C.dataRefresh[D]].setCommandComplete()
        }
    }
    if (C.redirectIP != undefined && C.result.success) {
        MC.redirectToIP(C.redirectIP)
    } else {
        if (C.result.success) {
            CommandSuccessHandling(C)
        } else {
            if ((C.result.code == 0) && (session.userName.get() == "setup")) {
                CommandSuccessHandling(C)
            } else {
                if (C.result.json && C.result.json.statusObject && C.result.json.statusObject.get("response_type") == "Warning") {
                    CommandWarningHandling(C)
                } else {
                    CommandFailureHandling(C)
                }
            }
        }
    }
};
MCObject.prototype.Info = function(C) {
    var E = "";
    if (C) {
        E += "MC datasets and subscriptions\n"
    }
    for (var D in this.dataSets) {
        var F = this.dataSets[D];
        E += F.Info(false);
        title = false
    }
    return E
};
MCObject.prototype.showInfo = function() {
    if (checkforconsole()) {
        console.log(this.Info(true))
    }
};
MCObject.prototype.redirectToIP = function(C) {
    MC.warningOutput("Redirecting to %s", C);
    RedirectToIPHandling(C);
    BC.off();
    setTimeout(function() {
        window.location = window.location.protocol + "//" + C + window.location.pathname
    }, 20 * SECOND)
};
var MC = new MCObject();
MCObject.prototype.addEvents = function(F) {
    if (!F.objects || F.objects.length == 0) {
        return false
    }
    if (!this.eventsSet.lastID) {
        this.eventsSet.data = F;
        for (var C = 0; C < F.objects.length; C++) {
            DC.addObject(F.objects[C])
        }
        this.eventsSet.lastID = F.objects[0].get("event_id");
        if (!settings.memorex) {
            this.url = "/api/show/events/last/100"
        }
        return true
    }
    var E = 0;
    while (E < F.objects.length && F.objects[E].get("event_id") != this.eventsSet.lastID) {
        E++
    }
    var G = APIEvents.MAX_EVENTS.paged;
    for (var C = E - 1; C >= 0; C--) {
        if (this.eventsSet.data.objects.unshift(F.objects[C]) > G) {
            var D = this.eventsSet.data.objects.pop();
            DC.removeObject(D)
        }
        DC.addObject(F.objects[C]);
        if (settings.isV3 && panels.ActivityBarPanel != undefined) {
            panels.ActivityBarPanel.notifyEvent(F.objects[C])
        }
    }
    this.eventsSet.lastID = F.objects[0].get("event_id");
    return true
};
MCObject.prototype.execCommandList = function(D, F) {
    if (!D || D.length == 0) {
        return
    }
    for (var C = 0; C < D.length; C++) {
        var E = D[C];
        if (!E.name || !$.isFunction(E.command) || !E.data || !E.options) {
            MC.errorOutput("ERROR: Aborted execCommandList, called with invalid command number: " + C + " (0 based)!");
            return
        }
        if (F.noDialog) {
            E.options.dialog = false
        } else {
            E.options.dialog = true
        }
    }
    if (this.cmdQueue && this.cmdQueue.length > 0) {
        MC.debugOutput("ERROR: attempt to execute command list while one still active.", "%s");
        return
    }
    if (F.noSuccessDialog != undefined) {
        D[D.length - 1].options.noSuccessDialog = F.noSuccessDialog
    }
    if (F.successMsg) {
        D[D.length - 1].options.successMsg = F.successMsg
    }
    if (F.closeActionOn) {
        D[D.length - 1].options.closeActionOn = F.closeActionOn
    }
    this.cmdQueue = D;
    this.qcmdCallback = F.callback;
    this.qcmdResult = {
        results: {}
    };
    if (F.confirmMsg) {
        CommandConfirmHandling(null, F)
    } else {
        this.qcmdExec()
    }
};
MCObject.prototype.qcmdExec = function() {
    if (this.cmdQueue && this.cmdQueue.length > 0) {
        var C = this.cmdQueue.shift();
        if (!C.options.cancel) {
            C.options.cancel = function() {
                MC.qcmdComplete({
                    error: strings.commandlist.canceled
                })
            }
        }
        if (this.qcmdCurrent) {
            C.options.dialogOverride = true
        } else {
            C.options.dialogOverride = false
        }
        if (this.cmdQueue.length > 0) {
            C.options.noSuccessDialog = true
        }
        if (C.options.callback) {
            C.options.secondaryCallback = C.options.callback
        }
        C.options.callback = createObjectCallback(this, this.qcmdComplete);
        this.qcmdCurrent = C.name;
        C.command.call(this, C.data, C.options)
    }
};
MCObject.prototype.qcmdComplete = function(C) {
    var D = false;
    this.qcmdResult.results[this.qcmdCurrent] = C;
    if (C.success || (C.json && C.json.statusObject.get("response_type") == "Warning")) {
        if (this.cmdQueue.length == 0) {
            if (this.qcmdCallback) {
                this.qcmdResult.success = true;
                this.qcmdResult.message = strings.commandlist.resultSuccessMsg;
                this.qcmdCallback(this.qcmdResult);
                this.qcmdCallback = null
            }
            this.qcmdCurrent = null
        } else {
            this.qcmdExec()
        }
    } else {
        this.cmdQueue = [];
        this.qcmdResult.success = false;
        this.qcmdResult.message = C.message;
        if (this.qcmdCallback) {
            this.qcmdCallback(this.qcmdResult);
            this.qcmdCallback = null
        }
        this.qcmdCurrent = null
    }
};
MCObject.NUMBER_REGEX = /[-]?[0-9][0-9\.]*/;
MCObject.prototype.extractNumber = function(D) {
    if (!D) {
        return 0
    }
    if ((typeof D) == "number") {
        return D
    }
    if ((typeof D) != "string") {
        return 0
    }
    var C = D.match(MCObject.NUMBER_REGEX);
    if (C == null) {
        return 0
    }
    return parseFloat(C[0])
};

function WebSession(D) {
    var C = new Date();
    this.sessionKey = location.host + "_" + C.getTime();
    this.class_name = "WebSession"
}
WebSession.prototype.getSessionKey = function() {
    return this.sessionKey
};
webSession = new WebSession();
BackChannel = function() {
    this.class_name = "BackChannel";
    this.dorequests = false;
    this.lastData = "First request, no data yet.";
    this.errorCount = 0;
    this.req_state = "PREPARING";
    this.start_time = 0;
    this.successCallback = createObjectCallback(this, this.__handleSuccess);
    this.errorCallback = createObjectCallback(this, this.__handleError);
    this.beforeSendCallback = createObjectCallback(this, this.__beforeSend);
    this.fastPoll = true;
    this.ajaxOptions = {
        type: "GET",
        url: "/api/backchannel",
        cache: false,
        dataType: "wbi",
        success: this.successCallback,
        error: this.errorCallback,
        beforeSend: this.beforeSendCallback
    }
};
BackChannel.prototype = new DHSObject();
BackChannel.prototype.__beforeSend = function(C) {
    if ((typeof(session) != "undefined") && (session.getSessionKey())) {
        C.setRequestHeader("sessionkey", session.getSessionKey())
    }
    C.setRequestHeader("datatype", "wbi");
    C.setRequestHeader("websessionkey", webSession.getSessionKey());
    C.setRequestHeader("ajaxid", C.ajaxID);
    if (this.fastPoll) {
        C.setRequestHeader("fastpoll", "true")
    }
};
BackChannel.prototype.makeRequest = function() {
    if (!this.dorequests) {
        MC.infoOutput("BC.makeRequest(): requests are disabled.");
        return
    }
    if (this.request_object != undefined) {
        MC.debugOutput("BC.makeRequest(): existing request_object %o, aborting!", this.request_object);
        this.request_object.abort();
        delete this.request_object
    }
    this.req_state = "in-flight";
    this.start_time = new Date();
    if (this.fastPoll) {
        this.ajaxOptions.timeout = 3000
    } else {
        this.ajaxOptions.timeout = 30000
    }
    this.ajaxOptions.ajaxID = getAjaxID();
    mcDebug("backChannel", "BC: initiating new request[%s] : %s", this.ajaxOptions.ajaxID, (this.fastPoll ? "fast" : "normal"));
    this.request_object = $.ajax(this.ajaxOptions)
};
BackChannel.prototype.__handleSuccess = function(C, E, D) {
    this.req_state = "complete";
    this.end_time = new Date();
    delete this.request_object;
    mcDebug("backChannel", "backChannel", "BC: request[%s] completed: textStatus: %s, time: %s, data: %o", D.ajaxID, E, timeDiff(this.start_time, this.end_time), C);
    this.lastStatus = E;
    this.lastData = C;
    this.errorCount = 0;
    connection.connected();
    if (E == "success") {
        if (C instanceof Messages) {
            C.process();
            if (this.webStop) {
                this.webStop = false;
                this.setFastPoll(true);
                setTimeout(createObjectCallback(this, this.makeRequest), 8000);
                return
            }
        } else {
            if ((typeof C) == "object" && C.message && (typeof C.message) == "string") {
                MC.warningOutput("BC: Web server says: " + C.message)
            } else {
                MC.errorOutput("BC: data is not Messages object: %o", C)
            }
        }
        this.setFastPoll(false);
        this.makeRequest()
    } else {
        if (E == "parsererror") {
            MC.warningOutput("BC: success::parser error - immediate request");
            this.setFastPoll(true);
            this.makeRequest()
        } else {
            if (E == "error") {
                MC.warningOutput("BC: success::error - delayed request");
                this.setFastPoll(true);
                setTimeout(createObjectCallback(this, this.makeRequest), 2000)
            } else {
                MC.warningOutput("BC: success::default - immediate request");
                this.makeRequest()
            }
        }
    }
};
BackChannel.prototype.__handleError = function(D, E, C) {
    this.req_state = "complete";
    this.end_time = new Date();
    delete this.request_object;
    MC.errorOutput("BC: request[%s] failed: textStatus: %s, time: %s, exception: %o", D.ajaxID, E, timeDiff(this.start_time, this.end_time), C);
    this.lastStatus = E;
    this.lastData = "No data, error on last request.";
    this.setFastPoll(true);
    if (E == "parsererror") {
        MC.warningOutput("BC:parser error: %o", D);
        MC.warningOutput("BC: error::parser error - immediate request");
        this.makeRequest()
    } else {
        if (E == "error") {
            this.errorCount++;
            MC.warningOutput("BC: error::error = delayed request");
            setTimeout(createObjectCallback(this, this.makeRequest), 2000)
        } else {
            if (E == "timeout") {
                this.errorCount++;
                MC.warningOutput("BC: error::timeout = delayed request");
                setTimeout(createObjectCallback(this, this.makeRequest), 3000)
            } else {
                this.errorCount++;
                MC.warningOutput("BC: error::default - immediate request");
                this.makeRequest()
            }
        }
    }
    if (this.errorCount > 3) {
        connection.disconnected()
    }
};
BackChannel.prototype.doRequests = function(D) {
    if (MC.memorex) {
        return
    }
    var C = this.dorequests;
    this.dorequests = D;
    if (C != D) {
        MC.infoOutput("BC: switching BackChannel mechanism %s", (D ? "on" : "off"))
    }
    if (!C && D) {
        this.makeRequest();
        if (!this.watchdogInterval) {
            this.watchdogInterval = setInterval(this.watchdog, 15000)
        }
    } else {
        if (C && !D && this.req_state == "in-flight" && this.request_object) {
            this.request_object.abort();
            delete this.request_object;
            clearInterval(this.watchdogInterval);
            delete this.watchdogInterval
        }
    }
};
BackChannel.prototype.watchdog = function() {
    if (this.dorequests && !this.request_object) {
        this.makeRequest()
    }
};
BackChannel.prototype.on = function() {
    this.doRequests(true)
};
BackChannel.prototype.off = function() {
    this.doRequests(false)
};
BackChannel.prototype.setFastPoll = function(C) {
    if (this.fastPoll != C) {
        mcDebug("backChannel", "BC: fastPoll from " + this.fastPoll + " to " + C);
        this.fastPoll = C
    }
};
var BC = new BackChannel();
BC.on();

function Size(D, E, C) {
    this.set(D, E, C)
}
Size.DECIMAL = "decimal";
Size.BINARY = "binary";
Size.MULTPREFIXES = "KMGT";
Size.base = function() {
    if (session && typeof session != "undefined") {
        return (session.getSessionPreference("storage_size_base") == 2 ? "binary" : "decimal")
    } else {
        return "decimal"
    }
};
Size.mult = function() {
    if (session && typeof session != "undefined") {
        var C = parseInt(session.getSessionPreference("storage_size_units_numeric"), 10);
        switch (C) {
            case 0:
                break;
            case 1:
                return "M";
            case 2:
                return "G";
            case 3:
                return "T";
            default:
                MC.errorOutput("Size.mult(): invalid storage_size_units_numeric: " + C + "; setting to auto");
                break
        }
    }
    return "auto"
};
Size.precision = function() {
    if (session && session != undefined) {
        return session.getSessionPreference("storage_size_precision")
    } else {
        return 1
    }
};
Size.defaultUnit = "B";
Size.valueRegEx = /^([0-9\.]+)([kKmMgGtT]?[iI]?.*)/;
Size.factor = {
    binary: {
        K: 1024,
        M: 1048576,
        G: 1073741824,
        T: 1099511627776
    },
    decimal: {
        K: 1000,
        M: 1000000,
        G: 1000000000,
        T: 1000000000000
    }
};
Size.round = function(G, C, F) {
    var H;
    if (F) {
        var E = 1;
        for (var D = 0; D < C; D++) {
            E *= 10
        }
        H = (Math.floor(G * E) / E).toFixed(C)
    } else {
        H = G.toFixed(C)
    }
    return H
};
Size.compare = function(D, C) {
    if (!(D instanceof Size) || !(C instanceof Size)) {
        return 0
    }
    if (D.value < C.value) {
        return -1
    } else {
        if (D.value > C.value) {
            return 1
        } else {
            return 0
        }
    }
};
Size.getPages = function(F, E) {
    if (!D) {
        return 0
    }
    var D = new Size(F);
    if (E && PAGEBLOCKS && PAGEBLOCKS[E]) {
        var C = PAGEBLOCKS[E]
    } else {
        var C = PAGEBLOCKS.A
    }
    var G = D.getBlocks();
    return Math.ceil(G / C)
};
Size.prototype.set = function(I, J, H) {
    if (I == undefined) {
        this.value = 0;
        this.unit = Size.defaultUnit;
        return
    }
    if (I instanceof Size) {
        this.value = I.value;
        this.unit = I.unit;
        return
    }
    if (I instanceof APIObject) {
        if (I.prop.blocks != undefined) {
            I = I.prop.blocks
        } else {
            I = 0
        }
    }
    if (I instanceof APIProp) {
        var C;
        if (I.attr.name.substr(0, 4) == "size") {
            C = I.text;
            J = I.attr.units
        } else {
            if (I.attr.name == "blocks") {
                C = I.text;
                J = "blocks";
                H = I.attr.blocksize;
                if (isNaN(H)) {
                    H = DC.cacheParameter.get("cache_block_size")
                }
            } else {
                C = 0
            }
        }
        I = C
    }
    I = I.toString();
    I = this.unTranslate(I);
    var G = Size.valueRegEx.exec(I);
    if ((!G) || (!(G instanceof Array)) || G[1] == undefined) {
        MC.debugOutput("Size.set(): Non-numeric value supplied, set to 0!");
        this.value = 0;
        this.unit = Size.defaultUnit;
        return
    }
    var F = DC.cacheParameter.get("cache_block_size");
    if ((J && J == "blocks") || (J == undefined && !G[2])) {
        if (H) {
            F = parseInt(H)
        }
        this.value = parseInt(G[1]) * F;
        this.unit = Size.defaultUnit;
        return
    }
    if (J && J == "pages") {
        var E = PAGEBLOCKS.A;
        if (H) {
            F = parseInt(H)
        }
        this.value = parseInt(G[1]) * E * F;
        this.unit = Size.defaultUnit;
        return
    }
    var D = {
        mult: Size.mult(),
        base: Size.base(),
        unit: Size.defaultUnit
    };
    if (J != undefined) {
        D = this.normalize(J)
    } else {
        if (G[2] != undefined) {
            D = this.normalize(G[2])
        }
    }
    if (H != undefined) {
        if (H == 2) {
            D.base = Size.BINARY
        } else {
            if (H == 10) {
                D.base = Size.DECIMAL
            }
        }
    }
    if (D.mult == "auto") {
        this.value = parseInt(G[1])
    } else {
        this.value = parseInt(G[1] * Size.factor[D.base][D.mult])
    }
    this.unit = D.unit
};
Size.prototype.format = function(F, C, E) {
    var D = this.getSize(F, C, E);
    var G = D.size;
    if (D.spec == "blocks") {
        G += " blocks"
    } else {
        G += D.spec
    }
    return (G)
};
Size.prototype.unTranslate = function(D) {
    if (strings.dotNotation != "." && D.indexOf(strings.dotNotation) > -1) {
        var C = new RegExp(strings.dotNotation, "g");
        D = D.replace(C, ".")
    }
    return D
};
Size.prototype.getSize = function(E, D, C) {
    var H = 0;
    if (E && E == "blocks") {
        var F = DC.cacheParameter.get("cache_block_size");
        if (C) {
            F = parseInt(C)
        }
        H = this.value / F;
        if (D == undefined) {
            D = 0
        } else {
            D = parseInt(D)
        }
        H = H.toFixed(D);
        return {
            size: H,
            spec: "blocks"
        }
    }
    var I = this.normalize(E);
    if (D == undefined) {
        D = Size.precision()
    } else {
        D = parseInt(D)
    }
    if (C != undefined) {
        if (C == 2) {
            I.base = Size.BINARY
        } else {
            if (C == 10) {
                I.base = Size.DECIMAL
            }
        }
    }
    var G = 1;
    var K = true;
    if (I.mult.toLowerCase() == "scale") {
        G = 10;
        K = true;
        I.mult = "auto"
    }
    if (I.mult.toLowerCase() == "auto") {
        if (Size.round((this.value / (Size.factor[I.base].M * G)), (3 + D), K) < 1) {
            I.mult = "K"
        }
        if (Size.round((this.value / (Size.factor[I.base].G * G)), (3 + D), K) < 1) {
            I.mult = "M"
        } else {
            if (Size.round((this.value / (Size.factor[I.base].T * G)), (3 + D), K) < 1) {
                I.mult = "G"
            } else {
                I.mult = "T"
            }
        }
    }
    if (I.mult === "T" && D === 0) {
        D = D = Size.precision()
    }
    H = Size.round((this.value / Size.factor[I.base][I.mult]), D, K).toLocaleString();
    H = H.replace(/\./g, strings.dotNotation);
    var J = I.mult + ((I.base == Size.BINARY) ? "i" : "") + this.unit;
    return {
        size: H,
        spec: J
    }
};
Size.prototype.getRawValue = function() {
    return this.value
};
Size.prototype.getBlocks = function() {
    var C = this.getSize("blocks");
    return parseInt(C.size, 10)
};
Size.prototype.getPages = function(D) {
    if (D && PAGEBLOCKS[D]) {
        var C = PAGEBLOCKS[D]
    } else {
        var C = PAGEBLOCKS.A
    }
    var E = this.getBlocks();
    return Math.ceil(E / C)
};
Size.prototype.normalize = function(C) {
    var G = Size.mult();
    var F = Size.base();
    var E = Size.defaultUnit;
    if (C == undefined) {
        return {
            mult: G,
            base: F,
            unit: E
        }
    }
    var H = C.toUpperCase();
    if (H == "AUTO") {
        return {
            mult: "auto",
            base: F,
            unit: E
        }
    } else {
        if (H == "SCALE") {
            return {
                mult: "scale",
                base: F,
                unit: E
            }
        }
    }
    var D = 0;
    G = H.substr(0, 1);
    if (Size.MULTPREFIXES.indexOf(G) == -1) {
        MC.debugOutput("Size.normalize(): invalid mult parameter: " + G + ", set to default!");
        G = Size.mult()
    } else {
        D++
    }
    if (H.length > 1 && H.substr(1, 1) == "I") {
        F = Size.BINARY;
        D++
    } else {
        F = Size.DECIMAL
    }
    if (H.length > D) {
        E = C.substr(D)
    }
    return {
        mult: G,
        base: F,
        unit: E
    }
};
Size.prototype.add = function(D, F, C) {
    if (D) {
        if (D instanceof Size) {
            this.value += D.value
        } else {
            var E = new Size(D, F, C);
            this.value += E.value
        }
    }
    return this
};
Size.prototype.subtract = function(D, F, C) {
    if (D) {
        if (D instanceof Size) {
            this.value -= D.value
        } else {
            var E = new Size(D, F, C);
            this.value -= E.value
        }
    }
    return this
};
Size.prototype.divide = function(C) {
    if (C) {
        this.value = parseInt(this.value / C)
    }
    return this
};
Size.prototype.multiply = function(C) {
    if (C) {
        this.value = parseInt(this.value * C)
    }
    return this
};

function DataCache() {
    this.base = {};
    this.noKeys = {};
    for (var C in DataCache.COLLECTIONS) {
        if (DataCache.COLLECTIONS[C].base) {
            this[C] = {}
        }
    }
}
DataCache.MAXKEYLENGTH = RI.getMaxNameLength();
DataCache.COLLECTIONS = {
    addresses: {},
    advSettings: {
        key: "singleton",
        base: true
    },
    cacheParameter: {
        key: "singleton",
        base: true
    },
    controllers: {
        key: "controller_id",
        base: true
    },
    controllersSerial: {
        key: "serial_number",
        base: true
    },
    disks: {
        key: "durable_id",
        base: true
    },
    disksSerial: {
        key: "serial_number",
        base: true
    },
    diskGroups: {
        key: "name",
        base: true,
        prefix: "dg",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    diskGroupsSerial: {
        key: "serial_number",
        base: true
    },
    drawers: {
        key: "durable_id"
    },
    enclosures: {
        key: "durable_id",
        base: true
    },
    enclosuresSerial: {
        key: "enclosure_wwn",
        base: true
    },
    expanders: {
        key: "durable_id"
    },
    expanderPorts: {
        key: "durable_id"
    },
    fans: {
        key: "durable_id"
    },
    fanModules: {
        key: "durable_id"
    },
    heatmaps: {
        key: "singleton",
        base: true
    },
    hosts: {
        key: "name",
        base: true,
        prefix: "Host",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    hostsId: {
        key: "durable_id",
        base: true
    },
    hostsSerial: {
        key: "serial_number",
        base: true
    },
    hostGroups: {
        key: "name",
        base: true,
        prefix: "HGrp",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    hostGroupsId: {
        key: "durable_id",
        base: true
    },
    hostGroupsSerial: {
        key: "serial_number",
        base: true
    },
    initiators: {
        key: "id",
        base: true
    },
    initiatorsId: {
        key: "durable_id",
        base: true
    },
    ioModules: {
        key: "durable_id",
        base: true
    },
    iscsiParams: {
        key: "singleton"
    },
    infinibandParams: {
        key: "singleton"
    },
    ldapParameters: {
        key: "singleton"
    },
    networkParameters: {
        key: "durable_id",
        base: true
    },
    resettableStats: {
        key: "singleton"
    },
    params: {
        key: "start_time_numeric"
    },
    peerConnections: {
        key: "peer_connection_name",
        base: true
    },
    peerConnectionsSerial: {
        key: "serial_number",
        base: true
    },
    pools: {
        key: "name",
        base: true
    },
    poolStats: {
        key: "pool",
        base: true
    },
    poolsSerial: {
        key: "serial_number",
        base: true
    },
    ports: {
        key: "durable_id",
        base: true
    },
    powerSupplies: {
        key: "durable_id"
    },
    profiles: {
        key: "storage-profile",
        base: true
    },
    remoteSystems: {
        key: "id",
        base: true
    },
    remoteSystemsIPA: {
        key: "ip_address_a",
        base: true
    },
    remoteSystemsIPB: {
        key: "ip_address_b",
        base: true
    },
    redundancy: {
        key: "singleton"
    },
    repImagesSerial: {
        key: "image_serial_number",
        base: true
    },
    repVolumesSerial: {
        key: "serial_number",
        base: true
    },
    repSets: {
        key: "name",
        base: true
    },
    repSetsSerial: {
        key: "serial_number",
        base: true
    },
    schedules: {
        key: "name",
        base: true,
        prefix: "Sched",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    protocols: {
        key: "singleton"
    },
    communicationPorts: {
        key: "singleton"
    },
    ses: {
        key: "wwpn"
    },
    sideplanes: {
        key: "durable_id"
    },
    snapPools: {
        key: "name",
        base: true,
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    snapPoolsSerial: {
        key: "serial_number",
        base: true
    },
    snapshots: {
        key: "name",
        base: true,
        prefix: "Snap",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    snapshotsSerial: {
        key: "serial_number",
        base: true
    },
    system: {
        key: "singleton"
    },
    systemParameters: {
        key: "singleton"
    },
    tasks: {
        key: "name",
        base: true,
        prefix: "Task",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    tiersSerial: {
        key: "serial_number",
        base: true
    },
    tierStatsSerial: {
        key: "serial_number",
        base: true
    },
    users: {
        key: "username",
        base: true
    },
    usergroups: {
        key: "usergroupname",
        base: true
    },
    vdisks: {
        key: "name",
        base: true,
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    vdisksSerial: {
        key: "serial_number",
        base: true
    },
    virtualReplicationSets: {
        key: "name",
        base: true
    },
    virtualReplicationSetsSerial: {
        key: "serial_number",
        base: true
    },
    volumeGroups: {
        key: "group_name",
        base: true,
        prefix: "VGrp",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    volumeGroupsSerial: {
        key: "serial_number",
        base: true
    },
    volumeGroupsId: {
        key: "durable_id",
        base: true
    },
    volumes: {
        key: "volume_name",
        base: true,
        prefix: "Vol",
        maxKeyLength: DataCache.MAXKEYLENGTH
    },
    volumesSerial: {
        key: "serial_number",
        base: true
    },
    volumeStatsSerial: {
        key: "serial_number",
        base: true
    },
    volumesId: {
        key: "durable_id",
        base: true
    },
    volGroupViewsSerial: {
        key: "serial_number",
        base: true
    },
    volGroupViewsId: {
        key: "durable_id",
        base: true
    },
    volViewsSerial: {
        key: "volume_serial",
        base: true
    },
    volViewsId: {
        key: "durable_id",
        base: true
    },
    volGroupMapsId: {
        key: "durable_id",
        base: true
    },
    volMapsId: {
        key: "durable_id",
        base: true
    },
    volGroupMapLuns: {
        key: "lun"
    },
    workload: {
        key: "singleton",
        base: true
    }
};
DataCache.BASETYPES = {
    "advanced-settings-table": ["advSettings"],
    "cache-settings": ["cacheParameter"],
    "communication-ports": ["communicationPorts"],
    controllers: ["controllers", "controllersSerial"],
    "cs-replication-set": ["virtualReplicationSets", "virtualReplicationSetsSerial"],
    "disk-groups": ["diskGroups", "diskGroupsSerial"],
    drawers: ["drawers"],
    drives: ["disks", "disksSerial"],
    enclosures: ["enclosures", "enclosuresSerial"],
    expanders: ["expanders"],
    "expander-ports": ["expanderPorts"],
    fan: ["fans"],
    "fan-modules": ["fanModules"],
    heatmaps: ["heatmaps"],
    "host-group": ["hostGroups", "hostGroupsSerial", "hostGroupsId"],
    host: ["hosts", "hostsSerial", "hostsId"],
    initiator: ["initiators", "initiatorsId"],
    "io-modules": ["ioModules"],
    "iscsi-parameters": ["iscsiParams"],
    "infiniband-parameters": ["infinibandParams"],
    "ldap-parameters": ["ldapParameters"],
    "network-parameters": ["networkParameters"],
    "resettable-statistics": ["resettableStats"],
    "peer-connections": ["peerConnections", "peerConnectionsSerial"],
    pools: ["pools", "poolsSerial"],
    port: ["ports"],
    "power-supplies": ["powerSupplies"],
    profiles: ["profiles"],
    redundancy: ["redundancy"],
    "remote-addresses": ["addresses"],
    "remote-system": ["remoteSystems", "remoteSystemsIPA", "remoteSystemsIPB"],
    "replication-image": ["repImagesSerial"],
    "replication-image-params": ["params"],
    "replication-set": ["repSets", "repSetsSerial"],
    "replication-volume": ["repVolumesSerial"],
    sideplanes: ["sideplanes"],
    schedules: ["schedules"],
    "security-communications-protocols": ["protocols"],
    ses: ["ses"],
    "snap-pools": ["snapPools", "snapPoolsSerial"],
    snapshots: ["snapshots", "snapshotsSerial"],
    "pool-statistics": ["poolStats"],
    tiers: ["tiersSerial"],
    "tier-statistics": ["tierStatsSerial"],
    system: ["system"],
    "system-parameters-table": ["systemParameters"],
    tasks: ["tasks"],
    users: ["users"],
    usergroups: ["usergroups"],
    "virtual-disks": ["vdisks", "vdisksSerial"],
    "volume-groups": ["volumeGroups", "volumeGroupsSerial", "volumeGroupsId"],
    volumes: ["volumes", "volumesSerial", "volumesId"],
    "volume-group-view": ["volGroupViewsSerial", "volGroupViewsId"],
    "volume-statistics": ["volumeStatsSerial"],
    "volume-view": ["volViewsSerial", "volViewsId"],
    "volume-group-view-mappings": ["volGroupMapsId"],
    "volume-view-mappings": ["volMapsId"],
    "volume-group-view-mappings-luns": ["volGroupMapLuns"],
    workload: ["workload"]
};
DataCache.ASSOCIATIONS = {
    enclosure_disks: {
        baseSet: "enclosuresSerial",
        assocSet: "disks",
        assocName: "disks",
        assocKeyProp: "enclosure_wwn",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    vdisk_volumes: {
        baseSet: "vdisksSerial",
        assocSet: "volumes",
        assocName: "volumes",
        assocKeyProp: "virtual_disk_serial",
        assocPrimaryKey: "volume_name",
        pending: {}
    },
    pool_volumes: {
        baseSet: "poolsSerial",
        assocSet: "volumes",
        assocName: "volumes",
        assocKeyProp: "container_serial",
        assocPrimaryKey: "volume_name",
        pending: {}
    },
    volume_snaps: {
        baseSet: "volumesSerial",
        assocSet: "volumes",
        assocName: "snapshots",
        assocKeyProp: "volume_parent",
        assocPrimaryKey: "volume_name",
        pending: {}
    },
    volume_repSet: {
        baseSet: "volumesSerial",
        assocSet: "repSetsSerial",
        assocName: "repSet",
        baseKeyProp: "replication_set",
        pending: {}
    },
    pool_stats: {
        baseSet: "pools",
        assocSet: "poolStats",
        assocName: "stats",
        baseKeyProp: "name",
        pending: {}
    },
    tier_stats: {
        baseSet: "tiersSerial",
        assocSet: "tierStatsSerial",
        assocName: "stats",
        baseKeyProp: "serial_number",
        pending: {}
    },
    init_maps: {
        baseSet: "initiatorsId",
        assocSet: "volGroupMapsId",
        assocName: "groupMaps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    init_groupMaps: {
        baseSet: "initiatorsId",
        assocSet: "volMapsId",
        assocName: "maps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    host_maps: {
        baseSet: "hostsId",
        assocSet: "volGroupMapsId",
        assocName: "groupMaps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    host_groupMaps: {
        baseSet: "hostsId",
        assocSet: "volMapsId",
        assocName: "maps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    hostGroup_maps: {
        baseSet: "hostGroupsId",
        assocSet: "volGroupMapsId",
        assocName: "groupMaps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    hostGroup_groupMaps: {
        baseSet: "hostGroupsId",
        assocSet: "volMapsId",
        assocName: "maps",
        assocKeyProp: "mapped_id",
        assocPrimaryKey: "durable_id",
        pending: {}
    },
    volGroup_view: {
        baseSet: "volumeGroupsSerial",
        assocSet: "volGroupViewsSerial",
        assocName: "mapView",
        baseKeyProp: "serial_number",
        pending: {}
    },
    vol_view: {
        baseSet: "volumesSerial",
        assocSet: "volViewsSerial",
        assocName: "mapView",
        baseKeyProp: "serial_number",
        pending: {}
    },
    diskGroup_disks: {
        baseSet: "diskGroupsSerial",
        assocSet: "disks",
        assocName: "disks",
        assocKeyProp: "virtual_disk_serial",
        assocPrimaryKey: "durable_id",
        pending: {}
    }
};
for (var collName in DataCache.COLLECTIONS) {
    var coll = DataCache.COLLECTIONS[collName];
    coll.associations = [];
    for (var assocName in DataCache.ASSOCIATIONS) {
        var assoc = DataCache.ASSOCIATIONS[assocName];
        if (assoc.baseSet == collName || assoc.assocSet == collName) {
            coll.associations.push(assocName);
            continue
        }
    }
}
DataCache.prototype.getUnusedKey = function(L, D, N, H) {
    if (!DC[L]) {
        MC.errorOutput("DC.getUnusedKey: collection not found: %s", L);
        return "NoName"
    }
    var Q = null;
    var R = null;
    var C = DataCache.COLLECTIONS[L].maxKeyLength || DataCache.MAXKEYLENGTH;
    for (var J = 1; J < arguments.length; J++) {
        var O = (typeof arguments[J]);
        if (O == "string") {
            Q = arguments[J]
        } else {
            if (O == "number") {
                C = parseInt(arguments[J], 10)
            } else {
                if (arguments[J] instanceof Array) {
                    R = arguments[J]
                } else {
                    MC.warningOutput("Invalid argument supplied to DC.getUnusedKey: " + arguments[J])
                }
            }
        }
    }
    var G = Q || DataCache.COLLECTIONS[L].prefix || L;
    var E = 1;
    var F = 4;
    if (Q) {
        var K = Q.match(/(.*?)([0-9]+)$/);
        if (K && K.length == 3) {
            G = K[1];
            E = parseInt(K[2], 10) + 1;
            F = K[2].length
        }
    }
    if (F > 15) {
        G = DataCache.COLLECTIONS[L].prefix || L;
        F = 4;
        E = 1
    }
    if ((utf8bytes(G) + F) > C) {
        G = DataCache.COLLECTIONS[L].prefix || L;
        F = 4;
        E = 1
    }
    var M;
    var S;
    var P = Math.pow(10, 15) - 1;
    for (var J = E; J < P; J++) {
        M = G + leadingZeros(J, F);
        if (utf8bytes(M) > C) {
            break
        }
        if (!DC[L][M]) {
            S = false;
            if (R) {
                for (var I = 0; I < R.length; I++) {
                    if (M == R[I]) {
                        S = true
                    }
                }
            }
            if (!S) {
                if (R) {
                    R.push(M)
                }
                return M
            }
        }
    }
    return "NoName"
};
DataCache.prototype.updateReferences = function(W) {
    var M;
    var X;
    var N;
    var O;
    var U;
    var R;
    if (W instanceof APIPeerConnections) {
        MC.debugOutput("update reference of APIPeerConnections")
    }
    var D = W.getKeyValue();
    if (D) {
        this.base[W.basetype][D] = W
    } else {
        this.noKeys[W.basetype] = "Not in collection"
    }
    N = DataCache.BASETYPES[W.basetype];
    if (N == undefined) {
        if (typeof inTesting != "undefined") {
            testingObjs[W.basetype] = W
        }
        return
    }
    if (W.parentObject instanceof APIObject) {
        M = W.parentObject
    } else {
        M = DC
    }
    for (var S = 0; S < N.length; S++) {
        U = N[S];
        O = DataCache.COLLECTIONS[U];
        R = O.key;
        if (!D) {
            this.noKeys[W.basetype] = "IN collection"
        }
        X = ((R == "singleton") ? "noKey" : W.getPropertyValue(R));
        if (X) {
            this._updateRef(M, U, X, W, false);
            if (M != DC && O.base) {
                this._updateRef(DC, U, X, W, false)
            }
        }
        var V = O.associations;
        for (var Q = 0; Q < V.length; Q++) {
            var E = V[Q];
            var G = DataCache.ASSOCIATIONS[E];
            var C = G.assocName;
            var L = DataCache.COLLECTIONS[G.baseSet].key;
            var F = DataCache.COLLECTIONS[G.assocSet].key;
            if (G.assocKeyProp) {
                if (G.assocSet == U) {
                    var T = W.getPropertyValue(G.assocKeyProp);
                    if (T) {
                        if (G.assocKeyProp == "mapped_id") {
                            var K = false;
                            if (T.indexOf("HG") == 0 && G.baseSet == "hostGroupsId") {
                                K = true
                            } else {
                                if (T.indexOf("H") == 0 && G.baseSet == "hostsId") {
                                    K = true
                                } else {
                                    if (T.indexOf("I") == 0 && G.baseSet == "initiatorsId") {
                                        K = true
                                    }
                                }
                            }
                            if (!K) {
                                continue
                            }
                        }
                        var E = W.getPropertyValue(G.assocPrimaryKey);
                        var J = DC[G.baseSet][T];
                        if (J) {
                            this._updateRef(J, C, E, W, true)
                        } else {
                            if (G.pending[T] == undefined) {
                                G.pending[T] = {}
                            }
                            var I = W.getPropertyValue(F);
                            G.pending[T][I] = true
                        }
                    } else {
                        this._removeAssocRef(null, W, U)
                    }
                } else {
                    if (G.baseSet == U) {
                        var H = W.getPropertyValue(L);
                        if (G.pending[H]) {
                            for (var I in G.pending[H]) {
                                var P = DC[G.assocSet][I];
                                if (P) {
                                    var E = P.getPropertyValue(G.assocPrimaryKey);
                                    this._updateRef(W, C, E, P, true)
                                }
                                delete G.pending[H][I]
                            }
                        }
                    }
                }
            }
            if (G.baseKeyProp) {
                if (G.baseSet == U) {
                    var E = W.getPropertyValue(G.baseKeyProp);
                    if (E) {
                        var P = DC[G.assocSet][E];
                        if (P) {
                            this._updateRef(W, C, "noKey", P, true);
                            W[C] = P
                        } else {
                            if (G.pending[E] == undefined) {
                                G.pending[E] = {}
                            }
                            var H = W.getPropertyValue(L);
                            G.pending[E][H] = true
                        }
                    } else {
                        this._removeAssocRef(W, null, U)
                    }
                } else {
                    if (G.assocSet == U) {
                        var I = W.getPropertyValue(F);
                        if (G.pending[I]) {
                            for (var H in G.pending[I]) {
                                var J = DC[G.baseSet][H];
                                if (J) {
                                    this._updateRef(J, C, "noKey", W, true)
                                }
                                delete G.pending[I][H]
                            }
                        }
                    }
                }
            }
        }
    }
};
DataCache.prototype._updateRef = function(C, G, F, D, I) {
    for (var E = 0; E < D.dcParents.length; E++) {
        var H = D.dcParents[E];
        if (H.parent == C && H.collection == G && H.isAssociation == I) {
            if (H.key == F) {
                return
            }
            if (H.key == "noKey") {
                delete H.parent[H.collection]
            } else {
                delete H.parent[H.collection][H.key]
            }
            D.dcParents.splice(E, 1);
            break
        }
    }
    if (F == "noKey") {
        C[G] = D
    } else {
        if (C[G] == undefined) {
            C[G] = {}
        }
        C[G][F] = D
    }
    D.dcParents.push({
        parent: C,
        collection: G,
        key: F,
        isAssociation: I
    })
};
DataCache.prototype._removeAssocRef = function(D, J, F) {
    var H = null;
    var C = D;
    var G = J;
    if (C) {
        G = C[F];
        if (G == undefined) {
            return
        }
        if (G) {
            for (var E = 0; E < G.dcParents; E++) {
                var I = G.dcParents[E];
                if (I.parent == C && I.collName == F && I.isAssociation) {
                    delete C[F];
                    H = E;
                    break
                }
            }
        }
    } else {
        if (G) {
            for (var E = 0; E < G.dcParents.length; E++) {
                var I = G.dcParents[E];
                if (I.collName == F && I.isAssociation) {
                    C = I.parent;
                    delete C[F][I.key];
                    H = E;
                    break
                }
            }
        } else {
            MC.errorOutput("Attempt to delete association refernence that doesn't exist, baseObj = %o, assocObj = %o, collName = %s", D, J, F)
        }
    }
    if (G && H) {
        G.dcParents.splice(H, 1)
    }
};
DataCache.prototype.addObject = function(D) {
    this.updateReferences(D);
    for (var C = 0; C < D.objects.length; C++) {
        this.addObject(D.objects[C])
    }
};
DataCache.prototype.findUserByName = function(C) {
    if (!C) {
        return null
    }
    if (DC.users[C]) {
        return DC.users[C]
    }
    return null
};
DataCache.prototype.findInitiatorByNickname = function(C) {
    if (!C) {
        return null
    }
    for (var D in DC.initiators) {
        if (DC.initiators[D].get("nickname") == C) {
            return DC.initiators[D]
        }
    }
    return null
};
DataCache.prototype.removeObject = function(F) {
    if (!F || !(F instanceof APIObject)) {
        return
    }
    for (var C = 0; C < F.objects.length; C++) {
        this.removeObject(F.objects[C])
    }
    if (F.dcParents == undefined) {
        return
    }
    for (var C = 0; C < F.dcParents.length; C++) {
        var E = F.dcParents[C];
        if (E.key == "noKey") {
            if (E.parent[E.collection] == F) {
                delete E.parent[E.collection]
            }
        } else {
            if (E.parent[E.collection][E.key] == F) {
                delete E.parent[E.collection][E.key]
            }
        }
    }
    F.dcParents = [];
    var D = F.getKeyValue();
    if (D && this.base[F.basetype][D] == F) {
        delete this.base[F.basetype][D]
    }
};
DataCache.prototype.addBasetype = function(C) {
    if (C && !this.base[C]) {
        this.base[C] = {}
    }
};
DataCache.prototype.printNoKeys = function() {
    var C = "The following basetypes have no primary KEY defined:\n";
    for (var D in this.noKeys) {
        C += "\t" + D + " : " + this.noKeys[D] + "\n"
    }
    if (window.console) {
        console.log(C)
    }
};
DC = new DataCache();
DataCache.prototype.savePortTypes = function() {
    DataCache.hasFc = false;
    DataCache.hasIscsi = false;
    DataCache.hasSas = false;
    DataCache.hasIB = false;
    for (var D in this.ports) {
        var E = this.ports[D];
        if (E.get("status_numeric") == PORT_STATES.NOT_PRESENT) {
            continue
        }
        var C = E.get("port_type");
        switch (C) {
            case "FC":
                DataCache.hasFc = true;
                break;
            case "iSCSI":
                DataCache.hasIscsi = true;
                break;
            case "SAS":
                DataCache.hasSas = true;
                break;
            case "IB":
                DataCache.hasIB = true;
                break;
            default:
                break
        }
    }
};
DataCache.prototype.findReplicationVolume = function(C) {
    var H = this.repSetsSerial;
    for (var E in H) {
        var G = H[E];
        var F = G.repVolumesSerial;
        if (F) {
            var D = F[C];
            if (D) {
                return D
            }
        }
    }
    return null
};
DataCache.prototype.findRemoteSystem = function(D) {
    var C = this.remoteSystemsIPA[D];
    if (C) {
        return C
    }
    var C = this.remoteSystemsIPB[D];
    if (C) {
        return C
    }
    var C = this.remoteSystems[D];
    if (C) {
        return C
    }
    return null
};
DataCache.prototype.getVirtualPoolNames = function() {
    var C = {};
    if (this.pools.A != undefined) {
        C.A = true
    }
    if (this.pools.B != undefined) {
        C.B = true
    }
    return C
};

function DCRef(D, C) {
    if (D instanceof APIObject) {
        this.basetype = D.basetype;
        this.key = D.getKeyValue() || "noKey"
    } else {
        this.basetype = D;
        this.key = C
    }
}
DCRef.fromID = function(G) {
    var F = G.indexOf("_");
    if (F == -1) {
        return null
    }
    var D = G.indexOf("_", F + 1);
    if (D == -1) {
        return null
    }
    var E = G.substr(F + 1, D - F - 1);
    var C = G.substr(D + 1);
    if (!C) {
        return null
    }
    return new DCRef(E, C)
};
DCRef.prototype.equals = function(C) {
    if (!C || !C instanceof DCRef) {
        return false
    }
    if (C.basetype == this.basetype && C.key == this.key) {
        return true
    } else {
        return false
    }
};
DCRef.prototype.makeID = function(C) {
    if (C == undefined) {
        C = ""
    }
    return "#" + C + "_" + this.basetype + "_" + this.key.replace(/(:|\.|\[|\]|,|=|@)/g, "\\$1")
};
DCRef.prototype.getObject = function() {
    if (!this.basetype) {
        return null
    }
    if (DC.base[this.basetype]) {
        return DC.base[this.basetype][this.key]
    }
    return null
};
(function(C) {
    C.dh = C.dh || {};
    C.extend(C.expr[":"], {
        treeNode: "(' '+a.className+' ').indexOf(' dh-treeNode ')"
    });
    C.fn.treeNode = function(D) {
        return this.each(function() {
            if (!C(this).is(".dh-treeNode")) {
                D.element = this;
                C.data(this, "dh-treeNode", D);
                C(this).addClass("dh-treeNode")
            }
        })
    };
    C.fn.treeNodeInstance = function() {
        if (C(this[0]).is(".dh-treeNode")) {
            return C.data(this[0], "dh-treeNode")
        }
        return false
    }
})($);

function ContainerNode(C) {
    if (arguments.length == 0) {
        return
    }
    this.name = C.name;
    this.defaultPanel = null;
    this.parent = C.parent;
    this.elements$ = $("<ul></ul>", C.doc);
    this.class_name = "ContainerNode";
    this.options = C;
    this.children = [];
    if (C.defaultOpen) {
        this.setExpansion(true)
    } else {
        this.setExpansion(false)
    }
}
ContainerNode.prototype.attach = function() {
    if (!this.attached) {
        this.attached = true;
        this.parent.elements$.append(this.elements$);
        this.bindEvents()
    }
};
ContainerNode.prototype.detach = function() {
    if (this.attached) {
        this.attached = false;
        this.elements$.remove();
        this.unbindEvents()
    }
};
ContainerNode.prototype.setExpansion = function(C) {
    if (C) {
        this.attach()
    } else {
        this.detach()
    }
    this.opened = C
};
ContainerNode.prototype.expand = function() {
    this.setExpansion(true);
    this.parent.setMyState()
};
ContainerNode.prototype.collapse = function() {
    this.setExpansion(false);
    this.parent.setMyState()
};
ContainerNode.prototype.expandAll = function() {
    var D = this.children.length;
    for (var C = 0; C < D; C++) {
        this.children[C].expandAll()
    }
};
ContainerNode.prototype.collapseAll = function() {
    var D = this.children.length;
    for (var C = 0; C < D; C++) {
        this.children[C].collapseAll()
    }
};
ContainerNode.prototype.getElements$ = function() {
    return this.elements$
};
ContainerNode.prototype.getChild = function(C) {
    var D = this.children[C];
    if (D == undefined) {
        D = null
    }
    return D
};
ContainerNode.prototype.length = function() {
    return this.children.length
};
ContainerNode.prototype.append = function(C) {
    this.children.push(C);
    this.elements$.append(C.elements$)
};
ContainerNode.prototype.prepend = function(C) {
    this.children.unshift(C);
    this.elements$.prepend(C.elements$)
};
ContainerNode.prototype.before = function(C, F) {
    var E = this.children.length;
    for (var D = 0; D < E; D++) {
        if (this.children[D] == C) {
            this.children.splice(D, 0, F);
            C.elements$.before(F.elements$);
            break
        }
    }
};
ContainerNode.prototype.after = function(E) {
    var D = this.children.length;
    for (var C = 0; C < D; C++) {
        if (this.children[C] == whichNode) {
            this.children.splice(C + 1, 0, E);
            whichNode.elements$.after(E.elements$);
            break
        }
    }
};
ContainerNode.prototype.remove = function(E) {
    E.elements$.remove();
    var D = this.children.length - 1;
    for (var C = 0; C <= D; C++) {
        if (this.children[C] == E) {
            this.children.splice(C, 1);
            if (C == D && C != 0) {
                this.children[C - 1].setNodeState(true)
            }
            break
        }
    }
};
ContainerNode.prototype.lastChild = function() {
    return this.children[this.children.length - 1]
};
ContainerNode.prototype.setStates = function() {
    var D = this.children.length - 1;
    for (var C = 0; C <= D; C++) {
        this.children[C].setNodeState(C == D)
    }
};
ContainerNode.prototype.bindEvents = function() {
    var D = this.children.length;
    for (var C = 0; C < D; C++) {
        this.children[C].bindEvents()
    }
};
ContainerNode.prototype.unbindEvents = function() {
    var D = this.children.length;
    for (var C = 0; C < D; C++) {
        this.children[C].unbindEvents()
    }
};

function DataNode(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.selectable != undefined) {
        this.selectable = C.selectable
    } else {
        this.selectable = true
    }
    this.type = C.type;
    this.name = C.name;
    this.nodeName = this.type + this.name;
    this.container = null;
    this.rootNode = C.rootNode || this;
    this.defaultPanel = C.defaultPanel;
    this.textTitle = "datanode";
    this.jsonObject = (C.jsonObject ? C.jsonObject : null);
    this.nodeClass = C.nodeClass;
    this.state = "noState";
    if (C.parentName) {
        this.parent = this.rootNode.nodeCache[C.parentType][C.parentName];
        this.level = this.parent.level + 1
    } else {
        this.parent = null;
        this.level = -1;
        this.createCache()
    }
    if (C.htmlText) {
        this.elements$ = $(C.htmlText, C.doc)
    } else {
        if (this.selectable) {
            this.elements$ = $(DataNode.selTemplate[this.level], C.doc)
        } else {
            this.elements$ = $(DataNode.template[this.level], C.doc)
        }
    }
    this.class_name = "DataNode";
    this.options = C;
    if (this.rootNode == this) {
        this.makeContainer()
    } else {
        var D = $("div", this.elements$);
        this.healthDiv$ = D.eq(0);
        this.nodeDiv$ = D.eq(1);
        this.nodeDiv$.addClass(C.nodeClass);
        if (this.selectable) {
            this.nodeA$ = $("a", this.elements$)
        } else {
            this.nodeA$ = $("span", this.elements$)
        }
        if (this.parent) {
            this.parent.addNode(this)
        }
        this.updateHealth();
        if (this.options.makeContainer) {
            this.makeContainer()
        }
    }
    this.bindEvents();
    this.rootNode.nodeCache[this.type][this.name] = this;
    if (this.parent) {
        this.parent.setMyState()
    }
}
DataNode.getTemplate = function(E, C) {
    var D = '<li><div class="treeL' + E + '"></div><div class="node">' + (C ? '<a style="white-space: nowrap;"></a>' : '<span style="white-space: nowrap;"></span>') + "</div></li>";
    return D
};
DataNode.initStaticData = function() {
    var D = 12;
    DataNode.template = [D];
    DataNode.selTemplate = [D];
    for (var C = 0; C < D; C++) {
        DataNode.template[C] = DataNode.getTemplate(C, false);
        DataNode.selTemplate[C] = DataNode.getTemplate(C, true)
    }
};
DataNode.initStaticData();
DataNode.prototype.createCache = function() {
    this.nodeCache = {};
    this.nodeCache[TREETYPES.ROOT] = {};
    this.nodeCache[TREETYPES.SYSTEM] = {};
    this.nodeCache[TREETYPES.LOGICAL] = {};
    this.nodeCache[TREETYPES.PHYSICAL] = {};
    this.nodeCache[TREETYPES.ENCLOSURE] = {};
    this.nodeCache[TREETYPES.CONTROLLER_SET] = {};
    this.nodeCache[TREETYPES.VDISK_SET] = {};
    this.nodeCache[TREETYPES.HOST_SET] = {};
    this.nodeCache[TREETYPES.SNAP_SET] = {};
    this.nodeCache[TREETYPES.SNAPPOOL_SET] = {};
    this.nodeCache[TREETYPES.CONTROLLER] = {};
    this.nodeCache[TREETYPES.VDISK] = {};
    this.nodeCache[TREETYPES.VDISK_FREE] = {};
    this.nodeCache[TREETYPES.VOLUME] = {};
    this.nodeCache[TREETYPES.SNAPSHOT] = {};
    this.nodeCache[TREETYPES.SNAPPOOL] = {};
    this.nodeCache[TREETYPES.HOST] = {};
    this.nodeCache[TREETYPES.VOLUME_MAP] = {};
    this.nodeCache[TREETYPES.REMOTE_SYSTEM] = {};
    this.nodeCache[TREETYPES.REPLICATION_VOLUME] = {};
    this.nodeCache[TREETYPES.REPLICATION_IMAGE] = {};
    this.nodeCache[TREETYPES.REPIMAGE_SET] = {};
    this.nodeCache[TREETYPES.HELP] = {}
};
DataNode.prototype.lostEvents = function() {
    this.hitAreaEvent = false;
    this.selectableEvent = false
};
DataNode.prototype.bindExpandableEvent = function() {
    if (this.hitArea$ && !this.hitAreaEvent) {
        this.hitArea$.click(createObjectCallback(this, this.toggleExpansion));
        this.hitAreaEvent = true
    }
};
DataNode.prototype.unbindExpandableEvent = function() {
    if (this.hitArea$ && this.hitAreaEvent) {
        this.hitArea$.unbind("click");
        this.hitAreaEvent = false
    }
};
DataNode.prototype.bindSelectableEvent = function() {
    if (this.selectable && !this.selectableEvent) {
        if (this.nodeDiv$) {
            this.nodeDiv$.click(createObjectCallback(this, this.selectNode));
            this.nodeDiv$.contextMenu("#contextmenu", createObjectCallback(this, this.onContextMenu));
            this.selectableEvent = true
        }
    }
};
DataNode.prototype.unbindSelectableEvent = function() {
    if (this.selectable && this.selectableEvent) {
        if (this.nodeDiv$) {
            this.nodeDiv$.unbind("click");
            this.nodeDiv$.unbind("contextmenu");
            this.selectableEvent = false
        }
    }
};
DataNode.prototype.bindEvents = function() {
    this.bindSelectableEvent();
    this.bindExpandableEvent();
    if (this.container && this.container.attached) {
        this.container.bindEvents()
    }
};
DataNode.prototype.unbindEvents = function() {
    this.unbindSelectableEvent();
    this.unbindExpandableEvent();
    if (this.container && this.container.attached) {
        this.container.unbindEvents()
    }
};
DataNode.prototype.reparent = function(C) {
    var E = "treeL" + this.level;
    this.level = C.level + 1;
    var D = "treeL" + this.level;
    this.healthDiv$.removeClass(E).addClass(D);
    this.parent = C
};
DataNode.prototype.getNode = function(C, D) {
    return this.rootNode.nodeCache[D][C]
};
DataNode.prototype.getNodeWithName = function(F) {
    var E = F.indexOf("_");
    if (E >= 0) {
        var D = F.substring(0, E + 1);
        var C = F.substring(E + 1);
        return this.rootNode.nodeCache[D][C]
    }
    return null
};
DataNode.prototype.markSetForDeletion = function(D) {
    var C = this.rootNode.nodeCache[D];
    if (C) {
        for (var F in C) {
            var E = C[F];
            if (E) {
                E.mark = true
            }
        }
    }
    return C
};
DataNode.prototype.deleteMarkedInSet = function(D) {
    if (D) {
        for (var E in D) {
            var C = D[E];
            if (C && C.mark) {
                C.parent.removeNode(C)
            }
        }
    }
    this.rootNode.container.setStates()
};
DataNode.prototype.makeContainer = function() {
    if (this.container) {
        return
    }
    this.container = new ContainerNode({
        doc: this.options.doc,
        parent: this,
        name: this.name,
        defaultOpen: this.options.defaultOpen
    });
    if (this.parent) {
        this.hitArea$ = $('<div class="hitarea"></div>', this.options.doc);
        this.elements$.prepend(this.hitArea$);
        this.bindExpandableEvent()
    }
};
DataNode.prototype.deleteContainer = function() {
    if (this.container) {
        this.container.detach();
        this.container.unbindEvents();
        this.container = null;
        this.unbindExpandableEvent();
        if (this.hitArea$) {
            this.hitArea$.remove()
        }
        this.hitArea$ = null;
        this.setNodeState(this.amLastChild())
    }
};
DataNode.prototype.setNodeState = function(C) {
    if (this.container) {
        var D = (this.container.opened) ? (C ? "lastCollapsable" : "collapsable") : (C ? "lastExpandable" : "expandable");
        if (D != this.state) {
            this.elements$.removeClass(this.state).addClass(D);
            this.state = D
        }
        this.container.setStates()
    } else {
        var D = (C ? "last" : "");
        if (D != this.state) {
            this.elements$.removeClass(this.state);
            if (D) {
                this.elements$.addClass(D)
            }
            this.state = D
        }
    }
};
DataNode.prototype.setMyState = function() {
    this.setNodeState(this.amLastChild())
};
DataNode.prototype.expand = function() {
    if (this.container) {
        this.container.expand()
    }
};
DataNode.prototype.collapse = function() {
    if (this.container) {
        this.container.collapse()
    }
};
DataNode.prototype.expandAll = function() {
    this.expand();
    if (this.container) {
        this.container.expandAll()
    }
};
DataNode.prototype.collapseAll = function() {
    if (this.container) {
        this.container.collapseAll()
    }
    this.collapse()
};
DataNode.prototype.toggleExpansion = function() {
    if (this.container && this.container.opened) {
        this.collapse()
    } else {
        this.expand()
    }
};
DataNode.prototype.amLastChild = function() {
    container = this.getParentContainer();
    if (container && container.lastChild() == this) {
        return true
    }
    return false
};
DataNode.prototype.updateHealth = function() {
    if (this.jsonObject) {
        var D = this.jsonObject.prop.health_numeric;
        if (D) {
            switch (parseInt(D.text)) {
                case 0:
                    var C = "treeHealthOk";
                    break;
                case 1:
                    var C = "treeHealthDegraded";
                    break;
                case 2:
                    var C = "treeHealthBad";
                    break;
                case 3:
                default:
                    var C = "treeHealthUnknown";
                    break
            }
        } else {
            var C = "treeHealthNone"
        }
    }
    if (this.healthClass) {
        this.healthDiv$.removeClass(this.healthClass)
    }
    this.healthDiv$.addClass(C);
    this.healthClass = C
};
DataNode.prototype.onContextMenu = function(D) {
    this.selectNode();
    var C = NAV.getContextMenu(this.defaultPanel, this.nodeName);
    if (C) {
        $(D).empty().html(C);
        return true
    } else {
        return false
    }
};
DataNode.handleContextMenuClick = function(F) {
    var C = $(F.target);
    var D = C.attr("name");
    var G = C.attr("selectionPath");
    var E = CTR.getNodeWithName(D);
    if (E) {
        if (NAV.isDisabled(G)) {
            return
        }
        E.selectNode();
        NAV.select(G)
    }
};
DataNode.prototype.getNodeName = function(D, C) {
    return D + C
};
DataNode.prototype.getTextTitle = function() {
    return this.textTitle
};
DataNode.prototype.setData = function(C) {};
DataNode.prototype.addTypeClass = function(C) {
    this.nodeDiv$.addClass(C)
};
DataNode.prototype.removeTypeClass = function(C) {
    this.nodeDiv$.removeClass(C)
};
DataNode.prototype.getMyContainer = function() {
    if (!this.container) {
        this.makeContainer()
    }
    return this.container
};
DataNode.prototype.getParentContainer = function() {
    if (this.parent) {
        return this.parent.getMyContainer()
    }
    return null
};
DataNode.prototype.hasContainer = function() {
    if (this.container) {
        return true
    }
    return false
};
DataNode.prototype.getName = function() {
    return this.name
};
DataNode.prototype.getType = function() {
    return this.type
};
DataNode.prototype.getJsonObject = function() {
    return this.jsonObject
};
DataNode.prototype.selectNode = function(C) {
    if (!C && panels.treePanel.getSelected() == this) {
        return true
    }
    $(".treeSelected", this.rootNode.elements$).removeClass("treeSelected");
    this.nodeDiv$.addClass("treeSelected");
    panels.contentPanel.setTitle(this.getTextTitle());
    panels.treePanel.setSelected(this);
    if (typeof this.defaultPanel == "string") {
        views.contentCanvas.viewAttach(NAV.getPanel(this.defaultPanel))
    } else {
        views.contentCanvas.viewAttach(this.defaultPanel)
    }
    return true
};
DataNode.prototype.setSelection = function() {
    var C = $(".treeSelected", this.rootNode.elements$).hasClass("treeSelected");
    if (!C) {
        this.nodeDiv$.addClass("treeSelected")
    }
};
DataNode.prototype.clearSelection = function() {
    $(".treeSelected", this.rootNode.elements$).removeClass("treeSelected")
};
DataNode.prototype.getChild = function(C) {
    if (this.container) {
        return this.container.getChild(C)
    }
    return null
};
DataNode.prototype.selectMe = function() {
    this.nodeDiv$.click()
};
DataNode.prototype.findSelectableAncestor = function() {
    if (!this.parent || this.parent == this.rootNode) {
        return panels.treePanel.system
    } else {
        if (this.parent.selectable) {
            return this.parent
        } else {
            return this.parent.findSelectableAncestor()
        }
    }
};
DataNode.prototype.destructor = function() {
    this.deleted = true;
    var E = this.getParentContainer();
    if (E && (E.length() <= 1)) {
        this.parent.deleteContainer()
    }
    var D = panels.treePanel.getSelected();
    var C = null;
    if (D == this) {
        C = this.findSelectableAncestor()
    }
    if (C) {
        C.selectNode()
    }
    if (this.parent) {
        this.parent.deleteNode(this)
    }
};
DataNode.prototype.handleUpdate = function(C) {
    this.mark = false;
    if (C.name) {
        this.name = C.name
    }
    if (C.jsonObject) {
        this.jsonObject = C.jsonObject
    }
    this.setData(C);
    var D = strings.treeNode[this.nodeClass];
    if (D) {
        this.textTitle = namedFormat(D, this)
    } else {
        MC.errorOutput("DataNode.prototype.handleUpdate: no format string for: " + this.nodeClass)
    }
    this.nodeA$.html(this.getTextTitle());
    this.updateHealth();
    return this
};
DataNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        C.append(D);
        D.reparent(this)
    }
};
DataNode.prototype.deleteNode = function(C) {};
DataNode.prototype.removeNode = function(C) {
    C.destructor();
    if (!this.deleted && this.container) {
        this.container.remove(C)
    }
    delete this.rootNode.nodeCache[C.type][C.name]
};
DataNode.prototype.expandTo = function() {
    var E = this;
    if (E != undefined) {
        var D = E;
        var C = [];
        while (D.parent) {
            C.push(D.parent);
            D = D.parent
        }
        if (D != E.rootNode) {
            MC.warningOutput("DataNode.expandTo: Did not find rootNode!");
            return
        }
        D = C.shift();
        while (D) {
            if (D.container && !D.container.opened) {
                D.container.setExpansion(true)
            }
            D = C.shift()
        }
        E.rootNode.setMyState()
    }
    return
};

function RootNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.rootNode = this;
    C.htmlText = '<div class="treeRoot"></div>';
    C.type = TREETYPES.ROOT;
    C.nodeClass = "RootNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.container.elements$.addClass("treeview");
    this.class_name = C.nodeClass
}
RootNode.prototype = new DataNode();
RootNode.prototype.constructor = RootNode;

function SystemNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.SYSTEM;
    C.nodeClass = "SystemNode";
    C.defaultPanel = "system";
    C.defaultOpen = true;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options);
    this.logical = new LogicalNode({
        name: "Logical",
        parentName: this.name,
        parentType: this.type,
        rootNode: this.rootNode,
        makeContainer: true,
        defaultOpen: true,
        selectable: false
    });
    this.physical = new PhysicalNode({
        name: "Physical",
        parentName: this.name,
        parentType: this.type,
        rootNode: this.rootNode,
        makeContainer: true,
        defaultOpen: true,
        selectable: false
    });
    panels.treePanel.system = this
}
SystemNode.prototype = new DataNode();
SystemNode.prototype.constructor = SystemNode;
SystemNode.prototype.setData = function(C) {
    if (this.jsonObject) {
        this.systemName = this.jsonObject.getPropertyValue("system_name");
        this.productId = this.jsonObject.getPropertyValue("product_id")
    } else {
        this.systemName = strings.system;
        this.productId = strings.system
    }
};
SystemNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        if (D.type == TREETYPES.ENCLOSURE) {
            this.physical.addNode(D)
        } else {
            if (D.type == TREETYPES.VDISK) {
                this.logical.addNode(D)
            } else {
                if (D.type == TREETYPES.HOST) {
                    this.logical.addNode(D)
                } else {
                    C.append(D);
                    D.reparent(this)
                }
            }
        }
    }
};

function RemoteSystemNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.REMOTE_SYSTEM;
    C.nodeClass = "RemoteSystemNode";
    C.defaultPanel = "remoteSystem";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
RemoteSystemNode.prototype = new DataNode();
RemoteSystemNode.prototype.constructor = RemoteSystemNode;
RemoteSystemNode.prototype.setData = function(C) {
    if (this.jsonObject) {
        this.systemName = this.jsonObject.getPropertyValue("system_name");
        this.ipA = this.jsonObject.getPropertyValue("ip_address_a");
        this.ipB = this.jsonObject.getPropertyValue("ip_address_b");
        this.productId = this.jsonObject.getPropertyValue("product_id")
    } else {
        this.systemName = strings.system;
        this.productId = strings.system;
        this.ipA = "";
        this.ipB = ""
    }
};

function LogicalNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.LOGICAL;
    C.nodeClass = "LogicalNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options);
    this.vdisks = new VdiskSetNode({
        name: "Vdisks",
        parentName: this.name,
        parentType: this.type,
        rootNode: this.rootNode,
        makeContainer: true,
        defaultOpen: true
    });
    this.hosts = new HostSetNode({
        name: "Hosts",
        parentName: this.name,
        parentType: this.type,
        rootNode: this.rootNode,
        makeContainer: true,
        defaultOpen: false
    })
}
LogicalNode.prototype = new DataNode();
LogicalNode.prototype.constructor = LogicalNode;
LogicalNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        if (D.type == TREETYPES.VDISK_SET || D.type == TREETYPES.HOST_SET) {
            C.append(D);
            D.reparent(this)
        } else {
            if (D.type == TREETYPES.VDISK) {
                this.vdisks.addNode(D)
            } else {
                if (D.type == TREETYPES.HOST) {
                    this.hosts.addNode(D)
                } else {
                    MC.warningOutput("Adding unknown node type (%s) to system Logical node.", D.type);
                    C.append(D);
                    D.reparent(this)
                }
            }
        }
    }
};

function PhysicalNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.PHYSICAL;
    C.nodeClass = "PhysicalNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
PhysicalNode.prototype = new DataNode();
PhysicalNode.prototype.constructor = PhysicalNode;

function ControllerSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.CONTROLLER_SET;
    C.nodeClass = "ControllerSetNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
ControllerSetNode.prototype = new DataNode();
ControllerSetNode.prototype.constructor = ControllerSetNode;

function VdiskSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.VDISK_SET;
    C.nodeClass = "VdiskSetNode";
    C.defaultPanel = "vdiskSet";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
VdiskSetNode.prototype = new DataNode();
VdiskSetNode.prototype.constructor = VdiskSetNode;
VdiskSetNode.prototype.hasMappableVolumes = function() {
    var D = MC.volumesSet.getData();
    for (var C = 0; C < D.objects.length; C++) {
        if (D.objects[C].isMappable()) {
            return true
        }
    }
    return false
};

function HostSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.HOST_SET;
    C.nodeClass = "HostSetNode";
    C.defaultPanel = "hostSet";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
HostSetNode.prototype = new DataNode();
HostSetNode.prototype.constructor = HostSetNode;

function SnapSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.SNAP_SET;
    C.nodeClass = "SnapSetNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
SnapSetNode.prototype = new DataNode();
SnapSetNode.prototype.constructor = SnapSetNode;
SnapSetNode.prototype.deleteNode = function(C) {
    if (!this.hasContainer()) {
        this.parent.removeNode(this)
    }
};

function SnapPoolSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.SNAPPOOL_SET;
    C.nodeClass = "SnapPoolSetNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
SnapPoolSetNode.prototype = new DataNode();
SnapPoolSetNode.prototype.constructor = SnapPoolSetNode;
SnapPoolSetNode.prototype.deleteNode = function(C) {
    if (!this.hasContainer()) {
        this.parent.removeNode(this)
    }
};

function RepImageSetNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.REPIMAGE_SET;
    C.nodeClass = "RepImageSetNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
RepImageSetNode.prototype = new DataNode();
RepImageSetNode.prototype.constructor = RepImageSetNode;
RepImageSetNode.prototype.deleteNode = function(C) {
    if (!this.hasContainer()) {
        this.parent.removeNode(this)
    }
};

function VdiskNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.VDISK;
    C.nodeClass = "VdiskNode";
    C.defaultPanel = "vdisk";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
VdiskNode.prototype = new DataNode();
VdiskNode.prototype.constructor = VdiskNode;
VdiskNode.prototype.setData = function(C) {
    this.vdiskName = this.jsonObject.getPropertyValue("name");
    this.sernum = this.jsonObject.getPropertyValue("serial_number");
    this.driveType = this.jsonObject.getPropertyValue("array_drive_type");
    this.freeSpace = this.jsonObject.getPropertyValue("freespace");
    this.status = this.jsonObject.getPropertyValue("status");
    this.statusNumeric = this.jsonObject.getPropertyValue("status_numeric");
    var D = this.isShutdown;
    this.isShutdown = this.jsonObject.isShutdown();
    if (this.isShutdown) {
        this.raid = strings.shutdown
    } else {
        this.raid = this.jsonObject.getPropertyValue("raidtype");
        if (this.driveType == "MIXED") {
            this.raid += "-MIXED"
        }
    }
    if (panels.treePanel.getSelected() == this && D != undefined) {
        if (this.isShutdown != D) {
            this.selectNode(true)
        }
    }
};
VdiskNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        if (D.type == TREETYPES.SNAPPOOL_SET) {
            C.append(D);
            D.reparent(this)
        } else {
            if (D.type == TREETYPES.SNAPPOOL) {
                if (!this.snapPoolSetNode) {
                    this.snapPoolSetNode = new SnapPoolSetNode({
                        name: "SnapPools" + this.sernum,
                        parentName: this.name,
                        parentType: this.type,
                        rootNode: this.rootNode,
                        makeContainer: true,
                        defaultOpen: false,
                        selectable: false
                    })
                }
                this.snapPoolSetNode.addNode(D)
            } else {
                if (D.type == TREETYPES.VDISK_FREE) {
                    if (!this.freeNode) {
                        this.freeNode = D
                    }
                    C.append(D);
                    D.reparent(this)
                } else {
                    if (this.snapPoolSetNode) {
                        C.before(this.snapPoolSetNode, D)
                    } else {
                        if (this.freeNode) {
                            C.before(this.freeNode, D)
                        } else {
                            C.append(D)
                        }
                    }
                    D.reparent(this)
                }
            }
        }
    }
};
VdiskNode.prototype.deleteNode = function(C) {
    if (C.type == TREETYPES.VDISK_FREE) {
        this.freeNode = null
    } else {
        if (C.type == TREETYPES.SNAPPOOL_SET) {
            this.snapPoolSetNode = null
        }
    }
};
VdiskNode.prototype.hasMappableVolumes = function() {
    var D = MC.volumesSet.getData().select({
        type: "prop",
        name: "virtual_disk_serial",
        value: this.sernum
    });
    for (var C = 0; C < D.objects.length; C++) {
        if (D.objects[C].isMappable()) {
            return true
        }
    }
    return false
};
VdiskNode.prototype.hasExtViewVolumes = function() {
    var D = MC.volumesSet.getData().select({
        type: "prop",
        name: "virtual_disk_serial",
        value: this.sernum
    });
    for (var C = 0; C < D.objects.length; C++) {
        if (D.objects[C].isRSRExternalView()) {
            return true
        }
    }
    return false
};
VdiskNode.prototype.isVdiskFTOL = function() {
    if (this.statusNumeric == 0) {
        return true
    }
    return false
};

function VdiskFreeNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.VDISK_FREE;
    C.nodeClass = "VdiskFreeNode";
    C.defaultPanel = "vdiskFree";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
VdiskFreeNode.prototype = new DataNode();
VdiskFreeNode.prototype.constructor = VdiskFreeNode;
VdiskFreeNode.prototype.setData = function(C) {
    this.vdiskName = this.jsonObject.getPropertyValue("name");
    this.sernum = this.jsonObject.getPropertyValue("serial_number");
    this.freeSpace = this.jsonObject.getPropertyValue("freespace");
    this.label = strings.vdiskLabel
};

function VolumeNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.VOLUME;
    C.nodeClass = "VolumeNode";
    C.defaultPanel = "volume";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
VolumeNode.prototype = new DataNode();
VolumeNode.prototype.constructor = VolumeNode;
VolumeNode.prototype.setData = function(C) {
    this.volName = this.jsonObject.prop.volume_name.text;
    this.volType = this.jsonObject.prop.volume_type.text;
    this.volTypeNumeric = parseInt(this.jsonObject.prop.volume_type_numeric.text, 10);
    this.vdiskName = this.jsonObject.prop.virtual_disk_name.text;
    this.sernum = this.jsonObject.prop.serial_number.text;
    this.size = this.jsonObject.prop.size.text;
    this.extView = this.jsonObject.isRSRExternalView();
    this.rsrSource = this.jsonObject.isRSRSource();
    this.rsrDest = this.jsonObject.isRSRDestination();
    this.mappable = this.jsonObject.isMappable();
    this.copyable = this.jsonObject.isCopyable();
    this.expandable = this.jsonObject.isExpandable();
    this.snappable = this.jsonObject.isSnappable();
    this.rsrPrepared = this.jsonObject.isRSRPrepared();
    this.standard = this.jsonObject.isStandard();
    this.label = strings.volumeLabel;
    var D = this.nodeClass;
    this.local = true;
    if (this.rsrSource) {
        D = "LocalSourceVolumeNode"
    } else {
        if (this.rsrDest) {
            D = "LocalTargetVolumeNode"
        } else {
            if (this.rsrPrepared) {
                D = "LocalPreparedVolumeNode"
            } else {
                D = this.options.nodeClass
            }
        }
    }
    if (D != this.nodeClass) {
        this.removeTypeClass(this.nodeClass);
        this.nodeClass = D;
        this.addTypeClass(this.nodeClass)
    }
};
VolumeNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        if (D.type == TREETYPES.SNAP_SET) {
            C.append(D);
            D.reparent(this)
        } else {
            if (D.type == TREETYPES.SNAPSHOT) {
                if (!this.snapSetNode) {
                    this.snapSetNode = new SnapSetNode({
                        name: "Snaps" + this.sernum,
                        parentName: this.name,
                        parentType: this.type,
                        rootNode: this.rootNode,
                        makeContainer: true,
                        defaultOpen: false,
                        selectable: false
                    })
                }
                this.snapSetNode.addNode(D)
            } else {
                if (D.type == TREETYPES.REPIMAGE_SET) {
                    if (this.snapSetNode) {
                        C.before(this.snapSetNode, D)
                    } else {
                        C.append(D)
                    }
                    D.reparent(this)
                } else {
                    if (D.type == TREETYPES.REPLICATION_IMAGE) {
                        if (!this.imageSetNode) {
                            this.imageSetNode = new RepImageSetNode({
                                name: "vImages" + this.sernum,
                                parentName: this.name,
                                parentType: this.type,
                                rootNode: this.rootNode,
                                makeContainer: true,
                                defaultOpen: false,
                                selectable: false
                            })
                        }
                        this.imageSetNode.addNode(D)
                    } else {
                        if (D.type == TREETYPES.REPLICATION_VOLUME) {
                            C.prepend(D);
                            D.reparent(this)
                        } else {
                            if (this.imageSetNode) {
                                C.before(this.imageSetNode, D)
                            } else {
                                if (this.snapSetNode) {
                                    C.before(this.snapSetNode, D)
                                } else {
                                    C.append(D)
                                }
                            }
                            D.reparent(this)
                        }
                    }
                }
            }
        }
    }
};
VolumeNode.prototype.deleteNode = function(C) {
    if (C.type == TREETYPES.SNAP_SET) {
        this.snapSetNode = null
    } else {
        if (C.type == TREETYPES.REPIMAGE_SET) {
            this.imageSetNode = null
        }
    }
};
VolumeNode.prototype.isDetached = function() {
    if (!this.rsrDest) {
        return undefined
    }
    var H = this.jsonObject.prop.serial_number.text;
    var F = this.jsonObject.prop.replication_set.text;
    var E = DC.repSetsSerial[F];
    if (E) {
        var G = E.repVolumesSerial;
        for (var D in G) {
            var C = G[D];
            if (D == H) {
                if (C.prop.status_numeric.text == "8") {
                    return true
                } else {
                    return false
                }
            }
        }
    }
    return undefined
};

function ReplicationVolumeNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.REPLICATION_VOLUME;
    C.nodeClass = "ReplicationVolumeNode";
    C.defaultPanel = "repVolume";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
ReplicationVolumeNode.prototype = new DataNode();
ReplicationVolumeNode.prototype.constructor = ReplicationVolumeNode;
ReplicationVolumeNode.prototype.setData = function(E) {
    var D = this.jsonObject.prop;
    this.volName = D.name.text;
    this.location = D.location_numeric.text;
    this.sernum = D.serial_number.text;
    this.extViewName = D.primary_volume_name.text;
    this.extViewSerial = D.primary_volume_serial.text;
    this.extView = this.jsonObject.isRSRExternalView();
    this.rsrSource = this.jsonObject.isRSRSource();
    this.rsrDest = this.jsonObject.isRSRDestination();
    this.local = (this.location == 0);
    var C = D.ip_address_a.text;
    if (C) {
        var G = DC.findRemoteSystem(C);
        if (G) {
            this.remoteSystemName = G.prop.system_name.text
        } else {
            this.remoteSystemName = ""
        }
    } else {
        this.remoteSystemName = DC.system.prop.system_name
    }
    var F = this.nodeClass;
    if (this.local) {
        if (this.rsrSource) {
            F = "LocalRepSourceVolumeNode"
        } else {
            F = "LocalRepTargetVolumeNode"
        }
    } else {
        if (this.rsrSource) {
            F = "RemoteRepSourceVolumeNode"
        } else {
            F = "RemoteRepTargetVolumeNode"
        }
    }
    if (F != this.nodeClass) {
        this.removeTypeClass(this.nodeClass);
        this.nodeClass = F;
        this.addTypeClass(this.nodeClass)
    }
};
ReplicationVolumeNode.prototype.addNode = function(D) {
    var C = this.getMyContainer();
    if (C) {
        if (D.type == TREETYPES.REPIMAGE_SET) {
            C.append(D);
            D.reparent(this)
        } else {
            if (D.type == TREETYPES.REPLICATION_IMAGE) {
                if (!this.imageSetNode) {
                    this.imageSetNode = new RepImageSetNode({
                        name: "rImages" + this.sernum,
                        parentName: this.name,
                        parentType: this.type,
                        rootNode: this.rootNode,
                        makeContainer: true,
                        defaultOpen: false,
                        selectable: false
                    })
                }
                this.imageSetNode.addNode(D)
            } else {
                if (D.type == TREETYPES.REPLICATION_VOLUME) {
                    C.prepend(D);
                    D.reparent(this)
                } else {
                    if (this.imageSetNode) {
                        C.before(this.imageSetNode, D)
                    } else {
                        C.append(D)
                    }
                    D.reparent(this)
                }
            }
        }
    }
};
ReplicationVolumeNode.prototype.deleteNode = function(C) {
    if (C.type == TREETYPES.REPIMAGE_SET) {
        this.imageSetNode = null
    }
};

function ReplicationImageNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.REPLICATION_IMAGE;
    C.nodeClass = "LocalRepImageNode";
    C.defaultPanel = "repImage";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
ReplicationImageNode.prototype = new DataNode();
ReplicationImageNode.prototype.constructor = ReplicationImageNode;
ReplicationImageNode.prototype.setData = function(D) {
    var C = this.jsonObject.prop;
    this.volParentObj = D.volParentObj;
    this.sernum = C.image_serial_number.text;
    this.snapName = C.snapshot_name.text;
    this.snapSerial = C.snapshot_serial.text;
    this.repSet = D.repSet;
    this.repVol = this.jsonObject.parentObject;
    this.isSource = this.jsonObject.isSource();
    this.imageName = this.jsonObject.prop.creation_date_time.text;
    if (!this.isSource) {
        var E = this.jsonObject.getSourceImage();
        if (E) {
            this.imageName = E.prop.creation_date_time.text
        }
    }
    if (D.nodeClass && D.nodeClass != this.nodeClass) {
        this.removeTypeClass(this.nodeClass);
        this.nodeClass = D.nodeClass;
        this.addTypeClass(this.nodeClass)
    }
};

function SnapNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.SNAPSHOT;
    C.nodeClass = "SnapNode";
    C.defaultPanel = "snapshot";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
SnapNode.prototype = new DataNode();
SnapNode.prototype.constructor = SnapNode;
SnapNode.prototype.setData = function(C) {
    this.volName = this.jsonObject.getPropertyValue("volume_name");
    this.volType = this.jsonObject.getPropertyValue("volume_type");
    this.volTypeNumeric = parseInt(this.jsonObject.getPropertyValue("volume_type_numeric"), 10);
    this.vdiskName = this.jsonObject.getPropertyValue("virtual_disk_name");
    this.sernum = this.jsonObject.getPropertyValue("serial_number");
    this.parentSernum = this.jsonObject.getPropertyValue("volume_parent");
    this.size = this.jsonObject.getPropertyValue("size");
    this.label = strings.snapLabel
};

function SnapPoolNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.SNAPPOOL;
    C.nodeClass = "SnapPoolNode";
    C.defaultPanel = "snapPool";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
SnapPoolNode.prototype = new DataNode();
SnapPoolNode.prototype.constructor = SnapPoolNode;
SnapPoolNode.prototype.setData = function(C) {
    this.volName = this.jsonObject.getPropertyValue("volume_name");
    this.volType = this.jsonObject.getPropertyValue("volume_type");
    this.volTypeNumeric = parseInt(this.jsonObject.getPropertyValue("volume_type_numeric"), 10);
    this.vdiskName = this.jsonObject.getPropertyValue("virtual_disk_name");
    this.sernum = this.jsonObject.getPropertyValue("serial_number");
    this.parentSernum = this.jsonObject.getPropertyValue("volume_parent");
    this.size = this.jsonObject.getPropertyValue("size")
};

function HostNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.HOST;
    C.nodeClass = "HostNode";
    C.defaultPanel = "host";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
HostNode.prototype = new DataNode();
HostNode.prototype.constructor = HostNode;
HostNode.prototype.setData = function(C) {
    this.hostName = this.jsonObject.getPropertyValue("host_name");
    this.hostId = this.jsonObject.getPropertyValue("host_id");
    this.name = (this.hostName != "") ? this.hostName : this.hostId
};

function VolumeMapNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.VOLUME_MAP;
    C.nodeClass = "VolumeMapNode";
    C.defaultPanel = null;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
VolumeMapNode.prototype = new DataNode();
VolumeMapNode.prototype.constructor = VolumeMapNode;
VolumeMapNode.prototype.setData = function(C) {
    this.chans = this.jsonObject.getPropertyValue("channels");
    this.lun = this.jsonObject.getPropertyValue("lun");
    this.hostName = this.jsonObject.getPropertyValue("nickname");
    this.portWwn = this.jsonObject.getPropertyValue("identifier");
    this.access = this.jsonObject.getPropertyValue("access");
    this.label = strings.volumeMapLabel
};

function EnclosureNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.ENCLOSURE;
    C.nodeClass = "EnclosureNode";
    C.defaultPanel = "enclosure";
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
EnclosureNode.prototype = new DataNode();
EnclosureNode.prototype.constructor = EnclosureNode;
EnclosureNode.prototype.setData = function(C) {
    this.enclId = this.jsonObject.getPropertyValue("enclosure_id");
    this.sernum = this.name;
    this.label = strings.enclosureLabel
};

function HelpNode(C) {
    if (arguments.length == 0) {
        return
    }
    C.type = TREETYPES.HELP;
    C.nodeClass = "HelpNode";
    if (C.parentName == "helpRoot") {
        C.parentType = TREETYPES.ROOT
    } else {
        C.parentType = TREETYPES.HELP
    }
    C.rootNode = C.helpInstance.tocRoot;
    DataNode.call(this, C);
    this.class_name = this.options.nodeClass;
    this.handleUpdate(this.options)
}
HelpNode.prototype = new DataNode();
HelpNode.prototype.constructor = HelpNode;
HelpNode.prototype.setData = function(C) {
    this.name = this.options.name;
    this.text = this.options.text
};
HelpNode.prototype.selectNode = function() {
    $(".treeSelected", this.rootNode.elements$).removeClass("treeSelected");
    this.nodeDiv$.addClass("treeSelected");
    this.options.helpInstance.navSelect(this.name);
    return true
};
HelpNode.prototype.bindSelectableEvent = function() {
    if (this.selectable && !this.selectableEvent) {
        if (this.nodeDiv$) {
            this.nodeDiv$.click(createObjectCallback(this, this.selectNode));
            this.selectableEvent = true
        }
    }
};
HelpNode.prototype.unbindSelectableEvent = function() {
    if (this.selectable && this.selectableEvent) {
        if (this.nodeDiv$) {
            this.nodeDiv$.unbind("click");
            this.selectableEvent = false
        }
    }
};
Help.USEPIN = true;
Help.HEIGHT = 600;
Help.WIDTH = 600;
Help.MAXHISTORY = 20;
Help.windows = [];
Help.id = 0;
Help.cssRules = [];

function Help() {
    this.pinned = false;
    this.history = [];
    this.current = -1;
    this.win = window.open("help/help.html", Help.id++, "height=" + Help.HEIGHT + ",width=" + Help.WIDTH + ",resizable=1");
    var C = detectBrowser();
    if (C.ie) {
        this.__loaded()
    } else {
        this.win.onload = createObjectCallback(this, this.__loaded)
    }
    Help.windows.unshift(this)
}
Help.show = function(D, E) {
    if (arguments.length == 0) {
        return
    }
    if (Help.windows.length > 0) {
        if (!Help.windows[0].win || Help.windows[0].win.closed) {
            Help.windows.shift()
        }
    }
    var C;
    if (D instanceof Panel) {
        if (D.options.noHelp) {
            return
        }
        C = D.options.name
    } else {
        if ((typeof D) == "string") {
            C = D
        } else {
            return
        }
    }
    C = C.replace(" ", "_");
    if (E) {
        if (Help.windows.length == 0 || Help.windows[0].pinned) {
            new Help()
        } else {
            Help.windows[0].win.focus()
        }
    }
    if (Help.windows.length > 0 && !Help.windows[0].pinned) {
        if (settings.emulator) {
            if (getCookie("language") != null) {
                var F = "lang/" + getCookie("language") + "/";
                Help.windows[0].__show(F + "help/" + C + ".html")
            } else {
                var F = "lang/English/";
                Help.windows[0].__show(F + "help/" + C + ".html")
            }
        } else {
            Help.windows[0].__show("help/" + C + ".html")
        }
    }
};
Help.close = function(C) {
    if (Help.windows.remove(C)) {
        if (C.win) {
            C.win.close()
        }
    }
};
Help.prototype.__show = function(D) {
    MC.debugOutput("Help.__show() file = " + D);
    this.history.length = this.current + 1;
    var C = this.__findInHistory(D);
    if (C >= 0) {
        var E = this.history.length - 1;
        if (C < E) {
            E++;
            this.history[E] = this.history[C];
            if (this.history.length > Help.MAXHISTORY) {
                this.history.shift();
                E--
            }
        }
        this.display(E)
    } else {
        this.__get(D)
    }
};
Help.prototype.__winClosing = function() {};
Help.prototype.__loaded = function() {
    this.content = $("div.helpContent", this.win.document);
    if (this.content && this.content.length > 0) {
        createCssRules(Help.cssRules, "all.css", this.win.document);
        this.win.document.title = strings.helpContentPanelTitle;
        this.content.text(strings.loading);
        this.head = $("head", this.win.document);
        this.body = $("body", this.win.document);
        this.helpTitle = $(".helpTitle", this.win.document);
        this.helpTitle.text(strings.applicationTitleAbbrev + " " + strings.help.helpTitle);
        this.header = $("div.helpHeader", this.win.document);
        this.helpBox = $("div.helpBox", this.win.document);
        this.helpPrev = $("div.helpPrev", this.win.document);
        this.helpNext = $("div.helpNext", this.win.document);
        this.helpPin = $("div.helpPin", this.win.document);
        if (!Help.USEPIN) {
            this.helpPin.hide()
        }
        this.helpClose = $("div.helpClose", this.win.document);
        this.helpContainer = $("div.helpContainer", this.win.document);
        this.nav = $("div.helpNav", this.win.document);
        this.helpContentsTitle = $("div.helpContentsTitle", this.win.document);
        this.helpContents = $("div.helpContents", this.win.document);
        this.helpContents.text(strings.loading);
        this.divider = $("div.helpDivider", this.win.document);
        this.divider.attr("title", strings.help.navTooltip);
        this.dividerText = $("span.helpDividerText", this.win.document);
        this.helpPrev.click(createObjectCallback(this, this.__goPrevious));
        this.helpPrev.attr("title", strings.help.prevTooltip);
        this.helpNext.click(createObjectCallback(this, this.__goNext));
        this.helpNext.attr("title", strings.help.nextTooltip);
        this.helpNavButton = $("div.helpNavButton", this.win.document);
        this.helpNavButton.attr("title", strings.help.navTooltip);
        this.helpNavButton.click(createObjectCallback(this, this.__navToggle));
        this.divider.hover(createObjectCallback(this, this.__divHover), createObjectCallback(this, this.__divUnhover));
        this.divider.click(createObjectCallback(this, this.__navToggle));
        this.dividerPosition = "left";
        try {
            this.helpContainer.animate({
                left: 0
            }, 10, "swing")
        } catch (C) {
            this.helpContainer.css("left", 0);
            this.noAnimation = true
        }
        if (Help.USEPIN) {
            this.helpPin.click(createObjectCallback(this, this.__pinMe));
            this.helpPin.attr("title", strings.help.pinTooltip)
        }
        this.helpClose.click(createObjectCallback(this, this.__close));
        this.helpClose.attr("title", strings.help.closeTooltip);
        this.helpContentsTitle.html(strings.help.contentsTitle);
        this.__createTOC();
        this.tocRoot.setMyState();
        this.helpContents.html(this.tocRoot.elements$);
        this.ready = true;
        if (this.pendingDisplay != undefined) {
            this.display(this.pendingDisplay)
        }
    } else {
        setTimeout(createObjectCallback(this, this.__loaded), 100)
    }
};
Help.prototype.__findInHistory = function(E) {
    var C = -1;
    if (E) {
        for (var D = this.history.length - 1; D >= 0; D--) {
            if (E == this.history[D].url) {
                C = D;
                break
            }
        }
    }
    return C
};
Help.prototype.__get = function(E) {
    var C = E;
    var F = C.split("/");
    if (F.remove("v3")) {
        F.remove("");
        C = F.join("/")
    }
    var D = session.getLocalePath() + C;
    RB.makeRequest({
        url: D,
        dataType: "text",
        httpReqType: "GET",
        callback: createObjectCallback(this, this.__renderResponse)
    })
};
Help.CONTEXT_PATTERN = /^(?:lang\/.*)?(?:help\/)([^\/]*)\.html$/;
Help.prototype.__renderResponse = function(D, E) {
    var G = this.history.length;
    var F = Help.CONTEXT_PATTERN.exec(E.url);
    if (F && F.length == 2) {
        var C = F[1]
    }
    if (E.textStatus == "success") {
        this.history[G] = {
            url: E.url,
            html: this.__processHtml(D, E),
            context: C
        }
    } else {
        this.history[G] = {
            url: "NotFound",
            html: strings.help.notFoundMsg(C),
            context: "NotFound"
        }
    }
    if (this.history.length > Help.MAXHISTORY) {
        this.history.shift();
        G--
    }
    this.display(G)
};
Help.VARIABLE_PATTERN = /\{\{([\w.]+)\}\}/g;
Help.prototype.__processHtml = function(html, request) {
    var newHTML = html.replace(Help.VARIABLE_PATTERN, function(match, variable) {
        var vParts = variable.split(".");
        var vStr = variable;
        if (vParts.length > 1) {
            switch (vParts[0]) {
                case "strings":
                    break;
                case "_RI":
                    vStr = vStr.substr(1);
                    break;
                case "_SP":
                    vStr = 'DC.systemParameters.get("' + vParts[1] + '")';
                    break;
                default:
                    vStr = "strings." + vStr;
                    break
            }
        } else {
            vStr = ("strings." + vStr)
        }
        var str;
        try {
            str = eval(vStr)
        } catch (exception) {
            MC.warningOutput("Invalid reference in help file %s, reference: %s", request.url, match)
        }
        if (str) {
            return str
        } else {
            return match
        }
    });
    return newHTML
};
Help.prototype.display = function(C) {
    if (this.ready) {
        if (this.pendingDisplay != undefined) {
            C = this.pendingDisplay;
            delete this.pendingDisplay
        }
        if (C >= 0 && C < this.history.length) {
            this.content.empty().append(this.history[C].html);
            this.content.find("a").click(createObjectCallback(this, this.__linkClick));
            var D = this.history[C].context;
            MC.debugOutput("Help.display context = %s", D);
            if (D != undefined) {
                if (D == "NotFound") {
                    this.tocRoot.clearSelection()
                } else {
                    var E = this.tocRoot.getNode(D, TREETYPES.HELP);
                    MC.debugOutput("Found HelpNode: %o", E);
                    if (E) {
                        E.expandTo();
                        E.setSelection()
                    }
                }
            }
            this.current = C;
            if (this.hash) {
                this.win.location.hash = this.hash;
                delete this.hash
            } else {
                this.win.location.hash = ""
            }
        }
    } else {
        this.pendingDisplay = C
    }
};
Help.prototype.__linkClick = function(D) {
    var C = D.target.pathname;
    if (C && C != "help/help.html" && C != "/help/help.html") {
        if (D.target.hash) {
            this.hash = D.target.hash
        }
        this.__show(C)
    }
    if (C != "/help/help.html") {
        D.preventDefault()
    }
};
Help.prototype.navSelect = function(C) {
    if (C != undefined) {
        if (settings.emulator) {
            if (getCookie("language") != null) {
                var D = "lang/" + getCookie("language") + "/";
                this.__show(D + "help/" + C + ".html")
            } else {
                var D = "lang/English/";
                this.__show(D + "help/" + C + ".html")
            }
        } else {
            this.__show("help/" + C + ".html")
        }
    }
};
Help.prototype.__navToggle = function() {
    if (this.dividerPosition == "left") {
        if (this.noAnimation) {
            this.helpContainer.css("left", 205)
        } else {
            this.helpContainer.animate({
                left: 205
            }, 500, "swing")
        }
        this.dividerPosition = "right";
        this.dividerText.addClass("helpDividerHidden")
    } else {
        if (this.noAnimation) {
            this.helpContainer.css("left", 0)
        } else {
            this.helpContainer.animate({
                left: 0
            }, 500, "swing")
        }
        this.dividerPosition = "left";
        this.dividerText.removeClass("helpDividerHidden")
    }
};
Help.prototype.__divHover = function() {
    if (this.dividerPosition == "left") {
        this.divider.removeClass("helpDividerL helpDividerR helpDividerRH").addClass("helpDividerLH");
        this.dividerText.addClass("helpDividerTextH")
    } else {
        this.divider.removeClass("helpDividerR helpDividerL helpDividerLH").addClass("helpDividerRH")
    }
};
Help.prototype.__divUnhover = function() {
    if (this.dividerPosition == "left") {
        this.divider.removeClass("helpDividerLH helpDividerR helpDividerRH").addClass("helpDividerL");
        this.dividerText.removeClass("helpDividerTextH")
    } else {
        this.divider.removeClass("helpDividerRH helpDividerL helpDividerLH").addClass("helpDividerR")
    }
};
Help.prototype.__goPrevious = function() {
    this.display(this.current - 1)
};
Help.prototype.__goNext = function() {
    this.display(this.current + 1)
};
Help.prototype.__pinMe = function() {
    this.pinned = true;
    this.helpPin.addClass("helpPinned");
    this.helpPin.unbind("click");
    this.helpPin.attr("title", strings.help.pinnedTooltip)
};
Help.prototype.__close = function() {
    Help.close(this)
};
Help.prototype.__createTOC = function(E, F) {
    if (E == undefined) {
        this.tocRoot = new RootNode({
            doc: this.win.document,
            name: "helpRoot",
            type: TREETYPES.ROOT,
            defaultOpen: true,
            helpInstance: this
        });
        this.__createTOCprefix();
        F = "helpRoot";
        for (var I in MENUS.topics) {
            if (MENUS.topics[I].useIt) {
                var D = MENUS.topics[I].topic;
                new HelpNode({
                    doc: this.win.document,
                    parentName: F,
                    helpInstance: this,
                    name: D,
                    text: strings.menus[I] + " " + strings.topic
                });
                this.__createTOC(MENUS[D], D)
            }
        }
        new HelpNode({
            doc: this.win.document,
            parentName: "helpRoot",
            helpInstance: this,
            name: "bannerPanels",
            text: strings.help.bannerPanels,
            selectable: false
        });
        F = "bannerPanels";
        for (var J in MENUS.bannerPanels) {
            var G = MENUS.bannerPanels[J].banner;
            new HelpNode({
                doc: this.win.document,
                parentName: F,
                helpInstance: this,
                name: G,
                text: strings.barPanels[G]
            });
            this.__createTOC(MENUS[G], G)
        }
        new HelpNode({
            doc: this.win.document,
            parentName: "helpRoot",
            helpInstance: this,
            name: "footerPanels",
            text: strings.help.footerPanels,
            selectable: false
        });
        F = "footerPanels";
        for (var J in MENUS.footerPanels) {
            var G = MENUS.footerPanels[J].banner;
            new HelpNode({
                doc: this.win.document,
                parentName: F,
                helpInstance: this,
                name: G,
                text: strings.barPanels[G]
            });
            this.__createTOC(MENUS[G], G)
        }
        this.__createTOCpostfix();
        return
    }
    for (var C in E) {
        var H = E[C].action;
        if (H) {
            var K;
            switch (C) {
                case "dateTimeSetup":
                case "userManagement":
                case "systemInfoSetup":
                case "servicesSetup":
                case "notificationSetup":
                    K = strings.menus[C];
                    break;
                default:
                    K = strings.actions[H] || strings.unknownVal;
                    break
            }
            new HelpNode({
                doc: this.win.document,
                parentName: F,
                helpInstance: this,
                name: H,
                text: K
            })
        }
    }
};
Help.prototype.__createTOCprefix = function() {
    new HelpNode({
        doc: this.win.document,
        parentName: "helpRoot",
        helpInstance: this,
        name: "GettingStarted",
        text: strings.help.gettingStarted
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "GettingStarted",
        helpInstance: this,
        name: "Concepts",
        text: strings.help.concepts,
        selectable: false
    });
    if (isHPsystem() && RI.pagedOnly()) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutHandlingLinearStorage",
            text: strings.help.aboutHandlingLinearStorage
        })
    }
    if (!RI.pagedOnly()) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutVirtualAndLinearStorage",
            text: strings.help.aboutVirtualAndLinearStorage
        })
    } else {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutVirtualStorage",
            text: strings.help.AboutVirtualStorage
        })
    }
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutThinProvisioning",
        text: strings.help.aboutThinProvisioning
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutATS",
        text: strings.help.aboutATS
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutStoragePools",
        text: strings.help.aboutStoragePools
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutDiskGroups",
        text: strings.help.aboutDiskGroups
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutRAID",
        text: strings.help.aboutRAID
    });
    if (RI.hasFeature("ssdSupport")) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutSSDs",
            text: strings.help.aboutSSDs
        });
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutSSDReadCache",
            text: strings.help.aboutSSDReadCache
        })
    }
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutSpares",
        text: strings.help.aboutSpares
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutReconstruction",
        text: strings.help.aboutReconstruction
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutQuickRebuild",
        text: strings.help.aboutQuickRebuild
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutVolumes",
        text: strings.help.aboutVolumes
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutVolumeCache",
        text: strings.help.aboutVolumeCache
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutHosts",
        text: strings.help.aboutHosts
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutMapping",
        text: strings.help.aboutMapping
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutSnapshots",
        text: strings.help.aboutSnapshots
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutVolumeCopy",
        text: strings.help.aboutVolumeCopy
    });
    if (RI.hasFeature("asyncRep") && !EXPR.isSasPortType) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutReplication",
            text: strings.help.aboutReplication
        })
    }
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutPerformanceMonitoring",
        text: strings.help.aboutPerformanceStatistics
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutLogManagement",
        text: strings.help.aboutLogManagement
    });
    if (isHPsystem()) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutLDAP",
            text: strings.help.aboutLDAP
        })
    }
    if (RI.hasFeature("DNS")) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutDNS",
            text: strings.help.aboutDNS
        })
    }
    new HelpNode({
        doc: this.win.document,
        parentName: "Concepts",
        helpInstance: this,
        name: "AboutFirmwareUpdate",
        text: strings.help.aboutFirmwareUpdate
    });
    if (RI.hasFeature("fde")) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutFDE",
            text: strings.help.aboutFDE
        })
    }
    if (RI.featureMatches("hardwarePlatform", "Gallium")) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutSingleController",
            text: strings.help.aboutSingleController
        })
    }
    if (EXPR.isFanOutSupported) {
        new HelpNode({
            doc: this.win.document,
            parentName: "Concepts",
            helpInstance: this,
            name: "AboutSASCabling",
            text: strings.help.aboutSASCabling
        })
    }
    new HelpNode({
        doc: this.win.document,
        parentName: "GettingStarted",
        helpInstance: this,
        name: "ConfigLimits",
        text: strings.help.configLimits
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "GettingStarted",
        helpInstance: this,
        name: "UsingWBI",
        text: strings.help.usingWBI,
        selectable: false
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBIBrowserSetup",
        text: strings.help.wbiBrowserSetup
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBIInterfaceAreas",
        text: strings.help.wbiInterfaceAreas
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBITips",
        text: strings.help.wbiTips
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBITableTips",
        text: strings.help.wbiTableTips
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBIHelpTips",
        text: strings.help.wbiHelpTips
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBIColorCodes",
        text: strings.help.wbiColorCodes
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBISizes",
        text: strings.help.wbiSizes
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "UsingWBI",
        helpInstance: this,
        name: "WBISignInOut",
        text: strings.help.wbiSignInOut
    });
    new HelpNode({
        doc: this.win.document,
        parentName: "GettingStarted",
        helpInstance: this,
        name: "FirstTimeConfig",
        text: strings.help.firstTimeConfig
    })
};
Help.prototype.__createTOCpostfix = function() {
    new HelpNode({
        doc: this.win.document,
        parentName: "helpRoot",
        helpInstance: this,
        name: "Glossary",
        text: strings.help.glossary
    })
};
Help.addBrandCss = function() {
    var C = DC.system.get("platform_brand_numeric");
    Help.cssRules.push({
        selector: ".BR:not(.BR_" + C + ")",
        style: "display: none;"
    });
    Help.cssRules.push({
        selector: ".xBR_" + C,
        style: "display: none;"
    })
};
Help.addPortCss = function() {
    if (!DataCache.hasFc) {
        Help.cssRules.push({
            selector: ".PT_FC",
            style: "display: none;"
        })
    }
    if (!DataCache.hasIscsi) {
        Help.cssRules.push({
            selector: ".PT_ISCSI",
            style: "display: none;"
        })
    }
    if (!DataCache.hasSas) {
        Help.cssRules.push({
            selector: ".PT_SAS",
            style: "display: none;"
        })
    }
    if ((!DataCache.hasFc) || (!DataCache.hasIscsi)) {
        Help.cssRules.push({
            selector: ".PT_FC_ISCSI",
            style: "display: none;"
        })
    }
};
Help.addRelInfoCss = function() {
    for (var D in RI) {
        if (!RI.hasOwnProperty(D) || typeof(RI[D]) == "function" || D == "modified" || D == "deleted") {
            continue
        }
        if (RI[D] == "true") {
            Help.cssRules.push({
                selector: ".RIF_" + D + ":not(.RIV_true)",
                style: "display: none;"
            })
        } else {
            if (RI[D] == "false") {
                Help.cssRules.push({
                    selector: ".RIE_" + D,
                    style: "display: none;"
                });
                Help.cssRules.push({
                    selector: ".RIF_" + D + ":not(.RIV_false)",
                    style: "display: none;"
                })
            } else {
                var C = RI[D].replace(/\./g, "_");
                Help.cssRules.push({
                    selector: ".RIF_" + D + ":not(.RIV_" + C + ")",
                    style: "display: none;"
                });
                Help.cssRules.push({
                    selector: ".xRI_" + D + "_" + C,
                    style: "display: none;"
                })
            }
        }
    }
};
Help.addEXPRCss = function() {
    if (!EXPR.is5U84) {
        Help.cssRules.push({
            selector: ".EV_is5U84",
            style: "display: none;"
        })
    }
    if (!EXPR.is5U84 && RI.hercules == "false" && RI.atlas == "false") {
        Help.cssRules.push({
            selector: ".EV_hasDrawers",
            style: "display: none;"
        })
    }
    if (!EXPR.is5U84 && RI.hercules == "false") {
        Help.cssRules.push({
            selector: ".EV_hasFans",
            style: "display: none;"
        })
    }
    if (!RI.hasFeature("dms") || !RI.hasFeature("copyServices")) {
        Help.cssRules.push({
            selector: ".EV_supportsSnaps",
            style: "display: none;"
        })
    }
    if (!(RI.hasFeature("asyncRep") && !EXPR.isSasPortType) || !RI.hasFeature("rsr")) {
        Help.cssRules.push({
            selector: ".EV_supportsReplications",
            style: "display: none;"
        })
    }
};

function CSSprop(C, E) {
    var D = C[0] && parseInt(jQuery.css(C[0], E, true), 10) || 0;
    return D
}(function(C) {
    C.dh = C.dh || {};
    C.extend(C.expr[":"], {
        view: "(' '+a.className+' ').indexOf(' dh-view ')"
    });
    C.fn.view = function() {
        return this.each(function() {
            if (!C(this).is(".dh-view")) {
                new C.dh.view(this)
            }
        })
    };
    C.fn.viewInstance = function() {
        if (C(this[0]).is(".dh-view")) {
            return C.data(this[0], "dh-view")
        }
        return false
    };
    C.dh.view = function(E) {
        this.class_name = "View";
        this.element = E;
        var D = this;
        C.data(this.element, "dh-view", this);
        this.panel = null;
        this.isVisible = false;
        C(this.element).addClass("dh-view");
        return this
    };
    C.extend(C.expr[":"], {
        dims: "(' '+a.className+' ').indexOf(' dh-dims ')"
    });
    C.fn.dimsInstance = function() {
        if (C(this[0]).is(".dh-dims")) {
            return C.data(this[0], "dh-dims")
        } else {
            return new C.dh.dims(this[0])
        }
    };
    C.dh.dims = function(E) {
        this.class_name = "Dims";
        var F = C(E);
        this.Offset = F.offset();
        this.Width = F.width();
        this.Height = F.height();
        this.BorderTop = CSSprop(F, "border-top-width");
        this.PaddingTop = CSSprop(F, "padding-top");
        this.MarginTop = CSSprop(F, "margin-top");
        this.BorderLeft = CSSprop(F, "border-left-width");
        this.PaddingLeft = CSSprop(F, "padding-left");
        this.MarginLeft = CSSprop(F, "margin-left");
        this.BorderBottom = CSSprop(F, "border-bottom-width");
        this.PaddingBottom = CSSprop(F, "padding-bottom");
        this.MarginBottom = CSSprop(F, "margin-bottom");
        this.BorderRight = CSSprop(F, "border-right-width");
        this.PaddingRight = CSSprop(F, "padding-right");
        this.MarginRight = CSSprop(F, "margin-right");
        this.vSpace = this.MarginTop + this.BorderTop + this.PaddingTop + this.PaddingBottom + this.BorderBottom + this.MarginBottom;
        this.hSpace = this.MarginLeft + this.BorderLeft + this.PaddingLeft + this.PaddingRight + this.BorderRight + this.MarginRight;
        this.element = E;
        var D = this;
        C.data(this.element, "dh-dims", this);
        C(this.element).addClass("dh-dims")
    };
    C.fn.extend({
        viewAttach: function(D) {
            var E = this.viewInstance();
            if (E) {
                var F = (E.panel == D);
                this.viewDetach(F);
                E.panel = D;
                if (E.panel != null) {
                    if (!F) {
                        C(this[0]).append(C(E.panel.elementContainer).children());
                        E.panel.elements = this[0]
                    }
                    E.panel.__attaching.call(E.panel, C(this).get(0));
                    if (E.isVisible) {
                        E.panel.__showing.call(E.panel)
                    }
                }
            }
        },
        viewDetach: function(E) {
            var D = this.viewInstance();
            if (D) {
                if (D.panel != null) {
                    if (D.isVisible) {
                        D.panel.__hiding.call(D.panel)
                    }
                    D.panel.__detaching.call(D.panel, C(this).get(0));
                    if (!E) {
                        C(this[0]).children().appendTo(D.panel.elementContainer);
                        D.panel.elements = D.panel.elementContainer;
                        delete D.panel
                    }
                }
            }
        },
        resizing: function() {
            var D = this.viewInstance();
            if (D) {
                if (D.panel != null) {
                    if (D.panel.resizing) {
                        D.panel.resizing()
                    } else {
                        MC.errorOutput("resizing view: " + C(this[0]).attr("id") + " failed, no resizing method on panel")
                    }
                }
            }
        },
        isAttached: function() {
            var D = this.parents();
            if (D && D.length > 0 && D[D.length - 1].tagName.toUpperCase() == "HTML") {
                return true
            }
            return false
        },
        dynamicSizing: function(D) {
            var E = this.viewInstance();
            if (E) {
                C(E.element).addClass("autowidth");
                C(E.element).addClass("autoheight");
                C.extend(E, D)
            }
        },
        sizing: function(D) {
            var E = this.viewInstance();
            if (E) {
                C.extend(E, D)
            }
        },
        setWidth: function(D) {
            var E = this.viewInstance();
            if (E) {
                E.width = D
            }
        },
        minWidth: function() {
            var D = this.viewInstance();
            if (D) {
                return D.minWidth
            }
            return 0
        },
        maxWidth: function() {
            var D = this.viewInstance();
            if (D) {
                return D.maxWidth
            }
            return 0
        },
        viewVisible: function(F) {
            var E = this.viewInstance();
            if (E) {
                var D = E.isVisible;
                E.isVisible = F;
                if (F) {
                    if (!D) {
                        if (E.panel != null) {
                            E.panel.__showing.call(E.panel)
                        }
                    }
                } else {
                    if (D) {
                        if (E.panel != null) {
                            E.panel.__hiding.call(E.panel)
                        }
                    }
                }
            }
        },
        centerOnPageVertically: function() {
            var E = C(this[0]);
            if (E.css("position") == "absolute") {
                var D = (C(window).height() / 2) - (E.height() / 2);
                if (D < 0) {
                    D = 0
                }
                E.css("top", D)
            }
        },
        centerOnPageHorizontally: function() {
            var E = C(this[0]);
            if (E.css("position") == "absolute") {
                var D = (C(window).width() / 2) - (E.width() / 2);
                if (D < 0) {
                    D = 0
                }
                E.css("left", D)
            }
        },
        getExtraSpace: function(D) {
            space = 0;
            if (D == undefined) {
                D = "vertical"
            }
            if (D == "top" || D == "vertical") {
                space += CSSprop(this, "padding-top");
                space += CSSprop(this, "border-top-width");
                space += CSSprop(this, "margin-top")
            }
            if (D == "bottom" || D == "vertical") {
                space += CSSprop(this, "padding-bottom");
                space += CSSprop(this, "border-bottom-width");
                space += CSSprop(this, "margin-bottom")
            }
            if (D == "left" || D == "horizontal") {
                space += CSSprop(this, "padding-left");
                space += CSSprop(this, "border-left-width");
                space += CSSprop(this, "margin-left")
            }
            if (D == "right" || D == "horizontal") {
                space += CSSprop(this, "padding-right");
                space += CSSprop(this, "border-right-width");
                space += CSSprop(this, "margin-right")
            }
            return space
        },
        autoHeight: function() {
            return this.each(function() {
                if (!C(this).hasClass("autoheight")) {
                    return
                }
                var N = C(this);
                var O = N.parent();
                var G = N.attr("id") || "noID";
                if (G == "rootView") {
                    N.height(C(window).height());
                    return
                }
                var L = O.height();
                if (L == 0) {
                    L = O.attr("auheight");
                    if (L == undefined) {
                        L = 0
                    }
                }
                var H = 0;
                var I = N.offset().top;
                var E = O.offset().top;
                var J = CSSprop(O, "border-top-width");
                var F = CSSprop(O, "padding-top");
                var K = CSSprop(N, "margin-top");
                if (I < E) {
                    return
                } else {
                    H = (I - K) - (E + J + F)
                }
                if (H < 0) {
                    H = 0
                }
                var D = N.getExtraSpace("vertical");
                var M = L - D - H;
                N.height(M);
                N.attr("auheight", M);
                N.find(">.ui-resizable-handle").height(M)
            })
        },
        autoWidth: function() {
            return this.each(function() {
                if (!C(this).hasClass("autowidth")) {
                    return
                }
                var L = C(this);
                var M = L.parent();
                var G = L.attr("id") || "noID";
                var O = M.width();
                if (O == 0) {
                    O = M.attr("auwidth");
                    if (O == undefined) {
                        O = 0
                    }
                }
                var N = 0;
                var I = L.offset().left;
                var E = M.offset().left;
                var H = CSSprop(M, "border-left-width");
                var K = CSSprop(M, "padding-left");
                var F = CSSprop(L, "margin-left");
                if (I < E) {
                    return
                } else {
                    N = (I - F) - (E + H + K)
                }
                var D = L.getExtraSpace("horizontal");
                var J = O - D - N;
                L.width(J);
                L.attr("auwidth", J);
                L.find(">.ui-resizable-handle").width(J)
            })
        }
    })
})($);

function Panel(E) {
    if (arguments.length == 0) {
        return
    }
    this.class_name = "Panel";
    this.options = {};
    $.extend(this.options, E);
    if (this.options.name) {
        if (panels[this.options.name] != undefined) {
            MC.errorOutput("Panel %s already exists!", this.options.name)
        } else {
            panels[this.options.name] = this
        }
    } else {
        this.options.name = "Panel"
    }
    this.name = this.options.name;
    this.htmlLoaded = false;
    this.jsLoaded = false;
    this.httpRequest = null;
    this.jsRequest = null;
    this.elementContainer = null;
    this.elements = null;
    this.isVisible = false;
    this.views = new Array();
    if (this.options.htmlText == undefined && this.options.html == undefined) {
        this.options.htmlText = " "
    }
    if (this.options.htmlText) {
        this.elementContainer = $('<div class="panel">' + this.options.htmlText + "</div>").get(0);
        this.elements = this.elementContainer;
        if (this.options.widgets instanceof WidgetContainer) {
            this.widgetContainer = this.options.widgets
        } else {
            if (this.options.widgets instanceof Array) {
                this.widgetContainer = new WidgetContainer({
                    name: "temp"
                })
            }
        }
        if (this.widgetContainer) {
            var C = [];
            if (this.options.widgetsParentID) {
                C = $("#" + this.options.widgetsParentID, this.elements)
            }
            if (C.length == 0) {
                C = $(".widgetParent", this.elements)
            }
            if (C.length == 0) {
                C = $(this.elements)
            }
            C.append(this.widgetContainer.getElements())
        }
        this.htmlLoaded = true
    } else {
        if (this.options.html) {
            this.__loadHtml();
            return
        }
    }
    if (this.options.javascript) {
        this.__loadJS();
        return
    }
    if (this.options.widgets instanceof Array) {
        for (var D = 0; D < this.options.widgets.length; D++) {
            this.widgetContainer.add(this.options.widgets[D])
        }
    }
    this.__loadingComplete();
    this.elements$ = $(this.elements);
    if (E.hoverPanel) {
        this._removeHoverCallback = createObjectCallback(this, this._removeHover);
        this.elements$.hoverIntent({
            sensitivity: 2,
            interval: 500,
            over: createObjectCallback(this, this._displayHover),
            out: this._removeHoverCallback
        })
    }
}
Panel.prototype = new DHSObject();
Panel.prototype.add = function(C) {
    if (this.widgetContainer) {
        this.widgetContainer.add(C)
    } else {
        alert("Internal Error: attempt to add Widget to Panel that has no WidgetContainer!")
    }
};
Panel.prototype.remove = function(C) {
    if (this.widgetContainer) {
        this.widgetContainer.remove(C)
    } else {
        alert("Internal Error: attempt to remove Widget from Panel that has no WidgetContainer!")
    }
};
Panel.prototype.update = function(C) {
    if (this.widgetContainer) {
        this.widgetContainer.update(C)
    }
};
Panel.prototype.retrieve = function(D, C) {
    if (this.widgetContainer) {
        this.widgetContainer.retrieve(D, C)
    }
};
Panel.prototype.__loadHtml = function() {
    this.httpRequest = $.ajax({
        url: this.options.html,
        dataType: "html",
        success: createObjectCallback(this, this.__htmlComplete),
        error: createObjectCallback(this, this.__htmlError)
    })
};
Panel.prototype.__htmlComplete = function(C, D) {
    this.htmlLoaded = true;
    this.elementContainer = $("<div>" + C + "</div>").get(0);
    this.elements = this.elementContainer;
    if (this.options.javascript) {
        this.__loadJS()
    } else {
        this.__loadingComplete()
    }
};
Panel.prototype.__htmlError = function(C, E, D) {
    MC.debugOutput("htmlError: " + C.toString() + "\ntextStatus: " + E);
    if ($.isFunction(this.options.error)) {
        this.options.error.call(this, C, E)
    }
};
Panel.prototype.__loadJS = function() {
    this.jsRequest = $.ajax({
        url: this.options.javascript,
        dataType: "script",
        success: createObjectCallback(this, this.__jsComplete),
        error: createObjectCallback(this, this.__jsError)
    })
};
Panel.prototype.__jsComplete = function(C, D) {
    this.jsLoaded = true;
    this.__loadingComplete()
};
Panel.prototype.__jsError = function(C, E, D) {
    MC.debugOutput("jsError: " + C.toString() + "\ntextStatus: " + E);
    if ($.isFunction(this.options.error)) {
        this.options.error.call(this, C, E)
    }
};
Panel.prototype.__loadingComplete = function() {
    if (this.options.viewElementNames) {
        var E = this.options.viewElementNames;
        var D = E.length;
        for (var C = 0; C < D; C++) {
            this.makeView(E[C])
        }
    }
    if (this.htmlLoaded && this.options.attachTo) {
        this.options.attachTo.viewAttach(this)
    }
    if ($.isFunction(this.options.success)) {
        this.options.success.call(this, this.elements)
    }
};
Panel.prototype.makeView = function(F) {
    var D = F;
    var E = F;
    if (typeof F == "string") {
        E = $("#" + F, this.elements)
    } else {
        D = E.attr("id")
    }
    if (E.length) {
        var C = E.view();
        if (!D) {
            MC.errorOutput("Making view of element without ID, element: %o", E)
        } else {
            if (views[D] != undefined) {
                MC.errorOutput("Making view with duplicate name: %s", D)
            } else {
                views[D] = E.view()
            }
        }
        E.viewVisible(this.isVisible);
        this.views[this.views.length] = E.get(0)
    }
};
Panel.prototype.attaching = function() {};
Panel.prototype.detaching = function() {};
Panel.prototype.showing = function() {};
Panel.prototype.hiding = function() {};
Panel.prototype.__attaching = function(C) {
    this.attaching(C);
    if (this.widgetContainer) {
        this.widgetContainer.__attaching(C)
    }
    if (this.options.attaching) {
        this.options.attaching.call(this, C)
    }
};
Panel.prototype.__detaching = function(C) {
    this.detaching(C);
    if (this.widgetContainer) {
        this.widgetContainer.__detaching(C)
    }
    if (this.options.detaching) {
        this.options.detaching.call(this, C)
    }
};
Panel.prototype.__showing = function(C) {
    this.isVisible = true;
    this.showing(C);
    if (this.widgetContainer) {
        this.widgetContainer.__showing(C)
    }
    if (this.options.showing) {
        this.options.showing.call(this, C)
    }
    if (this.resizing) {
        this.resizing()
    }
    if (this.helpAvailable()) {
        currentPanel = this
    }
    this.__makeViewsVisible(true);
    if (Help.USEPIN && Help.windows[0] && this.helpAvailable()) {
        Help.show(this)
    }
};
Panel.prototype.helpAvailable = function() {
    if (this instanceof ActiveDialogPanel) {
        return false
    }
    if (this instanceof HoverPanel) {
        return false
    }
    return true
};
Panel.prototype.__makeViewsVisible = function(C) {
    var E = this.views.length;
    for (var D = 0; D < E; D++) {
        $(this.views[D]).viewVisible(C)
    }
};
Panel.prototype.__hiding = function(C) {
    this.isVisible = false;
    this.__makeViewsVisible(false);
    if (this instanceof ActionPanel && this.helpAvailable()) {
        currentPanel = panels[currentTopic]
    }
    this.hiding(C);
    if (this.widgetContainer) {
        this.widgetContainer.__hiding(C)
    }
    if (this.options.hiding) {
        this.options.hiding.call(this, C)
    }
};
Panel.prototype.showContents = function() {
    MC.debugOutput(this.options.name + ":" + $(this.elements).html())
};
Panel.prototype.computeDimensions = function() {
    var C = arguments.length;
    if (C <= 0) {
        return
    }
    var K = arguments[0];
    var E = K.parent();
    var N = E.attr("id") || "noID";
    var S = E.attr("class");
    var R = E.height();
    var F = E.width();
    if (R == 0 || F == 0) {
        return
    }
    var J = E.dimsInstance();
    for (var I = 0; I < C; I++) {
        var K = arguments[I];
        var D = K.attr("id") || "noID";
        var Q = '"' + K.attr("class") + '"';
        var H = K.dimsInstance();
        if (!J.other) {
            var M = {
                top: 0,
                left: 0
            };
            J.other = M;
            if (H.Offset.top < J.Offset.top) {
                MC.errorOutput("ComputeDimensions: " + D + " - top offset less than parent offset")
            } else {
                M.top = (H.Offset.top - H.MarginTop) - (J.Offset.top + J.BorderTop + J.PaddingTop)
            }
            if (M.top < 0) {
                MC.errorOutput("ComputeDimensions: " + D + " - other top is less than 0");
                M.top = 0
            }
            if (H.Offset.left < J.Offset.left) {
                MC.errorOutput("ComputeDimensions: " + D + " - left offset less than parent offset")
            } else {
                M.left = (H.Offset.left - H.MarginLeft) - (J.Offset.left + J.BorderLeft + J.PaddingLeft)
            }
            if (M.left < 0) {
                MC.errorOutput("ComputeDimensions: " + D + " - other left is less than 0");
                M.left = 0
            }
        }
        var L = 0;
        var G = K.css("overflow");
        if (G == "auto" || G == "scroll") {
            L = Panel.getScrollbarWidth()
        }
        var O = R - H.vSpace - J.other.top;
        var P = F - H.hSpace - J.other.left;
        K.width(P);
        K.height(O);
        R = O;
        F = P - L;
        J = H;
        N = D;
        S = Q
    }
};
Panel.prototype.resizing = function() {};
Panel.prototype.getApiObject = function() {
    return null
};
Panel.prototype._displayHover = function(C) {
    if (this.savedHoverEvent && !this.hoverTimeout) {
        return
    }
    if (!this.hoverDisabled) {
        panels.hoverDialog.open({
            parentObj: this,
            offsetElement$: this.elements$,
            eventObj: C,
            panel: this.options.hoverPanel,
            height: this.options.hoverPanel.options.height,
            width: this.options.hoverPanel.options.width
        });
        this.savedHoverEvent = C;
        this.hoverObject$ = this.elements$;
        $(window).on("click", this._removeHoverCallback)
    }
};
Panel.prototype._removeHover = function(F) {
    if (F && F.type != "click" && this.hoverObject$) {
        var G = this.hoverObject$.offset();
        var D = Math.round(G.left);
        var C = Math.round(G.top);
        var H = D + this.hoverObject$.outerWidth() - 1;
        var E = C + this.hoverObject$.outerHeight() - 1;
        if (F.pageX >= G.left && F.pageX <= H && F.pageY >= G.top && F.pageY <= E) {
            return
        }
    }
    if (this.hoverTimeout) {
        clearTimeout(this.hoverTimeout);
        delete this.hoverTimeout
    }
    this.hoverDisabled = false;
    if (!this.savedHoverEvent) {
        return
    }
    $(window).off("click", this._removeHoverCallback);
    panels.hoverDialog.close();
    delete this.savedHoverEvent;
    delete this.hoverObject$
};
Panel.prototype.disableHover = function() {
    if (this.hoverDisabled) {
        return
    }
    this.hoverDisabled = true;
    if (this.savedHoverEvent) {
        panels.hoverDialog.close()
    }
};
Panel.prototype.enableHover = function() {
    if (!this.hoverDisabled) {
        return
    }
    this.hoverDisabled = false;
    if (this.savedHoverEvent) {
        panels.hoverDialog.open()
    }
};
Panel.getScrollbarWidth = function() {
    if (typeof Panel._scrollbarWidth == "undefined") {
        var E = document.createElement("p");
        E.style.width = "100%";
        E.style.height = "200px";
        var F = document.createElement("div");
        F.style.position = "absolute";
        F.style.top = "0px";
        F.style.left = "0px";
        F.style.visibility = "hidden";
        F.style.width = "200px";
        F.style.height = "150px";
        F.style.overflow = "hidden";
        F.appendChild(E);
        document.body.appendChild(F);
        var D = E.offsetWidth;
        F.style.overflow = "scroll";
        var C = E.offsetWidth;
        if (D == C) {
            C = F.clientWidth
        }
        document.body.removeChild(F);
        Panel._scrollbarWidth = (D - C)
    }
    return Panel._scrollbarWidth
};
Panel.prototype.focusOnFirstField = function() {
    var D = $(this.elements).find(".focusFirst[tabindex=0]");
    if (D.length < 1) {
        D = $(this.elements).find("[tabindex=0]").not(":disabled, .buttonDisabled, .Disabled")
    }
    if (D && D.length > 0) {
        var C = D.get(0);
        setTimeout(function() {
            try {
                C.focus()
            } catch (E) {
                MC.errorOutput("Unable to set focus on element, %o, in Panel", C)
            }
        }, 0)
    }
};

function EmptyPanel(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = "<div><B>UNDER CONSTRUCTION</B></div>";
    Panel.call(this, C)
}
EmptyPanel.prototype = new Panel();
var PrimaryTabClasses = {
    navClass: "p-tabs-nav",
    selectedClass: "p-tabs-selected",
    unselectClass: "p-tabs-unselect",
    disabledClass: "p-tabs-disabled",
    panelClass: "p-tabs-panel",
    hideClass: "p-tabs-hide",
    loadingClass: "p-tabs-loading"
};
var SecondaryTabClasses = {
    navClass: "s-tabs-nav",
    selectedClass: "s-tabs-selected",
    unselectClass: "s-tabs-unselect",
    disabledClass: "s-tabs-disabled",
    panelClass: "s-tabs-panel",
    hideClass: "s-tabs-hide",
    loadingClass: "s-tabs-loading"
};
var TerciaryTabClasses = {
    navClass: "t-tabs-nav",
    selectedClass: "t-tabs-selected",
    unselectClass: "t-tabs-unselect",
    disabledClass: "t-tabs-disabled",
    panelClass: "t-tabs-panel",
    hideClass: "t-tabs-hide",
    loadingClass: "t-tabs-loading"
};

function TopicPanel(C) {
    if (arguments.length == 0 || !C.name) {
        return
    }
    if (!C.title && strings.topics[C.name]) {
        C.title = strings.topics[C.name]
    }
    if (!C.menu) {
        C.menu = C.name
    }
    if (!C.actionCallback) {
        C.actionCallback = function() {}
    }
    this.menu = C.menu;
    C.autoHeight = true;
    C.htmlText = '<div class="topicOuter"><div class="topicHeader"><div class="topicTitle">' + C.title + '</div><div class="topicAction buttonPrimary">' + strings.topicButtonText + '</div></div><div class="topicTray" ><div class="topicContent scrollingDiv widgetParent ' + C.contentClass + '"></div></div></div>';
    Panel.call(this, C);
    this.class_name = "TopicPanel";
    this.panel$ = $(".topicOuter", this.elements);
    this.actionButton$ = $(".topicAction", this.elements);
    this.titleDiv$ = $(".topicTitle", this.elements);
    this.tray$ = $(".topicTray", this.elements);
    this.content$ = $(".topicContent", this.elements);
    this.actionMenu = panels.actionMenu;
    this.actionButton$.bind("click", createObjectCallback(this, this._actionClicked));
    this.actionButton$.mouseleave(createObjectCallback(this, this._actionButtonLeft));
    this.leftActionButtonTimeoutCallback = createObjectCallback(this, this._leftActionButtonTimeout)
}
TopicPanel.prototype = new Panel();
TopicPanel.prototype.constructor = TopicPanel;
TopicPanel.selection = [];
TopicPanel.getSelected = function(H, C) {
    var F = [];
    if (H instanceof Array) {
        for (var E = 0; E < H.length; E++) {
            var G = 0;
            for (var D = 0; D < TopicPanel.selection.length; D++) {
                if (TopicPanel.selection[D].basetype == H[E]) {
                    F.push(TopicPanel.selection[D]);
                    G++
                }
            }
            if (C) {
                if (C instanceof Array) {
                    if (G > C[E]) {
                        return null
                    }
                } else {
                    if (G > 0) {
                        if (G <= C) {
                            return F
                        } else {
                            return null
                        }
                    }
                }
            }
        }
    } else {
        var G = 0;
        for (var E = 0; E < TopicPanel.selection.length; E++) {
            if (TopicPanel.selection[E].basetype == H) {
                F.push(TopicPanel.selection[E]);
                G++
            }
        }
        if (G > C) {
            return null
        }
    }
    if (F.length > 0) {
        return F
    } else {
        return null
    }
};
TopicPanel.prototype.topicShowing = function() {
    this.panel$.css("visibility", "visible")
};
TopicPanel.prototype.update = function(C) {
    if (C[this.name] && C[this.name].previousSelection) {
        this.previousSelection = $.merge([], C[this.name].previousSelection)
    }
    if (C[this.name] && C[this.name].topicOptions) {
        this.topicOptions = C[this.name].topicOptions
    }
    Panel.prototype.update.call(this, C)
};
TopicPanel.prototype.resizing = function() {
    if (!this.panel$) {
        return
    }
    this.computeDimensions(this.panel$, this.tray$)
};
TopicPanel.prototype._leftActionButtonTimeout = function() {
    MC.debugOutput("TopicPanel.leftActionButtonTimeout()");
    if (this.actionMenu.visible && !this.actionMenuEntered) {
        this.actionMenu.close()
    }
};
TopicPanel.prototype._actionButtonLeft = function() {
    MC.debugOutput("TopicPanel.actionButtonLeft()");
    if (this.actionMenu.visible) {
        this.leavingActionButtonTimeout = setTimeout(this.leftActionButtonTimeoutCallback, 200)
    }
    return false
};
TopicPanel.prototype._actionClicked = function() {
    if (this.actionMenu.visible) {
        this.actionMenu.close()
    } else {
        this.actionMenuEntered = false;
        this.actionMenu.open({
            parentObj: this,
            menu: this.menu,
            position: {
                element$: this.actionButton$,
                direction: "below",
                edge: "left"
            },
            callback: this.options.actionCallback
        })
    }
};
TopicPanel.prototype.enteringSubMenu = function() {
    MC.debugOutput("TopicPanel action menu entered");
    this.actionMenuEntered = true
};

function ActionPanel(F) {
    if (arguments.length == 0 || !F.name) {
        return
    }
    if (F.autoHeight == undefined) {
        F.autoHeight = true
    }
    var E = {
        title: (strings.actions[F.name] || "NO TITLE"),
        okButtonText: strings.okButtonText,
        cancelButtonText: ((F.cancelButtonText) ? F.cancelButtonText : strings.cancelButtonText),
        closeButtonText: ((F.closeButtonText) ? F.closeButtonText : strings.closeButtonText),
        linkOkCancel: (F.linkOkClose == undefined) ? true : F.linkOkClose,
        applyButtonText: strings.applyButtonText
    };
    $.extend(E, F);
    E.showing = this._actionShowing;
    E.htmlText = '<div class="actionContainer dark" style="visibility: hidden"><div class="actionTray" ><div id="' + E.name + 'View" class="actionPanel scrollingDiv widgetParent"></div></div><div class="panelError"></div><div class="actionButtons"></div></div>';
    Panel.call(this, E);
    this.class_name = "ActionPanel";
    this.panel$ = $(".actionContainer", this.elements);
    this.tray$ = $(".actionTray", this.elements);
    this.content$ = $(".actionPanel", this.elements);
    this.buttons$ = $(".actionButtons", this.elements);
    if (!views[E.name + "View"]) {
        this.makeView(this.content$)
    }
    var D = [];
    if (this.options.okCallback) {
        this.actionOkButton = new ButtonWidget({
            emphasized: true,
            name: (E.name + "_ok"),
            primary: true,
            text: E.okButtonText,
            disable: true,
            callback: createObjectCallback(this, this._okClicked)
        });
        if (this.options.linkOkCancel) {
            var C = this.options.closeButtonText
        } else {
            var C = this.options.cancelButtonText
        }
    } else {
        var C = this.options.closeButtonText
    }
    if (this.options.applyCallback) {
        this.actionApplyButton = new ButtonWidget({
            emphasized: false,
            name: (E.name + "_apply"),
            text: E.applyButtonText,
            disable: true,
            callback: createObjectCallback(this, this._applyClicked)
        })
    }
    this.actionCancelButton = new ButtonWidget({
        emphasized: false,
        name: (E.name + "_cancel"),
        text: C,
        callback: createObjectCallback(this, this._cancelClicked)
    });
    if (typeof brandSettings.buttonOrientationLeftToRight != "undefined" && brandSettings.buttonOrientationLeftToRight == true) {
        if (this.actionOkButton) {
            D.push(this.actionOkButton)
        }
        if (this.actionApplyButton) {
            D.push(this.actionApplyButton)
        }
        D.push(this.actionCancelButton)
    } else {
        D.push(this.actionCancelButton);
        if (this.actionApplyButton) {
            D.push(this.actionApplyButton)
        }
        if (this.actionOkButton) {
            D.push(this.actionOkButton)
        }
    }
    this.buttonContainer = new ButtonContainer({
        alignment: "right",
        widgets: D
    });
    this.buttons$.append(this.buttonContainer.elements)
}
ActionPanel.prototype = new Panel();
ActionPanel.prototype.constructor = ActionPanel;
ActionPanel.prototype._actionShowing = function(C) {
    this.panel$.css("visibility", "visible")
};
ActionPanel.prototype.update = function(C) {
    if (C[this.name] && C[this.name].previousSelection) {
        this.previousSelection = $.merge([], C[this.name].previousSelection)
    }
    if (C[this.name] && C[this.name].actionOptions) {
        this.actionOptions = C[this.name].actionOptions
    }
    if (C[this.name + "_ok"]) {
        this.actionOkButton.update(C)
    }
    if (C[this.name + "_apply"]) {
        this.actionApplyButton.update(C)
    }
    if (C[this.name + "_cancel"]) {
        this.actionCancelButton.update(C)
    }
    Panel.prototype.update.call(this, C)
};
ActionPanel.prototype._buttonEnabled = function(F, E, C) {
    if (!(F instanceof ButtonWidget)) {
        return undefined
    }
    var D;
    if (E == undefined) {
        D = !F.disabled
    } else {
        D = E
    }
    F.handleUpdate({
        disable: (!D)
    });
    if (C === true) {
        F.focus()
    }
    return true
};
ActionPanel.prototype.setButtonText = function(C, F) {
    var D;
    var E = {};
    if (((C == "cancel") || (C == "apply") || (C == "ok")) && F) {
        C = this.options.name + "_" + C;
        E[C] = {
            text: F
        };
        this.buttonContainer.update(E)
    }
};
ActionPanel.prototype.cancelEnabled = function(C) {
    return this._buttonEnabled(this.actionCancelButton, C)
};
ActionPanel.prototype.okEnabled = function(D, C) {
    if ((this.options != undefined) && this.options.linkOkCancel) {
        this.setButtonText("cancel", (D) ? this.options.cancelButtonText : this.options.closeButtonText)
    }
    return this._buttonEnabled(this.actionOkButton, D, C)
};
ActionPanel.prototype.applyEnabled = function(D, C) {
    return this._buttonEnabled(this.actionApplyButton, D, C)
};
ActionPanel.prototype._okClicked = function() {
    if ($.isFunction(this.options.okCallback)) {
        this.options.okCallback(this)
    }
};
ActionPanel.prototype._cancelClicked = function() {
    var C = true;
    if ($.isFunction(this.options.cancelCallback)) {
        C = this.options.cancelCallback(this)
    }
    if (C) {
        panels.actionDialog.close(true)
    }
};
ActionPanel.prototype.close = function() {
    panels.actionDialog.close(true)
};
ActionPanel.prototype.resetSize = function(C) {
    panels.actionDialog.resetSize(C)
};
ActionPanel.prototype._applyClicked = function() {
    if ($.isFunction(this.options.applyCallback)) {
        this.options.applyCallback(this)
    }
};

function HoverPanel(D) {
    if (arguments.length == 0 || !D.name) {
        return
    }
    var C = {
        title: (strings.hovers[D.name] || "NO TITLE"),
        okButtonText: strings.okButtonText,
        cancelButtonText: strings.cancelButtonText
    };
    $.extend(C, D);
    C.htmlText = '<div class="hoverContainer widgetParent" style="visibility: hidden">' + (D.htmlText || "") + "</div>";
    C.showing = this._hoverShowing;
    Panel.call(this, C);
    this.class_name = "HoverPanel";
    this.panel$ = $(".hoverContainer", this.elements)
}
HoverPanel.prototype = new Panel();
HoverPanel.prototype.constructor = HoverPanel;
HoverPanel.prototype._hoverShowing = function(C) {
    this.panel$.css("visibility", "visible")
};
HoverPanel.prototype.resizing = function() {
    if (!this.panel$) {
        return
    }
};
HoverPanel.prototype.getApiObject = function() {
    if (this.currentParent instanceof APIObject) {
        return this.currentParent
    } else {
        if (this.currentParent instanceof Panel || this.currentParent instanceof Widget) {
            return this.currentParent.getApiObject()
        } else {
            if (this.currentParent instanceof DCRef) {
                return this.currentParent.getObject()
            } else {
                return null
            }
        }
    }
};

function findHighestZIndex() {
    var C = 0;
    $(".actionDialog").each(function() {
        var D = $(this).css("z-index");
        if (D && D != "auto" && D > C) {
            C = D
        }
    });
    return parseInt(C)
}

function TipPanel(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = '<div id="tipContainer" style="visibility: hidden;position: absolute;">    <div id="arrow-left"></div>    <div id="tipSection"><div id="tipText"></div></div></div>';
    Panel.call(this, C);
    this.class_name = "TipPanel";
    this.tipContainer$ = $("#tipContainer", this.elements);
    this.tipSection$ = $("#tipSection", this.elements);
    this.tipText$ = $("#tipText", this.elements)
}
TipPanel.prototype = new Panel();
TipPanel.prototype.constructor = TipPanel;
TipPanel.prototype.open = function(E, C) {
    this.tipShowing = true;
    this.tipContainer$.css("visibility", "visible");
    var D = findHighestZIndex();
    this.tipContainer$.css("z-index", D + 1);
    this.tipContainer$.css("top", C.top - 5.5);
    this.tipContainer$.css("left", C.left + 20);
    this.tipText$.html(E);
    var F = Math.round(this.tipText$.height() / 2) - 5;
    this.tipSection$.css("top", -F);
    this.firstClick = true;
    $(document).click(createObjectCallback(this, this.handleClick))
};
TipPanel.prototype.close = function() {
    this.tipShowing = false;
    this.tipContainer$.css("visibility", "hidden")
};
TipPanel.prototype.handleClick = function(C) {
    if (this.firstClick) {
        this.firstClick = false;
        return
    }
    if ((C.target.className != "tipWidget") && ($(C.target).closest("#tipText").length == 0) && (this.tipContainer$.css("visibility") != "hidden")) {
        this.close();
        $(document).unbind("click")
    }
};
MENUS = {};
MENUS.topics = {
    easystart: {
        topicClass: "easyStartTopic",
        topic: "EasyStartTopic",
        useIt: false
    },
    home: {
        topicClass: "homeTopic",
        topic: "HomeTopic",
        useIt: true
    },
    system: {
        topicClass: "systemTopic",
        topic: "SystemTopic",
        useIt: true
    },
    hosts: {
        topicClass: "hostsTopic",
        topic: "HostsTopic",
        useIt: true
    },
    pools: {
        topicClass: "poolsTopic",
        topic: "PoolsTopic",
        useIt: true
    },
    volumes: {
        topicClass: "volumesTopic",
        topic: "VolumesTopic",
        useIt: true
    },
    mapping: {
        topicClass: "mappingTopic",
        topic: "MappingTopic",
        useIt: true
    },
    replications: {
        topicClass: "replicationsTopic",
        topic: "RepsTopic",
        useIt: true
    },
    performance: {
        topicClass: "performanceTopic",
        topic: "PerfTopic",
        useIt: true
    }
};
MENUS.CTKTopic = {
    ctkAction: {
        action: "CTKAction",
        text: "CTK Action"
    }
};
MENUS.HomeTopic = {
    sysSettings: {
        action: "SystemSettings",
        actionOptions: {
            tab: "dateTime"
        }
    },
    storageSetup: {
        action: "StorageSetup"
    },
    storageCompleteSetup: {
        action: "StorageCompleteSetup"
    },
    hostSetup: {
        action: "HostSetup"
    },
    manageSchedules: {
        action: "ManageSchedulesAction",
        actionOptions: {
            all: true
        }
    },
    addStorage: {
        action: "AddStorageAction"
    }
};
MENUS.EasyStartTopic = {
    sysSettings: {
        action: "SystemSettings",
        actionOptions: {
            tab: "dateTime"
        }
    },
    storageSetup: {
        action: "StorageSetup"
    },
    hostSetup: {
        action: "HostSetup"
    },
    storageCompleteSetup: {
        action: "StorageCompleteSetup"
    },
    manageSchedules: {
        action: "ManageSchedulesAction",
        actionOptions: {
            all: true
        }
    }
};
MENUS.EasyStartTopic.addStorage = {
    action: "AddStorageAction"
};
MENUS.ButtonsTestPanel = {
    buttonsTest: {
        text: "Buttons Test",
        action: "ButtonsDarkTestAction"
    }
};
MENUS.SystemTopic = {
    sysSettings: {
        action: "SystemSettings",
        actionOptions: {
            tab: "dateTime"
        }
    },
    resetHostPort: {
        action: "ResetHostPortAction"
    },
    rescanDiskChannel: {
        action: "RescanDiskChannelAction"
    },
    clearMetadata: {
        action: "ClearMetadataAction"
    },
    updateFirmware: {
        action: "UpdateFirmwareAction"
    },
    fullDiskEncryption: {
        action: "FullDiskEncryptionAction"
    },
    advancedSettings: {
        action: "AdvancedSettingsAction"
    },
    restartSystem: {
        action: "RestartSystemAction"
    }
};
MENUS.HostsTopic = {
    hostSetup: {
        action: "HostSetup"
    },
    createInit: {
        action: "CreateInitAction"
    },
    modifyInit: {
        action: "ModifyInitAction"
    },
    deleteInit: {
        action: "DeleteInitAction"
    },
    addToHost: {
        action: "AddToHostAction"
    },
    removeFromHost: {
        action: "RemoveFromHostAction"
    },
    removeHost: {
        action: "RemoveHostAction"
    },
    renameHost: {
        action: "RenameHostAction"
    },
    addToHostGroup: {
        action: "AddToHostGroupAction"
    },
    removeFromHostGroup: {
        action: "RemoveFromHostGroupAction"
    },
    renameHostGroup: {
        action: "RenameHostGroupAction"
    },
    removeHostGroup: {
        action: "RemoveHostGroupAction"
    },
    configureChap: {
        action: "ConfigureChapAction"
    },
    mapInitiators: {
        action: "MapAction"
    },
    mapDetails: {
        action: "MapDetailAction"
    }
};
MENUS.PoolsTopic = {
    storageCompleteSetup: {
        action: "StorageCompleteSetup"
    },
    addDiskGroup: {
        action: "CreateDiskGroupAction"
    },
    modifyDiskGroup: {
        action: "ModifyDiskGroupAction"
    },
    removeDiskGroups: {
        action: "RemoveDiskGroupsAction"
    },
    expandDiskGroups: {
        action: "ExpandDiskGroupAction"
    },
    changeSpares: {
        action: "ChangeSparesAction"
    }
};
MENUS.PoolsTopic.createVolumes = {
    action: "createVolumesFactory",
    factory: true,
    actionOptions: {
        topic: "Pools"
    }
};
MENUS.PoolsTopic.poolSettings = {
    action: "PoolSettingsAction"
};
MENUS.PoolsTopic.diskGroupUtilities = {
    action: "diskGroupUtilities"
};
MENUS.PoolsTopic.dequarantine = {
    action: "DequarantineDiskGroupAction"
};
RSRVOLTOPIC = {};
ARVOLTOPIC = {};
ARVOLTOPIC.createVirtualVolumes = RSRVOLTOPIC.createVirtualVolumes = {
    action: "CreateVirtualVolumesAction",
    actionOptions: {
        topic: "Volumes"
    }
};
RSRVOLTOPIC.createLinearVolumes = ARVOLTOPIC.createLinearVolumes = {
    action: "CreateLinearVolumesAction",
    actionOptions: {
        topic: "Volumes"
    }
};
RSRVOLTOPIC.createSnapshot = ARVOLTOPIC.createSnapshot = {
    action: "CreateSnapshotAction",
    bottomDivider: true
};
RSRVOLTOPIC.modifyVolume = ARVOLTOPIC.modifyVolume = {
    action: "ModifyVolumeAction"
};
RSRVOLTOPIC.copyVolume = ARVOLTOPIC.copyVolume = {
    action: "CopyVolumeAction"
};
RSRVOLTOPIC.abortVolumeCopy = ARVOLTOPIC.abortVolumeCopy = {
    action: "AbortVolumeCopyAction"
};
RSRVOLTOPIC.rollbackVolume = ARVOLTOPIC.rollbackVolume = {
    action: "RollbackVolumeAction"
};
ARVOLTOPIC.createReplicationSetVol = {
    action: "CreateReplicationSetVol"
};
ARVOLTOPIC.replicate = {
    action: "ReplicateAction"
};
RSRVOLTOPIC.createReplicationSetVol = {
    action: "CreateRsrReplicationSet"
};
RSRVOLTOPIC.replicateVol = {
    action: "RsrReplicateAction"
};
RSRVOLTOPIC.replicateSnapshot = {
    action: "ReplicateSnapshotVol"
};
RSRVOLTOPIC.mapVolumes = ARVOLTOPIC.mapVolumes = {
    action: "MapAction"
};
RSRVOLTOPIC.mapDetails = ARVOLTOPIC.mapDetails = {
    action: "MapDetailAction"
};
RSRVOLTOPIC.removeMap = ARVOLTOPIC.removeMap = {
    action: "RemoveMappings"
};
RSRVOLTOPIC.addToVolumeGroup = ARVOLTOPIC.addToVolumeGroup = {
    action: "AddToVolumeGroupAction"
};
RSRVOLTOPIC.removeFromVolumeGroup = ARVOLTOPIC.removeFromVolumeGroup = {
    action: "RemoveFromVolumeGroupAction"
};
RSRVOLTOPIC.deleteVolumes = ARVOLTOPIC.deleteVolumes = {
    action: "DeleteVolumesAction",
    bottomDivider: true
};
RSRVOLTOPIC.renameVolumeGroup = ARVOLTOPIC.renameVolumeGroup = {
    action: "RenameVolumeGroupAction"
};
RSRVOLTOPIC.removeVolumeGroup = ARVOLTOPIC.removeVolumeGroup = {
    action: "RemoveVolumeGroupAction"
};
RSRVOLTOPIC.resetSnapshot = ARVOLTOPIC.resetSnapshot = {
    action: "ResetSnapshotAction"
};
RSRVOLTOPIC.manageSchedules = ARVOLTOPIC.manageSchedules = {
    action: "ManageSchedulesAction"
};
MENUS.VolumesTopic = ARVOLTOPIC;
MENUS.MappingTopic = {
    map: {
        action: "MapAction"
    },
    removeMap: {
        action: "RemoveMappings"
    },
    removeAllMaps: {
        action: "RemoveAllMappings"
    },
    mapDetails: {
        action: "MapDetailAction"
    }
};
MENUS.PerfTopic = {
    updatePerf: {
        action: "UpdatePerfAction"
    },
    exportPerf: {
        action: "ExportPerfAction"
    },
    resetPerf: {
        action: "ResetPerfAction"
    }
};
MENUS.RsrTopic = {
    addRemoteSystem: {
        action: "AddRemoteSystem"
    },
    deleteRemoteSystem: {
        action: "DeleteRemoteSystem"
    },
    createReplicationSet: {
        action: "CreateRsrReplicationSet"
    },
    checkLink: {
        action: "CheckLinksAction"
    },
    deleteReplicationSet: {
        action: "DeleteRsrReplicationSet"
    },
    replicateVol: {
        action: "RsrReplicateAction"
    },
    replicateSnapshot: {
        action: "ReplicateSnapshot"
    },
    setPrimaryVolume: {
        action: "SetPrimaryVolume"
    },
    abortReplication: {
        action: "AbortRsrReplication"
    },
    suspendReplication: {
        action: "SuspendRsrReplication"
    },
    resumeReplication: {
        action: "ResumeRsrReplication"
    },
    detachReplicationVolume: {
        action: "DetachReplicationVolume"
    },
    reattachReplicationVolume: {
        action: "ReattachReplicationVolume"
    },
    exportSnapshot: {
        action: "ExportSnapshot"
    },
    deleteSnapshot: {
        action: "DeleteRsrSnapshot"
    },
    manageSchedules: {
        action: "ManageSchedulesAction"
    }
};
MENUS.RepsTopic = {
    queryPeerConnection: {
        action: "QueryPeerConnectionAction"
    },
    createPeerConnection: {
        action: "CreatePeerConnectionAction"
    },
    deletePeerConnection: {
        action: "DeletePeerConnectionAction"
    },
    modifyPeerConnection: {
        action: "ModifyPeerConnectionAction"
    },
    createReplicationSet: {
        action: "CreateReplicationSet",
        topDivider: true
    },
    deleteReplicationSet: {
        action: "DeleteReplicationSet"
    },
    modifyReplicationSet: {
        action: "ModifyReplicationSet",
        bottomDivider: true
    },
    replicate: {
        action: "ReplicateAction"
    },
    abortReplication: {
        action: "AbortReplication"
    },
    suspendReplication: {
        action: "SuspendReplicationSet"
    },
    resumeReplication: {
        action: "ResumeReplicationSet"
    },
    manageSchedules: {
        action: "ManageSchedulesAction"
    }
};
MENUS.bannerPanels = {
    sysInfo: {
        banner: "SysInfoBarPanel"
    },
    connect: {
        banner: "ConnectBarPanel"
    },
    dateTime: {
        banner: "DateTimeBarPanel"
    },
    user: {
        banner: "UserBarPanel"
    }
};
MENUS.SysInfoBarPanel = {
    systemInfoSetup: {
        action: "SystemSettings",
        actionOptions: {
            tab: "systemInfo"
        }
    },
    servicesSetup: {
        action: "SystemSettings",
        actionOptions: {
            tab: "services"
        }
    },
    updateFirmware: {
        action: "UpdateFirmwareAction"
    },
    restartSystem: {
        action: "RestartSystemAction"
    },
    certificateInfo: {
        action: "ShowCertificateInfoAction"
    }
};
MENUS.ConnectBarPanel = {};
MENUS.DateTimeBarPanel = {
    dateTimeSetup: {
        action: "SystemSettings",
        actionOptions: {
            tab: "dateTime"
        }
    }
};
MENUS.UserBarPanel = {
    userManagement: {
        action: "SystemSettings",
        actionOptions: {
            tab: "manageUsers"
        }
    }
};
MENUS.footerPanels = {
    health: {
        banner: "HealthBarPanel"
    },
    event: {
        banner: "EventBarPanel"
    },
    capacity: {
        banner: "CapacityBarPanel"
    },
    perf: {
        banner: "PerfBarPanel"
    },
    tierIo: {
        banner: "TierIoBarPanel"
    },
    ssdActivity: {
        banner: "SSDActivityPanel"
    },
    activity: {
        banner: "ActivityBarPanel"
    }
};
MENUS.HealthBarPanel = {
    notificationSetup: {
        action: "SystemSettings",
        actionOptions: {
            tab: "notifications"
        }
    },
    saveLogs: {
        action: "SaveLogsAction"
    },
    viewSystem: {
        topic: "SystemTopic",
        topicOptions: {
            display: "table",
            tableSort: [
                [2, "desc"]
            ]
        }
    }
};
MENUS.EventBarPanel = {
    eventList: {
        action: "EventListAction"
    },
    notificationSetup: {
        action: "SystemSettings",
        actionOptions: {
            tab: "notifications"
        }
    }
};
MENUS.CapacityBarPanel = {};
MENUS.PerfBarPanel = {};
MENUS.TierIoBarPanel = {};
MENUS.SSDActivityPanel = {
    ssdActivity: {
        action: "SSDActivityDialog"
    }
};
MENUS.ActivityBarPanel = {
    noteDisplay: {
        action: "NoteDisplayAction"
    }
};
MENUS.HiddenActions = {
    scheduleReplications: {
        action: "ScheduleReplications"
    },
    initiateRsrReplication: {
        action: "InitiateRsrReplication"
    },
    scheduleRsrReplications: {
        action: "ScheduleRsrReplication"
    }
};

function Navigation() {}
Navigation.prototype.initialize = function() {};
Navigation.prototype._getPanel = function(D) {
    if (D == undefined) {
        MC.errorOutput("Null panel name provided!");
        return null
    }
    var E = window[D];
    if (!E || !$.isFunction(E)) {
        MC.errorOutput("%s: is not a constructor!", D);
        return null
    }
    if (panels[D]) {
        MC.debugOutput("Found panel %s already instantiated.", D);
        return panels[D]
    }
    var C = new E({});
    MC.debugOutput("Created new panel %s.", D);
    return C
};
Navigation.prototype.navTo = function(D, Q, L, U, F) {
    var S = MENUS[D];
    if (!S) {
        return
    }
    var I = S[Q];
    if (!I) {
        return
    }
    var O = I.topic;
    var N = I.topicOptions;
    var P = I.action;
    var K = I.actionOptions;
    var R = {};
    var J = {};
    if (F) {
        if (F.topicOptions) {
            R = F.topicOptions
        }
        if (F.actionOptions) {
            J = F.actionOptions
        }
    }
    if (U) {
        var G = U.slice(0)
    } else {
        var G = TopicPanel.selection.slice(0)
    }
    if (L) {
        var E = I.subMenu[L];
        if (!E) {
            return
        }
        if (E.topic) {
            O = E.topic;
            N = null
        }
        if (E.topicOptions) {
            N = E.topicOptions
        }
        if (E.action) {
            P = E.action;
            K = null
        }
        if (E.actionOptions) {
            K = E.actionOptions
        }
    }
    N = N || {};
    $.extend(N, R);
    K = K || {};
    $.extend(K, J);
    if (O) {
        if (O == "HomeTopic") {
            if (EZStartManager.showEasyStart()) {
                O = "EasyStartTopic"
            }
        }
        var H = this._getPanel(O);
        if (!H) {
            MC.errorOutput("Topic %s not found!", Q);
            return
        }
        var T = {};
        T[H.name] = {
            topicOptions: N,
            previousSelection: G
        };
        H.update(T);
        views.topicView.viewAttach(H);
        if (O == "EasyStartTopic") {
            panels.TopicMenuPanel.selectTopic("HomeTopic")
        } else {
            panels.TopicMenuPanel.selectTopic(O)
        }
        currentTopic = O
    }
    if (P) {
        if (I.factory) {
            var C = window[P](I)
        } else {
            var C = this._getPanel(P)
        }
        if (!C) {
            MC.errorOutput("Action %s not found!", P);
            return
        }
        if (!U) {
            var M = I.state;
            if (M instanceof Array) {
                G = M
            }
        }
        var T = {};
        T[C.name] = {
            actionOptions: K,
            previousSelection: G
        };
        C.update(T);
        if (panels.actionDialog.active) {
            panels.actionDialog.close(true)
        }
        panels.actionDialog.open({
            panel: C,
            height: C.options.height,
            width: C.options.width
        })
    }
};
var NAV = new Navigation({});

function Widget(D) {
    if (arguments.length == 0) {
        return
    }
    this.class_name = "Widget";
    this.options = {};
    $.extend(this.options, D);
    this.name = this.options.name || "";
    this.elements = null;
    if (this.options.htmlText) {
        this.elements = $(this.options.htmlText).get(0);
        if (this.options.id != undefined) {
            $(this.elements).attr("id", this.options.id)
        }
        if (this.options.classes != undefined) {
            $(this.elements).addClass(this.options.classes)
        }
    }
    if ($.isFunction(this.options.success)) {
        this.options.success.call(this, this.elements)
    }
    this.elements$ = $(this.elements);
    if (D.hoverPanel) {
        this._setupHover(D)
    }
    if (D.healthPosition) {
        var C = 'style="position: absolute; ' + D.healthPosition + '"';
        this.healthBadge$ = $("<img " + C + "></img>").appendTo(this.elements)
    }
    if (D.fanoutPosition) {
        var C = 'style="position: absolute; ' + D.fanoutPosition + '"';
        this.fanoutBadge$ = $("<img " + C + "></img>").appendTo(this.elements)
    }
    if (D.tooltip != undefined) {
        if (compareVersions($.fn.jquery, "1.4") >= 0) {
            $(this.elements).prop("title", D.tooltip)
        } else {
            $(this.elements).attr("title", D.tooltip)
        }
    }
    if (D.tip) {
        if (D.noTipIcon) {
            this.tip$ = $(this.elements)
        } else {
            this.tip$ = $('<div class="tipWidget"></div>').appendTo(this.elements)
        }
        this.tipShowing = false;
        this.tip$.click(createObjectCallback(this, this.toggleTip))
    }
}
Widget.prototype = new DHSObject();
Widget.prototype.__attaching = function(C) {
    if (this.attaching) {
        this.attaching(C)
    }
    if (this.options.attaching) {
        this.options.attaching.call(this, C)
    }
};
Widget.prototype.__detaching = function(C) {
    if (this.detaching) {
        this.detaching(C)
    }
    if (this.options.detaching) {
        this.options.detaching.call(this, C)
    }
};
Widget.prototype.__showing = function(C) {
    if (this.showing) {
        this.showing(C)
    }
    if (this.options.showing) {
        this.options.showing.call(this, C)
    }
};
Widget.prototype.__hiding = function(C) {
    if (this.tipShowing) {
        panels.tipPanel.close()
    }
    if (this.hiding) {
        this.hiding(C)
    }
    if (this.options.hiding) {
        this.options.hiding.call(this, C)
    }
};
Widget.prototype.getElements = function() {
    return this.elements
};
Widget.prototype.update = function(G) {
    if (this.name) {
        var F = G[this.name];
        if (typeof F != "undefined") {
            this.handleUpdate(F);
            if (F instanceof Object) {
                if (F.visibility) {
                    this.setVisibility(F.visibility)
                }
            }
            if (F.tooltip != undefined) {
                $(this.elements).prop("title", F.tooltip)
            }
            if (F.tip != undefined) {
                if (this.options.tip != undefined) {
                    this.options.tip = F.tip
                } else {
                    this.options.tip = F.tip;
                    if (F.noTipIcon != undefined) {
                        this.tip$ = $('<div class="tipWidget"></div>').appendTo(this.elements)
                    } else {
                        this.tip$ = $(this.elements)
                    }
                    this.tipShowing = false;
                    this.tip$.click(createObjectCallback(this, this.toggleTip))
                }
            }
            if (this.healthBadge$ && F.health) {
                var D = this.options.healthSize || "15";
                var C = "";
                switch (F.health) {
                    case "1":
                        C += "../images/health/degraded" + D + ".png";
                        break;
                    case "2":
                        C += "../images/health/bad" + D + ".png";
                        break;
                    case "3":
                        C += "../images/health/unknown" + D + ".png";
                        break;
                    default:
                        C = "";
                        break
                }
                if (C) {
                    this.healthBadge$.attr("src", C);
                    this.healthBadge$.show()
                } else {
                    this.healthBadge$.hide()
                }
            }
            if (this.fanoutBadge$) {
                var E = "";
                E += "../images/home/fanoutIconHome.png";
                this.fanoutBadge$.attr("src", E);
                this.fanoutBadge$.show()
            }
        }
    }
};
Widget.prototype.setVisibility = function(C) {
    if (C == "hidden" || C == "collapse") {
        $(this.elements).hide();
        if (this.labelElement) {
            this.labelElement.hide()
        }
    } else {
        $(this.elements).show();
        if (this.labelElement) {
            this.labelElement.show()
        }
    }
};
Widget.prototype.handleUpdate = function(C) {};
Widget.prototype.retrieve = function(C) {
    if (this.name) {
        this.handleRetrieve(C)
    }
};
Widget.prototype.handleRetrieve = function(C) {};
Widget.prototype.getApiObject = function() {
    return null
};
Widget.prototype._setupHover = function(C) {
    this._removeHoverCallback = createObjectCallback(this, this._removeHover);
    this.elements$.hoverIntent({
        sensitivity: (C.hoverSensitivity || 2),
        interval: (C.hoverInterval || 300),
        timeout: ((C.hoverTimeout == undefined) ? 0 : C.hoverTimeout),
        selector: ((C.hoverSelector == undefined) ? null : C.hoverSelector),
        over: createObjectCallback(this, this._displayHover),
        out: this._removeHoverCallback
    })
};
Widget.prototype._displayHover = function(C) {
    if (this.savedHoverEvent && !this.hoverTimeout) {
        return
    }
    if (!this.hoverDisabled) {
        panels.hoverDialog.open({
            parentObj: this,
            offsetElement$: this.elements$,
            eventObj: C,
            panel: this.options.hoverPanel,
            height: this.options.hoverPanel.options.height,
            width: this.options.hoverPanel.options.width + 20
        });
        this.savedHoverEvent = C;
        this.hoverObject$ = this.elements$;
        $(window).on("click", this._removeHoverCallback)
    }
};
Widget.prototype._removeHover = function(F) {
    if (F && F.type != "click" && this.hoverObject$) {
        var G = this.hoverObject$.offset();
        var D = Math.round(G.left);
        var C = Math.round(G.top);
        var H = D + this.hoverObject$.outerWidth() - 1;
        var E = C + this.hoverObject$.outerHeight() - 1;
        if (F.pageX >= G.left && F.pageX <= H && F.pageY >= G.top && F.pageY <= E) {
            return
        }
    }
    if (this.hoverTimeout) {
        clearTimeout(this.hoverTimeout);
        delete this.hoverTimeout
    }
    this.hoverDisabled = false;
    if (!this.savedHoverEvent) {
        return
    }
    $(window).off("click", this._removeHoverCallback);
    panels.hoverDialog.close();
    delete this.savedHoverEvent;
    delete this.hoverObject$
};
Widget.prototype.disableHover = function() {
    if (this.hoverDisabled) {
        return
    }
    this.hoverDisabled = true;
    if (this.savedHoverEvent) {
        panels.hoverDialog.close()
    }
};
Widget.prototype.enableHover = function() {
    if (!this.hoverDisabled) {
        return
    }
    this.hoverDisabled = false;
    if (this.savedHoverEvent) {
        panels.hoverDialog.close()
    }
};
Widget.prototype.toggleTip = function() {
    if (panels.tipPanel.tipShowing) {
        panels.tipPanel.close()
    } else {
        panels.tipPanel.open(this.options.tip, this.tip$.offset())
    }
};

function WidgetContainer(F) {
    if (arguments.length == 0) {
        return
    }
    if (!F.htmlText) {
        F.htmlText = '<div class="widgetContainer"></div>'
    }
    if (F.border) {
        if (F.classes) {
            F.classes += " "
        } else {
            F.classes = ""
        }
        F.classes += "containerWidgetBorder"
    }
    var C = "";
    if (F.topMargin) {
        C += " ARTopMargin"
    }
    if (F.bottomMargin) {
        C += " ARBottomMargin"
    }
    if (F.leftMargin) {
        C += " ARLeftMargin"
    }
    if (F.rightMargin) {
        C += " ARRightMargin"
    }
    if (F.topMediumMargin) {
        C += " ARTopMediumMargin"
    }
    if (F.bottomMediumMargin) {
        C += " ARBottomMediumMargin"
    }
    if (F.leftMediumMargin) {
        C += " ARLeftMediumMargin"
    }
    if (F.rightMediumMargin) {
        C += " ARRightMediumMargin"
    }
    if (F.topSmallMargin) {
        C += " ARTopSmallMargin"
    }
    if (F.bottomSmallMargin) {
        C += " ARBottomSmallMargin"
    }
    if (F.leftSmallMargin) {
        C += " ARLeftSmallMargin"
    }
    if (F.rightSmallMargin) {
        C += " ARRightSmallMargin"
    }
    F.classes += C;
    Widget.call(this, F);
    this.class_name = "WidgetContainer";
    this.containerElement = $(".widgetContainer", this.elements).get(0);
    if (!this.containerElement) {
        this.containerElement = this.elements
    }
    if (F.width != undefined) {
        $(this.elements).css("width", F.width + "px")
    }
    if (F.visibility != undefined) {
        this.setVisibility(F.visibility)
    }
    this.widgets = new Array();
    if (F.visibility != undefined) {
        this.setVisibility(F.visibility)
    }
    if (F.widgets) {
        var E = F.widgets.length;
        for (var D = 0; D < E; D++) {
            this.add(F.widgets[D])
        }
    }
}
WidgetContainer.prototype = new Widget();
WidgetContainer.prototype.constructor = WidgetContainer;
WidgetContainer.prototype.add = function(D) {
    this.widgets[this.widgets.length] = D;
    var C = "";
    if (D.options.topMargin) {
        C += " ARTopMargin"
    }
    if (D.options.bottomMargin) {
        C += " ARBottomMargin"
    }
    if (D.options.leftMargin) {
        C += " ARLeftMargin"
    }
    if (D.options.rightMargin) {
        C += " ARRightMargin"
    }
    if (D.options.topMediumMargin) {
        C += " ARTopMediumMargin"
    }
    if (D.options.bottomMediumMargin) {
        C += " ARBottomMediumMargin"
    }
    if (D.options.leftMediumMargin) {
        C += " ARLeftMediumMargin"
    }
    if (D.options.rightMediumMargin) {
        C += " ARRightMediumMargin"
    }
    if (D.options.topSmallMargin) {
        C += " ARTopSmallMargin"
    }
    if (D.options.bottomSmallMargin) {
        C += " ARBottomSmallMargin"
    }
    if (D.options.leftSmallMargin) {
        C += " ARLeftSmallMargin"
    }
    if (D.options.rightSmallMargin) {
        C += " ARRightSmallMargin"
    }
    $(D.getElements()).appendTo(this.containerElement).addClass(C)
};
WidgetContainer.prototype.remove = function(C) {
    if (C.destructor) {
        C.destructor()
    }
    var D = C.getElements();
    if (D) {
        $(D, this.containerElement).remove()
    }
    return this.widgets.remove(C)
};
WidgetContainer.prototype.findWidgetByName = function(C) {
    var E = this.widgets.length;
    for (var D = 0; D < E; D++) {
        if (this.widgets[D].name == C) {
            return this.widgets[D]
        }
    }
    return null
};
WidgetContainer.prototype._empty = function() {
    while (this.widgets.length) {
        this.remove(this.widgets[0])
    }
};
WidgetContainer.prototype.findWidgetByNameDeep = function(D) {
    var F = this.findWidgetByName(D);
    if (F) {
        return F
    }
    var G = this.widgets.length;
    for (var E = 0; E < G; E++) {
        if (this.widgets[E] instanceof WidgetContainer) {
            var C = this.widgets[E].findWidgetByNameDeep(D);
            if (C) {
                return C
            }
        }
    }
    return null
};
WidgetContainer.prototype.executeDeep = function(G, F) {
    if (!G) {
        return
    }
    if ($.isFunction(this[G])) {
        this[G].apply(this, F)
    }
    for (var D = 0, C = this.widgets.length; D < C; D++) {
        var E = this.widgets[D];
        if (E instanceof WidgetContainer) {
            E.executeDeep(G, F)
        } else {
            if ($.isFunction(E[G])) {
                E[G].apply(E, F)
            }
        }
    }
};
WidgetContainer.prototype.removeDeletedByProperty = function() {
    var D = this.widgets.length;
    for (var C = 0; C < D; C++) {
        if (this.widgets[C].deleted) {
            if (this.remove(this.widgets[C])) {
                C--;
                D--
            }
        }
    }
};
WidgetContainer.prototype.update = function(G) {
    Widget.prototype.update.call(this, G);
    var F = false;
    if (this.name && G[this.name] && G[this.name].disable != undefined) {
        F = true
    }
    var E = this.widgets.length;
    for (var D = 0; D < E; D++) {
        if (F) {
            var C = this.widgets[D].name;
            if (C && (!G[C] || G[C].disable == undefined)) {
                if (!G[C]) {
                    G[C] = {}
                }
                G[C].disable = G[this.name].disable
            }
        }
        this.widgets[D].update(G)
    }
};
WidgetContainer.prototype.retrieve = function(E, D) {
    for (var C = 0; C < this.widgets.length; C++) {
        this.widgets[C].retrieve(E, D)
    }
    Widget.prototype.retrieve.call(this, E)
};
WidgetContainer.prototype.__attaching = function(C) {
    Widget.prototype.__attaching.call(this, C);
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].__attaching(C)
    }
};
WidgetContainer.prototype.__detaching = function(C) {
    Widget.prototype.__detaching.call(this, C);
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].__detaching(C)
    }
};
WidgetContainer.prototype.__showing = function(C) {
    Widget.prototype.__showing.call(this, C);
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].__showing(C)
    }
};
WidgetContainer.prototype.__hiding = function(C) {
    Widget.prototype.__hiding.call(this, C);
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].__hiding(C)
    }
};

function TableWidget(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.htmlText) {
        C.htmlText = '<table class="tableWidget" border="0" cellpadding="0" cellspacing="0"><tbody class="widgetContainer"></tbody></table>'
    }
    if (C.maxRows == undefined && C.maxCols == undefined) {
        C.maxCols = 4
    } else {
        if (C.maxRows != undefined && C.maxCols != undefined) {
            delete C.maxRows
        }
    }
    this.rows = 0;
    this.cols = 0;
    if (C.maxCols != undefined) {
        this.lastAdded = {
            row: 0,
            col: -1
        }
    } else {
        this.lastAdded = {
            row: -1,
            col: 0
        }
    }
    WidgetContainer.call(this, C);
    this.class_name = "TableWidget";
    if (this.options.bodyClasses) {
        $(this.containerElement).addClass(this.options.bodyClasses)
    }
    if (this.options.tableClasses) {
        $(this.elements).addClass(this.options.tableClasses)
    }
    if (this.options.caption) {
        $(this.elements).append("<caption>" + this.options.caption + "</caption>")
    }
    this.handleUpdate(C)
}
TableWidget.prototype = new WidgetContainer();
TableWidget.prototype.constructor = TableWidget;
TableWidget.prototype.handleUpdate = function(C) {
    if (C.hide && C.hide.start != undefined) {
        this.hideRows(C.hide.start, C.hide.end)
    }
    if (C.show && C.show.start != undefined) {
        this.showRows(C.show.start, C.show.end)
    }
};
TableWidget.prototype.add = function(H) {
    if (H != undefined && (H instanceof Widget)) {
        if (H.options.label != undefined && !H.options.singleCell) {
            var G = new LabelWidget(H);
            this.add(G)
        }
        var D = "";
        if (H.options.topMargin) {
            D += " ARTopPadding"
        }
        if (H.options.bottomMargin) {
            D += " ARBottomPadding"
        }
        if (H.options.leftMargin) {
            D += " ARLeftPadding"
        }
        if (H.options.rightMargin) {
            D += " ARRightPadding"
        }
        if (H.options.topMediumMargin) {
            D += " ARTopMediumPadding"
        }
        if (H.options.bottomMediumMargin) {
            D += " ARBottomMediumPadding"
        }
        if (H.options.leftMediumMargin) {
            D += " ARLeftMediumPadding"
        }
        if (H.options.rightMediumMargin) {
            D += " ARRightMediumPadding"
        }
        if (H.options.topSmallMargin) {
            D += " ARTopSmallPadding"
        }
        if (H.options.bottomSmallMargin) {
            D += " ARBottomSmallPadding"
        }
        if (H.options.leftSmallMargin) {
            D += " ARLeftSmallPadding"
        }
        if (H.options.rightSmallMargin) {
            D += " ARRightSmallPadding"
        }
        if (H.options.wrapText) {
            D += " ARWrapText"
        }
        if (H.options.cellClasses) {
            H.options.cellClasses += D
        } else {
            H.options.cellClasses = D
        }
        this.calcTablePos(H);
        this.lastAdded.row = H.options.row;
        if (H.options.rowSpan != undefined) {
            this.lastAdded.row += (H.options.rowSpan - 1)
        }
        this.lastAdded.col = H.options.col;
        if (H.options.colSpan != undefined) {
            this.lastAdded.col += (H.options.colSpan - 1)
        }
        this.widgets[this.widgets.length] = H;
        for (var F = this.rows; F <= H.options.row; F++) {
            $(this.containerElement).append("<tr></tr>");
            this.rows = F + 1
        }
        var I;
        for (var F = 0; F < this.rows; F++) {
            I = $(this.containerElement).children().eq(F);
            for (var E = I.children().length; E <= H.options.col; E++) {
                I.append("<td></td>")
            }
        }
        if (H.options.col >= this.cols) {
            this.cols = H.options.col + 1
        }
        var C = $(this.containerElement).children().eq(H.options.row).children().eq(H.options.col);
        C.empty().append(H.getElements());
        if (H.options.cellClasses != undefined) {
            C.addClass(H.options.cellClasses)
        }
        if (H.options.colSpan != undefined) {
            C.attr("colSpan", H.options.colSpan)
        }
        if (H.options.rowSpan != undefined) {
            C.attr("rowSpan", H.options.rowSpan)
        }
    }
};
TableWidget.prototype.calcTablePos = function(D) {
    var E = D.options.row;
    var C = D.options.col;
    if (D.options.row == undefined) {
        if (this.options.maxRows != undefined) {
            E = this.lastAdded.row + 1;
            if (E >= this.options.maxRows) {
                E = 0;
                if (D.options.col == undefined) {
                    C = this.lastAdded.col + 1;
                    D.options.col = C
                }
            }
        } else {
            E = this.lastAdded.row
        }
    }
    if (D.options.col == undefined) {
        if (this.options.maxCols != undefined) {
            C = this.lastAdded.col + 1;
            if (C >= this.options.maxCols) {
                C = 0;
                if (D.options.row == undefined) {
                    E = this.lastAdded.row + 1
                }
            }
        } else {
            C = this.lastAdded.col
        }
    }
    D.options.row = E;
    D.options.col = C
};
TableWidget.prototype.showRows = function(D, C) {
    if (C == undefined) {
        $(this.containerElement).children("tr").slice(D).show()
    } else {
        $(this.containerElement).children("tr").slice(D, C + 1).show()
    }
};
TableWidget.prototype.hideRows = function(D, C) {
    if (C == undefined) {
        $(this.containerElement).children("tr").slice(D).hide()
    } else {
        $(this.containerElement).children("tr").slice(D, C + 1).hide()
    }
};
TableWidget.prototype.showColumns = function(J, M) {
    var L = $(this.containerElement).children("tr");
    var H = false;
    var F;
    for (var I = 0; I < L.length; I++) {
        var D = L[I];
        F = J;
        if ($(D).children("td").attr("colspan")) {
            var C = 0;
            var E = $(D).children("td");
            for (var G = 0; G < E.length; G++) {
                if ($(E[G]).attr("colspan")) {
                    var K = parseInt($(E[G]).attr("colspan"));
                    C += K;
                    if (C == J) {
                        F = G + 1;
                        break
                    }
                }
            }
        }
        if (M == undefined) {
            $(D).children("td").slice(F).show()
        } else {
            $(D).children("td").slice(F, M + 1).show()
        }
    }
};
TableWidget.prototype.hideColumns = function(J, M) {
    var L = $(this.containerElement).children("tr");
    var H = false;
    var F;
    for (var I = 0; I < L.length; I++) {
        var D = L[I];
        F = J;
        if ($(D).children("td").attr("colspan")) {
            var C = 0;
            var E = $(D).children("td");
            for (var G = 0; G < E.length; G++) {
                if ($(E[G]).attr("colspan")) {
                    var K = parseInt($(E[G]).attr("colspan"));
                    C += K;
                    if (C == J) {
                        F = G + 1;
                        break
                    }
                }
            }
        }
        if (M == undefined) {
            $(D).children("td").slice(F).hide()
        } else {
            $(D).children("td").slice(F, M + 1).hide()
        }
    }
};
TableWidget.prototype.addCSSClass = function(C) {
    $(this.elements).addClass(C)
};
TableWidget.prototype.removeCSSClass = function(C) {
    $(this.elements).removeClass(C)
};

function TextWidget(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.label) {
        C.htmlText = '<div><label class="inline ARRightMargin"></label><div class="inline"' + (C.width ? 'style="width: ' + C.width + 'px;"' : "") + "></div></div>"
    } else {
        C.htmlText = "<div " + (C.width ? 'style="width: ' + C.width + 'px;"' : "") + "></div>"
    }
    Widget.call(this, C);
    this.options.labelClass = "";
    this.options.cssClass = "";
    this.class_name = "TextWidget";
    this.labelElement = $("label", this.elements);
    if (C.label) {
        this.label$ = $("label", this.elements);
        this.text$ = $("div", this.elements)
    } else {
        this.text$ = $(this.elements)
    }
    this.handleUpdate(C)
}
TextWidget.prototype = new Widget();
TextWidget.prototype.handleUpdate = function(C) {
    if (C.text != undefined) {
        if (this.options.tip) {
            this.text$.prepend(C.text)
        } else {
            this.text$.html(C.text)
        }
    }
    if (this.label$ && C.labelClass != undefined) {
        this.label$.removeClass(this.options.labelClass);
        if (C.labelClass != "") {
            this.label$.addClass(C.labelClass)
        }
        this.options.labelClass = C.labelClass
    }
    if (C.cssClass && C.cssClass != this.options.cssClass) {
        this.text$.removeClass(this.options.cssClass);
        this.text$.addClass(C.cssClass);
        this.options.cssClass = C.cssClass
    } else {
        if (this.options.cssClass == "") {
            this.text$.addClass("textWidget");
            this.options.cssClass = C.cssClass
        }
    }
    if (C.label) {
        this.labelElement.html(C.label + (this.options.noTerminator ? "" : strings.labelTerminator))
    }
    if (C.disable != undefined) {
        if (C.disable) {
            this.text$.addClass("textDisabled")
        } else {
            this.text$.removeClass("textDisabled")
        }
    }
};

function StatusWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.cssClass = C.cssClass || "";
    C.htmlText = '<div class="' + C.cssClass + '"></div>';
    Widget.call(this, C);
    this.class_name = "StatusWidget";
    this.handleUpdate(C)
}
StatusWidget.prototype = new Widget();
StatusWidget.prototype.handleUpdate = function(D) {
    if (D) {
        $(this.elements).removeClass("confirmStatus processingStatus successStatus failureStatus messageStatus warningStatus errorStatus");
        var C = "";
        switch (D.status) {
            case "confirm":
                C = "confirmStatus";
                break;
            case "success":
                C = "successStatus";
                break;
            case "failure":
                C = "failureStatus";
                break;
            case "processing":
                C = "processingStatus";
                break;
            case "message":
                C = "messageStatus";
                break;
            case "warning":
                C = "warningStatus";
                break;
            case "error":
            default:
                C = "errorStatus";
                break
        }
        $(this.elements).addClass(C)
    }
};

function Arrangement(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.maxCols) {
        C.orientation = "vertical"
    } else {
        if (C.maxRows) {
            C.orientation = "horizontal"
        } else {
            C.orientation = C.orientation || "vertical";
            if (C.orientation == "vertical") {
                C.maxCols = 1
            } else {
                C.maxRows = 1
            }
        }
    }
    if (C.autoWidth) {
        this.arrangementClass = C.orientation + "AutoArrangement"
    } else {
        this.arrangementClass = C.orientation + "Arrangement"
    }
    C.htmlText = C.htmlText || '<div class="' + this.arrangementClass + ' widgetContainer"></div>';
    WidgetContainer.call(this, C);
    this.class_name = "Arrangement"
}
Arrangement.prototype = new WidgetContainer();
Arrangement.prototype.add = function(E) {
    if (!E) {
        return
    }
    if (this.tableWidget == undefined) {
        var C = this.options.tableClasses || this.arrangementClass + "Table";
        var D = {
            name: this.name + "Table",
            classes: C,
            maxCols: this.options.maxCols,
            maxRows: this.options.maxRows
        };
        this.tableWidget = new TableWidget(D);
        WidgetContainer.prototype.add.call(this, this.tableWidget)
    }
    if (!E.options) {
        E.options = {}
    }
    if (!E.options.cellClasses) {
        E.options.cellClasses = this.arrangementClass + "Cell"
    }
    this.tableWidget.add(E)
};

function ContentWidget(E) {
    if (arguments.length == 0) {
        return
    }
    if (E.scrollable == undefined) {
        E.scrollable = false
    }
    var D = ((E.scrollable) ? "contentScrollContainer" : "contentFillContainer");
    var C = ((E.height) ? ('style="height: ' + E.height + 'px"') : "");
    E.htmlText = '<div class="' + D + ' widgetContainer" ' + C + "></div>";
    Arrangement.call(this, E);
    this.class_name = "ContentWidget";
    this.handleUpdate(E)
}
ContentWidget.prototype = new Arrangement();
ContentWidget.prototype.handleUpdate = function(C) {};

function ContentHorizontalRule(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = '<HR class="contentHorizontalRule">';
    Widget.call(this, C);
    this.class_name = "ContentHorizontalRule"
}
ContentHorizontalRule.prototype = new Widget();

function ContentDivider(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = '<div class="contentDivider"></div>';
    Widget.call(this, C);
    this.class_name = "ContentDivider"
}
ContentDivider.prototype = new Widget();

function TaskHeaderWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.name = C.name;
    this.titleText = (typeof(C.titleText) != "undefined") ? C.titleText : "";
    this.titleClass = (typeof(C.titleClass) != "undefined") ? C.titleClass : "defaultTaskHeaderClass";
    this.titleWidget = new TextWidget({
        name: "titleWidget",
        text: this.titleText,
        cssClass: this.titleClass
    });
    this.hrWidget = new ContentHorizontalRule({});
    C.widgets = [this.titleWidget, this.hrWidget];
    Arrangement.call(this, C);
    this.update(C)
}
TaskHeaderWidget.prototype = new Arrangement();
TaskHeaderWidget.prototype.handleUpdate = function(E) {
    var D = this;
    var C = {};
    if (typeof(E.titleText) != "undefined") {
        this.titleText = E.titleText
    }
    if (typeof(E.titleClass) != "undefined") {
        this.titleClass = E.titleClass
    }
    C.titleWidget = {
        text: this.titleText,
        cssClass: this.titleClass
    };
    D.update(C)
};

function BlurbHeaderWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.name = C.name;
    this.titleText = (typeof(C.titleText) != "undefined") ? C.titleText : "";
    this.blurbText = (typeof(C.blurbText) != "undefined") ? C.blurbText : "";
    this.titleClass = (typeof(C.titleClass) != "undefined") ? C.titleClass : "defaultTaskHeaderClass";
    this.blurbClass = (typeof(C.blurbClass) != "undefined") ? C.blurbClass : "defaultTaskBlurbClass";
    this.titleWidget = new TextWidget({
        name: "titleWidget",
        text: this.titleText,
        cssClass: this.titleClass,
        bottomMargin: true
    });
    this.blurbWidget = new TextWidget({
        name: "blurbWidget",
        text: this.blurbText,
        cssClass: this.blurbClass
    });
    this.hrWidget = new ContentHorizontalRule({});
    C.widgets = [this.titleWidget, this.blurbWidget, this.hrWidget];
    Arrangement.call(this, C);
    this.update(C)
}
BlurbHeaderWidget.prototype = new Arrangement();
BlurbHeaderWidget.prototype.handleUpdate = function(E) {
    var D = this;
    if (typeof(E.titleText) != "undefined") {
        this.titleText = E.titleText
    }
    if (typeof(E.titleClass) != "undefined") {
        this.titleClass = E.titleClass
    }
    if (typeof(E.blurbText) != "undefined") {
        this.blurbText = E.blurbText
    }
    if (typeof(E.blurbClass) != "undefined") {
        this.blurbClass = E.blurbClass
    }
    var C = {
        titleWidget: {
            text: this.titleText,
            cssClass: this.titleClass
        },
        blurbWidget: {
            text: this.blurbText,
            cssClass: this.blurbClass
        }
    };
    D.update(C)
};

function BlurbWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.name = C.name;
    this.blurbText = (typeof(C.blurbText) != "undefined") ? C.blurbText : "";
    this.blurbClass = (typeof(C.blurbClass) != "undefined") ? C.blurbClass : "defaultTaskBlurbClass";
    this.blurbWidget = new TextWidget({
        name: "blurbWidget",
        text: this.blurbText,
        cssClass: this.blurbClass
    });
    this.hrWidget = new ContentHorizontalRule({});
    C.widgets = [this.blurbWidget, this.hrWidget];
    Arrangement.call(this, C);
    this.update(C)
}
BlurbWidget.prototype = new Arrangement();
BlurbWidget.prototype.handleUpdate = function(E) {
    var D = this;
    if (typeof(E.blurbText) != "undefined") {
        this.blurbText = E.blurbText
    }
    if (typeof(E.blurbClass) != "undefined") {
        this.blurbClass = E.blurbClass
    }
    var C = {
        blurbWidget: {
            text: this.blurbText,
            cssClass: this.blurbClass
        }
    };
    D.update(C)
};

function ViewWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = '<div class="' + C.viewID + '"></div>';
    Widget.call(this, C);
    this.class_name = "ViewWidget";
    $(this.elements).view()
}
ViewWidget.prototype = new Widget();
ViewWidget.prototype.handleUpdate = function(C) {
    if (C.attachPanel != undefined) {
        $(this.elements).viewAttach(C.attachPanel)
    }
};

function DualTableWidget(D) {
    if (arguments.length == 0) {
        return
    }
    this.name = D.name;
    D.orientation = "vertical";
    this.mode = "none";
    this.dataTable = new DataTable({
        name: "dataTable",
        caption: strings.loading,
        visibility: "collapse"
    });
    this.objectTable = new ObjectTable({
        name: "objectTable",
        caption: strings.loading,
        visibility: "collapse"
    });
    D.widgets = [this.dataTable, this.objectTable];
    Arrangement.call(this, D);
    this.class_name = "DualTableWidget";
    var C = {};
    C[this.name] = D;
    this.update(C)
}
DualTableWidget.prototype = new Arrangement();
DualTableWidget.prototype.handleUpdate = function(E) {
    if (E.mode != undefined) {
        this.mode = E.mode
    }
    if (E.noEmpty != undefined) {
        this.noEmpty = E.noEmpty
    }
    var D = {
        visibility: "collapse"
    };
    var C = {
        visibility: "collapse"
    };
    if (this.mode == "data") {
        $.extend(D, E);
        if ((!this.noEmpty) || (D.data && D.data.objects.length > 0)) {
            D.visibility = "visible"
        }
    } else {
        if (this.mode == "object") {
            C.visibility = "visible";
            $.extend(C, E)
        }
    }
    this.dataTable.update({
        dataTable: D
    });
    this.objectTable.update({
        objectTable: C
    })
};

function GraphWidget(D) {
    if (arguments.length == 0) {
        return
    }
    var C = {
        name: "graph",
        width: "200",
        height: "100"
    };
    $.extend(C, D);
    C.htmlText = '<div class="graphWidget" style="width: ' + C.width + "px; height: " + C.height + 'px;"></div>';
    Widget.call(this, C);
    this.class_name = "GraphWidget";
    this.graphData = [];
    this.graphOptions = {};
    this.plot = null;
    this.visible = (D.visible) ? true : false;
    this.tooltips = false;
    this.tooltipCallback = createObjectCallback(this, this.hoverCallback);
    this.hoverPoint = null;
    this.handleUpdate(C)
}
GraphWidget.prototype = new Widget();
GraphWidget.prototype.constructor = GraphWidget;
GraphWidget.colors = ["#000000", "#c00000", "#0000ff", "#33FF33", "#CC00CC", "#00CCCC", "#00ffff", "#a00000", "#a000ff", "#c0c060", "#ff0000", "#c000ff", "#ffff00", "#ff6080", "#ff00ff", "#0000a0", "#a000a0", "#ff00a0", "#ff4040", "#c06040", "#608040", "#00a0a0", "#ff8040", "#404000", "#804000", "#ff2060", "#c02080", "#802080", "#202080", "#a040c0", "#80c0a0", "#c06080", "#ff6080"];
GraphWidget.prototype.handleUpdate = function(D) {
    if (D == undefined) {
        return
    }
    if (D.graphOptions) {
        for (var C in D.graphOptions) {
            if (this.graphOptions[C] == undefined) {
                this.graphOptions[C] = {}
            }
            $.extend(this.graphOptions[C], D.graphOptions[C])
        }
    }
    if (D.graphData && (D.graphData instanceof Array)) {
        this.graphData = D.graphData
    }
    if (D.tooltips != undefined && this.tooltips != D.tooltips) {
        this.tooltips = D.tooltips;
        if (this.tooltips) {
            $(this.elements).bind("plothover", this.tooltipCallback)
        } else {
            $(this.elements).unbind("plothover", this.tooltipCallback)
        }
        if (this.graphOptions.grid == undefined) {
            this.graphOptions.grid = {}
        }
        this.graphOptions.grid.hoverable = this.tooltips
    }
    if (D.propertyGraphData) {
        this.processApiProperties(D.propertyGraphData)
    } else {
        if (D.objectGraphData) {
            this.processApiObjects(D.objectGraphData)
        }
    }
    if (this.visible) {
        if (D.clearGraphData) {
            this.graphData = []
        }
        this.plot = $.plot(this.elements, this.graphData, this.graphOptions)
    }
};
GraphWidget.prototype.handleRetrieve = function(C) {
    C[this.name] = {
        scaleUnit: this.scaleUnit
    }
};
GraphWidget.prototype.scale = function(M, K, L) {
    this.scaleUnit = K;
    var H = strings.microsec;
    var J = {
        binary: {
            K: 1024,
            M: 1048576,
            G: 1073741824,
            T: 1099511627776,
            P: 1125899906842624
        },
        decimal: {
            K: 1000,
            M: 1000000,
            G: 1000000000,
            T: 1000000000000
        }
    };
    J[H] = {
        ms: 1000,
        Seconds: 1000000,
        Minutes: 60000000
    };
    var I = 0;
    for (var G = 0; G < M.length; G++) {
        if (M[G] > I) {
            I = M[G]
        }
    }
    var E;
    var C = K;
    switch (C) {
        case H:
            if ((I / (J[C].ms * 10)) < 1) {
                break
            } else {
                if ((I / (J[C].Seconds * 10)) < 1) {
                    E = "ms"
                } else {
                    if ((I / (J[C].Minutes * 10)) < 1) {
                        E = "Seconds"
                    } else {
                        E = "Minutes"
                    }
                }
            }
            K = "";
            break;
        case "binary":
            if (L) {
                E = L
            } else {
                if (Size.round((I / (J[C].M)), 1, false) < 1) {
                    E = "KB"
                } else {
                    if (Size.round((I / (J[C].G)), 1, false) < 1) {
                        E = "MB"
                    } else {
                        if (Size.round((I / (J[C].T)), 1, false) < 1) {
                            E = "GB"
                        } else {
                            E = "TB"
                        }
                    }
                }
            }
            break;
        default:
            C = "decimal";
            if ((I / (J[C].K * 10)) < 1) {
                break
            } else {
                if ((I / (J[C].M * 10)) < 1) {
                    E = "K"
                } else {
                    if ((I / (J[C].G * 10)) < 1) {
                        E = "M"
                    } else {
                        if ((I / (J[C].T * 10)) < 1) {
                            E = "G"
                        } else {
                            E = "T"
                        }
                    }
                }
            }
            break
    }
    if (E != undefined) {
        for (var G = 0; G < this.graphData.length; G++) {
            var N = this.graphData[G].data;
            for (var F = 0; F < N.length; F++) {
                if (C == "binary") {
                    if (!isNaN(N[F][1])) {
                        var O = new Size(N[F][1]).getSize();
                        if (O.spec == "KB" || O.spec == "MB" || O.spec == "KiB" || O.spec == "MiB") {
                            O = new Size(N[F][1]).getSize(E, 4)
                        } else {
                            O = new Size(N[F][1]).getSize(E, 2)
                        }
                        var D = parseFloat(O.size);
                        N[F][1] = D
                    }
                } else {
                    var D = N[F][1] / J[C][E];
                    N[F][1] = Math.floor(D)
                }
            }
            this.graphData[G].data = N
        }
        this.scaleUnit = E + K;
        this.unit = E
    }
};
GraphWidget.prototype.processApiObjects = function(G) {
    var K = G.data;
    var J = [];
    if (G.colors) {
        J = G.colors
    }
    this.graphData = [];
    var D = [];
    for (var H = 0; H < K.length; H++) {
        var N = K[H];
        var M = [];
        var E = {};
        for (var F = 0; F < N.length; F++) {
            E = N[F];
            var I = parseInt(E.getPropertyValue("sample_time_numeric")) * 1000;
            if (I == undefined || I == 0) {
                continue
            }
            if ((MCDate.runningCPSmode)) {
                I -= (MCDate.arrayTimezoneOffset * 60000)
            }
            if (E.getPropertyValue(G.prop) != undefined) {
                var C = parseInt(E.getPropertyValue(G.prop));
                M.push([I, C]);
                D.push(C)
            }
        }
        var L = {
            color: (J[H] != undefined) ? J[H] : GraphWidget.colors[H],
            data: M
        };
        if (G.labels) {
            L.label = G.labels[H]
        }
        this.graphData.push(L)
    }
    if (G.baseUnit != undefined) {
        this.scale(D, G.baseUnit)
    }
};
GraphWidget.prototype.processApiProperties = function(O) {
    var N = O.data;
    var L = O.props;
    this.graphData = [];
    var M = [];
    var D = [];
    if (O.colors) {
        M = O.colors
    }
    for (var I = 0; I < L.length; I++) {
        var K = L[I];
        var Q = [];
        var E = {};
        var H = [];
        for (var F = N.length - 1; F >= 0; F--) {
            E = N[F];
            if (E.basetype == "heatmaps") {
                var J = parseInt(E.getPropertyValue("start_sample_time_numeric")) * 1000;
                var G = O.ssdInfo.blocks;
                H.push([J, G])
            } else {
                var J = parseInt(E.getPropertyValue("sample_time_numeric")) * 1000;
                if (J == undefined || J == 0) {
                    continue
                }
            }
            if (MCDate.runningCPSmode) {
                J -= (MCDate.arrayTimezoneOffset * 60000)
            }
            if (E.getPropertyValue(K) != undefined) {
                var C = parseInt(E.getPropertyValue(K));
                Q.push([J, C]);
                D.push(C)
            }
        }
        var P = {
            color: (M[I] != undefined) ? M[I] : GraphWidget.colors[I],
            data: Q
        };
        if (O.labels) {
            P.label = O.labels[I]
        }
        if (I == L.length - 1) {
            var R = {
                color: "#cfd4d6",
                data: H,
                points: {
                    show: false
                },
                lines: {
                    lineWidth: 1,
                    fill: true
                }
            };
            this.graphData.push(R)
        }
        this.graphData.push(P)
    }
    if (O.baseUnit != undefined) {
        this.scale(D, O.baseUnit, O.unit)
    }
};
GraphWidget.getTimeAxisOptions = function(D, C) {
    if (D.length <= C || D[C].getPropertyValue("sample_time_numeric") == 0) {
        return ""
    }
    var H = D[0].getPropertyValue("sample_time_numeric") - D[C].getPropertyValue("sample_time_numeric");
    var G = H / 60;
    var F = {
        tickSize: [G, "minute"]
    };
    var E = "%m/%d%<br />%h:%M";
    return F
};
GraphWidget.prototype.hoverCallback = function(E, G, D) {
    if (D) {
        if (this.hoverPoint == null || this.hoverPoint[0] != D.datapoint[0] || this.hoverPoint[1] != D.datapoint[1]) {
            this.hoverPoint = D.datapoint;
            this.hideTooltip();
            var C = D.datapoint[0];
            var F = D.datapoint[1];
            if (!this.name.localeCompare("workloadGraph")) {
                this.showTooltip(D.pageX, D.pageY, F + " " + this.unit)
            } else {
                this.showTooltip(D.pageX, D.pageY, D.series.label + " of " + C + " = " + F)
            }
        }
    } else {
        this.hideTooltip();
        this.hoverPoint = null
    }
};
GraphWidget.prototype.showing = function() {
    this.visible = true;
    this.scaleUnit = ""
};
GraphWidget.prototype.hiding = function() {
    this.visible = false
};
GraphWidget.prototype.showTooltip = function(C, E, D) {
    $('<div id="graphTooltip">' + D + "</div>").css({
        top: E + 5,
        left: C + 5
    }).appendTo("body").fadeIn(200)
};
GraphWidget.prototype.hideTooltip = function() {
    $("#graphTooltip").remove()
};

function ProcessingWidget(D) {
    if (arguments.length == 0) {
        return
    }
    var C = {
        name: "processingWidget",
        width: 160
    };
    $.extend(C, D);
    C.htmlText = '<div class="processIndicator" style="width: ' + C.width + 'px;"></div>';
    Widget.call(this, C);
    this.class_name = "ProcessingWidget"
}
ProcessingWidget.prototype = new Widget();
ProcessingWidget.prototype.constructor = ProcessingWidget;

function SegmentedGraphWidget(D) {
    if (arguments.length == 0) {
        return
    }
    var C = {
        name: "segGraph",
        captionVert: "% Used",
        captionHoriz: "Relative Object Size",
        sizeClass: "sgSizeDefault",
        usedClass: "sgUsedDefault"
    };
    $.extend(C, D);
    this.width = D.width || 200;
    this.height = D.height || 100;
    this.sizeClass = D.sizeClass || "sgSizeDefault";
    this.usedClass = D.usedClass || "sgUsedDefault";
    this.graphWidth = this.width - 10;
    this.graphHeight = this.height - 10;
    C.htmlText = '<div class="segGraphWrapper" style="width: ' + this.width + "px; height: " + this.height + 'px;"><div class="segGraphLeftCaption" style="width: ' + (this.height - 10) + "px; top: " + (this.height / 2 - 10) + "px; left: -" + (this.height / 2 - 9) + 'px; text-align: center;">' + C.captionVert + '</div><div class="segGraphBottomCaption" style="width: ' + (this.width - 10) + 'px">' + C.captionHoriz + '</div><div class="segGraphWidget" style="width: ' + (this.width - 10) + "px; height: " + (this.height - 10) + 'px;"></div></div>';
    Widget.call(this, C);
    this.class_name = "SegmentedGraphWidget";
    this.leftCaption$ = $(".segGraphLeftCaption", this.elements);
    this.bottomCaption$ = $(".segGraphBottomCaption", this.elements);
    this.graph$ = $(".segGraphWidget", this.elements);
    this.segments = [];
    this.visible = false;
    this.tooltips = false;
    this.tooltipCallback = createObjectCallback(this, this.hoverCallback);
    this.handleUpdate(C)
}
SegmentedGraphWidget.prototype = new Widget();
SegmentedGraphWidget.prototype.constructor = SegmentedGraphWidget;
SegmentedGraphWidget.prototype.handleUpdate = function(C) {
    if (C == undefined || C.segments == undefined) {
        return
    }
    if (C.sizeClass) {
        this.sizeClass = C.sizeClass
    }
    if (C.usedClass) {
        this.usedClass = C.usedClass
    }
    this.segments = C.segments;
    this.redrawGraph()
};
SegmentedGraphWidget.prototype.redrawGraph = function() {
    if (this.segments == undefined) {
        return
    }
    if (!this.elements$.is(":visible")) {
        return
    }
    this.graph$.empty();
    var K = this.elements$.width();
    var R = this.elements$.height();
    if (K != this.width || R != this.height) {
        this.height = R;
        this.width = K;
        this.graphWidth = this.width - 10;
        this.graphHeight = this.height - 10;
        this.leftCaption$.css({
            width: (this.height - 10) + "px",
            top: (this.height / 2 - 10) + "px",
            left: "-" + (Math.ceil(this.height / 2) - 1) + "px"
        });
        this.bottomCaption$.css("width", (this.width - 10) + "px");
        this.graph$.css({
            width: this.graphWidth + "px",
            height: this.graphHeight + "px"
        })
    }
    var Z = new Size();
    for (var T = 0, U = this.segments.length; T < U; T++) {
        var V = this.segments[T];
        Z.add(V.size);
        delete V.segAdjusted;
        delete V.segWidth;
        delete V.segShade
    }
    var G = this.graphWidth + 1;
    var Q = Z.getRawValue();
    var C = 0;
    var I = this.segments.length;
    var H = G / this.segments.length;
    var X = [];
    var W = 0;
    for (var T = 0; T < I; T++) {
        var V = this.segments[T];
        var J = Math.round(G * V.size.getRawValue() / Q);
        if (J < 2 && H > 2) {
            J = 2;
            V.segAdjusted = true
        }
        if (J >= H) {
            W++
        }
        V.segWidth = J;
        C += J;
        V.segShade = Math.floor(this.graphHeight * V.used.getRawValue() / V.size.getRawValue());
        X.push(T)
    }
    if (C != G) {
        var P = G - C;
        var Y = this;
        X.sort(function(d, c) {
            return Y.segments[c].size.getRawValue() - Y.segments[d].size.getRawValue()
        });
        var N = 3;
        for (var T = 0, U = X.length; T < U && P != 0; T++) {
            var V = this.segments[X[T]];
            if (N == 0) {
                MC.warningOutput("Cannot adjust graph segments enough.");
                break
            }
            if (V.segWidth <= N) {
                MC.warningOutput("Making another pass through segment adjustment with limit = %d", N);
                N--;
                T = 0;
                continue
            }
            if (!V.segAdjusted) {
                if (W - T != 0) {
                    var S = Math.ceil(Math.abs(P) / (W - T))
                } else {
                    var S = Math.ceil(Math.abs(P))
                }
                if (P < 0) {
                    S *= -1
                }
                if ((V.segWidth + S) < 0) {
                    MC.warningOutput("Cannot adjust graph segments enough.");
                    break
                }
                V.segWidth += S;
                V.segAdjusted = true;
                P -= S
            }
        }
    }
    var F = 0;
    for (var T = 0; T < I; T++) {
        var M = this.sizeClass;
        var D = this.usedClass;
        var V = this.segments[T];
        var J = V.segWidth - 1;
        if (T == (I - 1)) {
            var L = "segGraphAll segGraphLast"
        } else {
            var L = "segGraphAll"
        }
        var O = strings.segGraph.sizeTip(V.name, V.size.format("auto", 1));
        if (V.used) {
            O += strings.segGraph.usedTip(V.used.format("auto", 1))
        }
        if (V.sizeClass) {
            M = V.sizeClass
        }
        if (V.usedClass) {
            D = V.usedClass
        }
        var E = $('<div class="' + L + " " + M + '" title="' + O + '"  style="top: 0px; left: ' + F + "px; width: " + J + "px; height: " + this.graphHeight + 'px;"></div>').appendTo(this.graph$);
        if (V.segShade > 0) {
            E.append('<div class="segGraphUsed ' + D + '" style="bottom: 0px; left: 0px; width: ' + J + "px; height: " + V.segShade + 'px;"></div>')
        }
        F += V.segWidth
    }
};

function ButtonWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.text = D.text || "Submit";
    D.disable = D.disable || false;
    if (D.emphasized != undefined) {
        D.primary = D.emphasized
    }
    this.normalClass = "button" + (D.primary ? "Primary" : "");
    this.disabledClass = "buttonDisabled";
    var C = "buttonLarge";
    if (D.size && D.size == "small") {
        C = "buttonSmall"
    }
    if (D.size && D.size == "medium") {
        C = "buttonMedium"
    }
    this.buttonCallback = D.callback || D.click || function() {
        return false
    };
    if (!D.htmlText) {
        D.htmlText = '<div class="' + C + '"></div>'
    }
    Widget.call(this, D);
    this.class_name = "ButtonWidget";
    this.button$ = $(this.elements);
    this.button$.attr("tabindex", 1);
    this.button$.bind("keydown", createObjectCallback(this, this._keyDown));
    this.button$.disableTextSelect();
    this.disabled = !D.disable;
    this.handleUpdate(this.options)
}
ButtonWidget.prototype = new Widget();
ButtonWidget.prototype.constructor = ButtonWidget;
ButtonWidget.prototype.handleUpdate = function(C) {
    if (C.disable != undefined) {
        if (C.disable && !this.disabled) {
            this.button$.removeClass(this.normalClass).addClass(this.disabledClass);
            this.button$.unbind("click", this.buttonCallback)
        } else {
            if (!C.disable && this.disabled) {
                this.button$.removeClass(this.disabledClass).addClass(this.normalClass);
                this.button$.unbind("click").bind("click", this.buttonCallback)
            }
        }
        this.disabled = C.disable
    }
    if (C.text != undefined) {
        this.button$.html(C.text)
    }
    if (C.tooltip != undefined) {
        if (compareVersions($.fn.jquery, "1.4") >= 0) {
            $(this.elements).prop("title", C.tooltip)
        } else {
            $(this.elements).attr("title", C.tooltip)
        }
    }
};
ButtonWidget.prototype._keyDown = function(C) {
    if (C.keyCode == 13) {
        this.button$.click()
    }
};
ButtonWidget.prototype.focus = function() {
    var C = this.button$;
    setTimeout(function() {
        try {
            C.focus()
        } catch (D) {
            MC.debugOutput("Unable to set focus on this button: " + D.message)
        }
    }, 0)
};

function ButtonContainer(C) {
    if (arguments.length == 0) {
        return
    }
    C.orientation = C.orientation || "horizontal";
    C.alignment = C.alignment || "none";
    C.buttonClass = C.classes || "buttonContainer";
    C.htmlText = "<div class=" + C.buttonClass + ' style="float:' + C.alignment + ';"><div class="widgetContainer ' + C.orientation + 'Buttons" style="width: inherit;"></div></div>';
    WidgetContainer.call(this, C);
    this.class_name = "ButtonContainer"
}
ButtonContainer.prototype = new WidgetContainer();
ButtonContainer.prototype.constructor = ButtonContainer;
ButtonContainer.prototype.add = function(E) {
    if (!E instanceof ButtonWidget) {
        MC.errorOutput("Attempt to add non-button widget %o to ButtonContainer!", E);
        return
    }
    if (this.options.orientation == "horizontal") {
        E.button$.addClass("buttonHoriz")
    }
    WidgetContainer.prototype.add.call(this, E);
    if (this.widgets && this.widgets.length > 0) {
        var D = this.widgets[0].options.size;
        var C = "Large";
        if (D == "medium") {
            C = "Medium"
        }
        if (D == "small") {
            C = "Small"
        }
        if (this.options.orientation == "horizontal") {
            E.button$.addClass("button" + C + "HorizSpacing")
        } else {
            E.button$.addClass("button" + C + "VertSpacing")
        }
    }
    E.button$.attr("tabindex", 0)
};
ButtonContainer.prototype.prepend = function(E) {
    if (!E instanceof ButtonWidget) {
        MC.errorOutput("Attempt to add non-button widget %o to ButtonContainer!", E);
        return
    }
    if (this.options.orientation == "horizontal") {
        E.button$.addClass("buttonHoriz")
    }
    this.widgets[this.widgets.length] = E;
    $(E.getElements()).prependTo(this.containerElement);
    if (this.widgets && this.widgets.length > 0) {
        var D = this.widgets[0].options.size;
        var C = "Large";
        if (D == "medium") {
            C = "Medium"
        }
        if (D == "small") {
            C = "Small"
        }
        if (this.options.orientation == "horizontal") {
            E.button$.addClass("button" + C + "HorizSpacing")
        } else {
            E.button$.addClass("button" + C + "VertSpacing")
        }
    }
    E.button$.attr("tabindex", 0)
};
VALREGEX = {
    NAME: /^[^\\", <\u0000-\u001F][^\\",<\u0000-\u001F]*$/,
    PASSWORD: /^[^\\", <>'\u0000-\u001F]+$/,
    NAMEWITHCOMMA: /^[^\\", <>\u0000-\u001F][^\\"<>\u0000-\u001F]*$/,
    NAMENODOT: /^[^\\",<\. \u0000-\u001F][^\\",<\.\u0000-\u001F]*$/,
    USERNAME: /^[^,:\"\\<\s\u0000-\u001F]*$/,
    RW_COMMUNITY: /^[^"<> \u0000-\u001F][^"<>\u0000-\u001F]*[^"<> \u0000-\u001F]$/,
    WWN: /^(?:(?:(?:[a-fA-F0-9]{2}):?){8})$/,
    FDEPASSWORD: /^[^\\",<>\u0000-\u001F]+$/,
    REPNAME: /^[^\\",  <\u0000-\u001F]*[^\s,\\"<]$/,
    LOGNAME: /^[^\\"'`&\u0000-\u001F]+$/,
    DOMAINNAME: /^[^\"\\<>():;\u0000-\u001F]*$/
};
$.validator.addMethod("passwordComplexityCheck", function(F, E, H) {
    $.validator.messages.passwordComplexityCheck = strings.val.passSecurity;
    if (this.optional(E)) {
        return true
    }
    var D = (F != F.toLowerCase());
    var C = (F != F.toUpperCase());
    var I = /[0-9]/.test(F);
    var G = /[^0-9a-zA-Z]/.test(F);
    if (hasUTF(F) || (D && C && I && G)) {
        return true
    }
    return false
}, strings.val.passSecurity);
$.validator.addMethod("noBannedUsers", function(E, D) {
    var C = ["api", "mui", "root", "restoredefaults", "restoreusers", "sshd", "mc", "daemon", "admin", "setup"];
    $.validator.messages.noBannedUsers = strings.val.noBannedUsers;
    return (this.optional(D) || C.find(E) == -1)
}, strings.val.noBannedUsers);
$.validator.addMethod("utf8length", function(E, D, F) {
    $.validator.messages.utf8length = strings.val.utf8length;
    if (this.optional(D)) {
        return true
    }
    var C = parseInt(F, 10);
    if (utf8bytes(E) <= C) {
        return true
    } else {
        return false
    }
}, $.validator.messages.utf8length);
$.validator.addMethod("characterLength", function(E, D, F) {
    $.validator.messages.characterLength = strings.val.characterLength;
    if (this.optional(D)) {
        return true
    }
    var C = parseInt(F, 10);
    if (E.length <= C) {
        return true
    } else {
        return false
    }
}, $.validator.messages.characterLength);
$.validator.addMethod("emailLocalPart", function(D, C) {
    return this.optional(C) || D.match(/^[^\\",\s :;,<>()@\[\]]+$/) && !D.match(/\.{2,}|-{2,}/) && !D.match(/^\.|\.$/)
}, strings.val.emailLocalFormat);
$.validator.addMethod("emailSenderDomain", function(D, C) {
    return this.optional(C) || D.match(/^[^\\",\s :;,<>()]+$/)
}, strings.val.emailSenderDomain);
$.validator.addMethod("newEmail", function(D, C) {
    return this.optional(C) || D.match(/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/)
}, strings.val.emailFormat);
$.validator.addMethod("dhName", function(D, C) {
    $.validator.messages.dhName = strings.val.dhName;
    return this.optional(C) || VALREGEX.NAME.test(D)
}, strings.val.dhName);
$.validator.addMethod("rwCommunity", function(D, C) {
    $.validator.messages.rwCommunity = strings.val.rwCommunity;
    return this.optional(C) || VALREGEX.RW_COMMUNITY.test(D)
}, strings.val.rwCommunity);
$.validator.addMethod("dhPassword", function(D, C) {
    $.validator.messages.dhPassword = strings.val.passSecurity;
    return this.optional(C) || VALREGEX.PASSWORD.test(D)
}, strings.val.passSecurity);
$.validator.addMethod("dhUserName", function(D, C) {
    $.validator.messages.dhUserName = strings.val.dhUserName;
    return this.optional(C) || VALREGEX.USERNAME.test(D)
}, strings.val.dhUserName);
$.validator.addMethod("dhNameWithComma", function(D, C) {
    $.validator.messages.dhNameWithComma = strings.val.dhNameWithComma;
    return this.optional(C) || VALREGEX.NAMEWITHCOMMA.test(D)
}, strings.val.dhNameWithComma);
$.validator.addMethod("dhFdePassword", function(D, C) {
    $.validator.messages.dhFdePassword = strings.val.dhFdePassword;
    return this.optional(C) || VALREGEX.FDEPASSWORD.test(D)
}, strings.val.dhFdePassword);
$.validator.addMethod("dhRepName", function(D, C) {
    $.validator.messages.dhRepName = strings.val.dhRepName;
    return this.optional(C) || VALREGEX.REPNAME.test(D)
}, strings.val.dhRepName);
$.validator.addMethod("dhLogName", function(D, C) {
    $.validator.messages.dhRepName = strings.val.dhRepName;
    return this.optional(C) || VALREGEX.LOGNAME.test(D)
}, strings.val.dhLogName);
$.validator.addMethod("vdiskExists", function(D, C) {
    $.validator.messages.vdiskExists = strings.val.vdiskExists;
    var E = MC.vdisksSet.dataSelect({
        type: "prop",
        name: "name",
        value: D
    });
    return (E.objects.length) ? false : true
}, strings.val.vdiskExists);
$.validator.addMethod("diskGroupExists", function(D, C) {
    $.validator.messages.diskGroupExists = strings.val.diskGroupExists;
    if (DC.diskGroups[D]) {
        return false
    } else {
        return true
    }
}, strings.val.diskGroupExists);
$.validator.addMethod("dhHostName", function(D, C) {
    $.validator.messages.dhHostName = strings.val.dhHostName;
    return this.optional(C) || VALREGEX.NAMENODOT.test(D)
}, strings.val.dhHostName);
$.validator.addMethod("hostExists", function(D, C) {
    $.validator.messages.hostExists = strings.val.hostExists;
    return !DC.hosts[D]
}, strings.val.hostExists);
$.validator.addMethod("peerExists", function(D, C) {
    $.validator.messages.peerExists = strings.val.peerExists;
    return !DC.peerConnections[D]
}, strings.val.peerExists);
$.validator.addMethod("replicationSetExists", function(D, C) {
    $.validator.messages.replicationSetExists = strings.val.replicationSetExists;
    return !DC.virtualReplicationSets[D]
}, strings.val.replicationSetExists);
$.validator.addMethod("hostGroupExists", function(D, C) {
    $.validator.messages.hostGroupExists = strings.val.hostGroupExists;
    return !DC.hostGroups[D]
}, strings.val.hostGroupExists);
$.validator.addMethod("volumeExists", function(D, C) {
    $.validator.messages.volumeExists = strings.val.volumeExists;
    return !DC.volumes[D]
}, strings.val.volumeExists);
$.validator.addMethod("volumeGroupExists", function(D, C) {
    $.validator.messages.volumeGroupExists = strings.val.groupExists;
    return !DC.volumeGroups[D]
}, strings.val.groupExists);
$.validator.addMethod("chapExists", function(E, D) {
    $.validator.messages.chapExists = strings.val.chapDoesntExist;
    var C = DC.base["chap-records"][E];
    return ((C) ? true : false)
}, strings.val.chapDoesntExist);
$.validator.addMethod("chapSecret", function(D, C) {
    $.validator.messages.chapSecret = strings.val.chapSecret;
    if (this.optional(C)) {
        return true
    }
    if ((utf8bytes(D) <= 16) && (utf8bytes(D) >= 12)) {
        return true
    } else {
        return false
    }
}, strings.val.chapSecret);
$.validator.addMethod("chapName", function(D, C) {
    $.validator.messages.chapName = strings.val.chapName;
    return this.optional(C) || (/^([a-z0-9 -:.]+)$/.test(D))
}, strings.val.chapName);
$.validator.addMethod("ipv4Address", function(E, D) {
    $.validator.messages.ipv4Address = strings.val.ipv4Address;
    if (this.optional(D)) {
        return true
    }
    var C = E.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
    return C != null && C[1] <= 255 && C[2] <= 255 && C[3] <= 255 && C[4] <= 255
}, strings.val.ipv4Address);
$.validator.addMethod("validRange", function(G, F) {
    $.validator.messages.validRange = strings.val.validRange;
    var D = null;
    var C = G.split(",");
    for (var E = 0; E < C.length; E++) {
        D = C[E].match(/^((\d+)\.(\d+))$/) || C[E].match(/^((\d+)\.(\d+)(\,*))*$/) || C[E].match(/^((\d+)\.(\d+)\-(\d+)(\,*))*$/) || (C[E].length == 0);
        if (D == false) {
            break
        } else {
            D = true
        }
    }
    return D
}, strings.val.validRange);

function isIpv4(C) {
    var D = value.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
    return (D != null && D[1] <= 255 && D[2] <= 255 && D[3] <= 255 && D[4] <= 255)
}
$.validator.addMethod("binaryBaseSizeString", function(D, C) {
    $.validator.messages.binaryBaseSizeString = strings.val.binaryBaseSizeString;
    if (this.optional(C)) {
        return true
    }
    return D.match(/^(\d+)((\.|\,|。)(\d+))?(MiB|mib|GiB|gib|TiB|tib)$/)
}, strings.val.binaryBaseSizeString);
$.validator.addMethod("decimalBaseSizeString", function(D, C) {
    $.validator.messages.decimalBaseSizeString = strings.val.decimalBaseSizeString;
    if (this.optional(C)) {
        return true
    }
    return D.match(/^(\d+)((\.|\,|。)(\d+))?(MB|mb|GB|gb|TB|tb)$/)
}, strings.val.decimalBaseSizeString);
$.validator.addMethod("sizeRange", function(J, G, E) {
    $.validator.messages.sizeRange = strings.val.sizeRange;
    var I = new Size(J);
    var D = new Size(E[0]);
    var H = new Size(E[1]);
    var F = I.getBlocks();
    var C = D.getBlocks();
    var K = H.getBlocks();
    return this.optional(G) || (F >= C && F <= K)
}, strings.val.sizeRange);
$.validator.addMethod("ipv6AddressLong", function(E, D) {
    $.validator.messages.ipv6AddressLong = strings.val.ipv6Address;
    if (this.optional(D)) {
        return true
    }
    var C = E.match(/^[a-fA-F0-9]{1,4}:([a-fA-F0-9]{0,4}:){2,6}[a-fA-F0-9]{1,4}$/);
    return C != null
}, strings.val.ipv6Address);
$.validator.addMethod("ipv6Address", function(E, D) {
    $.validator.messages.ipv6Address = strings.val.ipv6Address;
    if (this.optional(D)) {
        return true
    }
    var C = E.match(/^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/);
    return C != null
}, strings.val.ipv6Address);
$.validator.addMethod("destPeerAddress", function(D, C) {
    $.validator.messages.destPeerAddress = strings.val.destAddr;
    return (($.validator.methods.wwn.call(this, D, C)) || ($.validator.methods.ipv4Address.call(this, D, C)))
}, strings.val.destAddr);
$.validator.addMethod("wwn", function(D, C) {
    return (this.optional(C) || VALREGEX.WWN.test(D))
}, strings.val.wwnError);

function isWWN(C) {
    if (VALREGEX.WWN.test(C)) {
        return true
    }
    return false
}
$.validator.addMethod("initNicknameExists", function(D, C) {
    if (this.optional(C)) {
        return true
    }
    return (DC.findInitiatorByNickname(D) == null)
}, strings.val.nicknameAlreadyExists);
$.validator.addMethod("wwn_iqn", function(D, C) {
    $.validator.messages.wwn_iqn = strings.val.wwniqnError;
    var F = /^(?:(?:(?:[a-f0-9]{2}):?){8})$/i;
    var E = /^(?:iqn\.(?:\d{4}-\d{2})(?:[\.:-]\w+)+)$|^(?:eui\.(?:[a-f0-9]){16})$/i;
    if (this.optional(C)) {
        return true
    }
    if (VALREGEX.WWN.test(D)) {
        return true
    } else {
        return (D.match(E) != null)
    }
}, strings.val.wwniqnError);
$.validator.addMethod("initNicknameExists", function(D, C) {
    $.validator.messages.initNicknameExists = strings.val.nicknameAlreadyExists;
    if (this.optional(C)) {
        return true
    }
    return (DC.findInitiatorByNickname(D) == null)
}, strings.val.nicknameAlreadyExists);
$.validator.addMethod("userExists", function(D, C) {
    $.validator.messages.userEixsts = strings.val.userExists;
    return (this.optional(C) || !DC.findUserByName(D))
}, strings.val.userExists);
$.validator.addMethod("dhsdate", function(D, C) {
    $.validator.messages.dhsdate = strings.val.dhsdate;
    return this.optional(C) || (/^\d{4}(\-|\/|\.)(0[1-9]|1[012])\1(0[1-9]|[12][0-9]|3[01])$/.test(D))
}, strings.val.dhsdate);
$.validator.addMethod("fcIdValue", function(D, C) {
    $.validator.messages.fcIdValue = strings.portconfig.fcIDrangeErr;
    if (this.optional(C)) {
        return true
    }
    if (D == 255) {
        return true
    } else {
        if ((D >= 0) && (D <= 125)) {
            return true
        } else {
            return false
        }
    }
}, strings.portconfig.fcIDrangeErr);
$.validator.addMethod("remoteSystemExists", function(D, C) {
    $.validator.messages.remoteSystemExists = strings.val.remoteSystemExists;
    var E = DC.findRemoteSystem(D);
    return (E != undefined) ? false : true
}, strings.val.remoteSystemExists);
$.validator.addMethod("isNumber", function(D, C) {
    $.validator.messages.isNumber = strings.val.NanError;
    return (!(isNaN(D)))
}, strings.val.NanError);
$.validator.addMethod("isInteger", function(D, C) {
    $.validator.messages.isInteger = strings.val.integer;
    return this.optional(C) || (/^-?\d+$/.test(D))
}, strings.val.integer);
$.validator.addMethod("isValidPhoneNumber", function(D, C) {
    $.validator.messages.isValidPhoneNumber = strings.val.integer;
    return (/^\d+$/.test(D))
}, strings.val.integer);
$.validator.addMethod("withinNumericRange", function(D, C, F) {
    var E = F.split(":");
    return (D >= E[0] && D <= E[1])
}, function(D) {
    if (D) {
        var C = D.split(":");
        return strings.specifyRange(C[0], C[1])
    }
});
$.validator.addMethod("dnsAddress", function(E, D) {
    $.validator.messages.dnsAddress = strings.val.dnsAddress;
    var C = E.match(/^(\d+)\.(\d+)\.(\d+)\.(\d+)$/);
    C = C != null && C[1] <= 255 && C[2] <= 255 && C[3] <= 255 && C[4] <= 255;
    if (!C) {
        E = E.replace("http://", "");
        E = E.replace("www.", "");
        return (/^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z-]{2,6}$/.test(E))
    } else {
        return C
    }
}, strings.val.dnsAddress);
$.validator.addMethod("domainname", function(D, C) {
    $.validator.messages.dnsAddress = strings.val.domainnmae;
    D = D.replace("http://", "");
    D = D.replace("www.", "");
    return (/^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z-]{2,6}$/.test(D))
}, strings.val.dnsAddress);
$.validator.addMethod("number", function(D, C) {
    $.validator.messages.dnsAddress = strings.val.number;
    return (/(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/.test(D))
}, strings.val.number);
$.validator.addMethod("notEqualTo", function(E, D, F) {
    $.validator.messages.notEqual = strings.val.notEqual;
    var C = true;
    E = $.trim(E);
    for (i = 0; i < F.length; i++) {
        if (E == $.trim($(F[i]).find(F[i]).val())) {
            C = false
        }
    }
    return this.optional(D) || C
}, strings.val.notEqual);

function LabelWidget(C) {
    if (arguments.length == 0) {
        return
    }
    var D;
    this.labelValue = "";
    if ((C instanceof Widget) && C.options.label != undefined) {
        D = C.options.labelOptions || {};
        if (C.labelElement) {
            C.labelElement.remove()
        }
        D.value = C.options.label;
        delete C.options.label;
        if (C instanceof InputWidget) {
            this.inputWidget = C
        }
        if (D.row == undefined && C.options.row != undefined) {
            D.row = C.options.row
        }
        if (D.col == undefined && C.options.col != undefined) {
            D.col = C.options.col - 1
        }
        if (!D.topMargin && !D.topMediumMargin && !D.topSmallMargin && !D.noMargin) {
            if (C.options.topMargin) {
                D.topMargin = true
            }
            if (C.options.topMediumMargin) {
                D.topMediumMargin = true
            }
            if (C.options.topSmallMargin) {
                D.topSmallMargin = true
            }
        }
        if (!D.bottomMargin && !D.bottomMediumMargin && !D.bottomSmallMargin && !D.noMargin) {
            if (C.options.bottomMargin) {
                D.bottomMargin = true
            }
            if (C.options.bottomMediumMargin) {
                D.bottomMediumMargin = true
            }
            if (C.options.bottomSmallMargin) {
                D.bottomSmallMargin = true
            }
        }
        if (C.rules && C.rules.required) {
            D.required = true
        }
    } else {
        if ((typeof C) == "object") {
            D = C;
            if (D.widget && D.widget instanceof InputWidget) {
                this.inputWidget = D.widget
            }
        } else {
            MC.errorOutput("LabelWidget constructor called with bad parameters.", "%s");
            return
        }
    }
    if (D.cellClasses == undefined) {
        D.cellClasses = "inputLabelCell"
    }
    if (this.inputWidget) {
        D.htmlText = '<label for="' + this.inputWidget.name + '"' + (D.display ? 'style="display:' + D.display + '"' : "") + "></label>"
    } else {
        D.htmlText = "<label></label>"
    }
    Widget.call(this, D);
    this.class_name = "LabelWidget";
    this.disabled = false;
    this.labelElement = $(this.elements);
    if (this.inputWidget) {
        this.inputWidget.labelElement = this.labelElement
    } else {
        if (C instanceof Widget) {
            C.labelElement = this.labelElement
        }
    }
    this.handleUpdate(D)
}
LabelWidget.prototype = new Widget();
LabelWidget.prototype.constructor = LabelWidget;
LabelWidget.terminateLabel = function(C) {
    if ((typeof C) == "string") {
        return C + strings.labelTerminator
    } else {
        return C
    }
};
LabelWidget.prototype.handleUpdate = function(D) {
    if (D.value) {
        this.labelValue = D.value
    }
    if (this.options.noTerminator) {
        var C = this.labelValue
    } else {
        var C = LabelWidget.terminateLabel(this.labelValue)
    }
    if (D.required) {
        C += '<span class="requiredIndicator">' + strings.requiredIndicator + "</span>"
    }
    this.labelElement.html(C)
};

function InputWidget(C) {
    if (arguments.length == 0) {
        return
    }
    WidgetContainer.call(this, C);
    this.class_name = "InputWidget";
    this.rules = C.rules;
    this.messages = C.messages
}
InputWidget.prototype = new WidgetContainer();
InputWidget.prototype.constructor = InputWidget;
InputWidget.prototype.update = function(H) {
    var G;
    var J;
    var E;
    if (this.form && this.form.name && H[this.form.name] instanceof Object) {
        G = H[this.form.name].disable
    }
    var D = false;
    if (this.name && H[this.name] instanceof Object) {
        var F = true;
        J = H[this.name].disable;
        E = H[this.name].visibility;
        if (H[this.name].focus) {
            D = true;
            delete H[this.name].focus
        }
    }
    var C = (J != undefined) ? J : G;
    var I = E;
    if ((typeof C) == "boolean") {
        this.disable(C)
    }
    if (D) {
        this.focus()
    }
    WidgetContainer.prototype.update.call(this, H);
    if (F && H[this.name].rules) {
        if (H[this.name].skipValidation) {
            this.setRules(H[this.name].rules, true, H[this.name].requiredField)
        } else {
            this.setRules(H[this.name].rules, false, H[this.name].requiredField)
        }
    }
    if (F && H[this.name].messages) {
        this.setMessages(H[this.name].messages)
    }
    this._resetTracking(H)
};
InputWidget.prototype.retrieve = function(D, C) {
    if (this.name) {
        if (!(D[this.name] instanceof Object)) {
            D[this.name] = {}
        }
        D[this.name].disable = this.disabled;
        D[this.name].valueChanged = this.valueChanged;
        D[this.name].invalid = this.invalid
    }
    WidgetContainer.prototype.retrieve.call(this, D, C)
};
InputWidget.prototype.focus = function() {
    if (this.inputElements && !this.disabled) {
        var C = $(this.inputElements).not(":disabled").filter(":visible").eq(0);
        setTimeout(function() {
            try {
                C.focus()
            } catch (D) {
                MC.debugOutput("Unable to set focus on this element: " + D.message)
            }
        }, 0)
    }
};
InputWidget.prototype.disable = function(C) {
    if (this.inputElements) {
        if (C) {
            this.disabled = true;
            this.inputElements.attr("disabled", "disabled")
        } else {
            this.disabled = false;
            this.inputElements.removeAttr("disabled")
        }
    }
};
InputWidget.prototype.fireChange = function(D) {
    this.flagChange();
    if (this.form) {
        this.form.onInputWidgetChanged()
    }
    if ($.isFunction(this.options.changeCallback)) {
        var C = {};
        if (this.name) {
            this.retrieve(C)
        }
        this.options.changeCallback.call(this, C, this, D)
    }
};
InputWidget.prototype.flagChange = function() {
    if (this.originalValue != undefined && this.name) {
        var C = {};
        this.retrieve(C);
        if (this.valueEqual(C[this.name].value, this.originalValue)) {
            this.valueChanged = false;
            if (this.labelElement) {
                this.labelElement.removeClass("valueChanged")
            }
        } else {
            this.valueChanged = true;
            if (this.labelElement) {
                this.labelElement.addClass("valueChanged")
            }
        }
    }
};
InputWidget.prototype.valueEqual = function(E, D) {
    if (E == D) {
        return true
    }
    if ((E instanceof Array) && (D instanceof Array)) {
        if (E.length != D.length) {
            return false
        }
        for (var C = 0; C < E.length; C++) {
            if (E[C] != D[C]) {
                return false
            }
        }
        return true
    }
    return false
};
InputWidget.prototype.setRules = function(H, F, E) {
    if (this.form) {
        this.form.setRules(this.name, H);
        this.form.updateRules();
        if (typeof F == "undefined" || !F) {
            this.form._handleUserEvent(this.inputElements[0], !this.inputElements.valid(), null)
        }
    }
    if (this.labelElement) {
        var D = this.labelElement.html();
        var C = (D.indexOf(strings.requiredIndicator) != "-1" ? true : false);
        var G = D.indexOf(strings.requiredIndicator);
        if (H.required && !C) {
            this.labelElement.html(D + '<span class="requiredIndicator">' + strings.requiredIndicator + "</span>")
        } else {
            if (!H.required && C) {
                if (E != undefined) {
                    if (!E) {
                        $(".requiredIndicator", this.labelElement).remove()
                    }
                } else {
                    $(".requiredIndicator", this.labelElement).remove()
                }
            }
        }
    }
};
InputWidget.prototype.setMessages = function(C) {
    if (this.form) {
        this.form.setMessages(this.name, C);
        this.form.updateMessages()
    }
};
InputWidget.prototype.highlightErr = function() {
    if (this.labelElement) {
        this.labelElement.addClass("labelErrHL")
    }
};
InputWidget.prototype.unhighlightErr = function(C) {
    if (this.labelElement) {
        this.labelElement.removeClass("labelErrHL")
    }
};
InputWidget.prototype.isSelected = function() {
    return false
};
InputWidget.prototype._resetTracking = function(C) {
    if (this.name && C[this.name] instanceof Object) {
        this.invalid = false;
        if (!this.disabled && this.form && this.inputElements) {
            if (!C[this.name].skipValidation) {
                this.invalid = !this.inputElements.valid()
            }
        }
    }
};

function TextInputWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.size = C.size || 20;
    C.maxLength = C.maxLength || false;
    C.htmlText = C.htmlText || '<div class="textInputDiv">' + (C.label ? '<label for="' + C.name + '" class="ARRightMargin">' + C.label + "</label>" : "") + '<input id="' + C.name + '" name="' + C.name + '" type="' + (C.password ? "password" : "text") + '" size="' + C.size + '" ' + (C.display ? 'style="display:' + C.display : "") + 'tabindex="' + C.tabindex + '" ' + (C.maxLength ? 'maxLength="' + C.maxLength + '" ' : "") + ' class="textInputWidget"></input></div>';
    InputWidget.call(this, C);
    this.class_name = "TextInputWidget";
    this.inputElements = $("input", this.elements);
    this.inputElements.bind("keydown", createObjectCallback(this, this.keyDown));
    if (C.label) {
        this.labelElement = $("label", this.elements);
        this.labelElement.html(C.label + (this.options.noTerminator ? "" : strings.labelTerminator));
        if (C.requiredField && this.labelElement.find(".requiredIndicator").length == 0) {
            this.labelElement.html(this.options.label + ('<span class="requiredIndicator">' + strings.requiredIndicator + "</span>") + (this.options.noTerminator ? "" : strings.labelTerminator))
        }
    }
    if (C.value) {
        this.handleUpdate(C)
    }
}
TextInputWidget.prototype = new InputWidget();
TextInputWidget.prototype.handleUpdate = function(C) {
    if (C && (C.value != undefined || C.display != undefined)) {
        if (C.unsetOrig) {
            delete this.originalValue;
            delete C.unsetOrig;
            this.inputElements.unbind("keyup")
        }
        if (C.setOrig) {
            this.originalValue = C.value;
            delete C.setOrig;
            this.inputElements.bind("keyup", createObjectCallback(this, this.flagChange));
            if (C.clearOnNextFocus && !this.clearOnNextFocusHandler) {
                this.clearOnNextFocusHandler = createObjectCallback(this, this._clearOnNextFocusHandler);
                this.inputElements.bind("focus", this.clearOnNextFocusHandler);
                delete C.clearOnNextFocus
            }
        }
        if (C.display) {
            this.inputElements.attr("style", "display:" + C.display);
            if (this.labelElement) {
                this.labelElement[0].style = "display:" + C.display
            }
        }
        if (C.value != undefined && C.value.length > parseInt(this.inputElements.attr("size")) && this.options.size == undefined) {
            this.inputElements.attr("size", C.value.length)
        }
        this.inputElements.val(C.value);
        this.flagChange()
    }
    if (C.requiredField && this.inputElements[0].labels != undefined && this.inputElements[0].labels[0] != undefined && this.labelElement.find(".requiredIndicator").length == 0) {
        this.labelElement.html(this.inputElements[0].labels[0].textContent + ('<span class="requiredIndicator">' + strings.requiredIndicator + "</span>"))
    }
};
TextInputWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].value = this.inputElements.val()
    }
};
TextInputWidget.prototype._clearOnNextFocusHandler = function(D) {
    if (this.clearOnNextFocusHandler) {
        var C = {
            value: "",
            setOrig: true
        };
        this.inputElements.unbind("focus", this.clearOnNextFocusHandler);
        delete this.clearOnNextFocusHandler;
        this.handleUpdate(C)
    }
};
TextInputWidget.prototype.keyDown = function(C) {
    if (C.keyCode == 13) {
        if ($.isFunction(this.options.enterCallback)) {
            this.options.enterCallback.call(this, this, C)
        }
    }
};

function FileInputWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.size = D.size || 20;
    var C = "";
    if (D.accept) {
        C = ' accept="' + D.accept + '" '
    }
    D.htmlText = D.htmlText || '<div class="textInputDiv">' + (D.label ? '<label for="' + D.name + '" class="ARRightMargin">' + D.label + "</label>" : "") + '<input id="' + D.name + '" name="' + D.name + '" type="file" ' + C + 'size="' + D.size + '" class="textInputWidget"></input></div>';
    TextInputWidget.call(this, D);
    this.class_name = "FileInputWidget";
    this.inputElements.change(createObjectCallback(this, this.fireChange))
}
FileInputWidget.prototype = new TextInputWidget();

function OptionInputWidget(F) {
    if (arguments.length == 0) {
        return
    }
    var C = "";
    if (F.multiple) {
        C = " MULTIPLE "
    }
    var D = "";
    if (F.size) {
        D = ' SIZE="' + F.size + '" '
    }
    var E = "";
    if (F.width) {
        E = ' style="width:' + F.width + 'px;" ';
        F.width = null
    }
    F.htmlText = '<div class="optionInputDiv">' + (F.label ? ('<label for="' + F.name + '" class="ARRightMargin"></label>') : "") + '<select id="' + F.name + '" name="' + F.name + '"' + C + D + E + ">";
    F.htmlText += "</select></div>";
    InputWidget.call(this, F);
    this.class_name = "OptionInputWidget";
    this.inputElements = $("select", this.elements);
    if (F.label) {
        this.labelElement = $("label", this.elements);
        if (F.multiple) {
            this.labelElement.addClass("verticalTop")
        }
    }
    this.handleUpdate(F)
}
OptionInputWidget.prototype = new InputWidget();
OptionInputWidget.prototype.handleUpdate = function(E) {
    if (E == undefined) {
        return
    }
    if (E.label && this.labelElement) {
        this.labelElement.html(E.label + (this.options.noTerminator ? "" : strings.labelTerminator))
    }
    var C = false;
    if (E.values) {
        this.values = E.values;
        C = true
    }
    if (E.unsetOrig) {
        delete this.originalValue;
        delete E.unsetOrig
    }
    if (E.setOrig && E.value != undefined) {
        this.originalValue = E.value;
        delete E.setOrig;
        C = true
    }
    if (C) {
        var F = "";
        var I = [];
        if (this.originalValue) {
            var K = this.originalValue;
            if (!(K instanceof Array)) {
                K = [K]
            }
            var D;
            for (var G = 0; G < this.values.length; G++) {
                D = "";
                for (var H = 0; H < K.length; H++) {
                    if (this.values[G].value == K[H]) {
                        D = strings.inputs.optionOrigFlag
                    }
                }
                I[G] = this.values[G].text + D
            }
        } else {
            for (var H = 0; H < this.values.length; H++) {
                I[H] = this.values[H].text
            }
        }
        var J;
        for (var H = 0; H < this.values.length; H++) {
            if (this.values[H].tip) {
                J = ' title="' + this.values[H].tip + '"'
            } else {
                J = ""
            }
            F += ('<option value="' + this.values[H].value + '"' + J + ">" + I[H] + "</option>")
        }
        this.inputElements.html(F)
    }
    if (E.value != undefined) {
        this.inputElements.val(E.value);
        this.flagChange()
    }
};
OptionInputWidget.prototype.__setValue = function() {
    this.inputElements.val(this.value);
    this.flagChange()
};
OptionInputWidget.prototype.handleRetrieve = function(I) {
    if (this.name && I) {
        if (!(I[this.name] instanceof Object)) {
            I[this.name] = {}
        }
        var H = I[this.name].value = this.inputElements.val();
        var E = "";
        var D = ((typeof H) == "object");
        if (D) {
            var E = []
        } else {
            var E = ""
        }
        if (this.values) {
            for (var G = 0, C = this.values.length; G < C; G++) {
                if (D) {
                    if (H) {
                        for (var F = 0; F < H.length; F++) {
                            if (this.values[G].value == H[F]) {
                                E.push(this.values[G].text)
                            }
                        }
                    }
                } else {
                    if (this.values[G].value == H) {
                        E = this.values[G].text
                    }
                }
            }
        }
        I[this.name].textValue = E
    }
};

function ComboBoxWidget(F) {
    if (arguments.length == 0 || !F.name) {
        return
    }
    var E = F.width || 100;
    F.width = null;
    F.maxLength = F.maxLength || 32;
    var D = ' style="width:' + E + 'px;" ';
    var C = createObjectCallback(this, this._itemSelected);
    this.delayedBlur = createObjectCallback(this, this._delayedBlur);
    this.scrollEnd = createObjectCallback(this, this._scrollEnd);
    F.htmlText = '<div class="comboWrapper">' + (F.label ? ('<label for="' + F.name + '" class="ARRightMargin"></label>') : "") + '<input name="' + F.name + '" type="text" maxLength="' + F.maxLength + '" style="width:' + E + 'px;" class="' + (F.allowInput ? "textInputWidget" : "comboText") + '"></input><div class="button comboButton"></div></div>';
    InputWidget.call(this, F);
    this.class_name = "ComboBoxWidget";
    this.listContainer$ = $('<div class="comboList" style="min-width:' + (E + 20) + 'px"></div>');
    this.list$ = $("<ul></ul>").appendTo(this.listContainer$);
    this.inputElements = $("input", this.elements);
    this.button$ = $(".comboButton", this.elements);
    this.button$.click(createObjectCallback(this, this._toggleList));
    this.list$.on("click", "li", C);
    this.inputElements.on("focus", createObjectCallback(this, this._onfocus));
    this.inputElements.on("blur", createObjectCallback(this, this._onblur));
    this.listContainer$.on("scroll", createObjectCallback(this, this._listScrolled));
    if (!F.allowInput) {
        this.inputElements.on("keydown", createObjectCallback(this, this._keydown));
        this.inputElements.attr("readonly", "readonly")
    }
    if (F.label) {
        this.labelElement = $("label", this.elements)
    }
    F.values = F.values || [];
    this.handleUpdate(F)
}
ComboBoxWidget.prototype = new InputWidget();
ComboBoxWidget.prototype.constructor = ComboBoxWidget;
ComboBoxWidget.prototype.showing = function() {
    if (this.isOpen == undefined) {
        this.listParent$ = this.elements$.closest(".scrollingDiv");
        if (this.listParent$) {
            this.listParent$.append(this.listContainer$)
        }
    }
    this._closeOptionList()
};
ComboBoxWidget.prototype.handleUpdate = function(J) {
    if (J == undefined) {
        return
    }
    if (J.unsetOrig) {
        delete this.originalValue;
        delete J.unsetOrig
    }
    if (J.setOrig) {
        if (J.value != undefined) {
            this.originalValue = J.value
        }
        delete J.setOrig
    }
    if (J.label && this.labelElement) {
        this.labelElement.html(J.label + (this.options.noTerminator ? "" : strings.labelTerminator))
    }
    if (J.values) {
        this.values = J.values;
        this.list$.empty();
        var I = [];
        if (this.originalValue) {
            var C = this.originalValue;
            if (!(C instanceof Array)) {
                C = [C]
            }
            var E;
            for (var F = 0; F < this.values.length; F++) {
                E = "";
                for (var H = 0; H < C.length; H++) {
                    if (this.values[F].value == C[H]) {
                        E = strings.inputs.optionOrigFlag
                    }
                }
                I[F] = this.values[F].text + E
            }
        } else {
            for (var H = 0; H < this.values.length; H++) {
                I[H] = this.values[H].text
            }
        }
        var D;
        for (var H = 0; H < this.values.length; H++) {
            if (this.values[H].tip) {
                D = ' title="' + this.values[H].tip + '"'
            } else {
                D = ""
            }
            var G = ("<li" + D + ">" + I[H] + "</li>");
            $(G).appendTo(this.list$).data("value", this.values[H].value)
        }
    }
    if (J.value) {
        this.inputElements.val(this._valueToText(J.value));
        this.flagChange()
    }
};
ComboBoxWidget.prototype.disable = function(C) {
    if (C) {
        this.button$.addClass("disabled")
    } else {
        this.button$.removeClass("disabled")
    }
    InputWidget.prototype.disable.call(this, C)
};
ComboBoxWidget.prototype._valueToText = function(D) {
    var E = D;
    for (var C = 0; C < this.values.length; C++) {
        if (this.values[C].value == D) {
            E = this.values[C].text;
            break
        }
    }
    return E
};
ComboBoxWidget.prototype._textToValue = function(E) {
    var D = E;
    for (var C = 0; C < this.values.length; C++) {
        if (this.values[C].text == E) {
            D = this.values[C].value;
            break
        }
    }
    return D
};
ComboBoxWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].value = this._textToValue(this.inputElements.val())
    }
};
ComboBoxWidget.prototype._toggleList = function() {
    MC.debugOutput("ComboBox: _toggleList, wasOpen: " + this.isOpen);
    if (this.blurTimeout) {
        clearTimeout(this.blurTimeout);
        delete this.blurTimeout
    }
    if (this.isOpen) {
        this._closeOptionList()
    } else {
        if (!this.disabled) {
            var F = this.listParent$.offset();
            var J = this.listParent$.height();
            var E = this.inputElements.offset();
            var I = {
                top: (E.top - F.top),
                left: (E.left - F.left)
            };
            var C = this.inputElements.outerHeight();
            this.listContainer$.height("auto");
            this.listContainer$.show();
            var K = this.listContainer$.outerHeight() + 2;
            var H = J - (I.top + C + 2);
            var G = I.top - 2;
            var D = false;
            if (K > 200) {
                D = 200;
                K = 200
            }
            if (K < H) {
                E.top += C + 2
            } else {
                if (K < G) {
                    E.top = F.top + (I.top - K);
                    if (D) {
                        E.top -= 3
                    }
                } else {
                    if (H >= G) {
                        D = H - 5;
                        E.top += C + 2
                    } else {
                        D = G - 5;
                        E.top = F.top + (I.top - D) - 3
                    }
                }
            }
            if (D) {
                this.listContainer$.height(D);
                this.listContainer$.css("overflow", "auto")
            }
            this.listContainer$.offset(E);
            this.isOpen = true;
            this.inputElements.focus()
        }
    }
};
ComboBoxWidget.prototype._itemSelected = function(D) {
    MC.debugOutput("ComboBox: itemSelected");
    this.itemSelected = true;
    if (this.blurTimeout) {
        clearTimeout(this.blurTimeout);
        delete this.blurTimeout
    }
    var C = $(D.currentTarget).data("value");
    this._setComboBoxValue(C)
};
ComboBoxWidget.prototype._setComboBoxValue = function(C) {
    if (typeof C == "undefined") {
        return
    }
    this.inputElements.val(this._valueToText(C));
    this._closeOptionList();
    this.inputElements.focus();
    if (this.form) {
        this.form._handleUserEvent(this.inputElements[0], !this.inputElements.valid(), null)
    }
};
ComboBoxWidget.prototype._closeOptionList = function() {
    this.listContainer$.hide();
    this.list$.find("li").removeClass("focus");
    this.isOpen = false
};
ComboBoxWidget.prototype._onfocus = function(C) {
    MC.debugOutput("ComboBox: onFocus");
    this.button$.addClass("focus");
    if (this.itemSelected) {
        $(C.currentTarget).trigger("blur");
        this.itemSelected = false
    }
};
ComboBoxWidget.prototype._listScrolled = function(C) {
    MC.debugOutput("Scroll event = %o", C);
    this.inputElements.focus();
    this.scrolled = true;
    if (this.scrollTimeout) {
        clearTimeout(this.scrollTimeout)
    }
    this.scrollTimeout = setTimeout(this.scrollEnd, 200)
};
ComboBoxWidget.prototype._scrollEnd = function() {
    MC.debugOutput("Clearing scrolled flag");
    this.scrolled = false
};
ComboBoxWidget.prototype._keydown = function(H) {
    if (this.isOpen && (H.keyCode == 9 || H.keyCode == 13)) {
        var C = this.list$.find("li.focus");
        this._setComboBoxValue(C.data("value"));
        return
    }
    if (H.keyCode == 9 || H.keyCode == 16 || H.keyCode == 17 || H.keyCode == 18) {
        return
    }
    if (H.keyCode == 27) {
        if (this.isOpen) {
            this._toggleList()
        }
        return
    }
    if (!this.isOpen) {
        this._toggleList()
    }
    var F = this.inputElements.val();
    if (this.isOpen) {
        var C = this.list$.find("li.focus");
        if (C.length > 0) {
            F = C.text()
        }
    }
    var I = 0;
    if (H.keyCode == 37 || H.keyCode == 38) {
        I = -1
    }
    if (H.keyCode == 39 || H.keyCode == 40) {
        I = 1
    }
    var G = "";
    var E = -1;
    var C;
    this.list$.find("li").removeClass("focus");
    for (var D = 0; D < this.values.length; D++) {
        G = this.values[D].text;
        C = this.list$.find('li:contains("' + G + '")');
        if (F == G) {
            E = D + I;
            if (E < 0) {
                E = this.values.length - 1
            } else {
                if (E >= this.values.length) {
                    E = 0
                }
            }
            G = this.values[E].text;
            C = this.list$.find('li:contains("' + G + '")');
            C.addClass("focus")
        }
    }
};
ComboBoxWidget.prototype._onblur = function(C) {
    MC.debugOutput("ComboBox: onBlur");
    if (this.isOpen) {
        this.blurTimeout = setTimeout(this.delayedBlur, 200)
    }
    this.button$.removeClass("focus")
};
ComboBoxWidget.prototype._delayedBlur = function() {
    MC.debugOutput("ComboBox: _delayedBlur");
    if (!this.scrolled) {
        this._closeOptionList()
    }
    delete this.blurTimeout
};

function ChecklistInputWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = '<div id="' + C.name + '" class="checklistInputDiv">' + (C.label ? '<label for="' + C.name + '" class="ARRightMargin">' + C.label + "</label>" : "") + "<ul>";
    for (i = 0; i < C.values.length; i++) {
        C.htmlText += ('<li><input type="checkbox" name="' + C.name + '" value="' + C.values[i].value + '" /><label for="' + C.values[i].value + '" class="ARLeftMargin">' + C.values[i].text + "</label></li>")
    }
    C.htmlText += "</ul></div>";
    InputWidget.call(this, C);
    this.class_name = "ChecklistInputWidget";
    this.inputElements = $("input", this.elements);
    if (C.label) {
        this.labelElement = $("label:first", this.elements)
    }
    if (C.value) {
        this.handleUpdate(C)
    }
}
ChecklistInputWidget.prototype = new InputWidget();
ChecklistInputWidget.prototype.handleUpdate = function(C) {
    if (C && C.value instanceof Array) {
        if (C.unsetOrig) {
            delete this.originalValue;
            delete C.unsetOrig
        }
        if (C.setOrig) {
            this.originalValue = C.value;
            delete C.setOrig
        }
        this.inputElements.val(C.value);
        this.flagChange()
    }
};
ChecklistInputWidget.prototype.handleRetrieve = function(D) {
    if (this.name && D) {
        if (!(D[this.name] instanceof Object)) {
            D[this.name] = {}
        }
        D[this.name].value = [];
        var C = this.inputElements.filter("input:checked");
        C.each(function() {
            D[this.name].value[D[this.name].value.length] = $(this).val()
        })
    }
};

function CheckboxInputWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.htmlText = C.htmlText || '<div class="checkboxInputDiv"><input id="' + C.name + '" name="' + C.name + '" type="checkbox" value="' + C.name + '" />' + (C.label ? '<label for="' + C.name + '" class="ARLeftSmallMargin">' + C.label + "</label>" : "") + "</div>";
    InputWidget.call(this, C);
    this.class_name = "CheckboxInputWidget";
    this.inputElements = $("#" + C.name, this.elements);
    if (C.label) {
        this.labelElement = $("label:first", this.elements)
    }
    this.handleUpdate(C)
}
CheckboxInputWidget.prototype = new InputWidget();
CheckboxInputWidget.prototype.handleUpdate = function(C) {
    if (C && C.value != undefined) {
        if (C.unsetOrig) {
            delete this.originalValue;
            delete C.unsetOrig
        }
        if (C.setOrig) {
            this.originalValue = C.value;
            delete C.setOrig
        }
        if (compareVersions($.fn.jquery, "1.6") >= 0) {
            this.inputElements.prop("checked", C.value)
        } else {
            this.inputElements.attr("checked", C.value)
        }
        this.fireChange("update")
    }
};
CheckboxInputWidget.prototype.getValue = function() {
    if (compareVersions($.fn.jquery, "1.6") >= 0) {
        return this.inputElements.prop("checked")
    } else {
        return this.inputElements.attr("checked")
    }
};
CheckboxInputWidget.prototype.fireChange = function(D) {
    if (this.currentValue == undefined) {
        this.currentValue = false
    }
    var C = this.getValue();
    if (C != this.currentValue) {
        this.currentValue = C;
        if (D === "update") {
            this.flagChange()
        } else {
            InputWidget.prototype.fireChange.call(this, D)
        }
    } else {
        this.flagChange()
    }
};
CheckboxInputWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        if (this.name && C && this.getValue()) {
            C[this.name].value = true
        } else {
            C[this.name].value = false
        }
    }
};
CheckboxInputWidget.prototype.isSelected = function() {
    return (this.name && this.getValue())
};

function RadioButtonsInputWidget(H) {
    if (arguments.length == 0) {
        return
    }
    var D = "";
    if (H.orientation && H.orientation == "horizontal") {
        D = ' class="horiz"'
    }
    H.htmlText = '<div id="' + H.name + '" class="radioButtonsInputDiv">' + (H.label ? ('<label for="' + H.name + '" class="ARRightMargin"></label>') : "") + "<ul" + D + ">";
    var C = 0;
    if (H.value) {
        for (var E = 0; E < H.values.length; E++) {
            if (H.value == H.values[E].value) {
                C = E
            }
        }
    }
    this.valueIndex = {};
    for (var E = 0; E < H.values.length; E++) {
        var F = "";
        if (E == C) {
            F = "CHECKED"
        }
        H.htmlText += ("<li" + D + '><input type="radio" name="' + H.name + '" value="' + H.values[E].value + '" ' + F + " />" + ((H.values[E].text) ? '<label for="' + H.values[E].value + '" class="ARLeftSmallMargin">' + H.values[E].text + "</label>" : "") + "</li>");
        this.valueIndex[H.values[E].value] = E
    }
    H.htmlText += "</ul></div>";
    InputWidget.call(this, H);
    this.class_name = "RadioButtonsInputWidget";
    this.inputElements = $("input", this.elements);
    if (H.label) {
        this.labelElement = $("label:first", this.elements)
    }
    this.items$ = $("li", this.elements);
    for (var E = 0; E < H.values.length; E++) {
        if (H.values[E].widget) {
            var G = H.values[E].widget;
            this.items$.eq(E).append(G.getElements());
            this.widgets[this.widgets.length] = G
        }
    }
    if (H.value) {
        this.currentValue = H.value
    } else {
        if (H.values && H.values.length > 0) {
            H.value = H.values[0].value;
            this.currentValue = H.value
        } else {
            this.currentValue = ""
        }
    }
    this.handleUpdate(H)
}
RadioButtonsInputWidget.prototype = new InputWidget();
RadioButtonsInputWidget.prototype.handleUpdate = function(E) {
    if (E.label && this.labelElement) {
        this.labelElement.html(E.label + (this.options.noTerminator ? "" : strings.labelTerminator))
    }
    if (E && E.values) {
        for (var D = 0; D < E.values.length; D++) {
            if (E.values[D].value != undefined && E.values[D].disable != undefined) {
                var C = this.valueIndex[E.values[D].value];
                if (C != undefined) {
                    var F = this.inputElements.eq(C);
                    if (E.values[D].disable) {
                        F.attr("disabled", "disabled")
                    } else {
                        F.removeAttr("disabled")
                    }
                }
            }
        }
    }
    if (E && E.value != undefined) {
        if (E.unsetOrig) {
            delete this.originalValue;
            delete E.unsetOrig
        }
        if (E.setOrig) {
            this.originalValue = E.value;
            delete E.setOrig
        }
        this.inputElements.val([E.value]);
        this.fireChange()
    }
};
RadioButtonsInputWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].value = this.inputElements.filter("input:checked").val()
    }
};
RadioButtonsInputWidget.prototype.fireChange = function(D) {
    var C = this.inputElements.filter("input:checked").val();
    if (C != this.currentValue) {
        this.currentValue = C;
        InputWidget.prototype.fireChange.call(this, D)
    } else {
        this.flagChange()
    }
};

function DateInputWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.size = D.size || 10;
    D.maxLength = D.maxLength || false;
    D.rules = D.rules || {};
    D.rules.dhsdate = true;
    TextInputWidget.call(this, D);
    this.class_name = "DateInputWidget";
    var C = {
        useShortYear: false,
        dateFormat: "yy-mm-dd",
        showOn: "button",
        buttonImageOnly: true,
        buttonImage: ("images/calendar.png"),
        changeMonth: true,
        changeYear: true,
        changeFirstDay: false,
        showOtherMonths: true,
        minDate: (D.minDate ? (D.minDate == "any" ? null : D.minDate) : new Date()),
        maxDate: (D.maxDate ? D.maxDate : null),
        onSelect: createObjectCallback(this, this.dateSelected),
        speed: "fast"
    };
    if (this.options.picker) {
        $.extend(C, this.options.picker)
    }
    if (!D.noHint) {
        $(this.elements).addClass("dateBox").append('<div class="dateHint">' + strings.val.dateFormat + "</div>")
    }
    if (D.value) {
        this.handleUpdate(D)
    }
}
DateInputWidget.prototype = new TextInputWidget();
DateInputWidget.prototype.disable = function(C) {
    InputWidget.prototype.disable.call(this, C)
};
DateInputWidget.prototype.dateSelected = function() {
    this.fireChange()
};
DateInputWidget.prototype.valueEqual = function(D, C) {
    var E = $.datepicker.formatDate("yy-mm-dd", D);
    if (E == C) {
        return true
    } else {
        return false
    }
};
DateInputWidget.prototype.handleUpdate = function(C) {
    if (!C.value && C.valueText) {
        C.value = C.valueText
    }
    if (C.value != undefined) {
        if ((C.value instanceof Date) || (C.value instanceof MCDate)) {
            C.value = $.datepicker.formatDate("yy-mm-dd", C.value)
        }
    }
    TextInputWidget.prototype.handleUpdate.call(this, C)
};
DateInputWidget.prototype.handleRetrieve = function(F) {
    var E = {};
    TextInputWidget.prototype.handleRetrieve.call(this, E);
    if (E[this.name].value) {
        try {
            var C = $.datepicker.parseDate("yy-mm-dd", E[this.name].value);
            if (!F[this.name]) {
                F[this.name] = {}
            }
            F[this.name].value = C;
            F[this.name].textValue = E[this.name].value
        } catch (D) {
            MC.errorOutput("Unable to parse the date, " + E[this.name].value, ".\n" + D)
        }
    } else {
        var C = new Date();
        if (!F[this.name]) {
            F[this.name] = {}
        }
        F[this.name].value = C;
        F[this.name].textValue = MCDate.toISODateString(C)
    }
};

function TimeInputWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.classes = "timeInput" + (C.classes ? " " + C.classes + " " : "");
    this.militaryValue = "military";
    this.amValue = "am";
    this.pmValue = "pm";
    this.hourName = C.name + "hour";
    this.minuteName = C.name + "minute";
    this.periodName = C.name + "period";
    this.hourBox = new TextInputWidget({
        name: this.hourName,
        classes: "inline",
        size: 2,
        maxLength: 2,
        rules: {
            required: true,
            digits: true,
            range: [0, 23]
        },
        value: "0",
        changeCallback: createObjectCallback(this, this._changeCallback)
    });
    if (!C.noHint) {
        $(this.hourBox.elements).addClass("timeBox").append('<div class="timeHint">' + strings.val.hourFormat + "</div>")
    }
    this.colon = new TextWidget({
        name: "colon",
        classes: "inline",
        leftSmallMargin: true,
        text: ":"
    });
    this.minuteBox = new TextInputWidget({
        name: this.minuteName,
        classes: "inline",
        leftSmallMargin: true,
        rightSmallMargin: true,
        size: 2,
        maxLength: 2,
        rules: {
            required: true,
            digits: true,
            range: [0, 59]
        },
        value: "0",
        changeCallback: createObjectCallback(this, this._changeCallback)
    });
    if (!C.noHint) {
        $(this.minuteBox.elements).addClass("timeBox").append('<div class="timeHint">' + strings.val.minuteFormat + "</div>")
    }
    this.period = new ComboBoxWidget({
        name: this.periodName,
        classes: "inline",
        leftSmallMargin: true,
        topSmallMargin: true,
        width: 32,
        value: this.militaryValue,
        changeCallback: createObjectCallback(this, this.timeModeChanged),
        values: [{
            value: this.militaryValue,
            text: strings.timeInput.military
        }, {
            value: this.amValue,
            text: strings.timeInput.am
        }, {
            value: this.pmValue,
            text: strings.timeInput.pm
        }],
        value: this.militaryValue
    });
    C.widgets = [this.hourBox, this.colon, this.minuteBox, this.period];
    InputWidget.call(this, C);
    this.class_name = "TimeInputWidget";
    if (C.value) {
        this.handleUpdate(C)
    }
}
TimeInputWidget.prototype = new InputWidget();
TimeInputWidget.prototype.constructor = TimeInputWidget;
TimeInputWidget.prototype.valueEqual = function(D, C) {
    if (D.getHours() == C.getHours() && D.getMinutes() == C.getMinutes()) {
        return true
    } else {
        return false
    }
};
TimeInputWidget.prototype.timeModeChanged = function(D) {
    if (D[this.periodName] == undefined) {
        return
    }
    var E = D[this.periodName].value;
    var C = {};
    if (E == this.militaryValue) {
        C[this.hourName] = {
            rules: {
                required: true,
                digits: true,
                range: [0, 23]
            }
        }
    } else {
        C[this.hourName] = {
            rules: {
                required: true,
                digits: true,
                range: [1, 12]
            }
        }
    }
    this.ignoreFireChange = true;
    this.update(C);
    this.ignoreFireChange = false;
    this.fireChange()
};
TimeInputWidget.prototype._changeCallback = function(E, C, D) {
    if (this.ignoreFireChange && !D) {
        return
    }
    this.fireChange(D)
};
TimeInputWidget.prototype.handleUpdate = function(G) {
    var F = {};
    F[this.hourName] = {};
    F[this.minuteName] = {};
    F[this.periodName] = {};
    var D = false;
    if (G.value != undefined && ((G.value instanceof Date) || (G.value instanceof MCDate))) {
        G.value.setSeconds(0);
        G.value.setMilliseconds(0);
        F[this.hourName].value = leadingZeros(G.value.getHours(), 2);
        F[this.hourName].rules = {
            required: true,
            digits: true,
            range: [0, 23]
        };
        F[this.minuteName].value = leadingZeros(G.value.getMinutes(), 2);
        F[this.periodName].value = this.militaryValue;
        D = true
    } else {
        if (G.textValue != undefined) {
            var E = G.textValue.match(/^(\d\d):(\d\d)$/);
            if (E) {
                F[this.hourName].value = E[1];
                F[this.hourName].rules = {
                    required: true,
                    digits: true,
                    range: [0, 23]
                };
                F[this.minuteName].value = E[2];
                F[this.periodName].value = this.militaryValue;
                D = true
            }
        }
    }
    if (D && G.setOrig) {
        this.originalValue = G.value;
        delete G.setOrig
    }
    if (G.unsetOrig) {
        delete this.originalValue;
        delete G.unsetOrig
    }
    if (G.disable != undefined) {
        var C = (G.disable ? true : false);
        F[this.hourName].disable = C;
        F[this.minuteName].disable = C;
        F[this.periodName].disable = C
    }
    this.ignoreFireChange = true;
    this.update(F);
    this.ignoreFireChange = false;
    this.fireChange()
};
TimeInputWidget.prototype.handleRetrieve = function(F) {
    if (this.name) {
        var D = new Date();
        var C = parseInt(F[this.hourName].value, 10);
        var E = parseInt(F[this.minuteName].value, 10);
        if (F[this.periodName].value == this.pmValue) {
            C += 12
        }
        delete F[this.hourName];
        delete F[this.minuteName];
        delete F[this.periodName];
        D.setHours(C);
        D.setMinutes(E);
        D.setSeconds(0);
        D.setMilliseconds(0);
        if (!F[this.name]) {
            F[this.name] = {}
        }
        F[this.name].value = D;
        F[this.name].textValue = "" + D.getHours() + ":" + D.getMinutes()
    }
};

function PortsInputWidget(F) {
    if (arguments.length == 0) {
        return
    }
    this.disable = false;
    this.value = null;
    this.rack = new RackEnclosureWidget({
        name: "rack",
        bottomMargin: true,
        selectable: true,
        exclusive: false,
        view: "rear",
        noLedControls: true,
        modes: [{
            tabular: false
        }, {
            tabular: true
        }],
        changeCallback: createObjectCallback(this, this.portSelected)
    });
    F.widgets = [this.rack];
    this.portTypes = {};
    var E = 0;
    for (var C in DC.ports) {
        var D = DC.ports[C].getPropertyValue("port_type");
        if (!(D in this.portTypes)) {
            this.portTypes[D] = true;
            E++
        }
    }
    this.hybrid = (E > 1);
    this.hostBusType = -1;
    WidgetContainer.call(this, F);
    this.class_name = "PortsInputWidget";
    this.handleUpdate(F)
}
PortsInputWidget.prototype = new WidgetContainer();
PortsInputWidget.prototype.portSelected = function(C, D) {
    if (D.selected && this.hybrid) {
        this.deselectOtherTypes(D.json.getPropertyValue("port_type"))
    }
    if (!this.form) {
        this.form = $.data($(this.elements).parents().filter("form").get(0), "dh-form")
    }
    if (this.form && D.inputElements$ && D.inputElements$.length > 0) {
        this.form.validator.settings.onclick.call(this.form.validator, D.inputElements$[0])
    }
};
PortsInputWidget.prototype.setProperties = function(C, D) {
    this.hostBusType = C;
    this.explicit = D
};
PortsInputWidget.prototype.handleUpdate = function(H) {
    if (H.disable != undefined) {
        this.disable = H.disable
    }
    if (H.value != undefined) {
        if (this.explicit) {
            this.value = H.value
        } else {
            this.value = "all"
        }
    }
    var F = "NONE";
    if (this.value != undefined && (this.value == "all" || this.value == "")) {
        switch (this.hostBusType) {
            case PORT_TYPES.ISCSI:
                F = "iSCSI";
                break;
            case PORT_TYPES.FC:
                F = "FC";
                break;
            case PORT_TYPES.SAS:
                F = "SAS";
                break;
            default:
                F = "";
                break
        }
        if (F == "") {
            if ("FC" in this.portTypes) {
                F = "FC"
            } else {
                if ("SAS" in this.portTypes) {
                    F = "SAS"
                } else {
                    if ("iSCSI" in this.portTypes) {
                        F = "iSCSI"
                    }
                }
            }
        }
    }
    var G = system.physicalPositionOffset;
    var D = [{
        filterAll: true,
        options: {
            visibility: "collapse",
            notPresent: true
        }
    }, {
        filterSelect: {
            type: "prop",
            name: "enclosure_id",
            value: G
        },
        options: {
            visibility: "visible",
            notPresent: false,
            inactive: true,
            selectable: false,
            selected: false,
            exclusive: false
        }
    }];
    var C = [{
        filterAll: true,
        options: {
            selectable: false,
            selectable: false,
            exclusive: false,
            inactive: true
        }
    }, {
        filterSelect: {
            type: "attr",
            name: "basetype",
            value: "port"
        },
        options: {
            inactive: false,
            selectable: true,
            selected: false,
            disabled: this.disable
        }
    }, {
        filterSelect: {
            type: "AND",
            conditions: [{
                type: "attr",
                name: "basetype",
                value: "port"
            }, {
                type: "prop",
                name: "port_type",
                value: F
            }]
        },
        options: {
            inactive: false,
            selectable: true,
            selected: true,
            disabled: this.disable
        }
    }];
    if (this.value instanceof Array) {
        for (var E = 0; E < this.value.length; E++) {
            if (this.value[E]) {
                C[C.length] = {
                    filterSelect: {
                        type: "AND",
                        conditions: [{
                            type: "attr",
                            name: "basetype",
                            value: "port"
                        }, {
                            type: "prop",
                            name: "port",
                            value: this.value[E]
                        }]
                    },
                    options: {
                        selected: true
                    }
                }
            }
        }
    }
    this.rack.update({
        rack: {
            enclosureFilters: D,
            componentFilters: C
        }
    })
};
PortsInputWidget.prototype.setVisibility = function(C) {
    this.rack.update({
        rack: {
            visibility: C
        }
    })
};
PortsInputWidget.prototype.handleRetrieve = function(H) {
    if (this.name && H) {
        var G = [];
        var I = {};
        this.rack.retrieve(I);
        if (I.rack && I.rack.components) {
            var F = I.rack.components.objects.length;
            for (var E = 0; E < F; E++) {
                var D = I.rack.components.objects[E];
                if (D) {
                    var C = D.getPropertyValue("port");
                    if (C) {
                        G[G.length] = C
                    }
                }
            }
        }
        if (!(H[this.name] instanceof Object)) {
            H[this.name] = {}
        }
        if (G.length > 0) {
            H[this.name].value = G
        } else {
            H[this.name].value = this.value
        }
        if (H.rack) {
            delete H.rack
        }
    }
};
PortsInputWidget.prototype.deselectOtherTypes = function(E) {
    var D = [{
        filterSelect: {
            type: "attr",
            name: "basetype",
            value: "port"
        },
        options: {
            inactive: false,
            selectable: true,
            disabled: this.disable
        }
    }];
    for (var C in this.portTypes) {
        if (E != C) {
            D.push({
                filterSelect: {
                    type: "AND",
                    conditions: [{
                        type: "attr",
                        name: "basetype",
                        value: "port"
                    }, {
                        type: "prop",
                        name: "port_type",
                        value: C
                    }]
                },
                options: {
                    selected: false
                }
            })
        }
    }
    this.rack.update({
        rack: {
            componentFilters: D
        }
    })
};

function SliderWidget(F) {
    if (arguments.length == 0) {
        return
    }
    F.size = F.size || 6;
    F.sliderOpts = F.sliderOpts || {};
    F.sliderOpts.minValue = (F.sliderOpts.minValue == undefined) ? 0 : F.sliderOpts.minValue;
    F.sliderOpts.maxValue = (F.sliderOpts.maxValue == undefined) ? 100 : F.sliderOpts.maxValue;
    F.sliderOpts.stepping = (F.sliderOpts.stepping == undefined) ? 1 : F.sliderOpts.stepping;
    F.sliderOpts.slide = createObjectCallback(this, this.slide);
    F.sliderOpts.change = createObjectCallback(this, this.slideChanged);
    F.value = (F.value == undefined) ? F.sliderOpts.minValue : F.value;
    F.sliderOpts.startValue = F.value;
    F.textPosition = F.textPosition || "left";
    var D = '<input id="' + F.name + 'Text" name="' + F.name + '" type="text" ' + (F.textEntry ? "" : "READONLY ") + 'size="' + F.size + '" class="sliderText"></input>';
    var G = '<td><div id="' + F.name + '" class="slider-background slider"><div class="slider-handle"></div></div></td>';
    var E = "";
    if (F.bookends) {
        G = '<td><p class="sliderBookend">' + F.sliderOpts.minValue + "</p></td>" + G + '<td><p class="sliderBookend">' + F.sliderOpts.maxValue + "</p></td>";
        E = "<td></td>"
    }
    var C = "";
    if (F.sizeUnitSelection) {
        C = '<td><select id="' + F.name + 'Unit" name="' + F.name + '" style="width:48px"></select></td>'
    }
    F.htmlText = '<div class="sliderInputDiv">' + (F.label ? '<label for="' + F.name + '" class="ARRightMargin">' + F.label + "</label>" : "") + '<table class="sliderTable" cellpadding="0" cellspacing="0" border="0" valign="bottom">';
    if (F.textPosition == "left") {
        F.htmlText += ('<tr><td class="ARRightSmallMargin">' + D + "</td>" + C + G + "</tr>")
    }
    if (F.textPosition == "right") {
        F.htmlText += ("<tr>" + G + '<td class="ARLeftSmallMargin">' + D + "</td>" + C + "</tr>")
    }
    if (F.textPosition == "top") {
        F.htmlText += ("<tr>" + E + "<td>" + D + "</td>" + C + "</tr><tr>" + G + "</tr>")
    }
    if (F.textPosition == "bottom") {
        F.htmlText += ("<tr>" + G + "</tr><tr>" + E + "<td>" + D + "</td>" + C + "</tr>")
    }
    F.htmlText += ("</table></div>");
    InputWidget.call(this, F);
    this.class_name = "SliderWidget";
    this.visible = false;
    this.inputElements = $("input:first", this.elements);
    this.inputElements.val(F.value);
    this.forced = false;
    this.inputElements.change(createObjectCallback(this, this.fireChange));
    this.sliderElement = $(".slider:first", this.elements);
    this.labelElement = $("label:first", this.elements);
    if (F.bookends) {
        this.bookends = $(".sliderBookend", this.elements)
    }
    if (F.sizeUnitSelection) {
        this.unitSelection = $("select:first", this.elements);
        this.unitSelection.change(createObjectCallback(this, this.unitChange))
    }
    this.disabled = false;
    this.sliderOpts = F.sliderOpts;
    this.handleUpdate(F)
}
SliderWidget.prototype = new InputWidget();
SliderWidget.prototype.constructor = SliderWidget;
SliderWidget.prototype.handleUpdate = function(D) {
    if (D) {
        if (D.unsetOrig) {
            delete this.originalValue;
            delete D.unsetOrig
        }
        if (D.setOrig) {
            this.originalValue = D.value;
            this.originalUnits = D.units;
            delete D.setOrig
        }
        var C = false;
        if (D.sliderOpts != undefined) {
            if (D.sliderOpts.maxValue && D.sliderOpts.maxValue != this.sliderOpts.maxValue) {
                C = true
            }
            if (D.value) {
                D.sliderOpts.startValue = D.value
            }
            $.extend(this.sliderOpts, D.sliderOpts);
            if (this.sliderInitialized) {
                if (this.visible) {
                    this.sliderElement.slider("destroy");
                    this.sliderElement.slider(this.sliderOpts);
                    this.disable(this.disabled)
                } else {
                    this.sliderElement.slider("destroy");
                    this.sliderInitialized = false
                }
            }
        }
        if (this.options.sizeUnitSelection && C) {
            var H = this.sliderOpts.maxValue;
            var E = this.options.units;
            if (D.units != undefined) {
                E = D.units
            }
            var K = Size.factor.decimal[E.charAt(0)];
            var I = "";
            for (var J in {
                    TB: 1,
                    GB: 1,
                    MB: 1
                }) {
                var F = Size.factor.decimal[J.charAt(0)];
                var G = H * (K / F);
                if (J == E || G >= 10) {
                    I += '<option value="' + J + '">' + J + "</option>"
                }
            }
            this.unitSelection.html(I)
        }
        if (D.units != undefined) {
            this.options.units = D.units;
            if (this.options.sizeUnitSelection) {
                this.unitSelection.val(D.units)
            }
        }
        if (this.options.bookends && (D.units != undefined || D.sliderOpts != undefined)) {
            this.bookends.eq(0).text(this.sliderOpts.minValue + (this.options.sizeUnitSelection ? "" : this.options.units));
            this.bookends.eq(1).text(this.sliderOpts.maxValue + (this.options.sizeUnitSelection ? "" : this.options.units))
        }
        if (D.value != undefined) {
            this.inputElements.val(D.value);
            if (this.sliderInitialized) {
                if (D.valueOverride) {
                    this.inputOverride = true
                }
                this.sliderElement.slider("moveTo", D.value, 0)
            }
            this.flagChange()
        }
    }
};
SliderWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].value = this.inputElements.val();
        C[this.name].units = this.options.units;
        C[this.name].forced = this.forced
    }
};
SliderWidget.prototype.slide = function(C, D) {
    if (D.value != undefined && !this.inputOverride) {
        this.inputElements.val(D.value);
        this.forced = false
    }
    this.inputOverride = false
};
SliderWidget.prototype.slideChanged = function(C, D) {
    this.slide(C, D);
    InputWidget.prototype.fireChange.call(this, C)
};
SliderWidget.prototype.showing = function() {
    this.visible = true;
    var C = this.inputElements.val();
    if (this.sliderInitialized) {
        this.sliderElement.slider("enable");
        this.sliderElement.slider("moveTo", C, 0)
    } else {
        this.sliderOpts.startValue = C;
        this.sliderElement.slider(this.sliderOpts);
        this.sliderInitialized = true;
        this.disable(this.disabled)
    }
};
SliderWidget.prototype.hiding = function() {
    this.visible = false
};
SliderWidget.prototype.disable = function(C) {
    if (C) {
        this.disabled = true;
        if (this.sliderInitialized) {
            this.sliderElement.slider("disable")
        }
        this.inputElements.attr("DISABLED", "true");
        if (this.bookends) {
            this.bookends.fadeTo(0, 0.5)
        }
    } else {
        this.disabled = false;
        if (this.sliderInitialized) {
            this.sliderElement.slider("enable")
        }
        this.inputElements.removeAttr("DISABLED");
        if (this.bookends) {
            this.bookends.fadeTo(0, 1)
        }
    }
};
SliderWidget.prototype.fireChange = function(C) {
    var E;
    var D = false;
    if (this.options.allowFloat) {
        E = parseFloat(this.inputElements.val())
    } else {
        E = parseInt(this.inputElements.val(), 10)
    }
    if (isNaN(E)) {
        E = 0;
        D = true
    }
    if (E < this.sliderOpts.minValue) {
        E = this.sliderOpts.minValue;
        this.forced = true
    } else {
        if (E > this.sliderOpts.maxValue) {
            E = this.sliderOpts.maxValue;
            this.forced = true
        } else {
            this.forced = false
        }
    }
    if (!D) {
        this.inputElements.val(E)
    }
    if (this.sliderInitialized) {
        E = Math.round(E / this.sliderOpts.stepping) * this.sliderOpts.stepping;
        this.inputOverride = true;
        this.sliderElement.slider("moveTo", E, 0)
    }
    InputWidget.prototype.fireChange.call(this, C)
};
SliderWidget.prototype.unitChange = function(J) {
    var F = this.unitSelection.val();
    if (F == this.options.units) {
        return
    }
    var E = Size.factor.decimal[this.options.units.charAt(0)];
    var G = Size.factor.decimal[F.charAt(0)];
    var H = E / G;
    var I;
    if (this.options.allowFloat) {
        I = parseFloat(this.inputElements.val())
    } else {
        I = parseInt(this.inputElements.val(), 10)
    }
    I = I * H;
    var C = parseInt(this.sliderOpts.minValue * H, 10);
    var D = parseInt(this.sliderOpts.maxValue * H, 10);
    if ((D - C) < 10) {
        this.unitSelection.val(this.options.units);
        return
    }
    this.sliderOpts.minValue = this.sliderOpts.minValue * H;
    this.sliderOpts.maxValue = this.sliderOpts.maxValue * H;
    if (this.visible) {
        this.sliderElement.slider("destroy");
        this.sliderElement.slider(this.sliderOpts);
        this.disable(this.disabled)
    }
    if (this.options.bookends) {
        this.bookends.eq(0).text(this.sliderOpts.minValue);
        this.bookends.eq(1).text(this.sliderOpts.maxValue)
    }
    this.inputElements.val(I);
    this.options.units = F;
    this.fireChange()
};
SliderWidget.prototype.flagChange = function() {
    if (this.originalValue != undefined && this.name) {
        var C = parseInt(this.inputElements.val(), 10);
        if (this.originalValue == C && this.originalUnits == this.options.units) {
            this.valueChanged = false;
            if (this.labelElement) {
                this.labelElement.removeClass("valueChanged")
            }
        } else {
            this.valueChanged = true;
            if (this.labelElement) {
                this.labelElement.addClass("valueChanged")
            }
        }
    }
};

function FormWidget(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.name == undefined) {
        MC.errorOutput("Internal error: FormWidget requires name!");
        return
    }
    this.tableClasses = (C.tableClasses) ? C.tableClasses : "";
    this.tableBodyClasses = (C.tableBodyClasses) ? C.tableBodyClasses : "";
    this.errorDivID = C.name + "ErrDiv";
    this.errorContainerID = C.name + "Errs";
    this.encType = (typeof(C.encType) == "undefined") ? "application/x-www-form-urlencoded" : C.encType;
    if (!C.htmlText) {
        C.htmlText = '<form enctype="' + this.encType + '" class="widgetContainer formWidget"><div id="' + this.errorDivID + '" class="formErrDiv" style="display: none"><p>' + strings.form.errTitle + '</p><ul id="' + this.errorContainerID + '"></ul></div></form>'
    }
    WidgetContainer.call(this, C);
    this.class_name = "FormWidget";
    this.form = this.elements;
    $.data(this.form, "dh-form", this);
    this.valOptions = C.valOptions || {};
    this.data = C.data || {};
    this.valOptions.docContext = this.elements;
    if (this.valOptions.rules == undefined) {
        this.valOptions.rules = {}
    }
    if (this.valOptions.messages == undefined) {
        this.valOptions.messages = {}
    }
    if (this.valOptions.ignore == undefined) {
        this.valOptions.ignore = ".diskCheck"
    } else {
        this.valOptions.ignore += " .diskCheck"
    }
    if (!C.defaultSubmit) {
        $(this.form).submit(function() {
            return false
        })
    }
    this.valOptions.errorContainer = "#" + this.errorDivID;
    this.valOptions.errorLabelContainer = "#" + this.errorContainerID;
    this.valOptions.wrapper = "li";
    this.valOptions.errorClass = "inputInvalid";
    this.valOptions.highlight = createObjectCallback(this, this._highlightErr);
    this.valOptions.unhighlight = createObjectCallback(this, this._unhighlightErr);
    this.valOptions.eventHandler = createObjectCallback(this, this._handleUserEvent);
    this.widgetMap = {};
    this.validator = $(this.form).validate(this.valOptions);
    this.processWidgets();
    this.disabled = false;
    this.valid = false;
    this.fieldsChanged = false;
    this.invalidFields = false;
    if (!this.data[this.name]) {
        this.data[this.name] = {}
    }
    if (this.options.visibility != undefined) {
        this.data[this.name].visibility = this.options.visibility
    }
    if (this.options.disable != undefined) {
        this.data[this.namedisable].disable = this.options.disable
    }
    this.update(this.data)
}
FormWidget.prototype = new WidgetContainer();
FormWidget.prototype.constructor = FormWidget;
FormWidget.prototype.add = function(C) {
    if (this.options.tableLayout) {
        if (this.tableWidget == undefined) {
            this.tableWidget = new TableWidget({
                name: this.name + "Table",
                maxCols: 2,
                tableClasses: this.tableClasses,
                bodyClasses: this.tableBodyClasses
            });
            WidgetContainer.prototype.add.call(this, this.tableWidget)
        }
        if (C.options.cellClasses == undefined) {
            if (C instanceof InputWidget) {
                C.options.cellClasses = "inputCell"
            } else {
                C.options.cellClasses = "otherCell"
            }
        }
        this.tableWidget.add(C)
    } else {
        WidgetContainer.prototype.add.call(this, C)
    }
};
FormWidget.prototype.update = function(E) {
    var C = false;
    var F = false;
    if (this.name) {
        var D = E[this.name];
        if (D instanceof Object) {
            if (D.disable != undefined) {
                this.disable(D.disable)
            }
            if (D.validate) {
                C = true;
                delete D.validate
            }
            if (D.resetValidation) {
                F = true;
                delete D.resetValidation
            }
        }
    }
    WidgetContainer.prototype.update.call(this, E);
    if (C) {
        this.valid = this.validate()
    }
    if (F) {
        this.resetValidation()
    }
};
FormWidget.prototype.disable = function(C) {
    if ((typeof C) == "boolean") {
        this.disabled = C
    }
};
FormWidget.prototype.processWidgets = function(C) {
    var E = C;
    if (E == undefined) {
        this.valOptions.rules = {};
        this.valOptions.messages = {};
        E = this.widgets
    }
    for (var D = 0; D < E.length; D++) {
        if ((E[D] instanceof InputWidget) && E[D].name) {
            E[D].form = this;
            this.widgetMap[E[D].name] = E[D];
            this.setRules(E[D].name, E[D].rules);
            this.setMessages(E[D].name, E[D].messages)
        }
        if (E[D].widgets) {
            this.processWidgets(E[D].widgets)
        }
    }
    this.updateMessages();
    this.updateRules()
};
FormWidget.prototype.setRules = function(C, D, E) {
    if (C && D) {
        this.valOptions.rules[C] = D;
        this.widgetMap[C].rules = D;
        if (D.required) {
            this.widgetMap[C].required = true;
            this.widgetMap[C].invalid = true
        } else {
            this.widgetMap[C].required = false
        }
    }
    if (E) {
        this.updateRules()
    }
};
FormWidget.prototype.setMessages = function(C, D) {
    if (C && D) {
        this.valOptions.messages[C] = D
    }
};
FormWidget.prototype.updateRules = function() {
    this.validator.settings.rules = this.valOptions.rules
};
FormWidget.prototype.updateMessages = function() {
    this.validator.settings.messages = this.valOptions.messages
};
FormWidget.prototype.validate = function() {
    return this.validator.form()
};
FormWidget.prototype.resetValidation = function() {
    this.validator.resetForm();
    this.valid = true
};
FormWidget.prototype.addCustomValidator = function(C) {
    this.validator.settings.customValidator = C
};
FormWidget.prototype.retrieve = function(D, C) {
    var E = D || this.data;
    if (this.name && E) {
        if (E[this.name] == undefined) {
            E[this.name] = {}
        }
        if (this.disabled) {
            E[this.name].disabled = true;
            E[this.name].valid = false;
            if (C) {
                WidgetContainer.prototype.retrieve.call(this, E, C)
            }
        } else {
            E[this.name].disabled = false;
            if (C) {
                E[this.name].valid = false;
                WidgetContainer.prototype.retrieve.call(this, E, C)
            } else {
                E[this.name].valid = this.validate();
                if (E[this.name].valid) {
                    WidgetContainer.prototype.retrieve.call(this, E, true);
                    E[this.name].valid = true
                }
            }
        }
    }
};
FormWidget.prototype._highlightErr = function(D, C) {
    $(D, this.form).addClass(C);
    if (D.name) {
        widget = this.widgetMap[D.name];
        if (widget && widget.highlightErr) {
            widget.highlightErr()
        }
    }
};
FormWidget.prototype._unhighlightErr = function(D, C) {
    $(D, this.form).removeClass(C);
    if (D.name) {
        widget = this.widgetMap[D.name];
        if (widget && widget.unhighlightErr) {
            widget.unhighlightErr()
        }
    }
};
FormWidget.prototype._handleUserEvent = function(E, C, F) {
    var D = E.name;
    if (D && this.widgetMap[D]) {
        var H = this.widgetMap[D];
        H.invalid = C;
        if (!C && H.required) {
            var G = {};
            H.retrieve(G);
            H.invalid = (G[D].value.length == 0)
        }
        if (F) {
            H.fireChange(F)
        }
    }
};
FormWidget.prototype.onInputWidgetChanged = function() {
    this._updateSubmissionStatus()
};
FormWidget.prototype._updateSubmissionStatus = function() {
    var H = false;
    var G = false;
    var E = false;
    for (var C in this.widgetMap) {
        var F = this.widgetMap[C];
        if (F.invalid) {
            E = true
        } else {
            if (F.name == "passwordConfirm" && this.widgetMap.passwordTextbox.valueChanged) {
                if (F.inputElements[0].value.length == 0) {
                    E = true
                }
            }
        }
        if (typeof F.valueChanged != "undefined") {
            H = true;
            if (F.valueChanged) {
                G = true
            }
        }
    }
    this.fieldsChanged = H && G;
    this.invalidFields = E;
    var D;
    if (this.invalidFields || (H && !G)) {
        D = false
    } else {
        D = true
    }
    if (D != this.valid) {
        this.valid = D;
        if (typeof this.options.onReadyForSubmission == "function") {
            this.options.onReadyForSubmission.call(this, this.valid)
        }
    }
};

function MappingInputWidget(H) {
    if (arguments.length == 0) {
        return
    }
    this.name = H.name;
    H.orientation = "vertical";
    this.doMap = false;
    this.buttonsControl = H.buttonsControl || false;
    this.cancelCallback = H.cancelCallback || function() {};
    this.applyCallback = H.applyCallback || function() {};
    this.multiVolume = H.multiVolume || false;
    this.buttonsNoDisable = H.buttonsNoDisable || false;
    var G = H.multiVolume ? "collapse" : "visible";
    var E = H.multiVolume ? strings.mapVolumes.startingLun : strings.lun;
    var D = [new TableWidget({
        row: 0,
        col: 0,
        widgets: [new CheckboxInputWidget({
            name: "doMap",
            row: 0,
            col: 1,
            bottomMargin: true,
            leftSmallMargin: true,
            label: strings.mappingInput.usageLabel,
            labelOptions: {
                row: 0,
                col: 0,
                bottomMargin: true
            },
            visibility: G,
            changeCallback: createObjectCallback(this, function(I) {
                this.changeDoMap(I.doMap.value)
            })
        }), new TextWidget({
            name: "doMapText",
            visibility: G,
            row: 0,
            col: 2,
            bottomMargin: true,
            leftMargin: true,
            text: ""
        })]
    }), new TableWidget({
        name: "lunAndAccess",
        row: 1,
        col: 0,
        widgets: [new TextInputWidget({
            name: "lun",
            row: 0,
            col: 1,
            bottomMargin: true,
            leftMargin: true,
            label: E,
            labelOptions: {
                row: 0,
                col: 0,
                bottomMargin: true
            },
            value: "0",
            rules: {
                required: true,
                digits: true
            },
            messages: {
                required: strings.createVolume.LUNMessage
            }
        }), new OptionInputWidget({
            name: "access",
            row: 0,
            col: 3,
            bottomMargin: true,
            leftMargin: true,
            label: strings.createVolume.accessLabel,
            labelOptions: {
                row: 0,
                col: 2,
                bottomMargin: true,
                leftMargin: true
            },
            values: [{
                value: PORT_ACCESS.NO_ACCESS,
                text: strings.no_access
            }, {
                value: PORT_ACCESS.READ_ONLY,
                text: strings.read_only
            }, {
                value: PORT_ACCESS.READ_WRITE,
                text: strings.read_write
            }],
            value: PORT_ACCESS.NO_ACCESS
        })]
    }), new LabelWidget({
        name: "portLabel",
        row: 2,
        col: 0,
        colSpan: 5,
        bottomSmallMargin: true,
        value: strings.mappingInput.portLabel
    }), this.portWidget = new PortsInputWidget({
        name: "ports",
        row: 3,
        col: 0,
        colSpan: 5,
        caption: strings.ports
    })];
    this.form = new FormWidget({
        name: "editMapForm",
        data: {},
        tableLayout: true,
        valOptions: {
            customValidator: createObjectCallback(this, this.customValidator)
        },
        widgets: D
    });
    H.widgets = [this.form];
    if (this.buttonsControl) {
        var C = [];
        if (!H.buttonsNoCancel) {
            C.push(new ButtonWidget({
                name: "cancelMapButton",
                text: strings.cancelButtonText,
                click: this.cancelCallback
            }))
        }
        C.push(new ButtonWidget({
            name: "modifyMapButton",
            text: strings.applyButtonText,
            click: this.applyCallback
        }));
        this.buttons = new ButtonContainer({
            name: "bc",
            row: 4,
            col: 0,
            topMargin: true,
            orientation: "horizontal",
            alignment: "right",
            widgets: C
        });
        H.widgets.push(this.buttons)
    }
    Arrangement.call(this, H);
    this.class_name = "MappingInputWidget";
    var F = {};
    F[this.name] = H;
    if (F[this.name].doMap == undefined) {
        F[this.name].doMap = {
            value: H.multiVolume,
            visibility: G
        }
    } else {
        F[this.name].doMap.visibility = G
    }
    if (F[this.name].doMapText == undefined) {
        F[this.name].doMapText = {
            visibility: G
        }
    } else {
        F[this.name].doMapText.visibility = G
    }
    this.update(F)
}
MappingInputWidget.prototype = new Arrangement();
MappingInputWidget.prototype.setMapProperties = function(C, D) {
    if (typeof this.portWidget != "undefined") {
        this.portWidget.setProperties(C, D)
    }
};
MappingInputWidget.prototype.customValidator = function() {
    var C = {};
    this.retrieve(C, true);
    if (this.savePorts) {
        if (!C[this.name].ports || C[this.name].ports.value.length == 0) {
            C[this.name].ports = {
                value: this.savePorts
            }
        }
        delete this.savePorts
    }
    if (C[this.name].doMap.value && parseInt(C[this.name].access.value) != PORT_ACCESS.NO_ACCESS && C[this.name].ports.value.length == 0) {
        return {
            access: {
                message: strings.mappingInput.noPortsSelectedErr,
                relatedInputs: ["rack"]
            }
        }
    }
    return null
};
MappingInputWidget.prototype.disable = function(C) {
    if (C != undefined && (typeof C) == "boolean") {
        var D = {
            doMap: {
                disable: C
            },
            ports: {
                disable: C
            },
            lun: {
                disable: C
            },
            access: {
                disable: C
            }
        };
        if (!this.buttonsNoDisable && !this.buttonsControl) {
            D.modifyMapButton.disable = C
        }
        this.form.update(D);
        if (this.buttons) {
            this.buttons.update(D)
        }
    }
};
MappingInputWidget.prototype.doMapSettings = function(C) {
    if (C.doMap == undefined || C.doMap.value == undefined) {
        return
    }
    var D = (this.doMap != C.doMap.value);
    this.doMap = C.doMap.value;
    if (!C.portLabel) {
        C.portLabel = {}
    }
    if (!C.ports) {
        C.ports = {}
    }
    if (!C.lun) {
        C.lun = {}
    }
    if (!C.access) {
        C.access = {}
    }
    if (!C.modifyMapButton) {
        C.modifyMapButton = {}
    }
    if (!C.doMapText) {
        C.doMapText = {}
    }
    if (!C.lunAndAccess) {
        C.lunAndAccess = {}
    }
    if (C.doMap.value) {
        C.lunAndAccess.visibility = "visible";
        C.portLabel.visibility = "visible";
        C.ports.visibility = "visible";
        C.lun.disable = false;
        C.access.disable = false;
        C.ports.disable = false;
        if (D && C.lun.value == undefined) {
            C.lun.value = getBaseLUN()
        }
    } else {
        C.lunAndAccess.visibility = "collapse";
        C.portLabel.visibility = "collapse";
        C.ports.visibility = "collapse";
        C.lun.disable = true;
        C.access.disable = true;
        C.ports.disable = true
    }
    C.modifyMapButton.disable = false;
    if (this.wasMapped) {
        C.doMapText.text = strings.mappingInput.wasMapped
    } else {
        C.doMapText.text = ""
    }
};
MappingInputWidget.prototype.changeDoMap = function(D) {
    var C = {
        doMap: {
            value: D
        }
    };
    this.doMapSettings(C);
    this.form.update(C);
    if (this.buttons) {
        this.buttons.update(C)
    }
    if (!this.doMap) {
        this.form.validate()
    }
};
MappingInputWidget.prototype.handleUpdate = function(D) {
    var C = {
        editMapForm: {},
        doMap: {
            value: this.options.multiVolume
        },
        ports: {
            value: "all"
        },
        lun: {
            value: "0"
        },
        access: {
            value: PORT_ACCESS.NO_ACCESS
        }
    };
    if (D.visibility != undefined) {
        C.editMapForm.visibility = D.visibility
    }
    if (D.disabled != undefined) {
        C.editMapForm.disable = D.disabled;
        this.disable(D.disabled)
    }
    if (D.ports != undefined) {
        C.ports = D.ports
    }
    if (D.lun != undefined) {
        C.lun = D.lun;
        if (D.lun.value && D.lun.value == "base") {
            C.lun.value = getBaseLUN()
        }
    }
    if (D.access != undefined) {
        C.access = D.access
    }
    if (D.applyAlways != undefined) {
        this.applyAlways = D.applyAlways
    }
    this.wasMapped = D.wasMapped;
    if (D.doMap != undefined && D.doMap.value != undefined) {
        C.doMap = D.doMap;
        this.doMapSettings(C)
    }
    this.form.update(C);
    if (this.buttons) {
        this.buttons.update(C)
    }
    this.savePorts = D.ports || [];
    this.form.validate()
};
MappingInputWidget.prototype.retrieve = function(D, C) {
    if (this.name && D) {
        var E = {};
        if (!this.doMap) {
            E.valid = true;
            E.doMap = {
                value: false
            }
        } else {
            this.form.retrieve(E, C);
            if (E.editMapForm) {
                E.valid = E.editMapForm.valid;
                delete E.editMapForm
            }
        }
        if (D.access) {
            delete D.access
        }
        if (D.ports) {
            delete D.ports
        }
        if (D.lun) {
            delete D.lun
        }
        if (D.editMapForm) {
            delete D.editMapForm
        }
        D[this.name] = E
    }
};
MappingInputWidget.prototype.setVisibility = function(C) {
    this.update({
        editMapForm: {
            visibility: C
        },
        ports: {
            visibility: ((C == "visible" && this.doMap) ? "visible" : "collapse")
        }
    })
};

function FileUploadWidget(E) {
    if (arguments.length == 0 || !E.name || !E.action) {
        return
    }
    this.inputName = E.name;
    this.formName = (E.name + "Form");
    this.submitName = (E.name + "Submit");
    this.errorDivID = E.name + "ErrDiv";
    this.errorContainerID = E.name + "Errs";
    this.inProcess = false;
    this.valueChanged = false;
    this.action = E.action;
    E.size = E.size || 50;
    E.submitText = E.submitText || strings.fileUpload.submitText;
    E.processingMsg = E.processingMsg || strings.fileUpload.processingMsg;
    E.successMsg = E.successMsg || strings.fileUpload.successMsg;
    E.failureMsg = E.failureMsg || strings.fileUpload.failureMsg;
    E.completedMsg = E.completedMsg || strings.fileUpload.completedMsg;
    var D = {};
    $.extend(D, E);
    D.name = this.inputName;
    D.changeCallback = createObjectCallback(this, this.filenameChanged);
    delete E.label;
    E.htmlText = '<div><table class="tableWidget" border="0" cellpadding="0" cellspacing="0"><tbody class="widgetContainer"></tbody></table></div>';
    var C = this;
    E.widgets = [new FormWidget({
        name: C.formName,
        row: 0,
        col: 0,
        htmlText: '<form id="' + C.formName + '" method="POST" action="' + E.action + '" enctype="multipart/form-data" class="widgetContainer formWidget"><div id="' + C.errorDivID + '" class="formErrDiv" style="display: none"><p>' + strings.form.errTitle + '</p><ul id="' + C.errorContainerID + '"></ul></div></form>',
        data: {},
        tableLayout: true,
        defaultSubmit: true,
        widgets: [new FileInputWidget(D)]
    })];
    if (!E.noButton) {
        E.widgets.push(new ButtonContainer({
            name: E.name + "bc",
            row: 0,
            col: 1,
            orientation: "horizontal",
            alignment: "right",
            widgets: [new ButtonWidget({
                name: C.submitName,
                text: E.submitText,
                disable: true,
                click: createObjectCallback(C, C.uploadFile)
            })]
        }))
    }
    TableWidget.call(this, E);
    this.class_name = "FileUploadWidget";
    this.form$ = $("#" + this.formName, this.elements);
    if (E.value) {
        this.handleUpdate(E)
    }
}
FileUploadWidget.prototype = new TableWidget();
FileUploadWidget.prototype.update = function(C) {
    if (!this.options.noButton && C[this.name] && C[this.name].disable != undefined) {
        if (C[this.submitName] == undefined) {
            C[this.submitName] = {}
        }
        C[this.submitName].disable = C[this.name].disable
    }
    TableWidget.prototype.update.call(this, C)
};
FileUploadWidget.prototype.filenameChanged = function(D, E) {
    var C = false;
    if (D[this.name].value == "") {
        C = true
    } else {
        this.valueChanged = true
    }
    if (!this.options.noButton) {
        var F = {};
        F[this.submitName] = {
            disable: C
        };
        this.update(F)
    }
    if (this.options.changeCallback && $.isFunction(this.options.changeCallback)) {
        this.options.changeCallback(D, E)
    }
};
FileUploadWidget.prototype.uploadFile = function() {
    applicationAccessed();
    if (this.options.resetAction && $.isFunction(this.options.resetAction)) {
        var D = this.options.resetAction();
        if (D) {
            this.action = D;
            this.form$.attr("action", this.action)
        }
    }
    this.inProcess = true;
    var C = {};
    this.retrieve(C);
    if (!C[this.formName].valid) {
        MC.warningOutput("Invalid fileName in FileUploadWidget, aborting upload.");
        return
    }
    if (this.options.startingCallback && $.isFunction(this.options.startingCallback)) {
        if (!this.options.startingCallback(C[this.inputName].value, this.action)) {
            MC.infoOutput("Aborted file upload to do false return from startingCallback function.");
            return
        }
    }
    if (MC.memorex) {
        MC.warningOutput("Offline, would have executed action: " + this.action);
        if (!this.options.noProcessingDialog) {
            ShowActiveDialog({
                type: "processing",
                message: "Simulating: " + this.options.processingMsg + "<br/>" + this.action
            })
        }
        setTimeout(createObjectCallback(this, this.finished), 2000);
        return
    } else {
        MC.warningOutput("executing action: " + this.action);
        var C = new FormData(this.form$[0]);
        $.ajax({
            url: this.action,
            data: C,
            contentType: false,
            processData: false,
            method: "POST",
            headers: {
                sessionkey: session.getSessionKey()
            },
            success: createObjectCallback(this, function(E) {
                this.finished(E)
            })
        });
        if (!this.options.noProcessingDialog) {
            ShowActiveDialog({
                type: "processing",
                message: this.options.processingMsg
            })
        }
    }
};
FileUploadWidget.prototype.finished = function(F) {
    if (!this.inProcess) {
        return
    }
    this.inProcess = false;
    var E = null;
    var D = null;
    if (F) {
        if (F.xmlStandalone || (F.firstChild && F.firstChild.firstChild && F.firstChild.firstChild.firstChild && (F.firstChild.firstChild.firstChild.nodeType == 1))) {
            E = F.firstChild;
            if (E) {
                D = new APIData(E)
            }
        } else {
            MC.warningOutput("Got unrecognized response from file upload")
        }
    }
    if (!D) {
        D = new APIData([new APIStatus([APIProp.fromObject({
            name: "response",
            value: strings.fileUpload.completedMsg
        }), APIProp.fromObject({
            name: "response_type",
            value: "Success"
        }), APIProp.fromObject({
            name: "response_type_numeric",
            value: "0"
        }), APIProp.fromObject({
            name: "return_code",
            value: 0
        })], {
            basetype: "status",
            name: "status"
        }, 2)])
    }
    if (!this.options.noCompletedDialog) {
        var G = {
            type: "success",
            message: this.options.successMsg,
            dialogOverride: true
        };
        var C = parseInt(D.statusObject.getPropertyValue("response_type_numeric"));
        if (C) {
            G.type = "failure";
            G.message = strings.enhanceOn + this.options.failureMsg + strings.enhanceOff + "<br />" + D.statusObject.getPropertyValue("response")
        }
        ShowActiveDialog(G)
    }
    MC.updateSets(this.options.dataRefresh);
    if (this.options.finishedCallback && $.isFunction(this.options.finishedCallback)) {
        this.options.finishedCallback(F, D)
    }
};

function DateTimeInputWidget(F) {
    if (arguments.length == 0 || !F.name) {
        return
    }
    this.name = F.name;
    this.startDate = (F.name + "StartDate");
    this.endDate = (F.name + "EndDate");
    this.startTime = (F.name + "StartTime");
    this.endTime = (F.name + "EndTime");
    var K = this;
    var D = (F.startLabel != undefined ? F.startLabel : strings.dateTimeInput.startLabel);
    var H = (F.startDateLabel != undefined ? F.startDateLabel : strings.dateTimeInput.startDateLabel);
    var C = (F.startTimeLabel != undefined ? F.startTimeLabel : strings.dateTimeInput.startTimeLabel);
    var G = [];
    if (D) {
        G.push(new LabelWidget({
            name: F.name + "sLabel",
            classes: "inline",
            value: D,
            noTerminator: F.noLabelTerm,
            rightMargin: true
        }))
    }
    if (H) {
        G.push(new LabelWidget({
            name: F.name + "sDateLbl",
            classes: "inline",
            value: H,
            noTerminator: F.noSubLabelTerm,
            rightSmallMargin: true
        }))
    }
    G.push(new DateInputWidget({
        name: K.startDate,
        classes: "inline",
        noHint: F.noHint,
        leftSmallMargin: true,
        rightSmallMargin: true,
        minDate: F.startMinDate ? F.startMinDate : null,
        maxDate: F.startMaxDate ? F.startMaxDate : null,
        changeCallback: createObjectCallback(this, this._fireChange),
        rules: {
            dhsdate: true
        }
    }));
    if (C) {
        G.push(new LabelWidget({
            name: F.name + "sTimeLbl",
            classes: "inline",
            value: C,
            leftSmallMargin: true,
            noTerminator: F.noSubLabelTerm,
            rightSmallMargin: true
        }))
    }
    G.push(new TimeInputWidget({
        name: K.startTime,
        classes: "inline",
        leftMargin: true,
        noHint: F.noHint,
        size: 8,
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    F.widgets = [new WidgetContainer({
        classes: "noWrap",
        widgets: G
    })];
    if (F.endWidget) {
        var I = [];
        var J = (F.endLabel != undefined ? F.endLabel : strings.dateTimeInput.endLabel);
        var E = (F.endDateLabel != undefined ? F.endDateLabel : strings.dateTimeInput.endDateLabel);
        var L = (F.endTimeLabel != undefined ? F.endTimeLabel : strings.dateTimeInput.endTimeLabel);
        if (J) {
            I.push(new LabelWidget({
                name: F.name + "eLabel",
                classes: "inline",
                value: J,
                noTerminator: F.noLabelTerm,
                rightMargin: true
            }))
        }
        if (E) {
            I.push(new LabelWidget({
                name: F.name + "eDateLbl",
                classes: "inline",
                value: E,
                noTerminator: F.noSubLabelTerm,
                rightSmallMargin: true
            }))
        }
        I.push(new DateInputWidget({
            name: K.endDate,
            classes: "inline",
            leftMargin: true,
            noHint: F.noHint,
            rightSmallMargin: true,
            minDate: F.endMinDate ? F.endMinDate : null,
            maxDate: F.endMaxDate ? F.endMaxDate : null,
            changeCallback: createObjectCallback(this, this._fireChange),
            rules: {
                dhsdate: true
            }
        }));
        if (L) {
            I.push(new LabelWidget({
                name: F.name + "eTimeLbl",
                classes: "inline",
                value: L,
                noTerminator: F.noSubLabelTerm,
                rightSmallMargin: true
            }))
        }
        I.push(new TimeInputWidget({
            name: K.endTime,
            noHint: F.noHint,
            classes: "inline",
            changeCallback: createObjectCallback(this, this._fireChange)
        }));
        F.widgets.push(new WidgetContainer({
            classes: "noWrap",
            topMargin: true,
            widgets: I
        }))
    }
    WidgetContainer.call(this, F);
    this.class_name = "DateTimeInputWidget";
    this.handleUpdate(F)
}
DateTimeInputWidget.prototype = new WidgetContainer();
DateTimeInputWidget.prototype.constructor = DateTimeInputWidget;
DateTimeInputWidget.prototype._flagChange = function(D) {
    this.valueChanged = false;
    for (var C in D) {
        if (D[C].valueChanged == true) {
            this.valueChanged = true
        }
    }
};
DateTimeInputWidget.prototype._fireChange = function(F, D, E) {
    if (this.ignoreFireChange && !E) {
        return
    }
    var C = {};
    this.retrieve(C);
    this._flagChange(C);
    if ($.isFunction(this.options.changeCallback)) {
        if (this.name) {
            if (!C[this.name]) {
                C[this.name] = {}
            }
            C[this.name].valueChanged = this.valueChanged
        }
        this.options.changeCallback(C, this, E)
    }
};
DateTimeInputWidget.prototype.update = function(F) {
    if (F == undefined || F[this.name] == undefined) {
        return
    }
    var C = F[this.name];
    var E = {};
    E[this.startDate] = {};
    E[this.endDate] = {};
    E[this.startTime] = {};
    E[this.endTime] = {};
    if (C.startValue) {
        E[this.startDate].value = C.startValue;
        E[this.startTime].value = C.startValue;
        if (C.setOrig) {
            E[this.startDate].setOrig = C.setOrig;
            E[this.startTime].setOrig = C.setOrig
        }
        if (C.unsetOrig) {
            E[this.startDate].unsetOrig = C.unsetOrig;
            E[this.startTime].unsetOrig = C.unsetOrig
        }
    }
    if (C.endValue) {
        E[this.endDate].value = C.endValue;
        E[this.endTime].value = C.endValue;
        if (C.setOrig) {
            E[this.endDate].setOrig = C.setOrig;
            E[this.endTime].setOrig = C.setOrig
        }
        if (C.unsetOrig) {
            E[this.endDate].unsetOrig = C.unsetOrig;
            E[this.endTime].unsetOrig = C.unsetOrig
        }
    }
    if (C.disable != undefined) {
        E[this.startDate].disable = C.disable;
        E[this.startTime].disable = C.disable;
        E[this.endDate].disable = C.disable;
        E[this.endTime].disable = C.disable
    }
    this.ignoreFireChange = true;
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].update(E)
    }
    this.ignoreFireChange = false;
    this._fireChange()
};
DateTimeInputWidget.prototype.retrieve = function(E) {
    for (var D = 0; D < this.widgets.length; D++) {
        this.widgets[D].retrieve(E)
    }
    E[this.name] = {
        startTextValue: "",
        endTextValue: ""
    };
    E[this.name].valueChanged = false;
    if (E[this.startDate] != undefined & E[this.startTime] != undefined && E[this.startDate].value != undefined & E[this.startTime].value != undefined) {
        var C = new Date(E[this.startDate].value.getTime());
        var F = E[this.startTime].value;
        C.setHours(F.getHours());
        C.setMinutes(F.getMinutes());
        C.setSeconds(0);
        C.setMilliseconds(0);
        E[this.name].startValue = C;
        E[this.name].startTextValue = E[this.startDate].textValue + " " + E[this.startTime].textValue;
        if (E[this.startDate].valueChanged || E[this.startTime].valueChanged) {
            E[this.name].valueChanged = true
        }
        delete E[this.startDate];
        delete E[this.startTime]
    }
    if (E[this.endDate] != undefined & E[this.endTime] != undefined && E[this.endDate].value != undefined & E[this.endTime].value != undefined) {
        var C = new Date(E[this.endDate].value.getTime());
        var F = E[this.endTime].value;
        C.setHours(F.getHours());
        C.setMinutes(F.getMinutes());
        C.setSeconds(0);
        C.setMilliseconds(0);
        E[this.name].endValue = C;
        E[this.name].endTextValue = E[this.endDate].textValue + " " + E[this.endTime].textValue;
        if (E[this.endDate].valueChanged || E[this.endTime].valueChanged) {
            E[this.name].valueChanged = true
        }
        delete E[this.endDate];
        delete E[this.endTime]
    }
};

function ScheduleInputWidget(E) {
    if (arguments.length == 0) {
        return
    }
    this.name = E.name;
    var C = createObjectCallback(this, this._fireChange);
    var D = new MCDate();
    this.valueChanged = false;
    this.names = {};
    this.names.startDateTime = E.name + "_startDateTime";
    this.names.repeat = E.name + "_repeat";
    this.names.repeatCount = E.name + "_repeatCount";
    this.names.repeatPeriod = E.name + "_repeatPeriod";
    this.names.repeatInputs = E.name + "_repeatInputs";
    this.names.end = E.name + "_end";
    this.names.ending = E.name + "_ending";
    this.names.endDateTime = E.name + "_endDateTime";
    this.names.endCount = E.name + "_endCount";
    this.names.timeConstraint = E.name + "_timeConstraint";
    this.names.betweenStart = E.name + "_betweenStart";
    this.names.betweenEnd = E.name + "_betweenEnd";
    this.names.dateConstraint = E.name + "_dateConstraint";
    this.names.only = E.name + "_only";
    this.names.dayChoice1 = E.name + "_dayChoice1";
    this.names.periodChoice1 = E.name + "_periodChoice1";
    this.names.dayChoice2 = E.name + "_dayChoice2";
    this.names.dayNumber = E.name + "_dayNumber";
    this.names.periodChoice2 = E.name + "_periodChoice2";
    E.widgets = [new WidgetContainer({
        name: E.name + "_startingDiv",
        classes: "noWrap",
        bottomMargin: true,
        widgets: [new DateTimeInputWidget({
            name: this.names.startDateTime,
            noHint: true,
            noSubLabelTerm: true,
            endLabel: "",
            startDateLabel: strings.schedule.onLabel,
            startTimeLabel: strings.schedule.atLabel,
            classes: "inlineBlock",
            changeCallback: C
        })]
    }), new WidgetContainer({
        name: E.name + "_repeatDiv",
        classes: "noWrap",
        bottomMargin: true,
        widgets: [new CheckboxInputWidget({
            name: this.names.repeat,
            classes: "inline",
            label: strings.schedule.repeatLabel,
            rightMargin: true,
            changeCallback: createObjectCallback(this, this._repeatChange)
        }), new TextInputWidget({
            name: this.names.repeatCount,
            classes: "inline",
            size: 3,
            maxLength: 3,
            label: strings.schedule.everyLabel,
            rules: {
                isNumber: true
            },
            rightSmallMargin: true,
            changeCallback: C
        }), new ComboBoxWidget({
            name: this.names.repeatPeriod,
            classes: "inline ARLeftSmallMargin",
            width: 50,
            values: [{
                value: "minutes",
                text: strings.schedule.minutes
            }, {
                value: "hours",
                text: strings.schedule.hours
            }, {
                value: "days",
                text: strings.schedule.days
            }, {
                value: "weeks",
                text: strings.schedule.weeks
            }, {
                value: "months",
                text: strings.schedule.months
            }, {
                value: "years",
                text: strings.schedule.years
            }],
            changeCallback: C
        })]
    }), new WidgetContainer({
        name: this.names.repeatInputs,
        widgets: [new WidgetContainer({
            name: E.name + "_repeatParams",
            bottomSmallMargin: true,
            widgets: [new TableWidget({
                name: E.name + "_repeatParamsTable",
                widgets: [new CheckboxInputWidget({
                    name: this.names.end,
                    row: 0,
                    col: 0,
                    classes: "inline",
                    cellClasses: "verticalTop",
                    singleCell: true,
                    label: strings.schedule.endLabel,
                    rightMargin: true,
                    changeCallback: createObjectCallback(this, this._endChange)
                }), new RadioButtonsInputWidget({
                    name: this.names.ending,
                    row: 0,
                    col: 1,
                    cellClasses: "schedEnd",
                    changeCallback: createObjectCallback(this, this._endingChange),
                    value: "specific",
                    values: [{
                        value: "specific",
                        text: strings.schedule.onLabel,
                        widget: new DateTimeInputWidget({
                            name: this.names.endDateTime,
                            classes: "inlineBlock ARLeftSmallMargin",
                            startLabel: "",
                            startDateLabel: "",
                            startTimeLabel: strings.schedule.atLabel,
                            noHint: true,
                            noSubLabelTerm: true,
                            startMinDate: D,
                            startValue: D,
                            changeCallback: C
                        })
                    }, {
                        value: "count",
                        text: strings.schedule.afterLabel,
                        widget: new WidgetContainer({
                            name: E.name + "_endCountDiv",
                            classes: "inlineBlock ARLeftSmallMargin",
                            widgets: [new TextInputWidget({
                                name: this.names.endCount,
                                size: 4,
                                maxLength: 4,
                                rules: {
                                    required: true,
                                    isNumber: true,
                                    range: [1, 9999]
                                },
                                classes: "inline",
                                leftSmallMargin: true,
                                rightSmallMargin: true,
                                changeCallback: C
                            }), new LabelWidget({
                                classes: "inline",
                                value: strings.schedule.occurrencesLabel
                            })]
                        })
                    }]
                })]
            })]
        }), new WidgetContainer({
            name: E.name + "_timeConstraintDiv",
            classes: "noWrap",
            bottomMargin: true,
            widgets: [new WidgetContainer({
                bottomMargin: true,
                widgets: [new CheckboxInputWidget({
                    name: this.names.timeConstraint,
                    classes: "inline",
                    label: strings.schedule.timeConstraintLabel,
                    changeCallback: createObjectCallback(this, this._timeConstraintChange)
                })]
            }), new LabelWidget({
                classes: "inline",
                value: strings.schedule.betweenLabel,
                noTerminator: true,
                rightSmallMargin: true,
                leftMargin: true
            }), new TimeInputWidget({
                name: this.names.betweenStart,
                noHint: true,
                classes: "inline",
                leftSmallMargin: true,
                rightSmallMargin: true,
                changeCallback: C
            }), new LabelWidget({
                classes: "inline",
                value: strings.schedule.andLabel,
                noTerminator: true,
                leftSmallMargin: true,
                rightSmallMargin: true
            }), new TimeInputWidget({
                name: this.names.betweenEnd,
                leftSmallMargin: true,
                noHint: true,
                classes: "inline",
                changeCallback: C
            })]
        }), new WidgetContainer({
            name: E.name + "_dateConstraintDiv",
            classes: "noWrap",
            bottomMargin: true,
            widgets: [new TableWidget({
                name: E.name + "_dateConstraintTable",
                widgets: [new CheckboxInputWidget({
                    name: this.names.dateConstraint,
                    row: 0,
                    col: 0,
                    classes: "inline",
                    cellClasses: "verticalTop",
                    singleCell: true,
                    label: strings.schedule.dateConstraintLabel,
                    rightMargin: true,
                    changeCallback: createObjectCallback(this, this._dateConstraintChange)
                }), new LabelWidget({
                    row: 1,
                    col: 0,
                    value: strings.schedule.scheduleOn,
                    leftMargin: true,
                    noTerminator: true
                }), new RadioButtonsInputWidget({
                    name: this.names.only,
                    row: 1,
                    col: 1,
                    changeCallback: createObjectCallback(this, this._onlyChange),
                    value: "no-only",
                    values: [{
                        value: "onlyAny",
                        widget: new WidgetContainer({
                            name: E.name + "_dayChoice1Div",
                            classes: "inlineBlock",
                            widgets: [new ComboBoxWidget({
                                name: this.names.dayChoice1,
                                classes: "inline",
                                label: strings.schedule.anyLabel,
                                labelOptions: {
                                    rightSmallMargin: true
                                },
                                value: strings.schedule.day,
                                values: this.getDayValues(),
                                width: 80,
                                leftMargin: true,
                                rightSmallMargin: true,
                                changeCallback: C
                            }), new ComboBoxWidget({
                                name: this.names.periodChoice1,
                                classes: "inline",
                                label: strings.schedule.ofLabel,
                                labelOptions: {
                                    rightSmallMargin: true
                                },
                                value: strings.schedule.year,
                                values: this.getPeriodValues(),
                                width: 65,
                                changeCallback: C
                            })]
                        })
                    }, {
                        value: "onlyThe",
                        widget: new WidgetContainer({
                            name: E.name + "_dayChoice2Div",
                            classes: "inlineBlock",
                            widgets: [new ComboBoxWidget({
                                name: this.names.dayChoice2,
                                classes: "inline",
                                value: strings.schedule.day,
                                values: this.getDayValues(),
                                width: 80,
                                leftMargin: true,
                                rightSmallMargin: true,
                                changeCallback: C
                            }), new TextInputWidget({
                                name: this.names.dayNumber,
                                label: strings.schedule.numberLabel,
                                labelOptions: {
                                    rightSmallMargin: true
                                },
                                size: 3,
                                rules: {
                                    isNumber: true
                                },
                                classes: "inline",
                                rightSmallMargin: true,
                                changeCallback: C
                            }), new ComboBoxWidget({
                                name: this.names.periodChoice2,
                                label: strings.schedule.ofLabel,
                                labelOptions: {
                                    rightSmallMargin: true
                                },
                                classes: "inline",
                                value: strings.schedule.year,
                                values: this.getPeriodValues(),
                                width: 60,
                                changeCallback: C
                            })]
                        })
                    }]
                })]
            })]
        })]
    })];
    WidgetContainer.call(this, E);
    this.class_name = "ScheduleInputWidget"
}
ScheduleInputWidget.prototype = new WidgetContainer();
ScheduleInputWidget.prototype.constructor = ScheduleInputWidget;
ScheduleInputWidget.prototype.getDayValues = function() {
    return ([{
        value: "day",
        text: strings.schedule.day
    }, {
        value: "weekday",
        text: strings.schedule.weekday
    }, {
        value: "weekendday",
        text: strings.schedule.weekendday
    }, {
        value: "saturday",
        text: strings.schedule.saturday
    }, {
        value: "sunday",
        text: strings.schedule.sunday
    }, {
        value: "monday",
        text: strings.schedule.monday
    }, {
        value: "tuesday",
        text: strings.schedule.tuesday
    }, {
        value: "wednesday",
        text: strings.schedule.wednesday
    }, {
        value: "thursday",
        text: strings.schedule.thursday
    }, {
        value: "friday",
        text: strings.schedule.friday
    }])
};
ScheduleInputWidget.prototype.getPeriodValues = function() {
    return ([{
        value: "year",
        text: strings.schedule.year
    }, {
        value: "month",
        text: strings.schedule.month
    }, {
        value: "january",
        text: strings.schedule.january
    }, {
        value: "february",
        text: strings.schedule.february
    }, {
        value: "march",
        text: strings.schedule.march
    }, {
        value: "april",
        text: strings.schedule.april
    }, {
        value: "may",
        text: strings.schedule.may
    }, {
        value: "june",
        text: strings.schedule.june
    }, {
        value: "july",
        text: strings.schedule.july
    }, {
        value: "august",
        text: strings.schedule.august
    }, {
        value: "september",
        text: strings.schedule.september
    }, {
        value: "october",
        text: strings.schedule.october
    }, {
        value: "november",
        text: strings.schedule.november
    }, {
        value: "december",
        text: strings.schedule.december
    }])
};
ScheduleInputWidget.prototype.showing = function() {
    var C = {};
    this.update(C)
};
ScheduleInputWidget.prototype._setFromExpression = function(P) {
    var K = {};
    var U;
    var S;
    var E = P.split(/,/);
    var H, O, I, C;
    var G, L, R, M, J, F, N, V;
    var Q = {
        START: 1,
        EVERY: 2,
        BETWEEN: 3,
        ONLY: 4,
        COUNT: 5,
        EXPIRES: 6
    };
    K[this.names.startDateTime] = {
        disable: true
    };
    K[this.names.repeatCount] = {
        disable: true
    };
    K[this.names.repeatPeriod] = {
        disable: true
    };
    K[this.names.repeatInputs] = {
        disable: true,
        visibility: "collapse"
    };
    K[this.names.repeat] = {
        value: false,
        disable: false
    };
    K[this.names.timeConstraint] = {
        value: false
    };
    K[this.names.dateConstraint] = {
        value: false
    };
    K[this.names.end] = {
        value: false
    };
    K[this.names.endDateTime] = {
        disable: true
    };
    K[this.names.ending] = {
        disable: true
    };
    K[this.names.endDateTime] = {
        disable: true
    };
    K[this.names.endCount] = {
        disable: true
    };
    K[this.names.betweenStart] = {
        disable: true
    };
    K[this.names.betweenEnd] = {
        disable: true
    };
    K[this.names.only] = {
        disable: true
    };
    for (var W = 0; W < E.length; W++) {
        var D = E[W].match(/^(S[^,]+)|(Ev[^,]+)|(B[^,]+)|(O[^,]+)|(Co[^,]+)|(Ex[^,]+)/);
        for (var T in Q) {
            if (D[Q[T]] !== undefined && D[Q[T]] !== "") {
                switch (Q[T]) {
                    case Q.START:
                        G = D[Q[T]].split(/\s/);
                        L = G[1].split("-");
                        R = G[2].split(":");
                        H = new Date(L[0], (L[1] - 1), L[2], R[0], R[1], R[2]);
                        K[this.names.startDateTime] = {
                            startValue: H,
                            startTextValue: (G[1] + " " + G[2]),
                            disable: false
                        };
                        break;
                    case Q.EVERY:
                        M = D[Q[T]].split(/\s/);
                        K[this.names.repeat] = {
                            disable: false,
                            value: true,
                            valuechanged: false
                        };
                        K[this.names.repeatCount] = {
                            disable: false,
                            value: M[1],
                            valuechanged: false
                        };
                        K[this.names.repeatPeriod] = {
                            disable: false,
                            value: M[2].toLowerCase(),
                            valuechanged: false
                        };
                        K[this.names.repeatInputs] = {
                            disable: false,
                            visibility: "visible"
                        };
                        break;
                    case Q.BETWEEN:
                        J = D[Q[T]].split(/\s/);
                        R = J[1].split(":");
                        H = new Date(2001, 0, 1, R[0], R[1], R[2]);
                        R = J[3].split(":");
                        U = new Date(2001, 0, 1, R[0], R[1], R[2]);
                        K[this.names.timeConstraint] = {
                            value: true
                        };
                        K[this.names.betweenStart] = {
                            value: H,
                            disable: false
                        };
                        K[this.names.betweenEnd] = {
                            value: U,
                            disable: false
                        };
                        break;
                    case Q.ONLY:
                        F = D[Q[T]].split(/\s/);
                        K[this.names.dateConstraint] = {
                            value: true
                        };
                        K[this.names.only] = {
                            value: (D[Q[T]].indexOf("Any") >= 0) ? "onlyAny" : "onlyThe",
                            disable: false
                        };
                        if (D[Q[T]].indexOf("Any") >= 0) {
                            K[this.names.dayChoice1] = {
                                value: F[2].toLowerCase()
                            };
                            K[this.names.periodChoice1] = {
                                value: F[4].toLowerCase()
                            }
                        } else {
                            K[this.names.dayChoice2] = {
                                value: F[2].toLowerCase()
                            };
                            K[this.names.periodChoice2] = {
                                value: F[4].toLowerCase()
                            };
                            S = F[1].match(/\d+/);
                            if (S) {
                                K[this.names.dayNumber] = {
                                    value: S[0]
                                }
                            }
                        }
                        break;
                    case Q.COUNT:
                        N = D[Q[T]].split(/\s/);
                        K[this.names.end] = {
                            value: true
                        };
                        K[this.names.ending].disable = false;
                        K[this.names.ending].value = "count";
                        K[this.names.endDateTime].disable = false;
                        K[this.names.ending] = {
                            value: "count"
                        };
                        K[this.names.endCount] = {
                            value: N[1]
                        };
                        break;
                    case Q.EXPIRES:
                        V = D[Q[T]].split(/\s/);
                        L = V[1].split("-");
                        R = V[2].split(":");
                        H = new Date(L[0], (L[1] - 1), L[2], R[0], R[1], R[2]);
                        K[this.names.end] = {
                            value: true
                        };
                        K[this.names.ending] = {
                            value: "specific",
                            disable: false
                        };
                        K[this.names.endDateTime] = {
                            startValue: H,
                            disable: false
                        };
                        break;
                    default:
                        break
                }
                break
            }
        }
    }
    return K
};
ScheduleInputWidget.prototype._setDefaults = function(F) {
    var E = {};
    var C = new MCDate();
    var G = MCDate.clone(C);
    C.setTime(C.getTime() + (5 * 60 * 1000));
    G.setTime(G.getTime() + (10 * 60 * 1000));
    var D = new Date(1970, 0, 1, 0, 0, 0);
    if (F[this.names.startDataTime]) {
        if (F[this.names.startDateTime].startValue == undefined) {
            F[this.names.startDateTime].startValue = C
        }
        if (F[this.names.startDateTime].disable == undefined) {
            F[this.names.startDateTime].disable = false
        }
    } else {
        F[this.names.startDateTime] = {
            startValue: C,
            disable: false
        }
    }
    if (F[this.names.repeat]) {
        if (F[this.names.repeat].repeat.value == undefined) {
            F[this.names.repeat].repeat.value = false
        }
        if (F[this.names.repeat].repeat.disable == undefined) {
            F[this.names.repeat].repeat.disable = false
        }
    } else {
        F[this.names.repeat] = {
            value: false,
            disable: false
        }
    }
    if (F[this.names.repeatCount]) {
        if (F[this.names.repeatCount].value == undefined) {
            if (this.name == "repSchedule") {
                F[this.names.repeatCount].value = "60"
            } else {
                F[this.names.repeatCount].value = "1"
            }
        }
        if (F[this.names.repeatCount].disable == undefined) {
            F[this.names.repeatCount].disable = true
        }
    } else {
        if (this.name == "repSchedule") {
            F[this.names.repeatCount] = {
                value: "60",
                disable: true
            }
        } else {
            F[this.names.repeatCount] = {
                value: "1",
                disable: true
            }
        }
    }
    if (F[this.names.repeatPeriod]) {
        if (F[this.names.repeatPeriod].value == undefined) {
            if (this.name == "repSchedule") {
                F[this.names.repeatPeriod].value = "minutes"
            } else {
                F[this.names.repeatPeriod].value = "days"
            }
        }
        if (F[this.names.repeatPeriod].disable == undefined) {
            F[this.names.repeatPeriod].disable = true
        }
    } else {
        if (this.name == "repSchedule") {
            F[this.names.repeatPeriod] = {
                value: "minutes",
                disable: true
            }
        } else {
            F[this.names.repeatPeriod] = {
                value: "days",
                disable: true
            }
        }
    }
    if (F[this.names.repeatInputs]) {
        if (F[this.names.repeatInputs].visibility == undefined) {
            F[this.names.repeatInputs].visibility = "hidden"
        }
        if (F[this.names.repeatInputs].disable == undefined) {
            F[this.names.repeatInputs].disable = true
        }
    } else {
        F[this.names.repeatInputs] = {
            visibility: "hidden",
            disable: true
        }
    }
    if (F[this.names.end]) {
        if (F[this.names.end].value == undefined) {
            F[this.names.end].value = false
        }
    } else {
        F[this.names.end] = {
            value: false
        }
    }
    if (F[this.names.ending]) {
        if (F[this.names.ending].value == undefined) {
            F[this.names.ending].value = "specific"
        }
    } else {
        F[this.names.ending] = {
            value: "specific"
        }
    }
    if (F[this.names.endDateTime]) {
        if (F[this.names.endDateTime].startValue == undefined) {
            F[this.names.endDateTime].startValue = G
        }
    } else {
        F[this.names.endDateTime] = {
            startValue: G
        }
    }
    if (F[this.names.endCount]) {
        if (F[this.names.endCount].value == undefined) {
            F[this.names.endCount].value = "1"
        }
    } else {
        F[this.names.endCount] = {
            value: "1"
        }
    }
    if (F[this.names.timeConstraint]) {
        if (F[this.names.timeConstraint].value == undefined) {
            F[this.names.timeConstraint].value = false
        }
    } else {
        F[this.name.timeConstraint] = {
            value: false
        }
    }
    if (F[this.names.betweenStart]) {
        if (F[this.names.betweenStart].value == undefined) {
            F[this.names.betweenStart].value = D
        }
    } else {
        F[this.names.betweenStart] = {
            value: D
        }
    }
    if (F[this.names.betweenEnd]) {
        if (F[this.names.betweenEnd].value == undefined) {
            F[this.names.betweenEnd].value = D
        }
    } else {
        F[this.names.betweenEnd] = {
            value: D
        }
    }
    if (F[this.names.dateConstraint]) {
        if (F[this.names.dateConstraint].value == undefined) {
            F[this.names.dateConstraint].value = false
        }
    } else {
        F[this.names.dateConstraint] = {
            value: false
        }
    }
    if (F[this.names.only]) {
        if (F[this.names.only].value == undefined) {
            F[this.names.only].value = "onlyAny"
        }
    } else {
        F[this.names.only] = {
            value: "onlyAny"
        }
    }
    if (F[this.names.dayChoice1]) {
        if (F[this.names.dayChoice1].value == undefined) {
            F[this.names.dayChoice1].value = "day"
        }
    } else {
        F[this.names.dayChoice1] = {
            value: "day"
        }
    }
    if (F[this.names.periodChoice1]) {
        if (F[this.names.periodChoice1].value == undefined) {
            F[this.names.periodChoice1].value = "year"
        }
    } else {
        F[this.names.periodChoice1] = {
            value: "year"
        }
    }
    if (F[this.names.dayNumber]) {
        if (F[this.names.dayNumber].value == undefined) {
            F[this.names.dayNumber].value = "1"
        }
    } else {
        F[this.names.dayNumber] = {
            value: "1"
        }
    }
    if (F[this.names.dayChoice2]) {
        if (F[this.names.dayChoice2].value == undefined) {
            F[this.names.dayChoice2].value = "day"
        }
    } else {
        F[this.names.dayChoice2] = {
            value: "day"
        }
    }
    if (F[this.names.periodChoice2]) {
        if (F[this.names.periodChoice2].value == undefined) {
            F[this.names.periodChoice2].value = "year"
        }
    } else {
        F[this.names.periodChoice2] = {
            value: "year"
        }
    }
};
ScheduleInputWidget.prototype.update = function(D) {
    var E = {};
    if (D[this.name] && D[this.name].value) {
        E = this._setFromExpression(D.scheduleWidget.value);
        this.disabled = false;
        $.extend(true, D, E)
    }
    if (D[this.name] && D[this.name].disable != undefined) {
        this._setDefaults(D);
        if (D[this.name].disable === false) {
            delete D[this.name].disable;
            this.disabled = false
        } else {
            delete D[this.names.startDateTime].disable;
            delete D[this.names.repeat].disable;
            D[this.names.repeatInputs] = {
                visibility: "hidden"
            };
            this.disabled = true
        }
    }
    if (D[this.name]) {
        if (D[this.name].setOrig) {
            for (var C in this.names) {
                if (D[this.names[C]]) {
                    D[this.names[C]].setOrig = true
                }
            }
        } else {
            if (D[this.name].unsetOrig) {
                for (var C in this.names) {
                    if (D[this.names[C]]) {
                        D[this.names[C]].unsetOrig = true
                    }
                }
            }
        }
    }
    WidgetContainer.prototype.update.call(this, D);
    this._flagChange(D)
};
ScheduleInputWidget.prototype.disable = function(D) {
    var C = {};
    C[this.name] = {
        disable: D
    };
    this.update(C);
    InputWidget.prototype.disable.call(this, D)
};
ScheduleInputWidget.prototype._flagChange = function(D) {
    this.valueChanged = false;
    for (var C in D) {
        if (D[C].valueChanged == true) {
            this.valueChanged = true
        }
    }
};
ScheduleInputWidget.prototype._fireChange = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    this._flagChange(C);
    if (F[D.name]) {
        if ($.isFunction(this.options.changeCallback)) {
            if (this.name) {
                if (!C[this.name]) {
                    C[this.name] = {}
                }
                C[this.name].valueChanged = this.valueChanged
            }
            this.options.changeCallback.call(this, C, this, E)
        }
    }
};
ScheduleInputWidget.prototype._repeatChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.end] = {
        value: false
    };
    C[this.names.timeConstraint] = {
        value: false
    };
    C[this.names.dateConstraint] = {
        value: false
    };
    C[this.names.repeatCount] = {
        disable: true
    };
    C[this.names.repeatPeriod] = {
        disable: true
    };
    C[this.names.repeatInputs] = {
        visibility: "hidden",
        disable: true
    };
    if (F[this.names.repeat].value) {
        C[this.names.repeatInputs].visibility = "visible";
        C[this.names.repeatCount].disable = false;
        C[this.names.repeatPeriod].disable = false;
        C[this.names.end] = {
            disable: false
        };
        C[this.names.endDateTime] = {
            disable: true
        };
        C[this.names.endCount] = {
            disable: true
        };
        C[this.names.timeConstraint].disable = false;
        C[this.names.dateConstraint].disable = false
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype._endChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.ending] = {
        disable: true
    };
    C[this.names.endDateTime] = {
        disable: true
    };
    C[this.names.endCount] = {
        disable: true
    };
    if (F[this.names.end].value) {
        C[this.names.ending].disable = false;
        C[this.names.ending].value = "specific";
        C[this.names.endDateTime].disable = false
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype._endingChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.endDateTime] = {
        disable: true
    };
    C[this.names.endCount] = {
        disable: true
    };
    if (F[this.names.ending].value == "specific") {
        C[this.names.endDateTime].disable = false
    } else {
        if (F[this.names.ending].value == "count") {
            C[this.names.endCount].disable = false
        }
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype._onlyChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.dayChoice1] = {
        disable: true
    };
    C[this.names.periodChoice1] = {
        disable: true
    };
    C[this.names.dayChoice2] = {
        disable: true
    };
    C[this.names.dayNumber] = {
        disable: true
    };
    C[this.names.periodChoice2] = {
        disable: true
    };
    if (F[this.names.only].value == "onlyAny") {
        C[this.names.dayChoice1].disable = false;
        C[this.names.periodChoice1].disable = false
    } else {
        if (F[this.names.only].value == "onlyThe") {
            C[this.names.dayChoice2].disable = false;
            C[this.names.dayNumber].disable = false;
            C[this.names.periodChoice2].disable = false
        }
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype._timeConstraintChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.betweenStart] = {
        disable: true
    };
    C[this.names.betweenEnd] = {
        disable: true
    };
    if (F[this.names.timeConstraint].value) {
        C[this.names.betweenStart].disable = false;
        C[this.names.betweenEnd].disable = false
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype._dateConstraintChange = function(F, D, E) {
    if (!this.widgets) {
        return
    }
    var C = {};
    C[this.names.only] = {
        disable: true
    };
    if (F[this.names.dateConstraint].value) {
        C[this.names.only].disable = false;
        C[this.names.only].value = "onlyAny";
        C[this.names.dayChoice2] = {
            disable: true
        };
        C[this.names.dayNumber] = {
            disable: true
        };
        C[this.names.periodChoice2] = {
            disable: true
        }
    }
    this.update(C);
    this._fireChange(F, D, E)
};
ScheduleInputWidget.prototype.numberedPostfix = function(E) {
    var D = parseInt(E, 10);
    var C = D % 100;
    if (C > 20) {
        C = C % 10
    }
    if (C == 0 || C >= 4) {
        return D + "th"
    }
    if (C == 1) {
        return D + "st"
    }
    if (C == 2) {
        return D + "nd"
    }
    return D + "rd"
};
ScheduleInputWidget.prototype.scheduleExpression = function(D) {
    var C = "start";
    if (D[this.names.startDateTime]) {
        C += " " + D[this.names.startDateTime].startTextValue
    }
    if (D[this.names.repeat] && D[this.names.repeat].value) {
        C += ", every";
        if (D[this.names.repeatCount]) {
            C += " " + D[this.names.repeatCount].value
        }
        if (D[this.names.repeatPeriod]) {
            C += " " + D[this.names.repeatPeriod].value
        }
    }
    if (D[this.names.timeConstraint] && D[this.names.timeConstraint].value) {
        C += ", between";
        if (D[this.names.betweenStart]) {
            C += " " + D[this.names.betweenStart].textValue + " and"
        }
        if (D[this.names.betweenEnd]) {
            C += " " + D[this.names.betweenEnd].textValue
        }
    }
    if (D[this.names.dateConstraint] && D[this.names.dateConstraint].value) {
        if (D[this.names.only].value == "onlyAny") {
            C += ", only";
            if (D[this.names.dayChoice1]) {
                C += " any " + D[this.names.dayChoice1].value + " of"
            }
            if (D[this.names.periodChoice1]) {
                C += " " + D[this.names.periodChoice1].value
            }
        } else {
            if (D[this.names.only].value == "onlyThe") {
                C += ", only";
                if (D[this.names.dayNumber]) {
                    C += " " + this.numberedPostfix(D[this.names.dayNumber].value)
                }
                if (D[this.names.dayChoice2]) {
                    C += " " + D[this.names.dayChoice2].value + " of"
                }
                if (D[this.names.periodChoice2]) {
                    C += " " + D[this.names.periodChoice2].value
                }
            }
        }
    }
    if (D[this.names.end] && D[this.names.end].value) {
        if (D[this.names.ending].value == "specific") {
            C += ", expires";
            if (D[this.names.endDateTime]) {
                C += " " + D[this.names.endDateTime].startTextValue
            }
        } else {
            if (D[this.names.ending].value == "count") {
                C += ", count";
                if (D[this.names.endCount]) {
                    C += " " + D[this.names.endCount].value
                }
            }
        }
    }
    return C
};
ScheduleInputWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        C[this.name] = {
            value: this.scheduleExpression(C)
        }
    }
};
ScheduleInputWidget.prototype.validateSchedule = function() {
    var F = {};
    this.retrieve(F);
    if (!F[this.names.startDateTime].disabled) {
        var E = F[this.names.startDateTime].startValue.getTime();
        var D = (new MCDate()).getTime();
        if (E < (D + 60000)) {
            ShowActiveDialog({
                type: "error",
                dialogOverride: "true",
                message: strings.schedule.invalidStartTime
            });
            return false
        }
        if (!F[this.names.endDateTime].disabled) {
            var C = F[this.names.endDateTime].startValue.getTime();
            if ((C - E) < 60000) {
                ShowActiveDialog({
                    type: "error",
                    dialogOverride: "true",
                    message: strings.schedule.invalidEndTime
                });
                return false
            }
        }
        if (this.options.repSchedule && !F[this.names.repeatCount].disabled) {
            if (F[this.names.repeatPeriod].value == "minutes" && (parseInt(F[this.names.repeatCount].value, 10) < 30)) {
                ShowActiveDialog({
                    type: "error",
                    dialogOverride: "true",
                    message: strings.schedule.invalidRepRecur
                });
                return false
            }
        }
    }
    return true
};

function SpaceMeter(D) {
    if (arguments.length == 0 || D.name == undefined) {
        return
    }
    var C = {
        labelClass: ""
    };
    $.extend(C, D);
    C.htmlText = '<div style="width:' + D.width + "px; height:" + D.height + 'px;" class="spaceMeterContainer">        <div class="spaceMeter"             style="overflow:visible;                    width:' + D.width + "px;                    height:" + D.height + 'px;">        </div></div>';
    Widget.call(this, C);
    this.class_name = "MeterBar";
    this.barElements$ = $("div.spaceMeter", this.elements);
    this.width = D.width;
    this.height = D.height;
    this.noText = D.noText;
    this.prec = ((D.prec == undefined) ? 1 : D.prec);
    this.handleUpdate(C)
}
SpaceMeter.prototype = new Widget();
SpaceMeter.prototype.constructor = SpaceMeter;
SpaceMeter.prototype.handleUpdate = function(C) {
    if (C == undefined || C.segments == undefined) {
        return
    }
    this.values = C;
    this.redrawGraph()
};
SpaceMeter.prototype.redrawGraph = function() {
    if (!this.values) {
        return
    }
    this.barElements$.html("");
    if (!this.values.segments || this.values.segments.length < 1) {
        return
    }
    var G = this.elements$.width();
    var C = this.elements$.height();
    if (G != this.width || C != this.height) {
        this.width = G;
        this.height = C;
        this.barElements$.css({
            width: this.width + "px",
            height: this.height + "px"
        })
    }
    var F = 0;
    if (this.values.total == undefined) {
        for (var E = 0; E < this.values.segments.length; E++) {
            if (this.values.segments[E].size instanceof Size) {
                F += this.values.segments[E].size.getBlocks()
            } else {
                F += this.values.segments[E].size
            }
        }
    } else {
        if (this.values.total instanceof Size) {
            F = this.values.total.getBlocks()
        } else {
            F = this.values.total
        }
    }
    var D = "";
    var H = this.height;
    if (this.values.lowerSegments) {
        if (this.values.total == undefined) {
            var I = 0;
            for (var E = 0; E < this.values.lowerSegments.length; E++) {
                if (this.values.lowerSegments[E].size instanceof Size) {
                    I += this.values.lowerSegments[E].size.getBlocks()
                } else {
                    I += this.values.lowerSegments[E].size
                }
            }
            if (I > F) {
                F = I
            }
        }
        H = parseInt(this.height / 2, 10);
        D += this._createSegments(this.values.lowerSegments, H, H, F)
    }
    if (F == 0) {
        return
    }
    D += this._createSegments(this.values.segments, 0, H, F);
    this.barElements$.html(D)
};
SpaceMeter.prototype._createSegments = function(I, E, H, K) {
    var D = 0;
    var M = 0;
    var C = "";
    var J = 0;
    var G = "";
    for (var F = 0; F < I.length; F++) {
        var L = I[F].size;
        if (L == undefined) {
            continue
        }
        if (L instanceof Size) {
            M = L.getBlocks();
            C = L.format("scale", this.prec)
        } else {
            M = L;
            C = "" + M
        }
        if (M == 0) {
            continue
        }
        J = parseInt(M / K * this.width, 10);
        G += this._meterSegment(I[F].cssClass, D, E, J, H, I[F].label, C);
        D += J
    }
    return G
};
SpaceMeter.prototype._meterSegment = function(R, H, I, D, Q, N, F) {
    var M = this.width;
    var P = "";
    M--;
    if ((H + D) >= M) {
        D = (M - H)
    }
    if (D <= 0) {
        return ""
    }
    var O = N + ": " + F;
    if (!this.noText && N) {
        P = O
    }
    var L = $(".spaceSeg").css("font-family");
    var E = $(".spaceSeg").css("font-size");
    var K = getTextWidth(P, (E + " " + L));
    var J = getTextWidth(N, (E + " " + L));
    var C = getTextWidth(F, (E + " " + L));
    if (K > D) {
        if (C < D) {
            P = F
        } else {
            if (J < D) {
                P = N
            } else {
                P = ""
            }
        }
    }
    var G = "";
    if (H == 0) {
        G = " spaceSegFirst"
    }
    return '<div title="' + O + '" class="spaceSeg ' + R + G + '"style="width:' + D + "px; height:" + Q + "px; line-height:" + Q + "px; left:" + H + "px; top:" + I + 'px;">' + P + "</div>"
};

function TableInator(J) {
    if (arguments.length == 0 || !J.name) {
        return
    }
    if (!TableInator.Initialized) {
        $.fn.dataTableExt.aoFeatures.push({
            fnInit: createObjectCallback(this, TableInator._createTableButtons),
            cFeature: "C",
            sFeature: "ClearFilters"
        });
        TableInator.Initialized = true
    } else {
        $.fn.dataTableExt.aoFeatures[0].fnInit = createObjectCallback(this, TableInator._createTableButtons)
    }
    var E = J.name;
    var G = $("table#" + J.name + ".tableInator");
    if (G && G.length > 0) {
        MC.errorOutput("Attempt to create TableInator with duplicate name: " + J.name);
        E += "X"
    }
    var D = "tableInator";
    if (J.classes) {
        D += " " + J.classes
    }
    var I = J.captionClass || "tableInatorCaption";
    this.errorListID = E + "Terrs";
    J.htmlText = '<div><ul id="' + this.errorListID + '" class="tableErrDiv" style="display: none"></ul><table id="' + E + '" class="' + D + '" align="left" border="0" cellspacing="0" cellpadding="0">' + (J.caption ? '<caption class="' + this.captionClass + '">' + J.caption + "</caption>" : "") + "<tbody></tbody></table></div>";
    if (J.hoverPanel) {
        J.hoverSelector = "TR"
    }
    Widget.call(this, J);
    this.class_name = "TableInator";
    this.dataTable$ = $(".tableInator", this.elements);
    this.title$ = $("." + I, this.elements);
    if (!J.dtOptions) {
        J.dtOptions = {}
    }
    if (J.noFeatures) {
        J.dtOptions.bFilter = false;
        J.dtOptions.bLengthChange = false;
        J.dtOptions.bInfo = false;
        J.dtOptions.bPaginate = false;
        J.dtOptions.bSort = false
    }
    this.dtOptions = {
        oLanguage: strings.dataTables,
        aLengthMenu: [
            [10, 20, 30, 40, 50, -1],
            [10, 20, 30, 40, 50, strings.All]
        ],
        bAutoWidth: false,
        sBasetype: J.rawBasetype,
        fnInfoCallback: createObjectCallback(this, this._infoCallback),
        fnDrawCallback: createObjectCallback(this, this._drawCallback),
        fnRowCallback: createObjectCallback(this, this._rowCallback),
        fnFilterCallback: createObjectCallback(this, this._filteredCallback)
    };
    if (J.dtOptions.bDeferRender == undefined) {
        this.dtOptions.bDeferRender = true
    }
    if (J.emptyTableString != undefined) {
        this.dtOptions.oLanguage = $.extend(true, [], strings.dataTables);
        this.dtOptions.oLanguage.sEmptyTable = J.emptyTableString
    }
    if (J.scrollY) {
        this.dtOptions.sScrollY = J.scrollY + "px";
        this.dtOptions.bPaginate = false
    }
    this.topFeatures = "";
    if (J.dtOptions && (J.dtOptions.bFilter === false || J.dtOptions.bFilter === "noControls")) {
        this.topFeatures += ""
    } else {
        if (J.dtOptions && J.dtOptions.bFilter === "noInput") {
            this.topFeatures += "C"
        } else {
            this.topFeatures += "fC"
        }
    }
    this.topFeatures += ((J.dtOptions && J.dtOptions.bLengthChange === false) ? "" : "l");
    this.topFeatures += ((J.dtOptions && J.dtOptions.bInfo === false) ? "" : "i");
    this.topFeatures += ((J.dtOptions && J.dtOptions.bPaginate === false) ? "" : "p");
    this.bottomFeatures = "";
    var F = ((this.topFeatures == "") ? "" : '<"tableInatorUpper"' + this.topFeatures + ">");
    var H = ((this.bottomFeatures == "") ? "" : '<"tableInatorLower"' + this.bottomFeatures + ">");
    if (J.editCallback) {
        delete J.selectable;
        this.editedCallback = createObjectCallback(this, this._cellTextEdited);
        this.textInput$ = $('<input id="TcellTextInput" name="TcellTextInput" type="text" value=""></input>');
        this.textInput$.on("keypress focusout", this.editedCallback);
        this.selectInput$ = $('<select id="TcellSelectInput" size="1"></select>');
        this.selectInput$.on("keypress focusout click", this.editedCallback)
    }
    var C = "tableInatorDiv";
    if (J.selectable) {
        C += " selectable"
    }
    this.dtOptions.sDom = '<"tableInatorOuter"' + F + '<"' + C + '"t>' + H + ">";
    $.extend(this.dtOptions, J.dtOptions);
    this.selectCallback = createObjectCallback(this, this._rowSelect);
    this.editingCallback = createObjectCallback(this, this._editCell);
    this.selected = [];
    this.lastSelected = [];
    this.columns = {};
    this.numColumns = 0;
    this.handleUpdate(J)
}
TableInator.prototype = new Widget();
TableInator.prototype.constructor = TableInator;
TableInator.createFilters = function(L, F, C, G) {
    if (!L || !F || !C) {
        return {}
    }
    var D = "";
    if (L.length > 0) {
        D += "/";
        for (var I = 0; I < L.length; I++) {
            var J = L[I];
            if (J.basetype == F) {
                var H = DC.base[F][J.key];
                if (H) {
                    var K = H.get(C);
                    if (K) {
                        if (D != "/") {
                            D += "|"
                        }
                        D += K
                    }
                }
            }
        }
        D += "/"
    }
    var E = {};
    E[G] = D;
    return E
};
TableInator._createTableButtons = function(G) {
    var E = G.oInstance;
    var D = [G.clearFiltersButton = new ButtonWidget({
        name: "clearFiltersButton",
        classes: "dataTables_clearFilter",
        text: strings.clearFilters,
        callback: function() {
            E.fnFilter("");
            for (var H = 0; H < G.aoColumns.length; H++) {
                E.fnFilter("", H);
                var I = $("span.colFilter", G.aoColumns[H].nTh);
                if (I) {
                    I.removeClass("colFilter_on colFilter_off").addClass("colFilter_off")
                }
            }
        }
    })];
    switch (this.name) {
        case "tVolumesVolumes":
        case "tHostsInits":
        case "tHostsMaps":
        case "tVolumesMaps":
        case "tMapsMaps":
        case "tPoolsPools":
        case "tPoolsDiskGroups":
        case "tPoolsDisks":
        case "tVolumesSnaps":
        case "repsTopicPeerTable":
        case "repsTopicRepSetTable":
            var F = detectBrowser();
            if (F.ie) {
                var C = (typeof navigator.msSaveBlob != "undefined" ? true : false)
            } else {
                var C = ("download" in document.createElement("a") ? true : false)
            }
            D.push(new ButtonWidget({
                name: "exportCSVButton",
                classes: "dataTables_clearFilter",
                text: strings.exportCSVLabel,
                disable: (C ? false : true),
                tooltip: (C ? "" : strings.browserNotSupported),
                callback: createObjectCallback(this, function() {
                    var H = NAV._getPanel("DownloadCSVAction");
                    H.csvObj = {
                        name: this.name,
                        selected: this.selected
                    };
                    panels.actionDialog.open({
                        panel: H,
                        height: H.options.height,
                        width: H.options.width
                    })
                })
            }));
            break;
        default:
            break
    }
    G.tableButtons = new ButtonContainer({
        name: "tablebc",
        orientation: "horizontal",
        widgets: D
    });
    return G.tableButtons.elements
};
TableInator.selectsEquivalent = function(D, C) {
    if (D.length != C.length) {
        return false
    }
    for (var F = 0; F < D.length; F++) {
        var G = false;
        for (var E = 0; E < C.length; E++) {
            if (D[F].equals(C[E])) {
                G = true;
                break
            }
        }
        if (!G) {
            return false
        }
    }
    return true
};
TableInator.prototype._init = function() {
    if (this.dataTable) {
        return
    }
    var C = this.options;
    if (!C.type || !C.metadata) {
        MC.errorOutput("TableInator.init(): No type or no metadata!");
        return
    }
    if (C.type == "apiData" || C.type == "dcCollection") {
        if (C.metadata instanceof APIObject) {
            this.metaObject = C.metadata
        } else {
            if (!meta[C.metadata]) {
                MC.errorOutput("TableInator.init(): apiData requires basetype metadata!");
                return
            }
            this.metaObject = meta[C.metadata]
        }
        if (!(this.metaObject instanceof APIObject)) {
            MC.errorOutput("TableInator.init(): no metadata found for basetype: %s!", C.metadata);
            return
        }
        var J = 0;
        this.dtOptions.aoColumns = [];
        if (C.fields && C.fields instanceof Array) {
            for (var F = 0; F < C.fields.length; F++) {
                var H = C.fields[F];
                var E = this.metaObject.prop[H].attr.sortType;
                if (decodeBooleanFlag(this.metaObject.prop[H].attr.sort)) {
                    J = F
                }
                var K = this.metaObject.prop[H];
                var I = "";
                if (K.attr.editable) {
                    if (K.attr.editable instanceof Array || $.isFunction(K.attr.editable)) {
                        I = "selectable"
                    } else {
                        I = "editable"
                    }
                }
                var D = {
                    mDataProp: "prop." + H + ".text",
                    sTitle: K.text,
                    bSortable: (E == "nosort" ? false : true),
                    fnRender: this._getRenderer(F, H),
                    sType: E,
                    editable: K.attr.editable,
                    sClass: I,
                    bFilterMenu: true
                };
                if (C.columnOverrides && C.columnOverrides[H]) {
                    $.extend(D, C.columnOverrides[H])
                }
                this.dtOptions.aoColumns.push(D);
                this.numColumns++;
                this.columns[H] = F
            }
        } else {
            var F = 0;
            for (var H in this.metaObject.prop) {
                if (decodeBooleanFlag(this.metaObject.prop[H].attr.draw)) {
                    var E = this.metaObject.prop[H].attr.sortType;
                    if (decodeBooleanFlag(this.metaObject.prop[H].attr.sort)) {
                        J = F
                    }
                    var K = this.metaObject.prop[H];
                    var I = "";
                    if (K.attr.editable) {
                        if (K.attr.editable instanceof Array || $.isFunction(K.attr.editable)) {
                            I = "selectable"
                        } else {
                            I = "editable"
                        }
                    }
                    var D = {
                        mDataProp: "prop." + H + ".text",
                        sTitle: K.text,
                        bSortable: (E == "nosort" ? false : true),
                        fnRender: this._getRenderer(F, H),
                        sType: E,
                        editable: K.attr.editable,
                        sClass: I,
                        bFilterMenu: true
                    };
                    if (C.columnOverrides && C.columnOverrides[H]) {
                        $.extend(D, C.columnOverrides[H])
                    }
                    this.dtOptions.aoColumns.push(D);
                    this.numColumns++;
                    this.columns[H] = F;
                    F++
                }
            }
        }
        if (!this.dtOptions.aaSorting) {
            this.dtOptions.aaSorting = [
                [J, "asc"]
            ]
        }
    } else {
        if (C.type == "apiObject") {
            if (C.metadata instanceof APIObject) {
                this.metaObject = C.metadata
            } else {
                if (!meta[C.metadata]) {
                    MC.errorOutput("TableInator.init(): apiData requires basetype metadata!");
                    return
                }
                this.metaObject = meta[C.metadata]
            }
            if (!(this.metaObject instanceof APIObject)) {
                MC.errorOutput("TableInator.init(): no metadata found for basetype: %s!", C.metadata);
                return
            }
            this.dtOptions.sDom = '<"tableInatorOuter"<"tableInatorDiv"t>>';
            this.dtOptions.bFilter = false;
            this.dtOptions.bLengthChange = false;
            this.dtOptions.bInfo = false;
            this.dtOptions.bPaginate = false;
            this.dtOptions.bSort = false;
            this.dtOptions.aoColumns = [{
                sTitle: strings.PropertyTitle,
                bSortable: false,
                sType: "string"
            }, {
                sTitle: strings.ValueTitle,
                bSortable: false,
                sType: "string"
            }];
            this.numColumns = 2;
            this.columns[0] = "property";
            this.columns[1] = "value"
        } else {
            if (C.type == "rawData") {
                if (!C.metadata instanceof Array) {
                    MC.errorOutput("TableInator.init(): rawData requires aoColumns array metadata!");
                    return
                }
                for (var F = 0; F < C.metadata.length; F++) {
                    var I = "";
                    if (C.metadata[F].editable) {
                        if (C.metadata[F].editable instanceof Array || $.isFunction(C.metadata[F].editable)) {
                            I = "selectable"
                        } else {
                            I = "editable"
                        }
                    }
                    if (C.metadata[F].sClass) {
                        C.metadata[F].sClass += I
                    } else {
                        C.metadata[F].sClass = I
                    }
                    if (typeof C.metadata[F].fnRender == "undefined") {
                        C.metadata[F].fnRender = this._getRenderer(F)
                    }
                }
                this.dtOptions.aoColumns = C.metadata;
                this.numColumns = C.metadata.length
            } else {
                MC.errorOutput("TableInator.init(): Invalid type: %s", C.type)
            }
        }
    }
    this.dataTable = this.dataTable$.dataTable(this.dtOptions);
    if (C.editCallback) {
        $("tbody", this.elements).on("click", "td.editable,td.selectable", this.editingCallback)
    } else {
        if (C.selectable) {
            $("tbody", this.elements).on("mousedown", "tr", this.selectCallback)
        }
    }
    var G = detectBrowser();
    if (G.ie) {
        $("#" + this.options.name, this.elements).mousedown(function(M) {
            if (M.ctrlKey || M.shiftKey) {
                this.onselectstart = function() {
                    return false
                };
                var L = this;
                window.setTimeout(function() {
                    L.onselectstart = null
                }, 0)
            }
        })
    }
    this.dataTableOuter$ = $(".tableInatorOuter", this.elements);
    if (C.width) {
        this.dataTableOuter$.width(C.width);
        this.dataTableOuter$.find(".tableInator").width(C.width)
    }
    if (C.minWidth) {
        this.dataTableOuter$.css("min-width", C.minWidth + "px");
        this.dataTableOuter$.find(".tableInator").css("min-width", C.minWidth + "px")
    }
};
TableInator.prototype.destroy = function() {
    if (this.dataTable) {
        this.dataTable.fnDestroy();
        delete this.dataTable
    }
};
TableInator.prototype._getRenderer = function(D, G) {
    var F = null;
    if (this.options.intercepts) {
        for (var E = 0; E < this.options.intercepts.length; E++) {
            var C = this.options.intercepts[E];
            if (((typeof C.selector) == "number" && C.selector == D) || ((typeof C.selector) == "string" && C.selector == G)) {
                F = C.renderer;
                break
            }
        }
    }
    if (!F) {
        if (this.metaObject && this.metaObject.prop[G].renderer) {
            F = this.metaObject.prop[G].renderer
        }
    }
    return F
};
TableInator.prototype.handleUpdate = function(C) {
    if (!this.dataTable) {
        this._init()
    }
    var L = false;
    if (C.criteria || C.displayLength) {
        var G = this.dataTable.fnSettings();
        if (C.criteria) {
            this.dtOptions.oCriteria = C.criteria;
            G.oFeatures.oCriteria = this.dtOptions.oCriteria
        }
        if (C.displayLength) {
            this.dtOptions.iDisplayLength = C.displayLength;
            G._iDisplayLength = this.dtOptions.iDisplayLength;
            if (G.nLengthSelect$) {
                G.nLengthSelect$.val(this.dtOptions.iDisplayLength)
            }
        }
        L = true
    }
    if (C.data) {
        this.dataTable.fnClearTable(($.isEmptyObject(C.data) || C.data.length == 0) ? true : false);
        var H = [];
        if (this.options.type == "apiData") {
            if (C.data.length > 0 && C.data[0] instanceof APIObject) {
                H = C.data
            }
        } else {
            if (this.options.type == "dcCollection") {
                for (var M in C.data) {
                    H.push(C.data[M])
                }
            } else {
                if (this.options.type == "apiObject") {
                    if (C.data instanceof APIObject) {
                        if (C.fields && C.fields instanceof Array) {
                            for (var I = 0; I < C.fields.length; I++) {
                                H.push([this.metaObject.prop[C.fields[I]].text, C.data.prop[C.fields[I]].text])
                            }
                        } else {
                            for (var J in C.data.prop) {
                                if (decodeBooleanFlag(this.metaObject.prop[J].attr.draw)) {
                                    H.push([this.metaObject.prop[J].text, C.data.prop[J].text])
                                }
                            }
                        }
                    }
                } else {
                    H = C.data
                }
            }
        }
        this.lastSelected = [];
        this.dataTable.fnAddData(H, false);
        L = true;
        this.errorCount = 0
    }
    if (C.filters) {
        var F;
        var E;
        for (var D in C.filters) {
            E = -1;
            if (D == "global") {
                E = null
            } else {
                if (!isNaN(D)) {
                    E = parseInt(D, 10)
                } else {
                    if (this.columns[D] != undefined) {
                        E = this.columns[D]
                    }
                }
            }
            if (E != -1) {
                var K = C.filters[D];
                if (K.charAt(0) == "/" && K.charAt(K.length - 1) == "/") {
                    var K = K.substr(1, K.length - 2);
                    this.dataTable.fnFilter(K, E, true, false)
                } else {
                    this.dataTable.fnFilter(K, E)
                }
            }
        }
        L = true
    }
    if (C.select) {
        this.pendingSelect = C.select;
        L = true
    } else {
        if (C.data) {
            this.selected = [];
            this.pendingSelect = this.selected
        }
    }
    if (C.selectable != undefined) {
        this.options.selectable = C.selectable
    }
    if (L) {
        this.dataTable.fnAdjustColumnSizing(false);
        if (C.redraw && C.redraw == keepCurrentPage) {
            this.dataTable.fnUpdate(null, null, null, C.redraw, null)
        } else {
            this.dataTable.fnDraw(true)
        }
    }
};
TableInator.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].selected = $.extend(true, [], this.selected)
    }
};
TableInator.prototype.getData = function(E, D) {
    var C = E;
    if (E instanceof DCRef) {
        C = $(E.makeID(this.name), this.dataTable$).get(0)
    }
    return this.dataTable.fnGetData(C, D)
};
TableInator.prototype.getVisibleRows = function() {
    return this.dataTable.fnGetData().length
};
TableInator.prototype.addData = function(C, D) {
    return this.dataTable.fnAddData(C, D)
};
TableInator.prototype.updateData = function(D, E, C, F) {
    return this.dataTable.fnUpdate(D, E, C, F)
};
TableInator.prototype.getNumVisibleRows = function() {
    var C = this.dataTable.fnGetData();
    return C.length
};
TableInator.prototype._infoCallback = function(I, F, E, D, H, C) {
    var J = "";
    var G = "";
    if (H < D) {
        J = strings.dataTables.sInfoFiltered(D);
        if (I.clearFiltersButton) {
            I.clearFiltersButton.handleUpdate({
                disable: false
            })
        }
    } else {
        if (I.clearFiltersButton) {
            I.clearFiltersButton.handleUpdate({
                disable: true
            })
        }
    }
    if (this.selected.length > 0) {
        G = strings.dataTables.sSelected(this.selected.length)
    }
    if (session.sessionPreferences.locale == "Japanese" && this.elements$.width() < 800) {
        return ""
    } else {
        if (this.elements$.width() < 800) {
            return strings.dataTables.sInfo(F, E, H)
        } else {
            if (session.sessionPreferences.locale == "Japanese") {
                return strings.dataTables.sInfo(F, E, H) + G
            } else {
                return strings.dataTables.sInfo(F, E, H) + J + G
            }
        }
    }
};
TableInator.prototype._filteredCallback = function(G) {
    var D = G.aoData;
    var C = G.aiDisplay;
    var F = false;
    for (var E = 0; E < D.length; E++) {
        if (C.find(E) == -1) {
            if (D[E]._aData.DT_isSelected) {
                F = this._unselectRow(E) || F
            }
        }
    }
    this.lastSelected.empty();
    if (F && this.options.selectCallback) {
        this.options.selectCallback(this.selected.slice(0))
    }
};
TableInator.prototype._drawCallback = function(C) {
    if (this.dataTable) {
        if (this.pendingSelect) {
            if (this.pendingSelect instanceof Array || this.pendingSelect instanceof DCRef) {
                this.selectRows(this.pendingSelect, true)
            } else {
                if (this.pendingSelect === "reselect") {
                    this.selectRows(this.selected, true)
                }
            }
            delete this.pendingSelect
        }
    }
};
TableInator.prototype._rowCallback = function(F, E, D, C) {
    if (E.DT_isSelected) {
        $(F).addClass("row_selected")
    }
    return F
};
TableInator.prototype._editCell = function(O) {
    if (!O.currentTarget) {
        return
    }
    if (this.editCell) {
        return
    }
    var U = this.dataTable.fnSettings();
    var N = $(O.currentTarget);
    var J = this.dataTable.fnGetPosition(O.currentTarget);
    var K = J[0];
    var G = J[2];
    var V = this.dataTable.fnGetData(K, G);
    var Q = N.outerWidth();
    var P = N.outerHeight();
    var S = U.aoColumns[G].editable;
    if (!S) {
        return
    }
    this.editCell = {
        row: K,
        col: G,
        oldData: V,
        td$: N
    };
    if (!this.inputParent$) {
        this.inputParent$ = this.dataTable$.closest(".tableInatorOuter")
    }
    $("#" + this.errorListID).empty();
    if ((S instanceof Array) || $.isFunction(S)) {
        if ($.isFunction(S)) {
            var E = S(K, G, V)
        } else {
            var E = S
        }
        if (E.length == 0) {
            delete this.editCell;
            return
        }
        var C = true;
        this.selectInput$.empty();
        this.editCell.attached$ = this.selectInput$.appendTo(this.inputParent$);
        this.editCell.input$ = this.selectInput$;
        this.editCell.input$.attr("size", E.length);
        for (var T = 0; T < E.length; T++) {
            this.editCell.input$.append('<option value="' + E[T] + '">' + E[T] + "</option>")
        }
        this.editCell.input$.attr("value", V)
    } else {
        if (S === "text" || (S instanceof Object && S.rules)) {
            var M = $('<form id="TcellForm"></form>');
            this.editCell.attached$ = M.appendTo(this.inputParent$);
            this.editCell.input$ = this.textInput$.appendTo(this.editCell.attached$);
            this.editCell.input$.prop("value", V);
            if (S instanceof Object) {
                this.editCell.validator = M.validate({
                    errorLabelContainer: "#" + this.errorListID,
                    errorClass: "inputInvalid",
                    rules: {
                        TcellTextInput: S.rules
                    }
                });
                if (this.editCell.validator.form()) {
                    this.editCell.valid = true
                } else {
                    this.editCell.valid = false
                }
                var H = N.attr("adjustMsg");
                if (H) {
                    $("#" + this.errorListID).append('<li class="inputAdjusted">' + H + "</li>").show()
                }
            }
        } else {
            MC.warningOutput("TableInator._editCell: Unknown editable type : %o", S);
            delete this.editCell;
            return
        }
    }
    var I = N.offset();
    Q -= (parseInt(this.editCell.input$.css("paddingLeft"), 10) + parseInt(this.editCell.input$.css("paddingRight"), 10) + 2);
    P -= (parseInt(this.editCell.input$.css("paddingTop"), 10) + parseInt(this.editCell.input$.css("paddingBottom"), 10) + 2);
    if (C) {
        var R = parseInt(this.editCell.input$.css("border-right-width"));
        Q -= R;
        this.editCell.input$.width(Q);
        var D = this.inputParent$.offset();
        var F = D.top + this.inputParent$.height();
        var L = this.editCell.input$.outerHeight();
        if ((I.top + L) > F) {
            I.top = I.top - L + P + 3
        }
    } else {
        this.editCell.input$.width(Q).height(P);
        this.editCell.input$.select()
    }
    this.editCell.input$.offset(I);
    this.editCell.input$.focus();
    N.addClass("editing");
    if ($.isFunction(this.options.editingCallback)) {
        this.options.editingCallback(true, this.editCell.row, this.editCell.col)
    }
};
TableInator.prototype.quitEditing = function() {
    if (this.editCell) {
        var C = {
            type: "focusout",
            currentTarget: {
                id: ""
            }
        };
        this._cellTextEdited(C)
    }
};
TableInator.prototype._cellTextEdited = function(K) {
    MC.debugOutput("TableInator._cellTextEdited");
    if (!this.editCell || this.inCellTextEdited) {
        MC.warningOutput("No cell being edited when TableInator._cellTextEdited called.");
        return true
    }
    if (K.type == "keypress" && K.keyCode == 13 && K.currentTarget.id == "TcellTextInput") {
        return false
    }
    this.inCellTextEdited = true;
    var F = this.errorCount;
    var H = false;
    var G = false;
    var L = this.editCell.input$.val();
    if (K.type == "focusout" || K.type == "click" || (K.type == "keypress" && (K.keyCode == 13 || K.keyCode == 9))) {
        K.type = "focusout";
        if (!L && K.currentTarget.id == "TcellSelectInput") {
            L = this.editCell.oldData
        }
        this.dataTable.fnUpdate(L, this.editCell.row, this.editCell.col, false);
        G = true;
        if (K.type == "keypress" && K.keyCode == 9) {
            H = true
        }
    } else {
        if (K.type == "keypress" && K.keyCode == 27) {
            this.dataTable.fnUpdate(this.editCell.oldData, this.editCell.row, this.editCell.col, false);
            G = true
        }
    }
    if (G) {
        var C = true;
        if (this.editCell.validator) {
            if (this.editCell.validator.form()) {
                if (!this.editCell.valid) {
                    this.errorCount--
                }
            } else {
                var C = false;
                if (this.editCell.valid) {
                    this.errorCount++
                }
            }
        }
        this.editCell.td$.removeClass("editing");
        this.editCell.attached$.detach();
        if ($.isFunction(this.options.editingCallback)) {
            this.options.editingCallback(false, this.editCell.row, this.editCell.col)
        }
        var J = false;
        if (L != this.editCell.oldData) {
            var I = this.dataTable.fnGetNodes(this.editCell.row);
            if ($.isFunction(this.options.editCallback)) {
                J = this.options.editCallback(this.editCell.row, this.editCell.col)
            }
            if (!J) {
                var E = this.getCellNode(this.editCell.row, this.editCell.col);
                var D = $(E).hasClass("inputInvalid");
                if (!C) {
                    if (!D) {
                        $(E).addClass("inputInvalid")
                    }
                } else {
                    if (D) {
                        $(E).removeClass("inputInvalid")
                    }
                }
            }
        }
        if (!J && H) {
            if (K.shiftKey) {
                var E = this.prevEditableCell(this.editCell.row, this.editCell.col)
            } else {
                var E = this.nextEditableCell(this.editCell.row, this.editCell.col)
            }
            if (E) {
                setTimeout(function() {
                    $(E).click()
                }, 10)
            }
        }
        delete this.editCell;
        if (F != this.errorCount) {
            if ($.isFunction(this.options.errorCallback)) {
                this.options.errorCallback(this.errorCount)
            }
        }
    }
    this.inCellTextEdited = false;
    return true
};
TableInator.prototype.removeRow = function(G) {
    var D = this.dataTable.fnSettings();
    var F = D.aoData;
    var E = F[G].nTr;
    var C = this.errorCount;
    this.errorCount -= $(".inputInvalid", E).length;
    this.dataTable.fnDeleteRow(G);
    if (C != this.errorCount) {
        if ($.isFunction(this.options.errorCallback)) {
            this.options.errorCallback(this.errorCount)
        }
    }
};
TableInator.prototype.nextEditableCell = function(F, I) {
    var H = this.dataTable.fnSettings();
    var E = H.aoColumns;
    if (I == undefined) {
        I = -1
    }
    if (F == undefined) {
        F = 0
    }
    var G = this._getDisplayRow(F);
    var D = -1;
    var J = -1;
    for (var C = 0; C < E.length; C++) {
        if (E[C].editable) {
            if (D == -1) {
                D = C
            }
            if (J == -1 && C > I) {
                J = C;
                break
            }
        }
    }
    if (J == -1) {
        J = D;
        G++
    }
    if (G < H.aiDisplay.length) {
        return this.getCellNode(G, J)
    }
    return null
};
TableInator.prototype.prevEditableCell = function(E, H) {
    var G = this.dataTable.fnSettings();
    aoColumns = G.aoColumns;
    if (H == undefined) {
        H = aoColumns.length
    }
    if (E == undefined) {
        var F = this.dataTable.fnGetNodes().length - 1
    }
    var F = this._getDisplayRow(E);
    var C = -1;
    var I = -1;
    for (var D = aoColumns.length - 1; D >= 0; D--) {
        if (aoColumns[D].editable) {
            if (C == -1) {
                C = D
            }
            if (I == -1 && D < H) {
                I = D;
                break
            }
        }
    }
    if (I == -1) {
        I = C;
        F--
    }
    if (F >= 0) {
        return this.getCellNode(F, I)
    }
    return null
};
TableInator.prototype.getErrorCount = function() {
    return (this.errorCount)
};
TableInator.prototype._getDisplayRow = function(E) {
    var C = this.dataTable.fnSettings().aiDisplay;
    for (var D = 0; D < C.length; D++) {
        if (C[D] == E) {
            return D
        }
    }
    return -1
};
TableInator.prototype._getDataRow = function(D) {
    var C = this.dataTable.fnSettings().aiDisplay;
    if (D < 0 || D > (C.length - 1)) {
        return -1
    }
    return C[D]
};
TableInator.prototype.getRefRow = function(F) {
    if (!(F instanceof DCRef)) {
        return -1
    }
    var H = F.makeID(this.name);
    var G = null;
    if (this.dataTable$.oApi._fnDetectType(H) !== "html") {
        var G = $(H, this.dataTable$).get(0)
    }
    if (G) {
        return this.dataTable.fnGetPosition(G)
    } else {
        var D = this.dataTable.fnSettings().aoData;
        for (var E = 0; E < D.length; E++) {
            var C = D[E]._aData;
            if (C.DT_RowId && ("#" + C.DT_RowId) == H) {
                return E
            } else {
                if (C.DT_RowId && ("#" + C.DT_RowId) == "#" + this.name + "_" + F.basetype + "_" + F.key) {
                    return E
                }
            }
        }
    }
    return -1
};
TableInator.prototype._rowSelect = function(C) {
    if (!C.currentTarget || !this.options.selectable) {
        return
    }
    var G = this._getSelectObjFromRow(C.currentTarget);
    if (G === null) {
        MC.warningOutput("TableInator(%s): Attempt to select row with no id", this.name);
        return
    }
    var F = this.dataTable.fnGetPosition(C.currentTarget);
    var D = false;
    var E = $(C.currentTarget).hasClass("row_selected");
    if (this.options.selectable == "single") {
        if (!E) {
            D = this._clearSelectAll();
            D = this._selectRow(F) || D
        } else {
            if ((onMac && C.metaKey) || C.ctrlKey) {
                if (E) {
                    D = this._unselectRow(F)
                }
            }
        }
    } else {
        if (C.which == 3) {
            return
        } else {
            if (C.shiftKey) {
                if (this.lastSelected.length > 0) {
                    D = this._clearSelectLast();
                    D = this._selectFromLast(F) || D
                } else {
                    D = this._clearSelectAll();
                    D = this._selectRow(F, true) || D
                }
            } else {
                if ((onMac && C.metaKey) || C.ctrlKey) {
                    if (E) {
                        D = this._unselectRow(F);
                        if (this.selected.length == 0) {
                            this.lastSelected = []
                        }
                    } else {
                        D = this._selectRow(F, true)
                    }
                } else {
                    if (!(E && this.selected.length == 1)) {
                        D = this._clearSelectAll();
                        D = this._selectRow(F, true) || D
                    }
                }
            }
        }
    }
    this.dataTable.oApi._fnUpdateInfo(this.dataTable.fnSettings());
    if (D && this.options.selectCallback) {
        this.options.selectCallback(this.selected.slice(0), C)
    }
};
TableInator.prototype._clearSelectAll = function() {
    if (this.selected.length == 0) {
        return false
    }
    var D = this.dataTable.fnSettings().aoData;
    for (var E = 0; E < D.length; E++) {
        var F = D[E].nTr;
        if (F) {
            $(F).removeClass("row_selected")
        }
        var C = D[E]._aData;
        D[E]._aData.DT_isSelected = false
    }
    this.selected.empty();
    this.lastSelected.empty();
    return true
};
TableInator.prototype._clearSelectLast = function() {
    if (this.lastSelected.length < 2) {
        return false
    }
    var D = this.lastSelected.length;
    for (var C = 1; C < D; C++) {
        this._unselectRow(this._getDataRow(this.lastSelected[C]))
    }
    this.lastSelected.splice(1, (this.lastSelected.length - 1));
    return true
};
TableInator.prototype.sort = function(C) {
    if (C && C instanceof Array) {
        this.dataTable.fnSort(C)
    }
};
TableInator.prototype._selectRow = function(G, C) {
    var F = null;
    var E = null;
    var D = null;
    var H = null;
    if (G instanceof DCRef) {
        var F = this.getRefRow(G);
        if (F >= 0) {
            H = G;
            E = this.dataTable.fnGetNodes(F);
            D = this.dataTable.fnGetData(F)
        }
    } else {
        F = G;
        E = this.dataTable.fnGetNodes(F);
        D = this.dataTable.fnGetData(F);
        H = this._getSelectObjFromRow(E)
    }
    if (D && H) {
        if (E) {
            $(E).addClass("row_selected")
        }
        this.selected.push(H);
        D.DT_isSelected = true;
        if (C) {
            this.lastSelected = [this._getDisplayRow(F)]
        }
        return true
    }
    return false
};
TableInator.prototype._selectFromLast = function(H) {
    var D = false;
    var G = this._getDisplayRow(H);
    var F = this.lastSelected[0];
    if (F < G) {
        F++;
        var C = F;
        F = G;
        G = C
    } else {
        F--
    }
    for (var E = G; E <= F; E++) {
        D = this._selectRow(this._getDataRow(E)) || D;
        this.lastSelected.push(E)
    }
    return D
};
TableInator.prototype._unselectRow = function(E) {
    var D = this.dataTable.fnGetData(E);
    var C = this.dataTable.fnGetNodes(E);
    if (!D || !D.DT_isSelected) {
        return false
    }
    var F = null;
    if (D.DT_RowId) {
        F = DCRef.fromID(D.DT_RowId)
    }
    if (C) {
        $(C).removeClass("row_selected")
    }
    D.DT_isSelected = false;
    if (F) {
        this.selected.remove(F);
        return true
    }
    return false
};
TableInator.prototype._getSelectObjFromRow = function(C) {
    if (!C.id) {
        return null
    }
    return DCRef.fromID(C.id)
};
TableInator.prototype.selectRows = function(D, G) {
    if (!D) {
        return
    }
    if (D instanceof Array) {
        var E = D.slice(0)
    } else {
        var E = [D]
    }
    var H = this.selected.slice(0);
    this._clearSelectAll();
    if (D === "all") {
        var C = this.dataTable.fnSettings().fnRecordsDisplay();
        for (var F = 0; F < C; F++) {
            this._selectRow(F)
        }
    } else {
        for (var F = 0; F < E.length; F++) {
            if (E[F].basetype == "tiDisplayRow") {
                this._selectRow(this._getDataRow(E[F].key))
            } else {
                if (E[F].basetype == "tiDataRow") {
                    this._selectRow(E[F].key)
                } else {
                    this._selectRow(E[F])
                }
            }
        }
    }
    this.dataTable.oApi._fnUpdateInfo(this.dataTable.fnSettings());
    if (this.options.selectCallback && !TableInator.selectsEquivalent(H, this.selected)) {
        this.options.selectCallback(this.selected, (G ? false : true))
    }
};
TableInator.prototype.pageToRow = function(H) {
    var E = H;
    if (H instanceof DCRef) {
        E = this.getRefRow(H);
        if (E < 0) {
            return
        }
    }
    var I = this._getDisplayRow(E);
    if (I < 0) {
        return
    }
    var F = this.dataTable.fnSettings();
    var D = F._iDisplayLength;
    var C = F.fnRecordsDisplay();
    var G = Math.floor(I / D);
    this.dataTable.fnPageChange(G, true)
};
TableInator.prototype.addCellClass = function(E, D, C) {
    var F = this.getCellNode(E, D);
    if (F) {
        $(F).addClass(C)
    }
};
TableInator.prototype.removeCellClass = function(E, D, C) {
    var F = this.getCellNode(E, D);
    if (F) {
        $(F).removeClass(C)
    }
};
TableInator.prototype.cellAdjusted = function(E, C, D) {
    var F = this.getCellNode(E, C);
    if (F) {
        $(F).prop("title", D);
        $(F).attr("adjustMsg", D);
        if (D) {
            $(F).addClass("inputAdjusted")
        } else {
            $(F).removeClass("inputAdjusted")
        }
    }
};
TableInator.prototype.cellTooltip = function(E, C, D) {
    var F = this.getCellNode(E, C);
    if (F) {
        $(F).prop("title", D)
    }
};
TableInator.prototype.getCellNode = function(D, C) {
    return this.dataTable.fnGetTd(D, C)
};
TableInator.prototype._displayHover = function(E) {
    if (this.savedHoverEvent && !this.hoverTimeout) {
        return
    }
    if (!this.hoverDisabled) {
        var D = E.currentTarget;
        var G = this._getSelectObjFromRow(D);
        if (!G) {
            return
        }
        var C = null;
        var F = G.getObject();
        if (F) {
            C = APIObject.getHover(G.basetype)
        } else {
            F = G
        }
        if (this.options.hoverPanel instanceof HoverPanel) {
            C = this.options.hoverPanel
        }
        if (!C || !F) {
            return
        }
        panels.hoverDialog.open({
            parentObj: F,
            offsetElement$: $(D),
            eventObj: E,
            panel: C,
            height: C.options.height,
            width: C.options.width
        });
        this.savedHoverEvent = E;
        this.hoverObject$ = $(D);
        $(window).on("click", createObjectCallback(this, this._removeHover))
    }
};
TableInator.healthIntercept = function(E) {
    if (E.prop && E.prop.health_numeric) {
        var D = E.prop.health_numeric.text;
        var F = E.prop.health.text
    } else {
        if (E.aData && E.aData.prop && E.aData.prop.health_numeric) {
            var D = E.aData.prop.health_numeric.text;
            var F = E.aData.prop.health.text
        } else {
            return "Bad Intercept"
        }
    }
    switch (parseInt(D)) {
        case 0:
            var C = "healthOk";
            break;
        case 1:
            var C = "healthDegraded";
            break;
        case 2:
            var C = "healthBad";
            break;
        case 3:
        default:
            var C = "healthUnknown";
            break
    }
    return '<div class="healthStyle ' + C + '"><span class="healthText">' + F + "</span></div>"
};
TableInator.volumeGroupIntercept = function(D) {
    if (!D.aData.prop || !D.aData.prop.volume_group) {
        return "Bad Intercept"
    }
    var C = D.aData.prop.volume_group.text;
    var E = DC.volumeGroupsSerial[C];
    if (E) {
        return E.get("group_name")
    } else {
        return ""
    }
};
var keepCurrentPage = "keepPage";

function LabeledWidgetContainer(C) {
    if (arguments.length == 0) {
        return
    }
    C.singleCell = true;
    C.widgetContainer = (C.fitContent) ? '<div class="widgetContainer" style="width: fit-content"></div>' : '<div class="widgetContainer"></div>';
    C.htmlText = '<div class="labeledWidgetContainer"><div class="labeledWidgetContainerBox"><label>' + C.label + "</label></div>" + C.widgetContainer + "</div>";
    WidgetContainer.call(this, C);
    this.class_name = "LabeledWidgetContainer"
}
LabeledWidgetContainer.prototype = new WidgetContainer();
LabeledWidgetContainer.prototype.constructor = LabeledWidgetContainer;

function CheckboxContainer(C) {
    if (arguments.length == 0) {
        return
    }
    C.singleCell = true;
    C.htmlText = '<div class="checkboxContainer"><div class="checkboxContainerBox"><input id="' + C.name + '" name="' + C.name + '" type="checkbox" value="' + C.name + '" />' + (C.label ? '<label for="' + C.name + '" class="ARLeftMargin">' + C.label + "</label>" : "") + '</div><div class="widgetContainer"></div></div>';
    CheckboxInputWidget.call(this, C);
    this.class_name = "CheckboxContainer"
}
CheckboxContainer.prototype = new CheckboxInputWidget();
CheckboxContainer.prototype.constructor = CheckboxContainer;
CheckboxContainer.prototype.fireChange = function(F) {
    var E = this.getValue();
    for (var D = 0, C = this.widgets.length; D < C; D++) {
        if ($.isFunction(this.widgets[D]["disable"])) {
            this.widgets[D].executeDeep("disable", [!E])
        }
    }
    CheckboxInputWidget.prototype.fireChange.call(this, F)
};

function HealthWidget(C) {
    if (!C.name) {
        C.name = "HealthWidget"
    }
    C.htmlText = '<div class="healthWidget"><p class="healthWidgetItem"><span class="healthWidgetIcon">&nbsp;</span><span class="ARLeftSmallMargin healthWidgetText"></span></p><div class="healthWidgetSub1"></div></div>';
    WidgetContainer.call(this, C);
    this.class_name = "HealthWidget";
    this.icon$ = $(".healthWidgetIcon", this.elements);
    this.health$ = $(".healthWidgetText", this.elements);
    this.sub1$ = $(".healthWidgetSub1", this.elements);
    this.handleUpdate(C)
}
HealthWidget.prototype = new WidgetContainer();
HealthWidget.prototype.constructor = HealthWidget;
HealthWidget.prototype.handleUpdate = function(L) {
    if (!L.obj || !(L.obj instanceof APIObject)) {
        return
    }
    var F = L.obj.get("health");
    if (!F) {
        return
    }
    var K = L.obj.get("health_numeric");
    var I = HEALTH_CLASS[K] || "";
    this.icon$.removeClass("healthDegraded healthBad healthUnknown healthNA").addClass(I);
    this.health$.html(F);
    var G = L.obj.get("health_reason");
    if (K == "0" || (K == "4" && !G)) {
        this.sub1$.html("")
    } else {
        var D = L.obj.get("health_recommendation");
        var J = '<p class="healthWidgetItem"><label class="ARRightMargin">' + strings.healthWidget.reasonLabel + ':</label><br /><span class="healthWidgetData">' + G + "</span></p>";
        if (D) {
            J += '<p class="healthWidgetItem"><label class="ARRightMargin">' + strings.healthWidget.recommendLabel + ':</label><br /><span class="healthWidgetData">' + D + "</span></p>"
        }
        var M = "";
        var O;
        var H;
        var N = 5;
        var C = 0;
        for (var E = 0; E < L.obj.objects.length; E++) {
            O = L.obj.objects[E];
            if (O.basetype == "unhealthy-component") {
                C++;
                if (C <= N) {
                    H = O.get("component_id");
                    F = O.get("health");
                    G = O.get("health_reason");
                    D = O.get("health_recommendation");
                    M += '<p class="healthWidgetComp"><span>' + H + ' - </span><span class="healthWidgetHealth">' + F + '</span></p><p class="healthWidgetSubItem"><span class="healthWidgetData">' + G + '</span></p><p class="healthWidgetSubItem"><span class="healthWidgetData">' + D + "</span></p>"
                }
            }
        }
        if (M) {
            if (C > N) {
                M += '<p class="healthWidgetComp">' + strings.healthWidget.more(C - N) + "</p>"
            }
            J += '<p class="healthWidgetUnhealthy">' + strings.healthWidget.unhealthyLabel + "</p>";
            J += M
        }
        this.sub1$.html(J);
        if (panels.hoverDialog.currentOptions.width < 350) {
            panels.hoverDialog.currentOptions.width = 350
        }
    }
};

function TabWidget(F) {
    if (arguments.length == 0) {
        return
    }
    this.name = F.name;
    if (F.type == "Primary") {
        this.tabClasses = PrimaryTabClasses
    } else {
        if (F.type == "Secondary") {
            this.tabClasses = SecondaryTabClasses
        } else {
            this.tabClasses = TerciaryTabClasses
        }
    }
    this.tabs = F.tabs;
    var E = "";
    if (this.tabs && (this.tabs.length > 0)) {
        E += '<div style="display: block;"><ul class="' + this.tabClasses.navClass + '">';
        var D = this.tabs.length;
        for (var C = 0; C < D; C++) {
            E += '<li class="' + (this.tabs[C].disabled ? this.tabClasses.disabledClass : "") + '" tabindex="0">' + this.tabs[C].label + "</li>"
        }
        E += "</ul>";
        E += '<div class="' + this.tabClasses.panelClass + ' widgetContainer"></div></div>'
    }
    F.htmlText = E;
    WidgetContainer.call(this, F);
    this.class_name = "TabWidget";
    this.tabs$ = $("li", this.elements);
    this.tabs$.click(createObjectCallback(this, this.selecting));
    this.tabs$.on("keydown", createObjectCallback(this, this._keyDown));
    this.selected = null;
    this.select(this.tabs[0].name)
}
TabWidget.UNSELECT_ALL = 100;
TabWidget.prototype = new WidgetContainer();
TabWidget.prototype.constructor = TabWidget;
TabWidget.prototype.handleUpdate = function(D) {
    if (D) {
        if (D.value != undefined) {
            if (D.value < this.tabs.length) {
                this.select(this.tabs[D.value].name)
            } else {
                this.unselect()
            }
        } else {
            if (D && D.tab) {
                this.select(D.tab)
            }
        }
        if (D.tabs) {
            if (D.tabs.length == this.tabs.length) {
                for (var C = 0; C < D.tabs.length; C++) {
                    if (D.tabs[C].disabled) {
                        if (C != this.selected) {
                            this.disableTab(C)
                        }
                    } else {
                        this.enableTab(C)
                    }
                }
            }
        }
    }
};
TabWidget.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        if (!(C[this.name] instanceof Object)) {
            C[this.name] = {}
        }
        C[this.name].value = this.selected;
        C[this.name].tab = (this.selected != null) ? this.tabs[this.selected].name : "";
        C[this.name].label = (this.selected != null) ? this.tabs[this.selected].label : "";
        C[this.name].disabled = (this.selected != null) ? this.tabs[this.selected].disabled : null
    }
};
TabWidget.prototype.select = function(C) {
    var E = this.tabs.length;
    for (var D = 0; D < E; D++) {
        if (this.tabs[D].name == C) {
            var F = this.tabs$.eq(D);
            if (F.length) {
                F.click();
                return
            }
        }
    }
    this.unselect()
};
TabWidget.prototype.enableTab = function(C) {
    if (C < 0 || C >= this.tabs.length) {
        return
    }
    $(this.tabs$[C]).removeClass(this.tabClasses.disabledClass);
    delete this.tabs[C].disabled
};
TabWidget.prototype.disableTab = function(C) {
    if (C < 0 || C >= this.tabs.length) {
        return
    }
    $(this.tabs$[C]).addClass(this.tabClasses.disabledClass);
    this.tabs[C].disabled = true
};
TabWidget.prototype.unselect = function() {
    this.tabs$.removeClass(this.tabClasses.selectedClass);
    this.selected = null;
    this.fireChange(null)
};
TabWidget.prototype.selecting = function(G) {
    if (!G.target) {
        return
    }
    var E = $(G.target);
    var F = E.get(0);
    var D = this;
    var C = 0;
    E = this.tabs$.filter(function(H) {
        if (this == F) {
            if (D.tabs[H].disabled) {
                return false
            }
            C = H;
            return true
        }
        return false
    });
    if (E.length) {
        if (this.selected != null) {
            this.unselect()
        }
        E.addClass(this.tabClasses.selectedClass);
        this.selected = C;
        this.fireChange(C)
    }
};
TabWidget.prototype.fireChange = function(C) {
    if ($.isFunction(this.options.changeCallback)) {
        this.options.changeCallback.call(this, C)
    }
};
TabWidget.prototype._keyDown = function(C) {
    if (C.keyCode == 13) {
        this.selecting(C)
    }
};

function StepsWidget(J) {
    if (arguments.length == 0) {
        return
    }
    this.name = J.name;
    if (J.steps) {
        var F = J.steps.length;
        this.stepWidth = J.width / F;
        var C = (this.stepWidth / 2).toFixed(2);
        var H = (this.stepWidth * (F - 1)).toFixed(2);
        var D = (100 / F).toFixed(2);
        var G = '<div class="stepsContainer" style="width: ' + J.width + 'px">    <hr class="stepBar" style="width:' + H + "px; left: " + C + 'px">    <hr id="stepsCompleteBar" class="stepBar" style="left: ' + C + 'px; background: #000">';
        for (var E = 0; E < F; E++) {
            var I = J.steps[E];
            G += '<div class="stepHolder" style="width:' + D + '%"><div class="stepCircle">';
            if (J.numberedSteps) {
                G += '<span class="stepNumber">' + (E + 1) + "</span>"
            }
            G += '</div><span class="stepLabel">' + I.label + "</span></div>"
        }
        G += "</div>"
    }
    J.htmlText = G;
    WidgetContainer.call(this, J);
    this.class_name = "StepsWidget";
    this.steps$ = $(".stepCircle", this.elements);
    this.stepsComplete$ = $("#stepsCompleteBar", this.elements)
}
StepsWidget.prototype = new WidgetContainer();
StepsWidget.prototype.constructor = StepsWidget;
StepsWidget.prototype.nextStep = function() {
    if (this.currentStep > 0) {
        $(".stepCircleActive").removeClass("stepCircleActive").addClass("stepCircleComplete");
        $(".stepNumberActive").removeClass("stepNumberActive").addClass("stepNumberComplete");
        var E = (this.stepWidth * this.currentStep).toFixed(2);
        this.stepsComplete$.css("width", E + "px")
    }
    var C = this.steps$.eq(this.currentStep);
    var D = $(".stepNumber", C);
    C.addClass("stepCircleActive");
    D.addClass("stepNumberActive");
    this.currentStep += 1
};
StepsWidget.prototype.showing = function() {
    this.currentStep = 0;
    this.nextStep()
};

function VerticalTabWidget(F) {
    if (arguments.length == 0) {
        return
    }
    this.name = F.name;
    this.tabClasses = {
        active: "vertTabActive",
        tab: "vertTab",
        borderBottom: "vertTabBorderBottom",
        borderTop: "vertTabBorderTop",
        borderRight: "vertTabBorderRight"
    };
    this.tabs = F.tabs;
    F.widgets = [new WidgetContainer({
        name: "tabWidgets",
        classes: "vertTabContent",
        widgets: F.widgets
    })];
    var E = "";
    if (this.tabs && (this.tabs.length > 0)) {
        E += '<div class="vertTabContainer"><div style="display: inline-block;height: inherit;"><ul class="vertTabHolder">';
        var D = this.tabs.length;
        for (var C = 0; C < D; C++) {
            E += '<li class="vertTab" tabindex="' + C + '"><div class="vertTabLabelContainer vertTabBorderRight"><div id="' + this.tabs[C].name + '" class="vertTabLabel">' + this.tabs[C].label + "</div></div></li>"
        }
        E += "</ul></div></div>"
    }
    F.htmlText = E;
    WidgetContainer.call(this, F);
    this.class_name = "VerticalTabWidget";
    this.selectedIndex = null;
    this.contentHolder$ = $("#vertTabContent", this.elements);
    this.tabs$ = $(".vertTab", this.elements);
    this.tabs$.click(createObjectCallback(this, this.selecting));
    this.select(this.tabs[0].name)
}
VerticalTabWidget.prototype = new WidgetContainer();
VerticalTabWidget.prototype.constructor = VerticalTabWidget;
VerticalTabWidget.prototype.setLabelRequired = function(C) {
    var D = $("#" + C).text();
    if (D.charAt(D.length - 1) != "*") {
        $("#" + C).append('&nbsp;<span style="font-size: 15px;" class="requiredIndicator">*</span>')
    }
};
VerticalTabWidget.prototype.setLabelComplete = function(C) {
    $(".requiredIndicator", "#" + C).remove();
    if ($("#" + C).find(".completed").length == 0) {
        $("#" + C).append('&nbsp;<div class="completed"></div>')
    }
};
VerticalTabWidget.prototype.select = function(C) {
    var E = this.tabs.length;
    for (var D = 0; D < E; D++) {
        if (this.tabs[D].name == C) {
            var F = this.tabs$.eq(D);
            if (F.length) {
                F.click();
                return
            }
        }
    }
    this.unselect()
};
VerticalTabWidget.prototype.selecting = function(G) {
    if (!G.target) {
        return
    }
    var F = $(G.target).closest("li")[0];
    var D = this;
    var C = 0;
    target$ = this.tabs$.filter(function(H) {
        if (this == F) {
            C = H;
            tabValue = F.innerText;
            return true
        }
        return false
    });
    if (target$.length) {
        if (this.selectedIndex != null) {
            this.unselect()
        }
        target$.removeClass(this.tabClasses.tab);
        target$.addClass(this.tabClasses.active);
        var E = $(".vertTabLabelContainer", target$);
        E.removeClass(this.tabClasses.borderRight);
        if (C > 0) {
            E.addClass(this.tabClasses.borderTop)
        }
        if (C < this.tabs.length - 1) {
            E.addClass(this.tabClasses.borderBottom)
        }
        this.selectedIndex = C;
        this.fireChange(C, tabValue)
    }
};
VerticalTabWidget.prototype.unselect = function() {
    var C = $("." + this.tabClasses.active);
    C.addClass(this.tabClasses.tab);
    C.removeClass(this.tabClasses.active);
    $(".vertTabLabelContainer", C).removeClass(this.tabClasses.borderTop + " " + this.tabClasses.borderBottom).addClass(this.tabClasses.borderRight);
    this.selectedIndex = null
};
VerticalTabWidget.prototype.fireChange = function(C, D) {
    if ($.isFunction(this.options.changeCallback)) {
        this.options.changeCallback.call(this, C, D)
    }
};

function SystemHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 350;
    C.name = "SystemHover";
    C.widgets = new TableWidget({
        maxCols: 2,
        widgets: [new TextWidget({
            name: "systemName",
            label: strings.sysInfoBar.nameLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "vendor",
            label: strings.sysInfoBar.vendorLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "location",
            label: strings.sysInfoBar.locationLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "contact",
            label: strings.sysInfoBar.contactLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "info",
            label: strings.sysInfoBar.infoLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "bundleA",
            label: strings.sysInfoBar.versionALabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "bundleB",
            label: strings.sysInfoBar.versionBLabel,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "topLevelSN",
            label: strings.sysInfoBar.topLevelSN,
            leftMargin: true,
            bottomSmallMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "topLevelPN",
            label: strings.sysInfoBar.topLevelPN,
            leftMargin: true,
            bottomSmallMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "SystemHover"
}
SystemHover.prototype = new HoverPanel();
SystemHover.prototype.constructor = SystemHover;
SystemHover.prototype.showing = function() {
    var C = {
        systemName: {
            text: DC.system.prop.system_name.text
        },
        vendor: {
            text: DC.system.prop.vendor_name.text
        },
        location: {
            text: DC.system.prop.system_location.text
        },
        contact: {
            text: DC.system.prop.system_contact.text
        },
        info: {
            text: DC.system.prop.system_information.text
        },
        redundancy: {
            text: DC.system.objects[0].prop.redundancy_mode.text
        },
        bundleA: {
            text: MC.versionsSet.data.objects[0].prop.bundle_version.text
        },
        bundleB: {
            text: MC.versionsSet.data.objects[1].prop.bundle_version.text
        }
    };
    if (isVistaSystem() || isQuantumSystem()) {
        MC.showFrus(createObjectCallback(this, this.updateTopLevelNumbers))
    } else {
        C.topLevelSN = {
            visibility: "collapse"
        };
        C.topLevelPN = {
            visibility: "collapse"
        }
    }
    this.update(C)
};
SystemHover.prototype.updateTopLevelNumbers = function(D) {
    if (D && D.objects) {
        var E = D.objects[0];
        var F = E.get("fru_tlasn");
        var C = E.get("fru_tlapn");
        panels.hoverDialog.currentOptions.width = 300;
        this.update({
            topLevelSN: {
                text: F
            }
        });
        this.update({
            topLevelPN: {
                text: C
            }
        })
    }
};

function DrivesHover(D) {
    if (arguments.length == 0) {
        return
    }
    var C = 0;
    D.width = 330;
    D.name = "DrivesHover";
    D.widgets = new WidgetContainer({
        widgets: [this.drivesTable = new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: D.width,
            widgets: [new TextWidget({
                name: "location",
                row: C++,
                label: strings.diskHover.locationLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                row: C++,
                label: strings.diskHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "usage",
                row: C++,
                label: strings.diskHover.usageLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "type",
                row: C++,
                label: strings.diskHover.typeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "size",
                row: C++,
                label: strings.diskHover.sizeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                row: C++,
                label: strings.diskHover.statusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rpm",
                row: C++,
                label: strings.diskHover.rpmLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "vendor",
                row: C++,
                label: strings.diskHover.vendorLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "model",
                row: C++,
                label: strings.diskHover.modelLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "revision",
                row: C++,
                label: strings.diskHover.revisionLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "powerOnHours",
                row: C++,
                label: strings.diskHover.powerOnHours,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ssdLife",
                row: (this.ssdLifeRow = C++),
                label: strings.diskHover.ssdLifeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "fdeState",
                row: (this.fdeStateRow = C++),
                label: strings.diskHover.fdeStateLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "fdeLockKey",
                row: (this.fdeLockKeyRow = C++),
                label: strings.diskHover.fdeLockKeyLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "piFormatted",
                row: (this.piFormattedRow = C++),
                label: strings.diskHover.piFormattedLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "job",
                row: (this.jobRow = C++),
                label: strings.diskHover.jobLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sectorFormat",
                row: C++,
                label: strings.diskHover.sectorFormatLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "transferRate",
                row: C++,
                label: strings.diskHover.tranferRateLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "smart",
                row: C++,
                label: strings.diskHover.smartLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "driveSpinDown",
                row: C++,
                label: strings.diskHover.driveSpinDownLabel,
                leftMargin: true,
                bottomSmallMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, D);
    this.class_name = "DrivesHover"
}
DrivesHover.prototype = new HoverPanel();
DrivesHover.prototype.constructor = DrivesHover;
DrivesHover.prototype.showing = function() {
    this.update({
        dataTable: {
            show: {
                start: 0
            }
        }
    });
    var H = this.getApiObject();
    var I = H.get("type_numeric");
    var M = new Size(H);
    var E = H.get("job_running");
    if (E) {
        E += " (" + H.get("current_job_completion") + ")"
    }
    var F = H.getInt("usage_numeric");
    var K = H.get("usage");
    if (F == DRIVE_USAGE.VIRTUAL_POOL) {
        K = strings.Pool + " " + H.get("storage_pool_name") + ", ";
        K += H.get("storage_tier");
        if (H.get("storage_tier_numeric") != TIERS.READCACHE) {
            K += " " + strings.Tier
        }
    } else {
        if (F == DRIVE_USAGE.LINEAR_POOL) {
            K = strings.Pool + " " + H.get("storage_pool_name") + ", Linear"
        }
    }
    if (RI.hasFeature("ssdSupport") && I == DISK_TYPES.SSD_SAS) {
        var J = true
    } else {
        var J = false
    }
    if (RI.hasFeature("fde")) {
        var C = true
    } else {
        var C = false
    }
    if (RI.hasFeature("e2ePi")) {
        var D = true
    } else {
        var D = false
    }
    var G = (J ? this.fdeStateRow : this.ssdLifeRow);
    if (C && D) {
        var L = {
            start: this.fdeStateRow
        }
    } else {
        if (C) {
            var L = {
                start: this.fdeStateRow,
                end: this.fdeLockKeyRow
            }
        } else {
            if (D) {
                var L = {
                    start: this.piFormattedRow
                }
            }
        }
    }
    this.update({
        dataTable: {
            hide: {
                start: G
            },
            show: L
        },
        location: {
            text: H.get("location")
        },
        serial: {
            text: H.get("serial_number")
        },
        usage: {
            text: K
        },
        type: {
            text: H.get("description")
        },
        size: {
            text: M.format("auto", 0)
        },
        status: {
            text: H.get("status")
        },
        rpm: {
            text: H.get("rpm") + "k"
        },
        vendor: {
            text: H.get("vendor")
        },
        model: {
            text: H.get("model")
        },
        revision: {
            text: H.get("revision")
        },
        job: {
            text: E
        },
        powerOnHours: {
            text: H.get("power_on_hours")
        },
        ssdLife: {
            text: H.get("ssd_life_left")
        },
        fdeState: {
            text: H.get("fde_state")
        },
        fdeLockKey: {
            text: H.get("lock_key_id")
        },
        piFormatted: {
            text: H.get("pi_formatted")
        },
        health: {
            obj: H
        },
        sectorFormat: {
            text: H.get("sector_format")
        },
        transferRate: {
            text: H.get("transfer_rate")
        },
        smart: {
            text: H.get("smart")
        },
        driveSpinDown: {
            text: H.get("disk_dsd_count")
        }
    });
    this.drivesTable.showRows(this.jobRow)
};

function EnclosuresHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 250;
    C.name = "EnclosuresHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "id",
                label: strings.enclosureHover.idLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.enclosureHover.statusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "vendor",
                label: strings.enclosureHover.vendorLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "model",
                label: strings.enclosureHover.modelLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "diskCount",
                label: strings.enclosureHover.diskCountLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "wwn",
                label: strings.enclosureHover.wwnLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "midSerial",
                label: strings.enclosureHover.midSerialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rev",
                label: strings.enclosureHover.revLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "partNumber",
                label: strings.enclosureHover.partNumberLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "manufacturingDate",
                label: strings.enclosureHover.manufacturingDateLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "manufacturingLabel",
                label: strings.enclosureHover.manufacturingLocationLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empARevision",
                label: strings.enclosureHover.empARevLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empBRevision",
                label: strings.enclosureHover.empBRevLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empABus",
                label: strings.enclosureHover.empABusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empBBus",
                label: strings.enclosureHover.empBBusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empATargetID",
                label: strings.enclosureHover.empATargetLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "empBTargetID",
                label: strings.enclosureHover.empBTargetLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "midplane",
                label: strings.enclosureHover.midPlaneLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "enclosurePower",
                label: strings.enclosureHover.enclosurePowerLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "PCIe2Capable",
                label: strings.enclosureHover.PCIlabel,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "EnclosuresHover"
}
EnclosuresHover.prototype = new HoverPanel();
EnclosuresHover.prototype.constructor = EnclosuresHover;
EnclosuresHover.prototype.showing = function() {
    var C = this.getApiObject();
    this.update({
        id: {
            text: C.get("enclosure_id")
        },
        status: {
            text: C.get("status")
        },
        vendor: {
            text: C.get("vendor")
        },
        model: {
            text: C.get("model")
        },
        diskCount: {
            text: C.get("number_of_disks")
        },
        wwn: {
            text: C.get("enclosure_wwn")
        },
        midSerial: {
            text: C.get("midplane_serial_number")
        },
        rev: {
            text: C.get("revision")
        },
        partNumber: {
            text: C.get("part_number")
        },
        manufacturingDate: {
            text: C.get("mfg_date")
        },
        manufacturingLabel: {
            text: C.get("mfg_location")
        },
        empARevision: {
            text: C.get("emp_a_rev")
        },
        empBRevision: {
            text: C.get("emp_b_rev")
        },
        empABus: {
            text: C.get("emp_a_busid")
        },
        empBBus: {
            text: C.get("emp_b_busid")
        },
        empATargetID: {
            text: C.get("emp_a_targetid")
        },
        empBTargetID: {
            text: C.get("emp_b_targetid")
        },
        midplane: {
            text: C.get("midplane_type")
        },
        enclosurePower: {
            text: C.get("enclosure_power")
        },
        PCIe2Capable: {
            text: C.get("pcie2_capable")
        },
        health: {
            obj: C
        }
    })
};

function ControllersHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 300;
    C.name = "ControllersHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "id",
                label: strings.controllerHover.idLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ip",
                label: strings.controllerHover.ipLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "descr",
                label: strings.controllerHover.descrLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.controllerHover.statusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "model",
                label: strings.controllerHover.modelLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.controllerHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "hwVersion",
                label: strings.controllerHover.hwVersionLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "systemMSize",
                label: strings.controllerHover.systemMemorySize,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rev",
                label: strings.controllerHover.revLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "cpldVersion",
                label: strings.controllerHover.cpldVersion,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "storageControllerVersion",
                label: strings.controllerHover.storageControllerVersion,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "storageControllerType",
                label: strings.controllerHover.storageControllerType,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "partNumber",
                label: strings.controllerHover.partNumber,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "position",
                label: strings.controllerHover.position,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "hardwareVersion",
                label: strings.controllerHover.hardwareVersion,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mfgDate",
                label: strings.controllerHover.mfgDate,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mfgLocation",
                label: strings.controllerHover.mfgLocation,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "ControllersHover"
}
ControllersHover.prototype = new HoverPanel();
ControllersHover.prototype.constructor = ControllersHover;
ControllersHover.prototype.showing = function() {
    var C = this.getApiObject();
    this.update({
        id: {
            text: C.get("controller_id")
        },
        ip: {
            text: C.get("ip_address")
        },
        descr: {
            text: C.get("description")
        },
        status: {
            text: C.get("status")
        },
        model: {
            text: C.get("model")
        },
        serial: {
            text: C.get("serial_number")
        },
        hwVersion: {
            text: C.get("hardware_version")
        },
        systemMSize: {
            text: C.get("system_memory_size")
        },
        rev: {
            text: C.get("revision")
        },
        cpldVersion: {
            text: C.get("cpld_version")
        },
        storageControllerVersion: {
            text: C.get("sc_fw")
        },
        storageControllerType: {
            text: C.get("sc_cpu_type")
        },
        partNumber: {
            text: C.get("part_number")
        },
        position: {
            text: C.get("position")
        },
        hardwareVersion: {
            text: C.get("hardware_version")
        },
        mfgDate: {
            text: C.get("mfg_date")
        },
        mfgLocation: {
            text: C.get("mfg_location")
        },
        health: {
            obj: C
        }
    })
};

function PowerSuppliesHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "PowerSuppliesHover";
    C.widgets = new WidgetContainer({
        widgets: [this.table = new TableWidget({
            name: "infoTable",
            widgets: [new TextWidget({
                name: "defaultLabel",
                text: strings.powerSupplyHover.defaultLabel,
                row: 0,
                col: 0,
                colSpan: 2,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.powerSupplyHover.statusLabel,
                row: 1,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "vendor",
                label: strings.powerSupplyHover.vendorLabel,
                row: 2,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "model",
                label: strings.powerSupplyHover.modelLabel,
                row: 3,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.powerSupplyHover.serialLabel,
                row: 4,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rev",
                label: strings.powerSupplyHover.revLabel,
                row: 5,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "location",
                label: strings.powerSupplyHover.location,
                row: 6,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "partNumber",
                label: strings.powerSupplyHover.partNumber,
                row: 7,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mfgdate",
                label: strings.powerSupplyHover.mfgdate,
                row: 8,
                col: 1,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mfglocation",
                label: strings.powerSupplyHover.mfglocation,
                row: 9,
                col: 1,
                leftMargin: true
            }), new HealthWidget({
                name: "health",
                row: 10,
                col: 0,
                colSpan: 2,
                topMargin: true,
                cellClasses: "alignTop"
            }), new TextWidget({
                name: "voltageLabel",
                text: strings.powerSupplyHover.voltageRegulator,
                row: 0,
                col: 1,
                colSpan: 2,
                largeLeftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status2",
                label: strings.powerSupplyHover.statusLabel,
                row: 1,
                col: 3,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "vendor2",
                label: strings.powerSupplyHover.vendorLabel,
                row: 2,
                col: 3,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "model2",
                label: strings.powerSupplyHover.modelLabel,
                row: 3,
                col: 3,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial2",
                label: strings.powerSupplyHover.serialLabel,
                row: 4,
                col: 3,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rev2",
                label: strings.powerSupplyHover.revLabel,
                row: 5,
                col: 3,
                leftMargin: true,
                bottomSmallMargin: true
            }), new HealthWidget({
                name: "health2",
                row: 6,
                col: 2,
                colSpan: 2,
                topMargin: true,
                cellClasses: "alignTop"
            })]
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "PowerSuppliesHover"
}
PowerSuppliesHover.prototype = new HoverPanel();
PowerSuppliesHover.prototype.constructor = PowerSuppliesHover;
PowerSuppliesHover.prototype.showing = function() {
    var G = this.getApiObject();
    var C = G.dcParents[0].parent.objects;
    for (var E = 0; E < C.length; E++) {
        if (C[E] instanceof APIPowerSupplies && C[E].get("location") == G.get("location") && C[E].get("name") != G.get("name")) {
            var H = C[E];
            if (H.get("name").indexOf("Voltage Regulator") > -1) {
                var F = H
            } else {
                var F = G;
                G = H
            }
        }
    }
    var D = {
        status: {
            text: G.get("status")
        },
        vendor: {
            text: G.get("vendor")
        },
        model: {
            text: G.get("model")
        },
        serial: {
            text: G.get("serial_number")
        },
        rev: {
            text: G.get("revision")
        },
        location: {
            text: G.get("location")
        },
        partNumber: {
            text: G.get("part_number")
        },
        mfgdate: {
            text: G.get("mfg_date")
        },
        mfglocation: {
            text: G.get("mfg_location")
        },
        health: {
            obj: G
        }
    };
    if (typeof H != "undefined") {
        this.options.width = 450;
        this.table.addCSSClass("equalWidth");
        D.status2 = {
            text: F.get("status"),
            visibility: "visible"
        };
        D.vendor2 = {
            text: F.get("vendor"),
            visibility: "visible"
        };
        D.model2 = {
            text: F.get("model"),
            visibility: "visible"
        };
        D.serial2 = {
            text: F.get("serial_number"),
            visibility: "visible"
        };
        D.rev2 = {
            text: F.get("revision"),
            visibility: "visible"
        };
        D.health2 = {
            obj: F,
            visibility: "visible"
        };
        D.defaultLabel = {
            visibility: "visible"
        };
        D.voltageLabel = {
            visibility: "visible"
        }
    } else {
        this.options.width = 240;
        this.table.removeCSSClass("equalWidth");
        D.status2 = {
            visibility: "collapse"
        };
        D.vendor2 = {
            visibility: "collapse"
        };
        D.model2 = {
            visibility: "collapse"
        };
        D.serial2 = {
            visibility: "collapse"
        };
        D.rev2 = {
            visibility: "collapse"
        };
        D.health2 = {
            visibility: "collapse"
        };
        D.defaultLabel = {
            visibility: "collapse"
        };
        D.voltageLabel = {
            visibility: "collapse"
        }
    }
    this.update(D)
};

function IoModulesHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 278;
    C.name = "IoModulesHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: 265,
            widgets: [new TextWidget({
                name: "id",
                label: strings.iomHover.idLabel,
                leftmargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "descr",
                label: strings.iomHover.descrLabel,
                leftmargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.iomHover.serialLabel,
                leftmargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "rev",
                label: strings.iomHover.revLabel,
                leftmargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "IoModulesHover"
}
IoModulesHover.prototype = new HoverPanel();
IoModulesHover.prototype.constructor = IoModulesHover;
IoModulesHover.prototype.showing = function() {
    var C = this.getApiObject();
    this.update({
        id: {
            text: C.get("controller_id")
        },
        descr: {
            text: C.get("description")
        },
        serial: {
            text: C.get("serial_number")
        },
        rev: {
            text: C.get("revision")
        },
        health: {
            obj: C
        }
    })
};

function PortHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 430;
    C.name = "PortHover";
    C.widgets = new WidgetContainer({
        widgets: [this.table = new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.portHover.name,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "type",
                label: strings.portHover.type,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "id",
                label: strings.portHover.idLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.portHover.status,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "configSpeed",
                label: strings.portHover.configSpeed,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "actualSpeed",
                label: strings.portHover.actualSpeed,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "topology",
                label: strings.portHover.topology,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipVersion",
                label: strings.portHover.ipVersion,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mac",
                label: strings.portHover.mac,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipAddress",
                label: strings.portHover.ipAddress,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipGateway",
                label: strings.portHover.ipGateway,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipNetmask",
                label: strings.portHover.ipNetmask,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipDefaultRouter",
                label: strings.portHover.ipDefaultRouter,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ipLinkLocal",
                label: strings.portHover.ipLinkLocal,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "fanoutSAS",
                label: strings.portconfig.cableTypeLabel,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "loopId",
                label: strings.portconfig.primaryLoop,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "supportedSpeeds",
                label: strings.portconfig.supportedSpeeds,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "SFPStatus",
                label: strings.portconfig.SFPStatus,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "partNumber",
                label: strings.portconfig.partNumber,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "tenGCompliance",
                label: strings.portconfig.tenGCompliance,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "cableLength",
                label: strings.portconfig.cableLength,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "cableTech",
                label: strings.portconfig.cableTech,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ethernetCompliance",
                label: strings.portconfig.ethernetCompliance,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "expectedLanes",
                label: strings.portconfig.expectedLanes,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "activeLanes",
                label: strings.portconfig.activeLanesLabel,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "disabledLanes",
                label: strings.portconfig.disabledLanes,
                labelOptions: {
                    classes: "noWrap"
                },
                leftMargin: true,
                bottomSmallMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "PortHover"
}
PortHover.prototype = new HoverPanel();
PortHover.prototype.constructor = PortHover;
PortHover.prototype.showing = function() {
    var E = this.getApiObject();
    var C = E.get("port_type");
    if (!E) {
        return
    }
    $("tr", this.elements).slice(6, 14).hide();
    var G = {
        name: {
            text: E.get("port")
        },
        type: {
            text: C
        },
        status: {
            text: E.get("status")
        }
    };
    var D = ((E.objects.length > 0) ? E.objects[0] : null);
    if (D) {
        if (C == "FC") {
            this.table.showRows(4, 7);
            this.table.hideRows(7, 14);
            this.table.showRows(15, 18);
            this.table.hideRows(19, 22);
            this.table.hideRows(23, 25);
            G.topology = {
                text: D.get("configured_topology")
            };
            G.configSpeed = {
                text: E.get("configured_speed")
            };
            G.actualSpeed = {
                text: E.get("actual_speed")
            };
            G.loopId = {
                text: D.get("primary_loop_id")
            };
            G.id = {
                text: E.get("target_id")
            };
            G.SFPStatus = {
                text: E.get("_sfp_status")
            };
            G.partNumber = {
                text: E.get("_sfp_part_number")
            };
            G.supportedSpeeds = {
                text: E.get("_sfp_supported_speeds")
            };
            panels.hoverDialog.currentOptions.width = 380
        } else {
            if (C == "SAS") {
                this.table.hideRows(4, 22);
                this.table.showRows(5, 6);
                this.table.showRows(23, 25);
                G.actualSpeed = {
                    text: E.get("actual_speed")
                };
                G.topology = {
                    text: E.get("_configured_topology")
                };
                G.expectedLanes = {
                    text: E.get("_sas_lanes_expected")
                };
                G.activeLanes = {
                    text: E.get("_sas_active_lanes")
                };
                G.disabledLanes = {
                    text: E.get("_sas_disabled_lanes")
                };
                if (EXPR.isFanOutSupported === true) {
                    this.table.showRows(14, 15);
                    var F = "";
                    if (E.getInt("fan_out") > 1) {
                        F = strings.portconfig.fanoutCable
                    } else {
                        F = strings.portconfig.stdCable
                    }
                    G.fanoutSAS = {
                        text: F
                    }
                }
                G.id = {
                    text: E.get("target_id")
                }
            } else {
                if (C == "iSCSI") {
                    this.table.hideRows(15, 17);
                    this.table.showRows(7, 9);
                    this.table.showRows(17, 22);
                    this.table.hideRows(23, 25);
                    if (DC.iscsiParams.get("iscsi_ip_version") == "4") {
                        this.table.showRows(10, 12);
                        this.table.hideRows(12, 14);
                        G.ipGateway = {
                            text: D.get("gateway")
                        };
                        G.ipNetmask = {
                            text: D.get("netmask")
                        }
                    } else {
                        this.table.hideRows(10, 12);
                        this.table.showRows(12, 14);
                        G.ipDefaultRouter = {
                            text: D.get("default_router")
                        };
                        G.ipLinkLocal = {
                            text: D.get("link_local_address")
                        }
                    }
                    G.mac = {
                        text: D.get("mac_address")
                    };
                    G.ipAddress = {
                        text: D.get("ip_address")
                    };
                    G.ipVersion = {
                        text: D.get("ip_version")
                    };
                    G.id = {
                        text: E.get("target_id")
                    };
                    G.SFPStatus = {
                        text: E.get("_sfp_status")
                    };
                    G.partNumber = {
                        text: E.get("_sfp_part_number")
                    };
                    G.configSpeed = {
                        text: E.get("configured_speed")
                    };
                    G.actualSpeed = {
                        text: E.get("actual_speed")
                    };
                    G.tenGCompliance = {
                        text: E.get("_sfp_10G_compliance")
                    };
                    G.cableLength = {
                        text: E.get("_sfp_cable_length")
                    };
                    G.cableTech = {
                        text: E.get("_sfp_cable_technology")
                    };
                    G.ethernetCompliance = {
                        text: E.get("_sfp_ethernet_compliance")
                    };
                    panels.hoverDialog.currentOptions.width = 380
                } else {
                    if (C == "IB") {
                        this.table.hideRows(4, 23);
                        G.id = {
                            text: E.get("target_id")
                        }
                    }
                }
            }
        }
    }
    G.healthWidget = {
        obj: E
    };
    this.update(G)
};

function NetworkParametersHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 320;
    C.name = "NetworkParametersHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.networkHover.name,
                leftMargin: true,
                bottomSmallMargin: true,
                wrapText: true
            }), new TextWidget({
                name: "mode",
                label: strings.networkHover.mode,
                leftMargin: true,
                bottomSmallMargin: true,
                wrapText: true
            }), new TextWidget({
                name: "ip",
                label: strings.networkHover.ip,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "mask",
                label: strings.networkHover.mask,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "gateway",
                label: strings.networkHover.gateway,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "macaddress",
                label: strings.networkHover.macAddress,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "NetworkParametersHover"
}
NetworkParametersHover.prototype = new HoverPanel();
NetworkParametersHover.prototype.constructor = NetworkParametersHover;
NetworkParametersHover.prototype.showing = function() {
    var C = this.getApiObject();
    if (!C) {
        return
    }
    this.update({
        name: {
            text: C.get("durable_id")
        },
        mode: {
            text: C.get("addressing_mode")
        },
        ip: {
            text: C.get("ip_address")
        },
        mask: {
            text: C.get("subnet_mask")
        },
        gateway: {
            text: C.get("gateway")
        },
        macaddress: {
            text: C.get("mac_address")
        },
        healthWidget: {
            obj: C
        }
    })
};

function FanHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 200;
    C.name = "FanHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.fanHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "location",
                label: strings.fanHover.location,
                leftMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.fanHover.status,
                leftMargin: true,
                bottomMargin: true
            }), new TextWidget({
                name: "internalFansInfo",
                colSpan: 2,
                text: strings.fanHover.internalFansInfo,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "firstFanName",
                label: strings.fanHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "firstFanStatus",
                label: strings.fanHover.status,
                leftMargin: true
            }), new TextWidget({
                name: "firstFanSpeed",
                label: strings.fanHover.speed,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "secondFanName",
                label: strings.fanHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "secondFanStatus",
                label: strings.fanHover.status,
                leftMargin: true
            }), new TextWidget({
                name: "secondFanSpeed",
                label: strings.fanHover.speed,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "FanHover"
}
FanHover.prototype = new HoverPanel();
FanHover.prototype.constructor = FanHover;
FanHover.prototype.showing = function() {
    this.update({
        dataTable: {
            show: {
                start: 0
            }
        }
    });
    var F = this.getApiObject();
    if (!F) {
        return
    }
    this.update({
        name: {
            text: F.get("name")
        },
        location: {
            text: F.get("location")
        },
        status: {
            text: F.get("status")
        },
        speed: {
            text: F.get("speed") + " r/min"
        },
        healthWidget: {
            obj: F
        }
    });
    if (F.basetype == "fan-modules") {
        var E = F.fans;
        var G = {};
        if (E) {
            for (var D in E) {
                G[E[D].get("name")] = {
                    name: E[D].get("name"),
                    status: E[D].get("status"),
                    speed: E[D].get("speed")
                }
            }
            var C = Object.keys(G);
            this.update({
                firstFanName: {
                    text: C[0]
                },
                firstFanSpeed: {
                    text: G[C[0]].speed
                },
                firstFanStatus: {
                    text: G[C[0]].status
                },
                secondFanName: {
                    text: C[1]
                },
                secondFanSpeed: {
                    text: G[C[1]].speed
                },
                secondFanStatus: {
                    text: G[C[1]].status
                }
            })
        }
    } else {
        this.update({
            dataTable: {
                hide: {
                    start: 3
                }
            }
        })
    }
};

function ExpanderPortsHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ExpanderPortsHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "enclosure",
                label: strings.expanderPortHover.enclosure,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "controller",
                label: strings.expanderPortHover.controller,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "name",
                label: strings.expanderPortHover.name,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.expanderPortHover.status,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "ExpanderPortsHover"
}
ExpanderPortsHover.prototype = new HoverPanel();
ExpanderPortsHover.prototype.constructor = ExpanderPortsHover;
ExpanderPortsHover.prototype.showing = function() {
    var C = this.getApiObject();
    if (!C) {
        return
    }
    this.update({
        enclosure: {
            text: C.get("enclosure_id")
        },
        controller: {
            text: C.get("controller")
        },
        name: {
            text: C.get("name")
        },
        status: {
            text: C.get("status")
        },
        healthWidget: {
            obj: C
        }
    })
};

function CompactFlashHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 250;
    C.name = "CompactFlashHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.compactFlashHover.name,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.compactFlashHover.status,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "cache",
                label: strings.compactFlashHover.cache,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "CompactFlashHover"
}
CompactFlashHover.prototype = new HoverPanel();
CompactFlashHover.prototype.constructor = CompactFlashHover;
CompactFlashHover.prototype.showing = function() {
    var C = this.getApiObject();
    if (!C) {
        return
    }
    this.update({
        name: {
            text: C.get("name")
        },
        status: {
            text: C.get("status")
        },
        cache: {
            text: C.get("cache_flush")
        },
        healthWidget: {
            obj: C
        }
    })
};

function DrawersHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 250;
    C.name = "DrawersHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "drawerName",
                label: strings.drawersHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "drawerPosition",
                label: strings.drawersHover.drawerPosition,
                leftMargin: true
            }), new TextWidget({
                name: "numberofdisks",
                label: strings.drawersHover.drawerDisks,
                leftMargin: true
            }), new TextWidget({
                name: "id",
                label: strings.drawersHover.id,
                leftMargin: true
            }), new TextWidget({
                name: "drawerStatus",
                label: strings.drawersHover.status,
                leftMargin: true
            }), new TextWidget({
                name: "wwn",
                label: strings.drawersHover.wwn,
                leftMargin: true,
                bottomMargin: true
            }), new TextWidget({
                name: "leftSideplaneInfo",
                colSpan: 2,
                text: strings.drawersHover.leftSideplaneInfo,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spLeftName",
                label: strings.drawersHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "spLeftStatus",
                label: strings.drawersHover.status,
                leftMargin: true
            }), new TextWidget({
                name: "spLeftPathID",
                label: strings.drawersHover.pathID,
                leftMargin: true
            }), new TextWidget({
                name: "spLeftExpanderCount",
                label: strings.drawersHover.expanders,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spLeftExpander0Name",
                label: strings.drawersHover.expanderName,
                leftMargin: true
            }), new TextWidget({
                name: "spLeftExpander0Status",
                label: strings.drawersHover.expanderStatus,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spLeftExpander1Name",
                label: strings.drawersHover.expanderName,
                leftMargin: true
            }), new TextWidget({
                name: "spLeftExpander1Status",
                label: strings.drawersHover.expanderStatus,
                leftMargin: true,
                bottomMargin: true
            }), new TextWidget({
                name: "rightSideplaneInfo",
                colSpan: 2,
                text: strings.drawersHover.rightSideplaneInfo,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spRightName",
                label: strings.drawersHover.name,
                leftMargin: true
            }), new TextWidget({
                name: "spRightStatus",
                label: strings.drawersHover.status,
                leftMargin: true
            }), new TextWidget({
                name: "spRightPathID",
                label: strings.drawersHover.pathID,
                leftMargin: true
            }), new TextWidget({
                name: "spRightExpanderCount",
                label: strings.drawersHover.expanders,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spRightExpander0Name",
                label: strings.drawersHover.expanderName,
                leftMargin: true
            }), new TextWidget({
                name: "spRightExpander0Status",
                label: strings.drawersHover.expanderStatus,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spRightExpander1Name",
                label: strings.drawersHover.expanderName,
                leftMargin: true
            }), new TextWidget({
                name: "spRightExpander1Status",
                label: strings.drawersHover.expanderStatus,
                leftMargin: true
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "DrawersHover"
}
DrawersHover.prototype = new HoverPanel();
DrawersHover.prototype.constructor = DrawersHover;
DrawersHover.prototype.showing = function() {
    var L = this.getApiObject();
    if (!L) {
        return
    }
    this.update({
        dataTable: {
            show: {
                start: 0
            }
        },
        drawerName: {
            text: L.get("name")
        },
        id: {
            text: L.get("drawer_id")
        },
        drawerPosition: {
            text: L.get("position")
        },
        numberofdisks: {
            text: L.get("number_of_disks")
        },
        drawerStatus: {
            text: L.get("status")
        },
        wwn: {
            text: L.get("drawer_wwn")
        },
        healthWidget: {
            obj: L
        }
    });
    if (L.sideplanes) {
        var I = {};
        for (var P in L.sideplanes) {
            var Q = L.sideplanes[P];
            var J = L.sideplanes[P].get("name");
            var T = L.sideplanes[P].expanders;
            var N = 0;
            I[J] = {
                name: J,
                status: Q.get("status"),
                pathID: Q.get("path_id"),
                expCount: Q.objectCount(),
                expanders: {}
            };
            while (N < Q.objectCount()) {
                for (var E in T) {
                    var R = T[E];
                    var O = R.get("name");
                    I[J].expanders[O] = {
                        name: O,
                        status: R.get("status")
                    };
                    N++
                }
            }
        }
        var D = Object.keys(I);
        var S = D[0];
        var H = D[1];
        var C = Object.keys(I[S].expanders);
        var M = C[0];
        var K = C[1];
        var U = Object.keys(I[H].expanders);
        var G = U[0];
        var F = U[1];
        this.update({
            spLeftName: {
                text: I[D[0]].name
            },
            spLeftStatus: {
                text: I[D[0]].status
            },
            spLeftPathID: {
                text: I[D[0]].pathID
            },
            spLeftExpanderCount: {
                text: I[D[0]].expCount
            },
            spLeftExpander0Name: {
                text: I[S].expanders[M].name
            },
            spLeftExpander0Status: {
                text: I[S].expanders[M].status
            },
            spLeftExpander1Name: {
                text: I[S].expanders[K].name
            },
            spLeftExpander1Status: {
                text: I[S].expanders[K].status
            },
            spRightName: {
                text: I[D[1]].name
            },
            spRightStatus: {
                text: I[D[1]].status
            },
            spRightPathID: {
                text: I[D[1]].pathID
            },
            spRightExpanderCount: {
                text: I[D[1]].expCount
            },
            spRightExpander0Name: {
                text: I[H].expanders[G].name
            },
            spRightExpander0Status: {
                text: I[H].expanders[G].status
            },
            spRightExpander1Name: {
                text: I[H].expanders[F].name
            },
            spRightExpander1Status: {
                text: I[H].expanders[F].status
            }
        })
    } else {
        this.update({
            dataTable: {
                hide: {
                    start: 6
                }
            }
        })
    }
};

function PeerConnectionsHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 370;
    D.name = "PeerConnectionsHover";
    var C = 0;
    D.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: D.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.peerConnectionsHover.name,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "serial",
                label: strings.peerConnectionsHover.serial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "type",
                label: strings.peerConnectionsHover.type,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "status",
                label: strings.peerConnectionsHover.status,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr1",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: (this.firstLocalRow = C++)
            }), new TextWidget({
                name: "localAddr2",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr3",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr4",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr5",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr6",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr7",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "localAddr8",
                label: strings.peerConnectionsHover.localPort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr1",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: (this.firstRemoteRow = C++)
            }), new TextWidget({
                name: "remoteAddr2",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr3",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr4",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr5",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr6",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr7",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "remoteAddr8",
                label: strings.peerConnectionsHover.remotePort,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            })]
        }), new HealthWidget({
            name: "healthWidget",
            topMargin: true
        })]
    });
    HoverPanel.call(this, D);
    this.class_name = "PeerConnectionsHover"
}
PeerConnectionsHover.prototype = new HoverPanel();
PeerConnectionsHover.prototype.constructor = PeerConnectionsHover;
PeerConnectionsHover.prototype.showing = function() {
    var C = {};
    var G = this.getApiObject();
    if (!G) {
        return
    }
    var E = G.getPortLabelsAddrs(true, true, true);
    var F = E.length;
    var H = G.getPortLabelsAddrs(false, true, true);
    var D = H.length;
    this.update({
        dataTable: {
            hide: {
                start: this.firstLocalRow + D,
                end: this.firstRemoteRow - 1
            }
        },
        name: {
            text: G.get("peer_connection_name")
        },
        serial: {
            text: G.get("serial_number")
        },
        type: {
            text: G.get("connection_type")
        },
        status: {
            text: G.get("connection_status")
        },
        localAddr1: {
            text: H[0]
        },
        localAddr2: {
            text: H[1]
        },
        localAddr3: {
            text: H[2]
        },
        localAddr4: {
            text: H[3]
        },
        localAddr5: {
            text: H[4]
        },
        localAddr6: {
            text: H[5]
        },
        localAddr7: {
            text: H[6]
        },
        localAddr8: {
            text: H[7]
        },
        remoteAddr1: {
            text: E[0]
        },
        remoteAddr2: {
            text: E[1]
        },
        remoteAddr3: {
            text: E[2]
        },
        remoteAddr4: {
            text: E[3]
        },
        remoteAddr5: {
            text: E[4]
        },
        remoteAddr6: {
            text: E[5]
        },
        remoteAddr7: {
            text: E[6]
        },
        remoteAddr8: {
            text: E[7]
        },
        healthWidget: {
            obj: G
        }
    });
    this.update({
        dataTable: {
            hide: {
                start: this.firstRemoteRow + F
            }
        }
    })
};

function ReplicationSetsHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 440;
    D.name = "ReplicationSetsHover";
    var C = 0;
    D.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: D.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.replicationSetsHover.name,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "serial",
                label: strings.replicationSetsHover.serial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "status",
                label: strings.replicationSetsHover.status,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "primaryVolume",
                label: strings.replicationSetsHover.primaryVolume,
                leftMargin: true,
                bottomSmallMargin: true,
                row: (this.firstVolumeRow = C++)
            }), new TextWidget({
                name: "primaryVolumeSerial",
                label: strings.replicationSetsHover.primaryVolumeSerial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "secondaryVolume",
                label: strings.replicationSetsHover.secondaryVolume,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "secondaryVolumeSerial",
                label: strings.replicationSetsHover.secondaryVolumeSerial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "primaryVolumeGroup",
                label: strings.replicationSetsHover.primaryVolumeGroup,
                leftMargin: true,
                bottomSmallMargin: true,
                row: (this.firstVolumeGroupRow = C++)
            }), new TextWidget({
                name: "primaryVolumeGroupSerial",
                label: strings.replicationSetsHover.primaryVolumeGroupSerial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "secondaryVolumeGroup",
                label: strings.replicationSetsHover.secondaryVolumeGroup,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "secondaryVolumeGroupSerial",
                label: strings.replicationSetsHover.secondaryVolumeGroupSerial,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "peerConnection",
                label: strings.replicationSetsHover.peerConnection,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "queuePolicy",
                label: strings.replicationSetsHover.queuePolicy,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "queueCount",
                label: strings.replicationSetsHover.queueCount,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "secondarySnapHist",
                label: strings.replicationSetsHover.secondarySnapHist,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "primarySnapHist",
                label: strings.replicationSetsHover.primarySnapHist,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "retentionCount",
                label: strings.replicationSetsHover.retentionCount,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "retentionPriority",
                label: strings.replicationSetsHover.retentionPriority,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "snapBasename",
                label: strings.replicationSetsHover.snapBasename,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "assocSchedule",
                label: strings.replicationSetsHover.associatedSchedule,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "progress",
                label: strings.replicationSetsHover.progress,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "currStart",
                label: strings.replicationSetsHover.currRunTimeStart,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "estTimeToCompletion",
                label: strings.replicationSetsHover.eTC,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "currTransferredData",
                label: strings.replicationSetsHover.currRunData,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastSuccessTime",
                label: strings.replicationSetsHover.lastSuccess,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastStartTime",
                label: strings.replicationSetsHover.lastRunStartTime,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastEndTime",
                label: strings.replicationSetsHover.lastRunEndTime,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastTransferredData",
                label: strings.replicationSetsHover.lastRunData,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastRunStatus",
                label: strings.replicationSetsHover.lastRunStatus,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            }), new TextWidget({
                name: "lastRunErrorStatus",
                label: strings.replicationSetsHover.lastRunErrorStatus,
                leftMargin: true,
                bottomSmallMargin: true,
                row: C++
            })]
        })]
    });
    HoverPanel.call(this, D);
    this.class_name = "ReplicationSetsHover"
}
ReplicationSetsHover.prototype = new HoverPanel();
ReplicationSetsHover.prototype.constructor = ReplicationSetsHover;
ReplicationSetsHover.prototype.showing = function() {
    var C = {};
    var F = this.getApiObject();
    if (!F) {
        return
    }
    var J = F.getInt("group_numeric");
    var H = F.getInt("snapshot_history_numeric");
    var E = (H == REPSNAPHIST.BOTH || H == REPSNAPHIST.SECONDARY ? strings.Enabled : strings.Disabled);
    var D = (H == REPSNAPHIST.BOTH ? strings.Enabled : strings.Disabled);
    var K = (H == REPSNAPHIST.BOTH || H == REPSNAPHIST.SECONDARY ? F.get("snapshot_count") : '<span style="color: #CCC">' + F.get("snapshot_count") + "</span>");
    var I = (H == REPSNAPHIST.BOTH || H == REPSNAPHIST.SECONDARY ? F.get("retention_priority") : '<span style="color: #CCC">' + F.get("retention_priority") + "</span>");
    var G = (H == REPSNAPHIST.BOTH || H == REPSNAPHIST.SECONDARY ? F.get("snapshot_basename") : '<span style="color: #CCC">' + F.get("snapshot_basename") + "</span>");
    this.update({
        dataTable: {
            hide: {
                start: (J) ? this.firstVolumeRow : this.firstVolumeGroupRow,
                end: (J) ? this.firstVolumeRow + 3 : this.firstVolumeGroupRow + 3
            },
            show: {
                start: (J) ? this.firstVolumeGroupRow : this.firstVolumeRow,
                end: (J) ? this.firstVolumeGroupRow + 3 : this.firstVolumeRow + 3
            }
        },
        name: {
            text: F.get("name")
        },
        serial: {
            text: F.get("serial_number")
        },
        status: {
            text: F.get("status")
        },
        primaryVolume: {
            text: F.get("primary_volume_name")
        },
        primaryVolumeSerial: {
            text: F.get("primary_volume_serial")
        },
        secondaryVolume: {
            text: F.get("secondary_volume_name")
        },
        secondaryVolumeSerial: {
            text: F.get("secondary_volume_serial")
        },
        primaryVolumeGroup: {
            text: F.get("primary_volume_name")
        },
        primaryVolumeGroupSerial: {
            text: F.get("primary_volume_serial")
        },
        secondaryVolumeGroup: {
            text: F.get("secondary_volume_name")
        },
        secondaryVolumeGroupSerial: {
            text: F.get("secondary_volume_serial")
        },
        peerConnection: {
            text: F.get("peer_connection_name")
        },
        queueCount: {
            text: F.get("queue_count")
        },
        queuePolicy: {
            text: F.get("queue_policy")
        },
        assocSchedule: {
            text: MC.getItemList(F.getAssociatedSchedules()).replace(/,/g, ", ")
        },
        secondarySnapHist: {
            text: E
        },
        primarySnapHist: {
            text: D
        },
        retentionCount: {
            text: K
        },
        retentionPriority: {
            text: I
        },
        snapBasename: {
            text: G
        },
        progress: {
            text: F.getRepObjProp(REPLICATION_STATE.CURRENT, "progress")
        },
        currStart: {
            text: F.getRepObjProp(REPLICATION_STATE.CURRENT, "time_start")
        },
        estTimeToCompletion: {
            text: F.getRepObjProp(REPLICATION_STATE.CURRENT, "estimated_time_completion")
        },
        currTransferredData: {
            text: F.getRepObjProp(REPLICATION_STATE.CURRENT, "total_data_transferred")
        },
        lastSuccessTime: {
            text: F.get("last_success_time")
        },
        lastStartTime: {
            text: F.getRepObjProp(REPLICATION_STATE.LAST, "time_start")
        },
        lastEndTime: {
            text: F.getRepObjProp(REPLICATION_STATE.LAST, "time_end")
        },
        lastTransferredData: {
            text: F.getRepObjProp(REPLICATION_STATE.LAST, "total_data_transferred")
        },
        lastRunStatus: {
            text: F.get("last_run_status")
        },
        lastRunErrorStatus: {
            text: F.getRepObjProp(REPLICATION_STATE.LAST, "run_errror")
        }
    })
};

function RemoteSystemHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 400;
    D.name = "RemoteSystemHover";
    var C = 0;
    D.widgets = [new TableWidget({
        name: "dataTable",
        maxCols: 2,
        width: D.width,
        widgets: [new TextWidget({
            name: "sysName",
            label: strings.remoteSystemHover.sysName,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "sysContact",
            label: strings.remoteSystemHover.sysContact,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "sysLoc",
            label: strings.remoteSystemHover.sysLoc,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "sysInfo",
            label: strings.remoteSystemHover.sysInfo,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "vendor",
            label: strings.remoteSystemHover.vendor,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "brand",
            label: strings.remoteSystemHover.brand,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "id",
            label: strings.remoteSystemHover.id,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "ipA",
            label: strings.remoteSystemHover.ipa,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "ipB",
            label: strings.remoteSystemHover.ipb,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "username",
            label: strings.remoteSystemHover.username,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "status",
            label: strings.remoteSystemHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        }), new TextWidget({
            name: "lastConn",
            label: strings.remoteSystemHover.lastConn,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++
        })]
    })];
    HoverPanel.call(this, D);
    this.class_name = "RemoteSystemHover"
}
RemoteSystemHover.prototype = new HoverPanel();
RemoteSystemHover.prototype.constructor = RemoteSystemHover;
RemoteSystemHover.prototype.showing = function() {
    var D = this.getApiObject();
    if (!D) {
        return
    }
    var C = {
        sysName: {
            text: D.get("system_name")
        },
        sysContact: {
            text: D.get("system_contact")
        },
        sysLoc: {
            text: D.get("system_location")
        },
        sysInfo: {
            text: D.get("system_information")
        },
        vendor: {
            text: D.get("vendor_name")
        },
        brand: {
            text: D.get("product_brand")
        },
        id: {
            text: D.get("product_id")
        },
        ipA: {
            text: D.get("ip_address_a")
        },
        ipB: {
            text: D.get("ip_address_b")
        },
        username: {
            text: D.get("username")
        },
        status: {
            text: D.get("status")
        },
        lastConn: {
            text: D.get("last_connected")
        }
    };
    this.update(C)
};

function RsrReplicationSetHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 500;
    C.name = "RsrReplicationSetHover";
    C.widgets = [new TableWidget({
        name: "dataTable",
        maxCols: 2,
        width: C.width,
        classes: "equalColumnWidth",
        widgets: [new TextWidget({
            name: "repSetName",
            label: strings.rsrReplicationSetHover.repSetName,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 0,
            col: 1
        }), new TextWidget({
            name: "serial",
            label: strings.rsrReplicationSetHover.serial,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 1,
            col: 1
        }), new TextWidget({
            name: "volLabel1",
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: 2,
            col: 0
        }), new TextWidget({
            name: "volLabel2",
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: 2,
            col: 2
        }), new TextWidget({
            name: "volName",
            label: strings.rsrReplicationSetHover.volName,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 3,
            col: 1
        }), new TextWidget({
            name: "status",
            label: strings.rsrReplicationSetHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 4,
            col: 1
        }), new TextWidget({
            name: "statusReason",
            label: strings.rsrReplicationSetHover.statusReason,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 5,
            col: 1
        }), new TextWidget({
            name: "location",
            label: strings.rsrReplicationSetHover.location,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 6,
            col: 1
        }), new TextWidget({
            name: "monitor",
            label: strings.rsrReplicationSetHover.monitor,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 7,
            col: 1
        }), new TextWidget({
            name: "maxQueue",
            label: strings.rsrReplicationSetHover.maxQueue,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 8,
            col: 1
        }), new TextWidget({
            name: "maxRetry",
            label: strings.rsrReplicationSetHover.maxRetry,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 9,
            col: 1
        }), new TextWidget({
            name: "onError",
            label: strings.rsrReplicationSetHover.onError,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 10,
            col: 1
        }), new TextWidget({
            name: "linkType",
            label: strings.rsrReplicationSetHover.linkType,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 11,
            col: 1
        }), new TextWidget({
            name: "onCollision",
            label: strings.rsrReplicationSetHover.onCollision,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 12,
            col: 1
        }), new TextWidget({
            name: "monitorInterval",
            label: strings.rsrReplicationSetHover.monitorInterval,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 13,
            col: 1
        }), new TextWidget({
            name: "priority",
            label: strings.rsrReplicationSetHover.priority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 14,
            col: 1
        }), new TextWidget({
            name: "connStatus",
            label: strings.rsrReplicationSetHover.connStatus,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 15,
            col: 1
        }), new TextWidget({
            name: "connTime",
            label: strings.rsrReplicationSetHover.connTime,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 16,
            col: 1
        }), new TextWidget({
            name: "volName2",
            label: strings.rsrReplicationSetHover.volName,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 3,
            col: 3
        }), new TextWidget({
            name: "status2",
            label: strings.rsrReplicationSetHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 4,
            col: 3
        }), new TextWidget({
            name: "statusReason2",
            label: strings.rsrReplicationSetHover.statusReason,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 5,
            col: 3
        }), new TextWidget({
            name: "location2",
            label: strings.rsrReplicationSetHover.location,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 6,
            col: 3
        }), new TextWidget({
            name: "monitor2",
            label: strings.rsrReplicationSetHover.monitor,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 7,
            col: 3
        }), new TextWidget({
            name: "maxQueue2",
            label: strings.rsrReplicationSetHover.maxQueue,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 8,
            col: 3
        }), new TextWidget({
            name: "maxRetry2",
            label: strings.rsrReplicationSetHover.maxRetry,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 9,
            col: 3
        }), new TextWidget({
            name: "onError2",
            label: strings.rsrReplicationSetHover.onError,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 10,
            col: 3
        }), new TextWidget({
            name: "linkType2",
            label: strings.rsrReplicationSetHover.linkType,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 11,
            col: 3
        }), new TextWidget({
            name: "onCollision2",
            label: strings.rsrReplicationSetHover.onCollision,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 12,
            col: 3
        }), new TextWidget({
            name: "monitorInterval2",
            label: strings.rsrReplicationSetHover.monitorInterval,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 13,
            col: 3
        }), new TextWidget({
            name: "priority2",
            label: strings.rsrReplicationSetHover.priority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 14,
            col: 3
        }), new TextWidget({
            name: "connStatus2",
            label: strings.rsrReplicationSetHover.connStatus,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 15,
            col: 3
        }), new TextWidget({
            name: "connTime2",
            label: strings.rsrReplicationSetHover.connTime,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 16,
            col: 3
        })]
    })];
    HoverPanel.call(this, C);
    this.class_name = "RsrReplicationSetHover"
}
RsrReplicationSetHover.prototype = new HoverPanel();
RsrReplicationSetHover.prototype.constructor = RsrReplicationSetHover;
RsrReplicationSetHover.prototype.showing = function() {
    var F = this.getApiObject();
    var C = {};
    if (!F) {
        return
    }
    var E = F.objects[0];
    var C = {
        repSetName: {
            text: F.get("name")
        },
        serial: {
            text: F.get("serial_number")
        },
        volName: {
            text: E.get("name")
        },
        status: {
            text: E.get("status")
        },
        statusReason: {
            text: E.get("status_reason")
        },
        location: {
            text: E.get("location")
        },
        monitor: {
            text: E.get("monitor")
        },
        maxRetry: {
            text: E.get("max_retry_time")
        },
        maxQueue: {
            text: E.get("max_queue")
        },
        onError: {
            text: E.get("error_policy")
        },
        linkType: {
            text: E.get("link_type")
        },
        onCollision: {
            text: E.get("collision_policy")
        },
        monitorInterval: {
            text: E.get("monitor_interval")
        },
        priority: {
            text: E.get("priority")
        },
        connStatus: {
            text: E.get("connection_status")
        },
        connTime: {
            text: E.get("connection_time")
        }
    };
    if (E.get("name") == E.get("primary_volume_name")) {
        C.volLabel1 = {
            text: strings.rsrReplicationSetHover.primaryVol
        };
        C.volLabel2 = {
            text: strings.rsrReplicationSetHover.secondaryVol
        }
    } else {
        C.volLabel1 = {
            text: strings.rsrReplicationSetHover.secondaryVol
        };
        C.volLabel2 = {
            text: strings.rsrReplicationSetHover.primaryVol
        }
    }
    if (typeof F.objects[1] != "undefined") {
        var D = F.objects[1];
        $.extend(C, {
            volName2: {
                text: D.get("name")
            },
            status2: {
                text: D.get("status")
            },
            statusReason2: {
                text: D.get("status_reason")
            },
            location2: {
                text: D.get("location")
            },
            monitor2: {
                text: D.get("monitor")
            },
            maxRetry2: {
                text: D.get("max_retry_time")
            },
            maxQueue2: {
                text: D.get("max_queue")
            },
            onError2: {
                text: D.get("error_policy")
            },
            linkType2: {
                text: D.get("link_type")
            },
            onCollision2: {
                text: D.get("collision_policy")
            },
            monitorInterval2: {
                text: D.get("monitor_interval")
            },
            priority2: {
                text: D.get("priority")
            },
            connStatus2: {
                text: D.get("connection_status")
            },
            connTime2: {
                text: D.get("connection_time")
            }
        })
    } else {}
    this.update(C)
};

function ReplicationImageHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ReplicationImageHover";
    var C = 0;
    D.widgets = [this.table = new TableWidget({
        name: "dataTable",
        maxCols: 4,
        widgets: [new TextWidget({
            name: "statusLabel",
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 0,
            colSpan: 2
        }), new TextWidget({
            name: "status",
            label: strings.replicationImageHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "progress",
            label: strings.replicationImageHover.progress,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "start",
            label: strings.replicationImageHover.start,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "lastUpdate",
            label: strings.replicationImageHover.lastUpdate,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "suspended",
            label: strings.replicationImageHover.suspended,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "ect",
            label: strings.replicationImageHover.ect,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "time",
            label: strings.replicationImageHover.time,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "snapLabel1",
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 0,
            colSpan: 2
        }), new TextWidget({
            name: "dg",
            label: strings.replicationImageHover.dg,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "serial",
            label: strings.replicationImageHover.serial,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "name",
            label: strings.replicationImageHover.name,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "creation",
            label: strings.replicationImageHover.creation,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "snapStatus",
            label: strings.replicationImageHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "statusReason",
            label: strings.replicationImageHover.statusReason,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "sourceVol",
            label: strings.replicationImageHover.sourceVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "parentVol",
            label: strings.replicationImageHover.parentVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "baseVol",
            label: strings.replicationImageHover.baseVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "numSnaps",
            label: strings.replicationImageHover.numSnaps,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "numSnapsTree",
            label: strings.replicationImageHover.numSnapsTree,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "snapPool",
            label: strings.replicationImageHover.snapPool,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "snapData",
            label: strings.replicationImageHover.snapData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "uniqueData",
            label: strings.replicationImageHover.uniqueData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "sharedData",
            label: strings.replicationImageHover.sharedData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "priority",
            label: strings.replicationImageHover.priority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "userPriority",
            label: strings.replicationImageHover.userPriority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "type",
            label: strings.replicationImageHover.type,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "size",
            label: strings.replicationImageHover.size,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "snapLabel2",
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 0
        }), new TextWidget({
            name: "name2",
            label: strings.replicationImageHover.name,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "serial2",
            label: strings.replicationImageHover.serial,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            name: "creation2",
            label: strings.replicationImageHover.creation,
            leftMargin: true,
            bottomSmallMargin: true,
            row: C++,
            col: 1
        }), new TextWidget({
            text: strings.replicationImageHover.secondaryVolSnap + strings.replicationImageHover.local,
            cssClass: "hoverSectionLabel",
            leftMargin: true,
            bottomSmallMargin: true,
            row: 8,
            col: 1,
            colSpan: 2
        }), new TextWidget({
            name: "dg2",
            label: strings.replicationImageHover.dg,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 9,
            col: 3
        }), new TextWidget({
            name: "serial3",
            label: strings.replicationImageHover.serial,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 10,
            col: 3
        }), new TextWidget({
            name: "name3",
            label: strings.replicationImageHover.name,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 11,
            col: 3
        }), new TextWidget({
            name: "creation3",
            label: strings.replicationImageHover.creation,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 12,
            col: 3
        }), new TextWidget({
            name: "snapStatus2",
            label: strings.replicationImageHover.status,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 13,
            col: 3
        }), new TextWidget({
            name: "statusReason2",
            label: strings.replicationImageHover.statusReason,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 14,
            col: 3
        }), new TextWidget({
            name: "sourceVol2",
            label: strings.replicationImageHover.sourceVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 15,
            col: 3
        }), new TextWidget({
            name: "parentVol2",
            label: strings.replicationImageHover.parentVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 16,
            col: 3
        }), new TextWidget({
            name: "baseVol2",
            label: strings.replicationImageHover.baseVol,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 17,
            col: 3
        }), new TextWidget({
            name: "numSnaps2",
            label: strings.replicationImageHover.numSnaps,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 18,
            col: 3
        }), new TextWidget({
            name: "numSnapsTree2",
            label: strings.replicationImageHover.numSnapsTree,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 19,
            col: 3
        }), new TextWidget({
            name: "snapPool2",
            label: strings.replicationImageHover.snapPool,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 20,
            col: 3
        }), new TextWidget({
            name: "snapData2",
            label: strings.replicationImageHover.snapData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 21,
            col: 3
        }), new TextWidget({
            name: "uniqueData2",
            label: strings.replicationImageHover.uniqueData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 22,
            col: 3
        }), new TextWidget({
            name: "sharedData2",
            label: strings.replicationImageHover.sharedData,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 23,
            col: 3
        }), new TextWidget({
            name: "priority2",
            label: strings.replicationImageHover.priority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 24,
            col: 3
        }), new TextWidget({
            name: "userPriority2",
            label: strings.replicationImageHover.userPriority,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 25,
            col: 3
        }), new TextWidget({
            name: "type2",
            label: strings.replicationImageHover.type,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 26,
            col: 3
        }), new TextWidget({
            name: "size2",
            label: strings.replicationImageHover.size,
            leftMargin: true,
            bottomSmallMargin: true,
            row: 27,
            col: 3
        })]
    })];
    HoverPanel.call(this, D);
    this.class_name = "ReplicationImageHover"
}
ReplicationImageHover.prototype = new HoverPanel();
ReplicationImageHover.prototype.constructor = ReplicationImageHover;
ReplicationImageHover.prototype.showing = function() {
    var H = this.getApiObject();
    if (!H) {
        return
    }
    var F = H.getSourceImage();
    var D = H.getDestImage();
    var I = this.getLocalImage(F, D);
    var O = strings.replicationImageHover.secondaryVolSnap;
    var N = strings.replicationImageHover.primaryVolSnap;
    var L = {};
    if (D != null) {
        var K = (D.isLocal() ? O : N);
        var J = (D.isLocal() ? N : O);
        var M = D.objects[0];
        if (M.getInt("status_numeric") == 2) {
            E = true
        }
        $.extend(L, {
            statusLabel: {
                text: strings.replicationImageHover.repSetStatus
            },
            snapLabel1: {
                text: K
            },
            snapLabel2: {
                text: J
            },
            status: {
                text: M.get("status")
            },
            progress: {
                text: M.get("progress") + "%"
            },
            start: {
                text: M.get("start_time")
            },
            lastUpdate: {
                text: M.get("update_time")
            },
            suspended: {
                text: M.get("suspended_time")
            },
            ect: {
                text: M.get("est_completion_time")
            },
            time: {
                text: M.get("time")
            }
        });
        this.table.showRows(1, 7)
    } else {
        var K = (F.isLocal() ? N : O);
        var J = (F.isLocal() ? O : N);
        $.extend(L, {
            snapLabel1: {
                text: K
            },
            snapLabel2: {
                text: J
            },
            statusLabel: {
                text: strings.replicationImageHover.repSetStatus + strings.replicationImageHover.noStatus
            }
        });
        this.table.hideRows(1, 7)
    }
    if (I != null && typeof I.length != "undefined") {
        var C = I[0];
        L.snapLabel1.text = N + strings.replicationImageHover.local;
        $.extend(L, {
            dg: {
                text: C.get("virtual_disk_name")
            },
            serial: {
                text: C.get("serial_number")
            },
            name: {
                text: C.get("name")
            },
            creation: {
                text: C.get("creation_date_time")
            },
            snapStatus: {
                text: C.get("status")
            },
            statusReasons: {
                text: C.get("status_reason")
            },
            sourceVol: {
                text: C.get("master_volume_name")
            },
            parentVol: {
                text: C.get("volume_parent")
            },
            baseVol: {
                text: C.get("base_volume")
            },
            numSnaps: {
                text: C.get("num_children")
            },
            numSnapsTree: {
                text: C.get("num_snaps_tree")
            },
            snapPool: {
                text: C.get("snap_pool_name")
            },
            snapData: {
                text: C.get("snap_data")
            },
            sharedData: {
                text: C.get("shareddata")
            },
            uniqueData: {
                text: C.get("uniquedata")
            },
            priority: {
                text: C.get("priority_value")
            },
            userPriority: {
                text: C.get("user_priority_value")
            },
            type: {
                text: C.get("snapshot_type")
            },
            size: {
                text: C.get("total_size")
            }
        });
        if (typeof I[1] != "undefined") {
            var G = I[1];
            $.extend(L, {
                dg2: {
                    text: G.get("virtual_disk_name")
                },
                serial3: {
                    text: G.get("serial_number")
                },
                name3: {
                    text: G.get("name")
                },
                creation3: {
                    text: G.get("creation_date_time")
                },
                snapStatus2: {
                    text: G.get("status")
                },
                statusReasons2: {
                    text: G.get("status_reason")
                },
                sourceVol2: {
                    text: G.get("master_volume_name")
                },
                parentVol2: {
                    text: G.get("volume_parent")
                },
                baseVol2: {
                    text: G.get("base_volume")
                },
                numSnaps2: {
                    text: G.get("num_children")
                },
                numSnapsTree2: {
                    text: G.get("num_snaps_tree")
                },
                snapPool2: {
                    text: G.get("snap_pool_name")
                },
                snapData2: {
                    text: G.get("snap_data")
                },
                sharedData2: {
                    text: G.get("shareddata")
                },
                uniqueData2: {
                    text: G.get("uniquedata")
                },
                priority2: {
                    text: G.get("priority_value")
                },
                userPriority2: {
                    text: G.get("user_priority_value")
                },
                type2: {
                    text: G.get("snapshot_type")
                },
                size2: {
                    text: G.get("total_size")
                }
            })
        }
        this.table.showColumns(2, 3);
        this.table.showRows(9, 27);
        this.table.hideRows(28, 31);
        this.options.width = 692;
        this.table.addCSSClass("equalColumnWidth")
    } else {
        this.table.hideColumns(2, 3);
        this.options.width = 578;
        var P = this.getRemoteImage(F, D);
        var E = false;
        if (I != null) {
            L.snapLabel1.text += strings.replicationImageHover.local;
            $.extend(L, {
                dg: {
                    text: I.get("virtual_disk_name")
                },
                serial: {
                    text: I.get("serial_number")
                },
                name: {
                    text: I.get("name")
                },
                creation: {
                    text: I.get("creation_date_time")
                },
                snapStatus: {
                    text: I.get("status")
                },
                statusReasons: {
                    text: I.get("status_reason")
                },
                sourceVol: {
                    text: I.get("master_volume_name")
                },
                parentVol: {
                    text: I.get("volume_parent")
                },
                baseVol: {
                    text: I.get("base_volume")
                },
                numSnaps: {
                    text: I.get("num_children")
                },
                numSnapsTree: {
                    text: I.get("num_snaps_tree")
                },
                snapPool: {
                    text: I.get("snap_pool_name")
                },
                snapData: {
                    text: I.get("snap_data")
                },
                sharedData: {
                    text: I.get("shareddata")
                },
                uniqueData: {
                    text: I.get("uniquedata")
                },
                priority: {
                    text: I.get("priority_value")
                },
                userPriority: {
                    text: I.get("user_priority_value")
                },
                type: {
                    text: I.get("snapshot_type")
                },
                size: {
                    text: I.get("total_size")
                }
            });
            this.table.showRows(9, 27)
        } else {
            if (E) {
                L.snapLabel1.text = L.snapLabel1.text + strings.replicationImageHover.snapNotCreated
            } else {
                L.snapLabel1.text = L.snapLabel1.text + strings.replicationImageHover.snapDeleted
            }
            this.table.hideRows(9, 27)
        }
        if (P != null) {
            if (E && P.get("snapshot_serial") == "00000000000000000000000000000000") {
                L.snapLabel2.text += strings.replicationImageHover.snapNotCreated
            }
            $.extend(L, {
                name2: {
                    text: P.get("snapshot_name")
                },
                serial2: {
                    text: P.get("snapshot_serial")
                },
                creation2: {
                    text: P.get("creation_date_time")
                }
            });
            this.table.showRows(28, 31)
        } else {
            this.table.showRows(28, 28);
            this.table.hideRows(29, 31);
            L.snapLabel2.text = L.snapLabel2.text + strings.replicationImageHover.snapDeleted
        }
    }
    this.update(L)
};
ReplicationImageHover.prototype.getLocalImage = function(D, C) {
    if (D != null) {
        if (C != null) {
            if (D.isLocal() && C.isLocal()) {
                return [DC.snapshotsSerial[D.get("snapshot_serial")], DC.snapshotsSerial[C.get("snapshot_serial")]]
            }
        }
        if (D.isLocal()) {
            return DC.snapshotsSerial[D.get("snapshot_serial")]
        }
    }
    if (C != null) {
        if (C.isLocal()) {
            return DC.snapshotsSerial[C.get("snapshot_serial")]
        }
    }
    return null
};
ReplicationImageHover.prototype.getRemoteImage = function(D, C) {
    if (D != null) {
        if (!D.isLocal()) {
            return D
        }
    }
    if (C != null) {
        if (!C.isLocal()) {
            return C
        }
    }
    return null
};

function DiskGroupHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 380;
    C.name = "DiskGroupHover";
    C.widgets = new WidgetContainer({
        widgets: [new TableWidget({
            name: "tableData",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.diskGroupHover.nameLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.diskGroupHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "pool",
                label: strings.diskGroupHover.poolLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "tier",
                label: strings.diskGroupHover.tierLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "poolPct",
                label: strings.diskGroupHover.poolPctLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "allocPages",
                label: strings.diskGroupHover.allocPagesLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "availPages",
                label: strings.diskGroupHover.availPagesLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "adaptTargetSpareCapacity",
                label: strings.diskGroupHover.adaptTargetSpareCapacity,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "adaptActualSpareCapacity",
                label: strings.diskGroupHover.adaptActualSpareCapacity,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "chunkSize",
                label: strings.diskGroupHover.chunkSizeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "owner",
                label: strings.diskGroupHover.ownerLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "spareCount",
                label: strings.diskGroupHover.spareCountLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sectorFormat",
                label: strings.diskGroupHover.sectorFormatLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "created",
                label: strings.diskGroupHover.created,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "minDiskSize",
                label: strings.diskGroupHover.minDiskSize,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "dsdEnable",
                label: strings.diskGroupHover.dsdEnable,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "size",
                label: strings.diskGroupHover.size,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "free",
                label: strings.diskGroupHover.free,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "raid",
                label: strings.diskGroupHover.raid,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "disks",
                label: strings.diskGroupHover.disks,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.diskGroupHover.status,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "currentJob",
                label: strings.diskGroupHover.currentJob,
                leftMargin: true,
                bottomSmallMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "DiskGroupHover"
}
DiskGroupHover.prototype = new HoverPanel();
DiskGroupHover.prototype.constructor = DiskGroupHover;
DiskGroupHover.prototype.showing = function() {
    var G = this.currentParent;
    var I = parseInt(G.get("storage_type_numeric"));
    var C = parseInt(G.get("raidtype_numeric"));
    var L = {
        start: 3,
        end: 6
    };
    var D = {
        start: 10,
        end: 11
    };
    var K = {
        start: 3,
        end: 9
    };
    var E = {
        start: 7,
        end: 11
    };
    if (I == 1 && C != DATAPROTECTIONLEVEL.ADAPT) {
        D = {
            start: 7,
            end: 11
        };
        var J = L;
        var H = D
    } else {
        if (I == 0 && C != DATAPROTECTIONLEVEL.ADAPT) {
            L = {
                start: 3,
                end: 8
            };
            var J = D;
            var H = L
        } else {
            if (I == 1) {
                var J = K;
                var H = D
            } else {
                var J = E;
                var H = L
            }
        }
    }
    var F = {
        tableData: {
            hide: H,
            show: J
        },
        name: {
            text: G.get("name")
        },
        serial: {
            text: G.get("serial_number")
        },
        pool: {
            text: G.get("pool")
        },
        tier: {
            text: G.get("storage_tier")
        },
        poolPct: {
            text: G.get("pool_percentage")
        },
        allocPages: {
            text: G.get("allocated_pages")
        },
        availPages: {
            text: G.get("available_pages")
        },
        adaptTargetSpareCapacity: {
            text: G.get("adapt_target_spare_capacity")
        },
        adaptActualSpareCapacity: {
            text: G.get("adapt_actual_spare_capacity")
        },
        owner: {
            text: strings.ownerCombined(G.get("preferred_owner"), G.get("owner"))
        },
        chunkSize: {
            text: G.get("chunksize")
        },
        spareCount: {
            text: G.get("sparecount")
        },
        sectorFormat: {
            text: G.get("pool_sector_format")
        },
        created: {
            text: G.get("create_date")
        },
        minDiskSize: {
            text: G.get("min_drive_size")
        },
        dsdEnable: {
            text: G.get("disk_dsd_enable_vdisk")
        },
        size: {
            text: G.get("size")
        },
        free: {
            text: G.get("freespace")
        },
        raid: {
            text: G.get("raidtype")
        },
        disks: {
            text: G.get("diskcount")
        },
        status: {
            text: G.get("status")
        },
        currentJob: {
            text: G.get("current_job")
        },
        health: {
            obj: G
        }
    };
    this.update(F)
};

function PoolHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 370;
    D.name = "PoolHover";
    var C = 0;
    D.widgets = new WidgetContainer({
        widgets: [this.poolHoverTable = new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: D.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.poolHover.nameLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.beginCommonRow = C
            }), new TextWidget({
                name: "serial",
                label: strings.poolHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "size",
                label: strings.poolHover.sizeLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "availSize",
                label: strings.poolHover.availSizeLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.endCommonRow = ++C
            }), new TextWidget({
                name: "overcommit",
                label: strings.poolHover.overcommitLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.beginVirtRow = ++C
            }), new TextWidget({
                name: "overcommitted",
                label: strings.poolHover.overcommitted,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "lowThresh",
                label: strings.poolHover.lowThreshLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "midThresh",
                label: strings.poolHover.midThreshLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "highThresh",
                label: strings.poolHover.highThreshLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "allocPages",
                label: strings.poolHover.allocPagesLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "virtSnapSize",
                label: strings.poolHover.snapPages,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.virtSnapSizeRow = ++C
            }), new TextWidget({
                name: "availPages",
                label: strings.poolHover.availPagesLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.endVirtRow = ++C
            }), new TextWidget({
                name: "snapSize",
                label: strings.poolHover.snapSize,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.linearSnapSizeRow = this.beginLinearRow = ++C
            }), new TextWidget({
                name: "owner",
                label: strings.poolHover.ownerLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.endLinearRow = ++C
            }), new TextWidget({
                name: "sectorFormat",
                label: strings.poolHover.sectorFormatLabel,
                leftMargin: true,
                bottomSmallMargin: true,
                row: this.beginFooterRow = this.endFooterRow = ++C
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, D);
    this.class_name = "PoolHover"
}
PoolHover.prototype = new HoverPanel();
PoolHover.prototype.constructor = PoolHover;
PoolHover.prototype.showing = function() {
    var G = this.currentParent;
    var E = parseInt(G.get("storage_type_numeric"));
    var C = G.getInt("over_committed_numeric");
    var D = (RI.hasFeature("dms") || RI.hasFeature("copyServices"));
    this.poolHoverTable.showRows(this.beginCommonRow, this.endCommonRow);
    this.poolHoverTable.showRows(this.beginFooterRow, this.endFooterRow);
    if (E == STORAGE_CLASS.VIRTUAL) {
        this.poolHoverTable.showRows(this.beginVirtRow, this.endVirtRow);
        this.poolHoverTable.hideRows(this.beginLinearRow, this.endLinearRow);
        this.poolHoverTable.hideRows(this.linearSnapSizeRow, this.linearSnapSizeRow);
        if (D) {
            this.poolHoverTable.showRows(this.virtSnapSizeRow, this.virtSnapSizeRow)
        } else {
            this.poolHoverTable.hideRows(this.virtSnapSizeRow, this.virtSnapSizeRow)
        }
    } else {
        this.poolHoverTable.hideRows(this.beginVirtRow, this.endVirtRow);
        this.poolHoverTable.showRows(this.beginLinearRow, this.endLinearRow);
        if (D) {
            this.poolHoverTable.showRows(this.linearSnapSizeRow, this.linearSnapSizeRow)
        } else {
            this.poolHoverTable.hideRows(this.linearSnapSizeRow, this.linearSnapSizeRow)
        }
    }
    var F = {
        name: {
            text: G.get("name")
        },
        serial: {
            text: G.get("serial_number")
        },
        size: {
            text: G.get("total_size")
        },
        availSize: {
            text: G.get("total_avail")
        },
        overcommit: {
            text: G.get("overcommit")
        },
        overcommitted: {
            text: G.get("over_committed")
        },
        lowThresh: {
            text: G.get("low_threshold")
        },
        midThresh: {
            text: G.get("middle_threshold")
        },
        highThresh: {
            text: G.get("high_threshold")
        },
        allocPages: {
            text: G.get("allocated_pages")
        },
        availPages: {
            text: G.get("available_pages")
        },
        owner: {
            text: strings.ownerCombined(G.get("preferred_owner"), G.get("owner"))
        },
        sectorFormat: {
            text: G.get("pool_sector_format")
        },
        health: {
            obj: G
        },
        virtSnapSize: {
            text: MC.poolsSet.virtPoolSnapSizeUsed[G.get("owner")].getPages()
        },
        snapSize: {
            text: MC.poolsSet.linearSnapSizeUsed[G.get("owner")].format("scale")
        },
        sectorFormat: {
            text: G.get("pool_sector_format")
        }
    };
    this.update(F)
};

function VMenuPanel(D) {
    if (arguments.length == 0 || !D.name) {
        return
    }
    var C = {
        menuClasses: "vMenu",
        titleClasses: "vMenuTitle",
        xOffset: 6,
        yOffset: 3,
        itemClasses: {
            all: "vMenuAll",
            odd: "vMenuOdd",
            even: "vMenuEven",
            hover: "vMenuHover"
        }
    };
    $.extend(C, D);
    C.htmlText = '<div id="' + D.name + '" class="' + C.menuClasses + '"></div>';
    Panel.call(this, C);
    this.class_name = "VMenuPanel";
    this.leftTimeoutCallback = createObjectCallback(this, this._leftTimeout);
    this.menu$ = $("#" + D.name, this.elements);
    this.menu$.hide();
    this.menu$.bind("mouseenter", createObjectCallback(this, this._entering));
    this.menu$.bind("mouseleave", createObjectCallback(this, this._leaving));
    $(this.elements).on("click", ".vMenuItem", createObjectCallback(this, this._onClick));
    $(this.elements).on("mouseenter", ".vMenuItem", createObjectCallback(this, this._itemEntered));
    $(this.elements).on("mouseleave", ".vMenuItem", createObjectCallback(this, this._itemLeft))
}
VMenuPanel.prototype = new Panel();
VMenuPanel.prototype.constructor = Panel;
VMenuPanel.prototype.open = function(F) {
    applicationAccessed();
    if (this.visible) {
        return
    }
    if (F) {
        this.title = F.title || this.options.title;
        this.parentObj = F.parentObj || this.options.parentObj;
        this.parentMenu = this.parentObj.menu || null;
        this.menu = F.menu || this.options.menu;
        if (this.parentMenu == this.menu) {
            this.parentMenu = null
        }
        this.position = F.position || this.options.position;
        this.callback = F.callback || this.options.callback
    }
    if (!this.menu || !this.position) {
        MC.errorOutput("Missing parameters for displaying menu: %o", this);
        return
    }
    delete this.highlighted$;
    this.itemObjects = [];
    this.menu$.html("");
    var C = "M";
    if (this.parentMenu) {
        this.menuObj = MENUS[this.parentMenu][this.menu].subMenu;
        C += this.parentMenu + "I" + this.menu + "S"
    } else {
        this.menuObj = MENUS[this.menu];
        C += this.menu + "I"
    }
    this.itemClasses = this.options.itemClasses;
    var H = 1;
    for (var N in this.menuObj) {
        var D = this.menuObj[N];
        var E = C + N;
        var G = "vMenuItem " + this.itemClasses.all + " " + ((H % 2 == 0) ? this.itemClasses.even : this.itemClasses.odd);
        var L = "";
        if (D.image) {
            L = 'style="background-image:url(' + D.image + ');"'
        }
        var M = D.text || strings.menus[N] || "undefined";
        if (D.topDivider) {
            G += " vMenuTopDivider"
        }
        if (D.bottomDivider) {
            G += " vMenuBottomDivider"
        }
        if (D.action && window[D.action]) {
            var K = window[D.action].getMenuState;
            if ($.isFunction(K)) {
                D.state = K(D)
            }
        }
        if (D.inactive) {
            D.state = "Feature not yet implemented."
        }
        if (D.state == undefined || D.state instanceof Array) {
            var J = '<div id="' + E + '" class="' + G + '" ' + L + ">" + M + "</div>"
        } else {
            if ((typeof D.state) == "string") {
                G += " vMenuDisabled";
                var J = '<div id="' + E + '" class="' + G + '" title="' + D.state + '" ' + L + ">" + M + "</div>"
            } else {
                if (D.state === false) {
                    continue
                } else {
                    MC.errorOutput("Unknown menu state: %o.", D.state);
                    continue
                }
            }
        }
        this.itemObjects[H] = $(J).appendTo(this.menu$).data("item", N);
        if (D.defaultItem) {
            this.highlighted$ = this.itemObjects[H];
            this.highlighted$.addClass(this.itemClasses.hover)
        }
        H++
    }
    if (H == 1) {
        var G = "vMenuItem vMenuAll " + this.itemClasses.odd + " vMenuDisabled";
        var J = '<div id="' + E + '" class="' + G + '" title="' + strings.menuTips.noEntries + '">' + strings.menus.noEntries + "</div>";
        this.itemObjects[H] = $(J).appendTo(this.menu$).data("item", "noEntries")
    }
    this.menu$.show();
    var I = this._calcPosition(F);
    this.menu$.offset(I);
    this.visible = true
};
VMenuPanel.prototype._calcPosition = function(E) {
    var K = null;
    if (E.position.top != undefined && E.position.left != undefined) {
        var K = E.position
    } else {
        if (E.position.element$) {
            var N = E.position.direction || "below";
            var F = E.position.edge || ((N == "above" || N == "below") ? "left" : "top");
            var L = E.position.element$;
            var M = L.offset();
            var J = L.outerWidth();
            var G = L.outerHeight();
            var D = this.menu$.outerWidth();
            var C = this.menu$.outerHeight();
            var K = {
                top: 0,
                left: 0
            };
            if (N == "below") {
                K.top = M.top + G + this.options.yOffset - 2
            } else {
                if (N == "above") {
                    K.top = M.top - C - this.options.yOffset
                } else {
                    if (N == "left") {
                        K.left = M.left - D - this.options.xOffset
                    } else {
                        if (N == "right") {
                            K.left = M.left + J + this.options.xOffset
                        }
                    }
                }
            }
            if (K.left == 0) {
                if (F == "left") {
                    K.left = M.left
                } else {
                    K.left = (M.left + J) - D
                }
            }
            if (K.top == 0) {
                if (F == "top") {
                    K.top = M.top
                } else {
                    K.top = (M.top + G) - C
                }
            }
            var H = $(window).width();
            var I = $(window).height();
            if (K.top < this.options.yOffset) {
                K.top = this.options.yOffset
            }
            if ((K.top + C) > (I - this.options.yOffset)) {
                K.top = I - C - this.options.yOffset
            }
            if (K.left < this.options.xOffset) {
                K.left = this.options.xOffset
            }
            if ((K.left + D) > (H - this.options.xOffset)) {
                K.left = H - D - this.options.xOffset
            }
        } else {
            MC.errorOutput("VMenuPanel %s: Invalid position specified: %o", this.options.name, E.position);
            var K = {
                top: 100,
                left: 100
            }
        }
    }
    return K
};
VMenuPanel.prototype._entering = function(C) {
    if (this.parentObj.enteringSubMenu) {
        this.parentObj.enteringSubMenu()
    }
    return true
};
VMenuPanel.prototype._leaving = function(C) {
    this.parentEntered = false;
    if (this.visible) {
        this.leavingTimeout = setTimeout(this.leftTimeoutCallback, 100)
    }
    return false
};
VMenuPanel.prototype._leftTimeout = function() {
    if (!this.visible) {
        return
    }
    if (this.visible && !this.parentEntered) {
        this.close();
        if (this.callback) {
            this.callback(null, null, null)
        }
    }
};
VMenuPanel.prototype.close = function(C) {
    this.menu$.hide();
    this.visible = false
};
VMenuPanel.prototype._itemEntered = function(C) {
    if (this.highlighted$) {
        this.highlighted$.removeClass(this.options.itemClasses.hover)
    }
    $(C.currentTarget).addClass(this.options.itemClasses.hover);
    this.highlighted$ = $(C.currentTarget);
    return false
};
VMenuPanel.prototype._itemLeft = function(C) {
    $(C.currentTarget).removeClass(this.options.itemClasses.hover);
    return true
};
VMenuPanel.prototype.enteringParent = function() {
    this.parentEntered = true
};
VMenuPanel.prototype._onClick = function(E) {
    var D = $(E.currentTarget).data("item");
    var C = this.menuObj[D];
    if (!C) {
        MC.warningOutput("Menu item [%s] not found!", D);
        return false
    }
    if (C.state && (typeof C.state) == "string") {
        return false
    }
    this.close();
    if (this.parentMenu) {
        NAV.navTo(this.parentMenu, this.menu, D);
        if (this.callback) {
            this.callback(this.parentMenu, this.menu, D)
        }
    } else {
        NAV.navTo(this.menu, D, null);
        if (this.callback) {
            this.callback(this.menu, D, null)
        }
    }
    return false
};

function TopicMenuPanel(F) {
    if (arguments.length == 0) {
        return
    }
    if (!F.name) {
        F.name = "TopicMenuPanel"
    }
    this.menu = F.menu;
    this.menuObj = MENUS[this.menu];
    if (!(RI.hasFeature("asyncRep") && !EXPR.isSasPortType)) {
        delete MENUS.topics.replications;
        delete MENUS.RepsTopic
    }
    F.htmlText = '<div id="M' + this.menu + '"><table cellspacing="0" cellpadding="0"><tr><td><div class="topicMenu"></div></td></tr></table></div>';
    Panel.call(this, F);
    this.class_name = "TopicMenuPanel";
    this.menu$ = $(".topicMenu", this.elements);
    this.topicList = {};
    for (var C in this.menuObj) {
        if (!this.menuObj[C].useIt) {
            continue
        }
        var E = this.menuObj[C].text || strings.menus[C] || "undefined";
        var D = '<div id="M' + this.menu + "I" + C + '" class="topicItem">  <div class="topicImage ' + this.menuObj[C].topicClass + '"></div>  <div class="topicText">' + E + "</div></div>";
        $(D).appendTo(this.menu$).data("item", C);
        this.topicList[this.menuObj[C].topic] = C
    }
    $(".topicItem", this.elements).mouseenter(createObjectCallback(this, this._topicEntered));
    $(".topicItem", this.elements).mouseleave(createObjectCallback(this, this._topicLeft));
    $(".topicItem", this.elements).click(createObjectCallback(this, this._onClick));
    this.smCallback = createObjectCallback(this, this.subMenuCallback);
    this.leftTimeoutCallback = createObjectCallback(this, this._leftTimeout);
    this.subMenu = new VMenuPanel({
        name: "topicSubMenu",
        xOffset: 6,
        attachTo: views.topicSubMenuView
    })
}
TopicMenuPanel.prototype = new Panel();
TopicMenuPanel.prototype.constructor = TopicMenuPanel;
TopicMenuPanel.prototype._topicEntered = function(E) {
    if (this.leavingTimeout) {
        clearTimeout(this.leavingTimeout)
    }
    var D = $(E.currentTarget);
    var C = D.data("item");
    if (C != this.currentTopic) {
        D.addClass("topicHover")
    }
    if (this.subMenuOpen) {
        if (this.subMenuOpen != C) {
            $("#M" + this.menu + "I" + this.subMenuOpen).removeClass("topicHover");
            this.subMenu.close();
            delete this.subMenuOpen
        } else {
            this.subMenu.enteringParent()
        }
    }
    if (this.menuObj[C].subMenu) {
        this.subMenu.open({
            parentObj: this,
            menu: C,
            position: {
                element$: D,
                direction: "right",
                edge: "top"
            },
            callback: this.smCallback
        });
        this.subMenuOpen = C;
        this.subMenuEntered = false
    }
    return false
};
TopicMenuPanel.prototype._leftTimeout = function() {
    if (this.subMenuOpen && !this.subMenuEntered) {
        this.subMenu.close();
        $("#M" + this.menu + "I" + this.subMenuOpen).removeClass("topicHover")
    } else {}
};
TopicMenuPanel.prototype._topicLeft = function(C) {
    if (this.subMenuOpen) {
        this.leavingTimeout = setTimeout(this.leftTimeoutCallback, 200)
    } else {
        $(C.currentTarget).removeClass("topicHover")
    }
    return false
};
TopicMenuPanel.prototype._onClick = function(D) {
    var C = $(D.currentTarget).data("item");
    NAV.navTo(this.menu, C, null);
    if (this.subMenuOpen) {
        $("#M" + this.menu + "I" + this.subMenuOpen).removeClass("topicHover");
        this.subMenu.close();
        delete this.subMenuOpen
    }
    return false
};
TopicMenuPanel.prototype.selectTopic = function(C) {
    var D = this.topicList[C];
    var E = "#M" + this.menu + "I" + D;
    if (this.currentTopicID) {
        $(this.currentTopicID, this.elements).removeClass("topicSelected")
    }
    $(E, this.elements).addClass("topicSelected");
    this.currentTopicID = E
};
TopicMenuPanel.prototype.enteringSubMenu = function() {
    this.subMenuEntered = true
};
TopicMenuPanel.prototype.subMenuCallback = function(D, C, E) {
    if (this.subMenuOpen) {
        $("#M" + this.menu + "I" + this.subMenuOpen).removeClass("topicHover");
        delete this.subMenuOpen
    }
};

function Grid(C) {
    if (arguments.length == 0) {
        return
    }
    var D = {
        caption: undefined,
        header: undefined,
        data: null,
        rows: 0,
        cols: 0,
        selectable: false,
        maxSelectable: 0,
        exclusive: false,
        sortable: true,
        fresh: true,
        intercept: null,
        filter: null,
        meta: null
    };
    $.extend(D, C);
    this.update(D);
    this.numSelected = 0
}
Grid.prototype.update = function(D) {
    if (D.rows != undefined) {
        this.rows = D.rows
    }
    if (D.cols != undefined) {
        this.cols = D.cols
    }
    if (D.data != undefined) {
        this.data = D.data;
        delete this.sortOrder
    }
    if (D.caption != undefined) {
        this.caption = D.caption
    }
    if (D.header != undefined) {
        this.header = D.header
    }
    if (D.selectable != undefined) {
        this.selectable = D.selectable
    }
    if (D.maxSelectable != undefined) {
        this.maxSelectable = parseInt(D.maxSelectable)
    }
    if (isNaN(this.maxSelectable)) {
        this.maxSelectable = 0
    }
    if (D.exclusive) {
        this.maxSelectable = 1
    }
    if (D.sortable != undefined) {
        this.sortable = D.sortable
    }
    if (D.sortOrder != undefined) {
        this.sortOrder = null
    }
    if (D.intercept != undefined) {
        this.intercept = D.intercept
    }
    if (D.filter != undefined) {
        this.filter = D.filter
    }
    if (D.meta != undefined) {
        this.meta = D.meta
    }
    if (D.selection != undefined) {
        this.selection = D.selection;
        this.numSelected = 0;
        for (var C = 0; C < this.selection.length; C++) {
            if (this.selection[C]) {
                this.numSelected++
            }
        }
    }
    this._setDimensions()
};
Grid.prototype._initialize = function() {
    if (this.meta) {
        if (this.filter && this.filter.fields) {
            this.fields = new Array();
            for (var C = 0; C < this.filter.fields.length; C++) {
                var E = this.filter.fields[C];
                if (this.meta.prop[E]) {
                    if (this.meta.prop[E].filter(this.filter)) {
                        this.fields.push(E)
                    }
                }
            }
        } else {
            this.fields = new Array();
            for (var E in this.meta.prop) {
                if ((!this.filter) || this.meta.prop[E].filter(this.filter)) {
                    this.fields.push(E)
                }
            }
        }
        var D = this.fields.length;
        this.colMeta = new Array(D);
        for (var C = 0; C < D; C++) {
            var F = this.meta.prop[this.fields[C]];
            this.colMeta[C] = {
                sortable: true,
                sort: "string"
            };
            if (F) {
                $.extend(this.colMeta[C], F.attr);
                this.colMeta[C].text = F.text
            }
            if (typeof this.colMeta[C].sortable != "boolean") {
                this.colMeta[C].sortable = (this.colMeta[C].sortable == "true") ? true : false
            }
        }
    }
};
Grid.prototype.isSortable = function() {
    return this.sortable
};
Grid.prototype.isSelectable = function() {
    var C = false;
    if ((typeof this.selectable) == "boolean") {
        if (this.selectable) {
            C = true
        }
    } else {
        if (this.selectable instanceof Array) {
            C = true
        }
    }
    return C
};
Grid.prototype.getMaxSelectable = function() {
    return (this.maxSelectable)
};
Grid.prototype.colIsSortable = function(C) {
    if (!this.sortable) {
        return false
    }
    if (this.colMeta && C < this.colMeta.length && this.colMeta[C].sortable) {
        return true
    }
    return false
};
Grid.prototype.colCollate = function(C) {
    if (this.colMeta && C < this.colMeta.length) {
        return this.colMeta[C].sort
    }
    return "text"
};
Grid.prototype.colSorted = function(D) {
    if (this.colMeta && D < this.colMeta.length && this.colMeta[D].sorted) {
        var C = ((this.colMeta[D].ascending) ? "A" : "D") + (this.colMeta[D].sortSequence);
        return C
    }
    return false
};
Grid.prototype.colIsTitle = function(C) {
    if (this.colMeta && C < this.colMeta.length && this.colMeta[C].title) {
        return true
    }
    return false
};
Grid.prototype.select = function(E, D) {
    if (!this.selectable) {
        return
    }
    if (this.rowIsSelectable(E)) {
        if (!this.selection) {
            this.selection = new Array(this.rows);
            for (var C = 0; C < this.rows; C++) {
                this.selection[C] = false
            }
        }
        E = this._logToPhys(E);
        if (this.selection && E < this.selection.length) {
            if (this.selection[E] && !D) {
                this.numSelected--
            } else {
                if (!this.selection[E] && D) {
                    this.numSelected++
                }
            }
            this.selection[E] = D
        }
    }
};
Grid.prototype.rowIsSelectable = function(C) {
    if (!this.selectable) {
        return false
    }
    if (this.selectable instanceof Array) {
        C = this._logToPhys(C);
        if (C < this.selectable.length) {
            if (this.selectable[C]) {
                return true
            }
            return false
        }
        return false
    }
    return true
};
Grid.prototype.rowIsSelected = function(C) {
    C = this._logToPhys(C);
    if (this.selection && C < this.selection.length) {
        return this.selection[C]
    }
};
Grid.prototype.clearSelections = function() {
    delete this.selection;
    this.numSelected = 0
};
Grid.prototype.sort = function(H, I) {
    if (this.colIsSortable(H)) {
        if (!this.sortOrder) {
            this.sortOrder = new Array(this.rows);
            for (var J = 0; J < this.rows; J++) {
                this.sortOrder[J] = J
            }
        }
        var E = this;

        function K(Q, O) {
            var P = E._getSortCell(Q, H);
            var R = E._getSortCell(O, H);
            var N = P.localeCompare(R);
            return N
        }

        function D(R, O) {
            var Q = E._getSortCell(R, H);
            var U = E._getSortCell(O, H);
            var N = 0;
            if (Q.indexOf(strings.driveLabel) == 0 && U.indexOf(strings.driveLabel) == 0) {
                var S = strings.driveLabel.length;
                var P = Q.substring(S + 1);
                var T = U.substring(S + 1);
                N = APIDrives.compareLocation(P, T)
            } else {
                N = Q.localeCompare(U)
            }
            return N
        }

        function G(Q, O) {
            var P = MC.extractNumber(E._getSortCell(Q, H));
            var R = MC.extractNumber(E._getSortCell(O, H));
            var N = 0;
            if (P < R) {
                N = -1
            } else {
                if (P > R) {
                    N = 1
                }
            }
            return N
        }

        function L(R, P) {
            var S = E._getSortCell(R, H);
            var O = E._getSortCell(P, H);
            var Q = MC.extractNumber(S);
            var T = MC.extractNumber(O);
            if (S == Q) {
                var N = 0;
                if (Q < T) {
                    N = -1
                } else {
                    if (Q > T) {
                        N = 1
                    }
                }
            } else {
                var N = S.localeCompare(O)
            }
            return N
        }

        function M(Q, O) {
            var T = new Size(E._getSortCell(Q, H));
            var R = new Size(E._getSortCell(O, H));
            var P = T.getBlocks();
            var S = R.getBlocks();
            var N = 0;
            if (P < S) {
                N = -1
            } else {
                if (P > S) {
                    N = 1
                }
            }
            return N
        }
        var F = K;
        switch (this.colCollate(H)) {
            case "integer":
                F = G;
                break;
            case "datetime":
                F = L;
                break;
            case "size":
                F = M;
                break;
            case "rackComponentName":
                F = D;
                break;
            default:
                F = K;
                break
        }
        this.sortOrder.sort(F);
        if (I == "D") {
            this.sortOrder.reverse()
        }
        for (var J = 0; J < this.colMeta.length; J++) {
            this.colMeta[J].sorted = false
        }
        var C = this.colMeta[H];
        C.sorted = true;
        C.sortSequence = 1;
        C.ascending = (I == "A")
    }
};
Grid.prototype._logToPhys = function(C) {
    if (this.sortOrder && C < this.sortOrder.length) {
        return this.sortOrder[C]
    }
    return C
};
Grid.prototype._physToLog = function(D) {
    if (this.sortOrder) {
        for (var C = 0; C < this.sortOrder.length; C++) {
            if (this.sortOrder[C] == D) {
                return C
            }
        }
    }
    return D
};
Grid.prototype.isFresh = function() {
    var C = this.fresh;
    this.fresh = false;
    return C
};
Grid.prototype.setData = function(C) {
    this.data = C;
    this.fresh = true;
    this._setDimensions()
};
Grid.prototype._setDimensions = function() {
    this._initialize()
};
Grid.prototype.setCaption = function(C) {
    this.caption = C
};
Grid.prototype.hasCaption = function() {
    return this.caption ? true : false
};
Grid.prototype.getCaption = function() {
    return this.caption
};
Grid.prototype.getRows = function() {
    return this.rows
};
Grid.prototype.getCols = function() {
    return this.cols
};
Grid.prototype.getCell = function(E, D) {
    var C = this._logToPhys(E);
    return this._getIntCell(C, D)
};
Grid.prototype._getSortCell = function(E, D) {
    var C = this._getPhysCell(E, D);
    if (C == undefined) {
        return this._getIntCell(E, D)
    }
    return C
};
Grid.prototype._getIntCell = function(D, C) {
    if (this.intercept) {
        var F = this.intercept.length;
        for (var E = 0; E < F; E++) {
            var H = this.intercept[E];
            if (!H.dataHandler) {
                continue
            }
            if (H.selector) {
                if (typeof(H.selector) == "number") {
                    if (H.selector == C) {
                        return H.dataHandler(this._getPhysObject(D), H.selector)
                    }
                } else {
                    if (this._getColField(D, C) == H.selector) {
                        return H.dataHandler(this._getPhysObject(D), H.selector)
                    }
                }
            } else {
                var G = this._getColField(D, C);
                if (G != undefined) {
                    return H.dataHandler(this._getPhysObject(D), G)
                }
            }
        }
    }
    return this._getPhysCell(D, C)
};
Grid.prototype.getCellClass = function(G, C) {
    if (this.intercept) {
        var E = this.intercept.length;
        for (var D = 0; D < E; D++) {
            var F = this.intercept[D];
            if (!F.classHandler) {
                continue
            }
            if (F.selector) {
                if (typeof(F.selector) == "number") {
                    if (F.selector == C) {
                        return F.classHandler(this.getObject(G), F.selector)
                    }
                } else {
                    if (this.fields[C] == F.selector) {
                        return F.classHandler(this.getObject(G), F.selector)
                    }
                }
            } else {
                return F.classHandler(this.getObject(G), this.fields[C])
            }
        }
    }
    return false
};
Grid.prototype.setHeader = function(C) {
    this.header = C
};
Grid.prototype.hasHeader = function() {
    return (this.header || this.meta)
};
Grid.prototype.getHeader = function(C) {
    if (C >= 0) {
        if (this.header && C < this.header.length) {
            return this.header[C]
        }
        if (this.colMeta && C < this.colMeta.length) {
            var D = this.colMeta[C];
            if (D != undefined) {
                return D.text
            }
        }
    }
    return undefined
};
Grid.prototype.getHeaderDesc = function(C) {
    if (C >= 0) {
        if (this.colMeta && C < this.colMeta.length) {
            var D = this.colMeta[C];
            if (D != undefined) {
                return D.desc
            }
        }
    }
    return undefined
};
Grid.prototype.getObject = function(D) {
    var C = this._logToPhys(D);
    return this._getPhysObject(C)
};
Grid.prototype._getPhysObject = function(C) {
    return undefined
};
Grid.prototype._getColField = function(D, C) {
    if (C < this.fields.length) {
        return this.fields[C]
    }
    return undefined
};

function BasicDataGrid(C) {
    if (arguments.length == 0) {
        return
    }
    Grid.call(this, C)
}
BasicDataGrid.prototype = new Grid();
BasicDataGrid.prototype._setDimensions = function() {
    this._initialize();
    if (!this.rows) {
        this.rows = (this.data ? this.data.length : 0)
    }
    if (!this.cols) {
        if (this.fields) {
            this.cols = this.fields.length
        } else {
            var D = this.rows;
            for (var C = 0; C < D; C++) {
                if (this.data && this.data[C]) {
                    if (this.data[C].length > this.cols) {
                        this.cols = this.data[C].length
                    }
                }
            }
        }
    }
};
BasicDataGrid.prototype._getPhysCell = function(D, C) {
    if (this.data && (D < this.data.length)) {
        if (this.data[D] && (C < this.data[D].length)) {
            return this.data[D][C]
        }
    }
    return undefined
};
BasicDataGrid.prototype._getPhysObject = function(C) {
    if (this.data && (C < this.data.length)) {
        return this.data[C]
    }
    return undefined
};

function BasicObjectGrid(C) {
    if (arguments.length == 0) {
        return
    }
    C.cols = C.cols || 2;
    this.order = C.order || "horizontal";
    Grid.call(this, C)
}
BasicObjectGrid.prototype = new Grid();
BasicObjectGrid.prototype._setDimensions = function() {
    this._initialize();
    if (this.cols % 2 != 0) {
        this.cols = (this.cols / 2) * 2
    }
    if (this.data && this.data.length) {
        this.rows = Math.ceil(this.data.length / (this.cols / 2))
    } else {
        this.rows = 0;
        this.cols = 0
    }
};
BasicObjectGrid.prototype.colIsTitle = function(C) {
    return (C % 2 == 0)
};
BasicObjectGrid.prototype._getColField = function(F, D) {
    if (F >= 0 && F < this.rows && D >= 0 && D < this.cols) {
        var C = (this.order == "horizontal") ? C = F * this.cols + D : C = D * this.rows + F;
        var E = Math.floor(C / 2);
        if (E < this.fields.length) {
            if (C % 2 == 1) {
                return this.fields[E]
            }
        }
    }
    return undefined
};
BasicObjectGrid.prototype._getPhysCell = function(F, D) {
    if (F >= 0 && F < this.rows && D >= 0 && D < this.cols) {
        var C = (this.order == "horizontal") ? C = F * this.cols + D : C = D * this.rows + F;
        var E = Math.floor(C / 2);
        if (E < this.data.length) {
            var G = this.data[E];
            return (C % 2 == 0) ? G.name : G.value
        }
    }
    return undefined
};
BasicObjectGrid.prototype._getPhysObject = function(G) {
    var C = new Array();
    for (var E = 0; E < this.cols; E += 2) {
        var D = (this.order == "horizontal") ? D = G * this.cols + E : D = E * this.rows + G;
        var F = Math.floor(D / 2);
        if (F < this.data.length) {
            C[C.length] = this.data[F]
        }
    }
    return C
};

function APIDataGrid(C) {
    if (arguments.length == 0) {
        return
    }
    BasicDataGrid.call(this, C)
}
APIDataGrid.prototype = new BasicDataGrid();
APIDataGrid.prototype._getMetaFrom = function(C) {
    this.meta = C ? C.meta : null
};
APIDataGrid.prototype._setDimensions = function() {
    if (this.data && this.data instanceof APIData) {
        this.rows = this.data.objects.length;
        this._getMetaFrom(this.data.objects[0]);
        this._initialize();
        if (this.fields) {
            this.cols = this.fields.length
        } else {
            this.cols = 0
        }
    } else {
        this.rows = 0;
        this.cols = 0
    }
};
APIDataGrid.prototype._getPhysCell = function(D, C) {
    if (D >= 0 && D < this.rows && C >= 0 && C < this.cols) {
        var E = this.data.objects[D].prop[this.fields[C]];
        if (E != undefined) {
            return E.text
        }
    }
    return undefined
};
APIDataGrid.prototype._getPhysObject = function(C) {
    if (C >= 0 && C < this.rows) {
        return this.data.objects[C]
    }
    return undefined
};

function APIObjectGrid(C) {
    if (arguments.length == 0) {
        return
    }
    this.filter = C.filter || null;
    BasicObjectGrid.call(this, C)
}
APIObjectGrid.prototype = new BasicObjectGrid();
APIObjectGrid.prototype._setDimensions = function() {
    if (this.cols % 2 != 0) {
        this.cols = (this.cols / 2) * 2
    }
    if (this.data && this.data instanceof APIObject) {
        APIDataGrid.prototype._getMetaFrom.call(this, this.data);
        this._initialize();
        if (this.fields) {
            this.rows = Math.ceil(this.fields.length / (this.cols / 2))
        } else {
            this.rows = 0;
            this.cols = 0
        }
    } else {
        this.rows = 0;
        this.cols = 0
    }
};
APIObjectGrid.prototype._getPhysCell = function(F, D) {
    if (F >= 0 && F < this.rows && D >= 0 && D < this.cols) {
        var C = (this.order == "horizontal") ? C = F * this.cols + D : C = D * this.rows + F;
        var E = Math.floor(C / 2);
        if (E < this.fields.length) {
            var G = (C % 2 == 0) ? this.meta.prop[this.fields[E]] : this.data.prop[this.fields[E]];
            if (G != undefined) {
                return G.text
            }
        }
    }
    return undefined
};
APIObjectGrid.prototype._getPhysObject = function(C) {
    return this.data
};
ObjectTable = function(C) {
    if (arguments.length == 0) {
        return
    }
    var D = {
        headerClass: "objectTitle",
        titleClass: "propertyTitle",
        titleSpacerClass: "propertySpacerTitle",
        valueClass: "propertyValue",
        valueAltClass: "propertyAltValue",
        valueSpacerClass: "propertySpacerValue",
        valueWidth: "200",
        spacerWidth: "20",
        titleWidth: "200",
        captionClass: "propertyCaption",
        alternate: false
    };
    $.extend(D, C);
    this.headerClass = D.headerClass;
    this.titleClass = D.titleClass;
    this.titleSpacerClass = D.titleSpacerClass;
    this.valueClass = D.valueClass;
    this.valueAltClass = D.valueAltClass;
    this.valueSpacerClass = D.valueSpacerClass;
    this.valueWidth = D.valueWidth;
    this.titleWidth = D.titleWidth;
    this.spacerWidth = D.spacerWidth;
    this.captionClass = D.captionClass;
    this.alternate = D.alternate;
    D.htmlText = '<div><table class="propertyTable" align="left" border="0" cellspacing="0" cellpadding="0">' + (D.caption ? ('<caption class="' + this.captionClass + '"></caption>') : "") + "<tbody></tbody></table></div>";
    Widget.call(this, D);
    this.class_name = "ObjectTable";
    this.tableBody$ = $("tbody", this.elements);
    this.title$ = $("." + this.captionClass, this.elements);
    this.handleUpdate(D);
    this.tableBody$.disableTextSelect()
};
ObjectTable.prototype = new Widget();
ObjectTable.prototype.handleUpdate = function(D) {
    if (!D) {
        return
    }
    if (D.grid != undefined) {
        this.grid = D.grid
    }
    if (D.caption) {
        if (this.grid) {
            this.grid.setCaption(D.caption)
        }
        if (this.title$) {
            this.title$.html(D.caption)
        }
    } else {
        if (this.grid && this.grid.hasCaption()) {
            if (this.title$) {
                this.title$.html(this.grid.getCaption())
            }
        }
    }
    if (!this.grid) {
        return
    }
    this.rows = this.grid.getRows();
    this.cols = this.grid.getCols();
    var G = "";
    if (this.grid.hasHeader()) {
        var N = this.headerClass;
        G += "<tr>";
        for (var E = 0; E < this.cols; E++) {
            if ((E > 0) && (E < (this.cols - 1)) && ((E % 2) == 0)) {
                G += '<td class="' + this.titleSpacerClass + '" style="width:' + this.spacerWidth + 'px;"><nobr>&nbsp;</nobr></td>'
            }
            var M = this.grid.getHeader(E);
            if (M == undefined) {
                M = "&nbsp;"
            }
            G += '<td class="' + N + '"><nobr>';
            G += M;
            G += "</nobr></td>"
        }
        G += "</tr>"
    }
    if (this.rows == 0) {
        var K = (this.cols) ? this.cols : 1;
        G += '<td class="' + this.valueClass + '" colspan="' + K + '"><nobr>' + strings.emptyTableMessage + "</nobr></td>"
    }
    for (var O = 0; O < this.rows; O++) {
        var F = this.valueClass;
        var J = this.titleClass;
        if (this.alternate && ((O % 2) == 0)) {
            F = this.valueAltClass
        }
        G += "<tr>";
        for (var E = 0; E < this.cols; E++) {
            if ((E > 0) && (E < (this.cols - 1)) && ((E % 2) == 0)) {
                G += '<td class="' + this.valueSpacerClass + '" style="width:' + this.spacerWidth + 'px;"><nobr>&nbsp;</nobr></td>'
            }
            var L = "";
            if (this.grid.colIsTitle(E)) {
                var I = this.grid.getHeaderDesc(O * (this.cols / 2) + Math.floor(E / 2));
                if (I) {
                    L = ' title="' + I + '"'
                }
                var H = J;
                var C = this.titleWidth
            } else {
                var H = F;
                var C = this.valueWidth
            }
            var M = this.grid.getCell(O, E);
            if (M == undefined) {
                M = "&nbsp;"
            }
            G += '<td class="' + H + '"' + L + '><div class="propertyHolder"><nobr>';
            G += M;
            G += "</nobr></div></td>"
        }
        G += "</tr>"
    }
    this.tableBody$.html(G)
};

function TableRow(C) {
    this.class_name = "TableRow";
    this.elements$ = $("<tr></tr>");
    this.parent = C.parent;
    this.selectable = C.selectable;
    if (this.selectable) {
        this.elements$.addClass("rowSelectable").click(createObjectCallback(this, this.selecting))
    }
    this.parent.append(this.elements$);
    this.selected = false;
    this.index = C.index
}
TableRow.prototype.append = function(C) {
    this.elements$.append(C);
    if (this.selectable) {
        this.children$ = this.elements$.children();
        this.selector$ = $("input", this.elements$)
    }
};
TableRow.prototype.setSelected = function() {
    if (this.selectable) {
        this.selector$.prop("checked", true);
        this.children$.addClass("rowSelected");
        this.selected = true;
        this.parent.selecting(this.index)
    }
};
TableRow.prototype.setUnselected = function() {
    if (this.selectable) {
        this.selector$.prop("checked", false);
        this.children$.removeClass("rowSelected");
        this.selected = false;
        this.parent.unselecting(this.index)
    }
};
TableRow.prototype.selecting = function(C) {
    applicationAccessed();
    if (C && C.shiftKey) {
        this.parent.selectToIndex(this.index);
        return
    }
    if (this.parent.exclusive) {
        if (!this.selected) {
            this.parent.deselectCurrent();
            this.setSelected()
        }
    } else {
        if (this.selected) {
            this.setUnselected()
        } else {
            if (this.parent.canSelect()) {
                this.setSelected();
                this.parent.lastSelectedIndex = this.index
            } else {
                this.selector$.prop("checked", false)
            }
        }
    }
};
TableRow.prototype.select = function() {
    this.elements$.click()
};
DataTable = function(D) {
    if (arguments.length == 0) {
        return
    }
    var E = {
        titleClass: "objectTitle",
        valueClass: "objectValue",
        valueAltClass: "objectAltValue",
        valueTitleClass: "propertyTitle",
        valueSortedClass: "objectSortedValue",
        captionClass: "objectCaption",
        selectorClass: "objectSelector",
        selectorAltClass: "objectAltSelector",
        selectorTitleClass: "objectSelectorTitle",
        sortedDownTitleClass: "objectDownSortedTitle",
        sortedUpTitleClass: "objectUpSortedTitle",
        sortableTitleClass: "objectSortableTitle",
        alternate: true
    };
    $.extend(E, D);
    this.titleClass = E.titleClass;
    this.valueClass = E.valueClass;
    this.valueAltClass = E.valueAltClass;
    this.valueTitleClass = E.valueTitleClass;
    this.valueSortedClass = E.valueSortedClass;
    this.captionClass = E.captionClass;
    this.selectorClass = E.selectorClass;
    this.selectorAltClass = E.selectorAltClass;
    this.selectorTitleClass = E.selectorTitleClass;
    this.sortedDownTitleClass = E.sortedDownTitleClass;
    this.sortedUpTitleClass = E.sortedUpTitleClass;
    this.sortableTitleClass = E.sortableTitleClass;
    this.alternate = E.alternate;
    var C = "objectTable";
    if (E.classes) {
        C += " " + E.classes
    }
    E.htmlText = '<div><table class="' + C + '" align="left" border="0" cellspacing="0" cellpadding="0">' + (E.caption ? '<caption class="' + this.captionClass + '"></caption>' : "") + "<tbody></tbody></table><div>";
    Widget.call(this, E);
    this.class_name = "DataTable";
    this.tableBody$ = $("tbody", this.elements);
    this.title$ = $("." + this.captionClass, this.elements);
    this.rows = new Array();
    this.handleUpdate(E);
    this.tableBody$.disableTextSelect()
};
DataTable.prototype = new Widget();
DataTable.prototype.handleUpdate = function(Q) {
    if (!Q) {
        return
    }
    if (Q.sortInfo) {
        this.sortInfo = Q.sortInfo
    }
    if (Q.grid != undefined) {
        this.grid = Q.grid;
        if (this.sortInfo) {
            this.grid.sort(this.sortInfo.column, this.sortInfo.order)
        }
    }
    if (Q.resetSort) {
        delete this.sortInfo
    }
    if (Q.caption) {
        if (this.grid) {
            this.grid.setCaption(Q.caption)
        }
    }
    if (this.grid && this.grid.hasCaption()) {
        if (this.title$) {
            this.title$.html(this.grid.getCaption())
        }
    }
    if (!this.grid) {
        return
    }
    this.rows = this.grid.getRows();
    this.cols = this.grid.getCols();
    this.selectable = this.grid.isSelectable();
    this.maxSelectable = this.grid.getMaxSelectable();
    this.exclusive = (this.maxSelectable == 1);
    this.sortable = this.grid.isSortable();
    if (typeof Q.selected != undefined) {
        if ((typeof Q.selected == "boolean") && (!Q.selected)) {
            this.grid.clearSelections()
        }
        if ((typeof Q.selected == "number")) {
            if (this.exclusive) {
                this.grid.clearSelections()
            }
            if (this.maxSelectable == 0 || this.grid.numSelected < this.maxSelectable) {
                this.grid.select(Q.selected, true)
            }
        }
    }
    if (this.selectable) {
        var X = '<input type="' + (this.exclusive ? "radio" : "checkbox") + '">';
        var L = '<input type="' + (this.exclusive ? "radio" : "checkbox") + '" disabled>';
        var P = '<td class="' + this.selectorClass + '">' + X + "</td>";
        var S = '<td class="' + this.selectorAltClass + '">' + X + "</td>";
        var R = '<td class="' + this.selectorClass + '">' + L + "</td>";
        var I = '<td class="' + this.selectorAltClass + '">' + L + "</td>"
    }
    var F = "";
    if (this.grid.hasHeader()) {
        F += "<tr>";
        if (this.selectable) {
            F += '<td class="' + this.selectorTitleClass + '">' + (this.exclusive ? "&nbsp;" : X) + "</td>"
        }
        for (var H = 0; H < this.cols; H++) {
            var U = this.grid.getHeader(H);
            if (this.sortable) {
                var G = this.grid.colIsSortable(H);
                var C = this.grid.colSorted(H);
                if (C) {
                    if (C.charAt(0) == "A") {
                        var D = this.sortedDownTitleClass
                    } else {
                        var D = this.sortedUpTitleClass
                    }
                } else {
                    var D = this.titleClass
                }
                if (G) {
                    D += " " + this.sortableTitleClass
                }
            } else {
                var G = false;
                var D = this.titleClass
            }
            if (U == undefined) {
                U = "&nbsp;"
            }
            var W = this.grid.getHeaderDesc(H);
            var O = "";
            if (W) {
                O = ' title="' + W + '"'
            }
            F += '<td class="' + D + '"' + O + "><nobr>";
            F += U;
            F += "</nobr></td>"
        }
        F += "</tr>";
        this.tableBody$.html(F);
        if (this.selectable && (!this.exclusive)) {
            this.selectAll$ = $("input", this.tableBody$).click(createObjectCallback(this, this.selectAllClicked))
        }
        if (this.sortable) {
            this.sortableAll$ = $("." + this.sortableTitleClass, this.tableBody$).click(createObjectCallback(this, this.sortColumnClicked))
        }
    } else {
        this.tableBody$.html("")
    }
    this.tableRows = new Array(this.rows);
    if (this.rows == 0) {
        var N = (this.cols) ? this.cols : 1;
        var Y = new TableRow({
            index: 0,
            parent: this,
            selectable: false
        });
        Y.append('<td class="' + this.valueClass + '" colspan="' + N + '"><nobr>' + strings.emptyTableMessage + "</nobr></td>")
    }
    for (var K = 0; K < this.rows; K++) {
        var M = this.grid.rowIsSelectable(K);
        var Y = new TableRow({
            index: K,
            parent: this,
            selectable: M
        });
        this.tableRows[K] = Y;
        var F = "";
        if (this.alternate && ((K % 2) == 0)) {
            var J = this.valueAltClass;
            if (this.selectable) {
                if (M) {
                    F += S
                } else {
                    F += I
                }
            }
        } else {
            var J = this.valueClass;
            if (this.selectable) {
                if (M) {
                    F += P
                } else {
                    F += R
                }
            }
        }
        for (var H = 0; H < this.cols; H++) {
            if (this.sortable && this.grid.colSorted(H)) {
                var E = this.valueSortedClass;
                var T = this.valueWidth
            } else {
                if (this.grid.colIsTitle(H)) {
                    var E = this.valueTitleClass;
                    var T = this.titleWidth
                } else {
                    var E = J;
                    var T = this.valueWidth
                }
            }
            var V = this.grid.getCellClass(K, H);
            if (V) {
                E = V + " " + E
            }
            var U = this.grid.getCell(K, H);
            if ((U == undefined) || ((typeof U == "string") && (U.length == 0))) {
                U = "&nbsp;"
            }
            F += '<td class="' + E + '"><nobr>';
            F += U;
            F += "</nobr></td>"
        }
        Y.append(F);
        if (this.grid.rowIsSelected(K)) {
            Y.setSelected()
        }
    }
};
DataTable.prototype.append = function(C) {
    this.tableBody$.append(C)
};
DataTable.prototype.canSelect = function() {
    if (!this.selectable) {
        return false
    }
    if (this.maxSelectable == 0 || this.maxSelectable == 1 || this.grid.numSelected < this.maxSelectable) {
        return true
    }
    ShowActiveDialog({
        type: "message",
        message: strings.exceededTableSelectionMsg(this.maxSelectable)
    });
    return false
};
DataTable.prototype.selecting = function(D) {
    this.grid.select(D, true);
    if (this.options.selecting) {
        var C = this.grid._logToPhys(D);
        this.options.selecting(C, this.grid.getObject(D))
    }
};
DataTable.prototype.unselecting = function(D) {
    this.grid.select(D, false);
    if (this.options.unselecting) {
        var C = this.grid._logToPhys(D);
        this.options.unselecting(C, this.grid.getObject(D))
    }
};
DataTable.prototype.deselectCurrent = function() {
    for (var C = 0; C < this.rows; C++) {
        if (this.grid.rowIsSelected(C)) {
            this.grid.select(C, false);
            this.tableRows[C].setUnselected()
        }
    }
};
DataTable.prototype.selectToIndex = function(D) {
    if (this.lastSelectedIndex == undefined) {
        return
    }
    var F = this.lastSelectedIndex;
    var C = D;
    if (this.lastSelectedIndex > D) {
        F = D;
        C = this.lastSelectedIndex
    }
    for (var E = F; E <= C; E++) {
        if (!this.grid.rowIsSelected(E)) {
            if (this.maxSelectable == 0 || this.grid.numSelected < this.maxSelectable) {
                this.tableRows[E].setSelected()
            } else {
                ShowActiveDialog({
                    type: "message",
                    message: strings.exceededTableSelectionMsg(this.maxSelectable)
                });
                break
            }
        }
    }
};
DataTable.prototype.selectAllClicked = function() {
    var C = this.selectAll$.prop("checked");
    if (C) {
        $.each(this.tableRows, function() {
            if (this.parent.maxSelectable == 0 || this.parent.grid.numSelected < this.parent.maxSelectable) {
                if ($.isFunction(this.setSelected)) {
                    this.setSelected()
                }
            }
        })
    } else {
        $.each(this.tableRows, function() {
            if ($.isFunction(this.setUnselected)) {
                this.setUnselected()
            }
        })
    }
};
DataTable.prototype.sortColumnClicked = function(G) {
    var E = 0;
    if (G) {
        if (G.currentTarget && G.currentTarget.cellIndex) {
            E = G.currentTarget.cellIndex
        } else {
            if (G.target) {
                if (G.target.cellIndex) {
                    E = G.target.cellIndex
                } else {
                    var D = $(G.target).parents().filter(".objectSortableTitle").get(0);
                    if (D && D.cellIndex) {
                        E = D.cellIndex
                    }
                }
            }
        }
    }
    if (this.selectable) {
        E--
    }
    if (this.grid) {
        var C = this.grid.colSorted(E);
        var F = "A";
        if (C && C.charAt(0) == "A") {
            F = "D"
        }
        this.grid.sort(E, F);
        this.handleUpdate({});
        this.sortInfo = {
            column: E,
            order: F
        }
    }
};
DataTable.prototype.handleRetrieve = function(E) {
    if (!this.selectable) {
        return
    }
    var F = new APIData();
    var D = this.rows;
    for (var C = 0; C < D; C++) {
        if (this.grid.rowIsSelected(C)) {
            F.addObject(this.grid.getObject(C))
        }
    }
    E[this.name] = F
};

function interceptHealthHandler(G, D) {
    var F = G.getPropertyValue(D);
    var E = D.substr(0, D.lastIndexOf("_numeric"));
    var C = G.getPropertyValue(E);
    return interceptHealthHTML(F, C)
}

function interceptHealthHTML(D, E) {
    switch (parseInt(D)) {
        case 0:
            var C = "healthOk";
            break;
        case 1:
            var C = "healthDegraded";
            break;
        case 2:
            var C = "healthBad";
            break;
        case 3:
        default:
            var C = "healthUnknown";
            break
    }
    return '<div class="healthStyle ' + C + '"><span class="healthText">' + E + "</span></div>"
}

function interceptProgressHandler(E, C) {
    var D = E.getPropertyValue(C + "_numeric");
    return htmlProgressBar({
        percent: D,
        width: 80,
        caption: strings.progressBarText(D)
    })
}

function interceptJobHandler(F, C) {
    var E = F.getPropertyValue(C + "_numeric");
    var D = F.getPropertyValue(C + "_completion");
    return interceptJobHTML(E, D)
}

function interceptJobHTML(E, C) {
    var D = jobNumericToString(E);
    var F = jobToPercent(C);
    if (!D) {
        return ""
    }
    return htmlProgressBar({
        percent: F,
        width: 80,
        caption: strings.jobDescription(D, F)
    })
}

function interceptScheduleExpressionHandler(G, D) {
    var L = G.getPropertyValue(D);
    var K = L.split(",");
    for (var H = 0; H < K.length; H++) {
        var F = K[H].split(" ");
        for (var E = 0; E < F.length; E++) {
            var C = F[E].toLowerCase();
            var I = strings.schedule[C];
            if (I) {
                F[E] = I
            }
        }
        K[H] = F.join(" ")
    }
    var J = K.join(",");
    return J
}

function jobNumericToString(C) {
    switch (parseInt(C)) {
        case 0:
            return "";
        case 1:
            return strings.LOWF;
        case 2:
            return strings.INIT;
        case 3:
            return strings.RCON;
        case 4:
            return strings.VRFY;
        case 5:
            return strings.EXPD;
        case 6:
            return strings.VRSC;
        case 7:
            return strings.DRSC;
        case 8:
            return strings.BGMS;
        case 9:
            return strings.VREMV;
        case 10:
            return strings.RTIER;
        case 11:
            return strings.CPYBK;
        case 12:
            return strings.VPREP;
        case 13:
            return strings.VDRAIN;
        case 14:
            return strings.VRECV;
        case 15:
            return strings.PRERCON;
        case 16:
            return strings.RBAL;
        default:
            return strings.unknownVal
    }
    return strings.unknownVal
}

function jobToPercent(C) {
    if (!C) {
        return 0
    }
    re = /[0-9]+/;
    return parseInt(C.match(re))
}

function htmlProgressBar(D) {
    var E = "";
    var F = "width: 100%;";
    var C = "";
    if (D.width != undefined) {
        F = "width: " + D.width + "px;"
    }
    if (D.height != undefined) {
        C = "height: " + D.height + "px;"
    }
    if (D.caption != undefined) {
        E = E + "<table><tr><td>" + D.caption + "</td><td>"
    }
    E = E + '<table class="progressLeft" style="' + F + " " + C + '"><tr>';
    if (D.percent > 0) {
        E = E + '<td class="progressFinished" style="width: ' + D.percent + '%;"></td>'
    }
    if (D.percent < 100) {
        E = E + "<td></td>"
    }
    E = E + "</tr></table>";
    if (D.caption != undefined) {
        E = E + "</td></tr></table>"
    }
    return E
}

function WelcomePanel(H) {
    if (arguments.length == 0) {
        return
    }
    if (H.name == undefined) {
        H.name = "welcomePanel"
    }
    H.attachTo = $("#rootView");
    var D = this;
    var E = session.getSupportedLocales();
    var C = [{
        value: "default",
        text: strings.login.defaultLocale
    }];
    for (var G = 0; G < E.length; G++) {
        C.push({
            value: E[G].locale,
            text: E[G].translated
        })
    }
    var F = '<div id="loginPage">  <table>    <tr><td></td><td></td><td></td></tr>    <tr><td width="50%"></td><td>       <div id="loginDiv" class="dark">           <div id="welcomeTitle">' + strings.applicationWelcomeTitle + '</div>           <div class="welcomeInputContainer">               <div id="welcomeInputs" class="widgetContainer welcomeInputs"></div>           </div>       </div>    </td><td width="50%"></td></tr>    <tr><td></td><td></td><td></td></tr>  </table></div>';
    H.widgets = new WidgetContainer({
        name: "welcomePageContainer",
        htmlText: F,
        widgets: [new FormWidget({
            name: "welcomeForm",
            tableLayout: true,
            data: {},
            classes: "scrollingDiv",
            widgets: [new TextWidget({
                name: "message",
                text: "",
                row: 0,
                col: 0,
                colSpan: 2,
                bottomMargin: true
            }), new ButtonWidget({
                id: "welcomeButton",
                row: 1,
                col: 0,
                bottomMargin: true,
                paddingBottom: true,
                name: "ok",
                primary: true,
                text: strings.welcome.getStarted,
                callback: createObjectCallback(this, this.launchEULA)
            }), new ComboBoxWidget({
                name: "locale",
                row: 2,
                col: 0,
                values: C,
                width: 150,
                topMargin: true,
                bottomMargin: true,
                value: "default"
            }), new TextWidget({
                name: "systemStateNotice",
                classes: "systemStateNotice",
                text: "",
                row: 3,
                col: 0,
                colSpan: 3,
                topMargin: true
            })]
        })]
    });
    Panel.call(this, H);
    this.setSystemStateNotice()
}
WelcomePanel.prototype = new Panel();
WelcomePanel.prototype.constructor = WelcomePanel;
WelcomePanel.prototype.hiding = function() {};
WelcomePanel.prototype.showing = function() {
    this.update({
        locale: {
            disable: true
        }
    });
    if (settings.emulator) {
        var C = [{
            value: getCookie("language"),
            text: getCookie("language"),
            disable: true
        }];
        this.update({
            locale: {
                values: C,
                value: getCookie("language"),
                disable: true
            }
        })
    }
};
WelcomePanel.prototype.launchEULA = function() {
    var C = {};
    this.retrieve(C);
    session.requestedLocale = C.locale.value;
    if (EXPR.isDellBrand == true) {
        new EULAPanel({})
    } else {
        new SetupUserPanel({})
    }
};
WelcomePanel.prototype.setSystemStateNotice = function() {
    if (session.systemState == "initializing" || session.systemState == "down" || connection.getLinkState() == "DISCONNECTED") {
        if (session.systemState == "initializing") {
            var F = '<span class="loginWarning">' + strings.login.initializing + "</span>";
            this.update({
                message: {
                    text: F
                },
                ok: {
                    disable: true
                },
                locale: {
                    disable: true
                }
            })
        } else {
            var H = '<div class="warningImage" style="float: left;"></div><span class="loginWarning">' + strings.login.systemUnavailable + "</span>";
            this.update({
                systemStateNotice: {
                    text: H
                },
                ok: {
                    disable: true
                },
                locale: {
                    disable: true
                }
            })
        }
    } else {
        this.update({
            message: {
                text: ""
            },
            systemStateNotice: {
                text: ""
            },
            ok: {
                disable: false
            },
            locale: {
                disable: false
            }
        })
    }
    var D = new Date();
    var E = (D.getTime() - connection.securityTS) / 1000;
    var C = connection.getSecurityState();
    var G = 120;
    if (E > G && C == "UNAUTHORIZED") {
        $(window).mousemove(function() {
            $(window).off("mousemove");
            BC.on()
        });
        BC.off()
    }
};

function EULAPanel(D) {
    if (arguments.length == 0) {
        return
    }
    if (D.name == undefined) {
        D.name = "EULAPanel"
    }
    D.attachTo = views.rootView;
    var C = '<div id="loginPage">  <table>    <tr><td></td><td></td><td></td></tr>    <tr><td width="50%"></td><td>      <div id="eulaDiv">        <div class="eulaInputContainer">          <div id="eulaInputs" class="widgetContainer eulaInputs"></div>        </div>      </div>    </td><td width="50%"></td></tr>    <tr><td></td><td></td><td></td></tr>  </table></div>';
    D.widgets = new WidgetContainer({
        name: "eulaContainer",
        htmlText: C,
        widgets: [new FormWidget({
            name: "eulaForm",
            tableLayout: true,
            data: {},
            classes: "scrollingDiv",
            widgets: [new ContentWidget({
                row: 0,
                col: 0,
                name: "eulaContent",
                scrollable: true,
                height: 500,
                width: 700,
                border: true,
                widgets: [new TextWidget({
                    name: "eulaText",
                    text: strings.welcome.eulaLoading
                })]
            }), new ButtonContainer({
                name: "bc",
                orientation: "horizontal",
                alignment: "right",
                row: 1,
                col: 0,
                colSpan: 2,
                widgets: [new ButtonWidget({
                    name: "accept",
                    primary: true,
                    disable: true,
                    topSmallMargin: true,
                    text: strings.welcome.accept,
                    callback: createObjectCallback(this, this.eulaAccepted)
                }), new ButtonWidget({
                    name: "decline",
                    disable: true,
                    topSmallMargin: true,
                    text: strings.welcome.decline,
                    callback: createObjectCallback(this, this.eulaDeclined)
                })]
            })]
        })]
    });
    Panel.call(this, D)
}
EULAPanel.prototype = new Panel();
EULAPanel.prototype.constructor = EULAPanel;
EULAPanel.prototype.showing = function() {
    RB.makeRequest({
        url: "help/EULA.html",
        dataType: "text",
        httpReqType: "GET",
        callback: createObjectCallback(this, function(C, D) {
            if (D.textStatus == "success") {
                var E = {
                    eulaText: {
                        text: C
                    },
                    accept: {
                        disable: false
                    },
                    decline: {
                        disable: false
                    }
                };
                this.update(E)
            } else {
                MC.debugOutput("ERROR: EULA not fetched.")
            }
        })
    })
};
EULAPanel.prototype.eulaAccepted = function() {
    new SetupUserPanel({})
};
EULAPanel.prototype.eulaDeclined = function() {
    this.update({
        accept: {
            disable: true
        },
        decline: {
            disable: true
        }
    });
    location.reload()
};

function SetupUserPanel(E) {
    if (arguments.length == 0) {
        return
    }
    if (E.name == undefined) {
        E.name = "setupUserPanel"
    }
    E.attachTo = $("#rootView");
    var C = this;
    var D = '<div id="loginPage">  <table cellspacing="0" cellpadding="0">    <tr><td></td><td></td><td></td></tr>    <tr><td width="50%"></td><td>      <div id="loginDiv" class="dark">        <div id="setupUserTitle">' + strings.setupUser.setupNewUserMsg + '</div>        <div class="setupUserInputContainer">          <div id="setupUserInputs" class="widgetContainer setupUserInputs"></div>        </div>      </div>    </td><td width="50%"></td></tr>    <tr><td></td><td></td><td></td></tr>  </table></div>';
    E.widgets = new WidgetContainer({
        name: "setupUserContainer",
        htmlText: D,
        widgets: [new FormWidget({
            name: "setupUserform",
            tableLayout: true,
            classes: "scrollingDiv",
            widgets: [new TextInputWidget({
                name: "userTextbox",
                row: 1,
                col: 0,
                maxLength: 32,
                size: 23,
                label: strings.Username,
                bottomSmallMargin: true,
                labelOptions: {
                    row: 0,
                    col: 0,
                    bottomSmallMargin: true
                },
                messages: {
                    required: strings.userManagement.validation.usernameError
                },
                changeCallback: createObjectCallback(this, this.usernameChanged)
            }), new TextInputWidget({
                name: "passwordTextbox",
                row: 3,
                col: 0,
                maxLength: 32,
                size: 23,
                label: strings.Password,
                bottomSmallMargin: true,
                labelOptions: {
                    row: 2,
                    col: 0,
                    bottomSmallMargin: true
                },
                password: true,
                messages: {
                    required: strings.userManagement.validation.noEmptyPassword,
                    utf8length: strings.userManagement.validation.passwordLength
                },
                changeCallback: createObjectCallback(this, this.changedCallback)
            }), new TextInputWidget({
                name: "passwordConfirm",
                row: 5,
                col: 0,
                maxLength: 32,
                size: 23,
                label: strings.userManagement.panelText.ConfirmPassword,
                bottomSmallMargin: true,
                labelOptions: {
                    row: 4,
                    col: 0,
                    bottomSmallMargin: true
                },
                password: true,
                messages: {
                    required: strings.userManagement.validation.confirmPassword,
                    utf8length: strings.userManagement.validation.passwordLength
                },
                changeCallback: createObjectCallback(this, this.changedCallback)
            }), new ButtonWidget({
                id: "createUserButton",
                row: 6,
                col: 0,
                name: "ok",
                primary: true,
                text: strings.setupUser.createButtonText,
                topSmallMargin: true,
                callback: createObjectCallback(this, this.loginAndCreateUser)
            }), new TextWidget({
                name: "message",
                classes: "userCreationMessage",
                text: "",
                row: 7,
                col: 0,
                colSpan: 2
            })]
        })]
    });
    Panel.call(this, E)
}
SetupUserPanel.prototype = new Panel();
SetupUserPanel.prototype.constructor = SetupUserPanel;
SetupUserPanel.prototype.showing = function() {
    this.update({
        userTextbox: {
            focus: true
        },
        ok: {
            disable: true
        }
    })
};
SetupUserPanel.prototype.usernameChanged = function(F, D, E) {
    if (E != undefined && E.type == "focusout") {
        var C = {
            message: {
                text: ""
            }
        };
        C.userTextbox = {
            rules: {
                required: true,
                dhUserName: true,
                utf8length: 29,
                noBannedUsers: true
            },
            messages: {
                required: strings.userManagement.validation.usernameError
            }
        };
        this.update(C);
        this.changedCallback(F, D, E)
    }
};
SetupUserPanel.prototype.changedCallback = function(F, D, E) {
    if (E && E.type == "focusout") {
        if (D.name == "passwordTextbox") {
            this.update({
                passwordTextbox: {
                    rules: {
                        dhPassword: true,
                        characterLength: 32,
                        minlength: 8,
                        required: true,
                        passwordComplexityCheck: true
                    }
                },
                message: {
                    text: ""
                }
            })
        } else {
            if (D.name == "passwordConfirm") {
                this.update({
                    passwordConfirm: {
                        rules: {
                            equalTo: "#passwordTextbox",
                            required: true
                        }
                    },
                    message: {
                        text: ""
                    }
                })
            }
        }
    }
    var C = {};
    this.retrieve(C);
    if ((C.hasOwnProperty("userTextbox") && C.userTextbox.value != "" && !C.userTextbox.invalid) && (C.hasOwnProperty("passwordTextbox") && C.passwordTextbox.value != "" && !C.passwordTextbox.invalid) && (C.hasOwnProperty("passwordConfirm") && C.passwordConfirm.value != "" && !C.passwordConfirm.invalid)) {
        this.update({
            ok: {
                disable: false
            }
        })
    } else {
        this.update({
            ok: {
                disable: true
            }
        })
    }
};
SetupUserPanel.prototype.loginAndCreateUser = function() {
    var D = {};
    this.retrieve(D);
    if (D.passwordTextbox.value != D.passwordConfirm.value) {
        this.update({
            passwordConfirm: {
                rules: {
                    equalTo: "#passwordTextbox",
                    required: true
                }
            },
            ok: {
                disable: true
            }
        });
        return
    }
    var C = {
        username: D.userTextbox.value,
        password: D.passwordTextbox.value,
        roles: ["manage", "standard", "monitor"],
        interfaces: "cli,wbi,ftp",
        locale: session.requestedLocale.toLocaleLowerCase() == "default" ? "English" : session.requestedLocale
    };
    this.update({
        ok: {
            disable: true
        },
        message: {
            text: strings.setupUser.processingMsg(C.username)
        }
    });
    session.login("setup", "", createObjectCallback(this, function() {
        if (session.isAuthorized()) {
            MC.createSystemUser(C, {
                dialog: false,
                callback: createObjectCallback(this, function(E) {
                    if (E.code == 0) {
                        EXPR.needWelcome = false;
                        this.update({
                            message: {
                                text: strings.setupUser.success(C.username)
                            }
                        });
                        session.login(C.username, C.password)
                    } else {
                        this.update({
                            message: {
                                text: strings.setupUser.error(C.username)
                            },
                            ok: {
                                disable: false
                            }
                        })
                    }
                })
            })
        } else {
            MC.debugOutput('ERROR: Failed to login with "setup" user.');
            this.update({
                message: {
                    text: strings.setupUser.error(C.username)
                },
                ok: {
                    disable: false
                }
            })
        }
    }))
};

function LoginPanel(H) {
    if (arguments.length == 0) {
        return
    }
    if (H.name == undefined) {
        H.name = "loginPanel"
    }
    H.attachTo = $("#rootView");
    var D = this;
    var E = session.getSupportedLocales();
    var C = [{
        value: "default",
        text: strings.login.defaultLocale
    }];
    for (var G = 0; G < E.length; G++) {
        C.push({
            value: E[G].locale,
            text: E[G].translated
        })
    }
    var F = '<div id="loginPage">  <table cellspacing="0" cellpadding="0">    <tr><td></td><td></td><td></td></tr>    <tr><td width="50%"></td><td>      <div id="loginDiv" class="dark">        <div id="loginTitle">' + strings.applicationTitle + '</div>        <div class="loginInputContainer">          <div id="loginInputs" class="widgetContainer loginInputs"></div>        </div>      </div>    </td><td width="50%"></td></tr>    <tr><td></td><td></td><td></td></tr>  </table></div>';
    H.widgets = new WidgetContainer({
        name: "loginContainer",
        htmlText: F,
        widgets: [new FormWidget({
            name: "loginform",
            data: {},
            tableLayout: true,
            classes: "scrollingDiv",
            widgets: [new TextWidget({
                name: "message",
                text: "",
                row: 0,
                col: 0,
                colSpan: 2,
                bottomMargin: true
            }), new TextInputWidget({
                name: "username",
                row: 2,
                col: 0,
                maxLength: 32,
                size: 23,
                label: strings.login.user,
                labelOptions: {
                    row: 1,
                    col: 0,
                    bottomSmallMargin: true
                },
                bottomMargin: true,
                enterCallback: createObjectCallback(this, this.initiateLogin)
            }), new TextInputWidget({
                name: "password",
                row: 4,
                col: 0,
                maxLength: 32,
                size: 23,
                label: strings.login.password,
                labelOptions: {
                    row: 3,
                    col: 0,
                    bottomSmallMargin: true
                },
                password: true,
                bottomMargin: true,
                enterCallback: createObjectCallback(this, this.initiateLogin)
            }), new ButtonContainer({
                name: "bc",
                orientation: "horizontal",
                alignment: "left",
                row: 5,
                col: 0,
                colSpan: 2,
                bottomMargin: true,
                widgets: [new ButtonWidget({
                    id: "loginButton",
                    name: "ok",
                    primary: true,
                    text: strings.login.login,
                    callback: createObjectCallback(this, this.initiateLogin)
                }), new ButtonWidget({
                    name: "clear",
                    text: strings.login.clear,
                    callback: function() {
                        D.update({
                            username: {
                                value: ""
                            },
                            password: {
                                value: ""
                            }
                        });
                        document.getElementById("username").focus()
                    }
                })]
            }), new ComboBoxWidget({
                name: "locale",
                row: 6,
                col: 0,
                values: C,
                width: 150,
                bottomMargin: true,
                value: "default"
            }), new TextWidget({
                name: "systemStateNotice",
                classes: "systemStateNotice",
                text: "",
                row: 8,
                col: 0,
                colSpan: 2,
                topMargin: true
            })]
        })]
    });
    Panel.call(this, H);
    this.setSystemStateNotice()
}
LoginPanel.prototype = new Panel();
LoginPanel.prototype.constructor = LoginPanel;
LoginPanel.prototype.showing = function() {
    this.update({
        locale: {
            disable: true
        }
    })
};
LoginPanel.prototype.setSystemStateNotice = function() {
    if (session.systemState == "initializing" || session.systemState == "down" || connection.getLinkState() == "DISCONNECTED") {
        if (session.systemState == "initializing") {
            var F = '<span class="loginWarning">' + strings.login.initializing + "</span>";
            this.update({
                message: {
                    text: F
                },
                username: {
                    disable: true
                },
                password: {
                    disable: true
                },
                ok: {
                    disable: true
                },
                locale: {
                    disable: true
                },
                clear: {
                    disable: true
                }
            })
        } else {
            var H = '<div class="warningImage" style="float: left;"></div><span class="loginWarning">' + strings.login.systemUnavailable + "</span>";
            this.update({
                systemStateNotice: {
                    text: H
                },
                username: {
                    disable: true
                },
                password: {
                    disable: true
                },
                ok: {
                    disable: true
                },
                locale: {
                    disable: true
                },
                clear: {
                    disable: true
                }
            })
        }
    } else {
        this.update({
            message: {
                text: ""
            },
            systemStateNotice: {
                text: ""
            },
            username: {
                disable: false,
                focus: true
            },
            password: {
                disable: false
            },
            ok: {
                disable: false
            },
            locale: {
                disable: false
            },
            clear: {
                disable: false
            }
        })
    }
    var D = new Date();
    var E = (D.getTime() - connection.securityTS) / 1000;
    var C = connection.getSecurityState();
    var G = 120;
    if (E > G && C == "UNAUTHORIZED") {
        $(window).mousemove(function() {
            $(window).off("mousemove");
            BC.on()
        });
        BC.off()
    }
};
LoginPanel.prototype.initiateLogin = function() {
    this.update({
        message: {
            text: "&nbsp;" + strings.login.authenticating
        }
    });
    var D = {};
    this.retrieve(D);
    session.requestedLocale = D.locale.value;
    var C = this;
    session.login(D.username.value, D.password.value, function() {
        if (session.isAuthorized()) {
            C.update({
                message: {
                    text: "&nbsp;" + strings.login.success
                }
            });
            if (settings.memorex) {
                session.preApplicationStart()
            }
        } else {
            C.update({
                message: {
                    text: "&nbsp;" + strings.login.failure
                }
            })
        }
    })
};

function SessionKey(C) {
    var D = {
        name: "wbisessionkey",
        value: C
    };
    PersistedProperty.call(this, D)
}
SessionKey.prototype = new PersistedProperty();

function UserName(C) {
    C.name = "wbiusername";
    PersistedProperty.call(this, C)
}
UserName.prototype = new PersistedProperty();

function PreInitObject() {
    this.items = new Array()
}

function SystemInfo(C) {
    this.ulpEnabled = true;
    this.maxPorts = 0;
    this.maxDrives = 0;
    this.maxVolumes = 0;
    this.maxVdisks = 0;
    this.maxLuns = 0;
    this.maxOwnedArraysPerController = 0;
    this.maxCapiArrays = 0;
    this.maxChunkSize = 0;
    this.physicalPositionOffset = 0;
    this.backoffPercentage = 0;
    this.vdiskMetaBlocks = 0;
    this.vdiskMetaBlocksPerDisk = 0;
    this.local_controller = "A";
    this.local_controller_numeric = 1;
    this.profilesEnabled = false;
    this.minBackingStoreSize = 0;
    MC.systemParametersSet.requestData({
        update: false,
        durable: "all",
        requestor: "SystemInfo",
        handler: createObjectCallback(this, this.handleData)
    })
}
SystemInfo.prototype.handleData = function(D) {
    if (!D) {
        return
    }
    var C = D.getData().getNthObject(0);
    if (C) {
        this.ulpEnabled = (C.getPropertyValue("ulp_enabled") == "true");
        this.maxPorts = parseInt(C.getPropertyValue("max_ports"));
        this.maxDrives = parseInt(C.getPropertyValue("max_drives"));
        this.maxVolumes = parseInt(C.getPropertyValue("max_volumes"));
        this.maxVdisks = parseInt(C.getPropertyValue("max_vdisks"));
        this.maxLuns = parseInt(C.getPropertyValue("max_luns"));
        this.maxOwnedArraysPerController = parseInt(C.getPropertyValue("max_owned_arrays_per_controller"));
        this.maxCapiArrays = parseInt(C.getPropertyValue("max_capi_arrays"));
        this.maxChunkSize = parseInt(C.getPropertyValue("max_chunk_size"));
        this.physicalPositionOffset = parseInt(C.getPropertyValue("physical_position_offset"));
        this.backoffPercentage = parseFloat(C.getPropertyValue("backoff_percentage"));
        this.vdiskMetaBlocks = parseInt(C.getPropertyValue("vdisk_metadata_size_blocks"));
        this.vdiskMetaBlocksPerDisk = parseInt(C.getPropertyValue("vdisk_metadata_size_perdisk_blocks"));
        this.local_controller = C.getPropertyValue("local_controller");
        this.local_controller_numeric = parseInt(C.getPropertyValue("local_controller_numeric"));
        this.profilesEnabled = (C.getPropertyValue("profiles_enabled") == "true");
        this.minBackingStoreSize = parseInt(C.getPropertyValue("min_backing_store_size"))
    }
};
SystemInfo.prototype.getHostPortsList = function() {
    var D = [];
    if (this.ulpEnabled) {
        for (var C = 0; C < this.maxPorts; C++) {
            D[D.length] = "A" + C
        }
        for (var C = 0; C < this.maxPorts; C++) {
            D[D.length] = "B" + C
        }
    } else {
        for (var C = 0; C < this.maxPorts; C++) {
            D[D.length] = "" + C
        }
    }
    return D
};
LicenseInfo.EXPIRING = 14;

function LicenseInfo() {
    var C = this;
    C.EULAfile = " ";
    this.subscription = MC.licenseSet.requestData({
        update: false,
        durable: "all",
        requestor: "LicenseInfo",
        handler: createObjectCallback(this, this.handleData)
    })
}
LicenseInfo.prototype.getFeatureList = function() {
    if (LicenseInfo.features != undefined) {
        return LicenseInfo.features
    }
    if (this.licenseData == undefined) {
        return {}
    }
    LicenseInfo.features = {};
    for (var E in this.licenseData.prop) {
        var C = E.lastIndexOf("_expiry_numeric");
        if (C != -1) {
            var D = E.substring(0, C);
            if (this.licenseData.meta.prop[D].attr.draw == "true") {
                LicenseInfo.features[D] = true
            }
        }
    }
    return LicenseInfo.features
};
LicenseInfo.prototype.handleData = function(G) {
    this.licenseData = G.getData().objects[0];
    if (this.licenseData == undefined) {
        return
    }
    this.synthLicense = {};
    var F = parseInt(this.licenseData.getPropertyValue("base_max_snapshots"));
    var C = parseInt(this.licenseData.getPropertyValue("max_snapshots"));
    this.synthLicense.snapshot = (F == 0 && C == 0) ? 0 : 1;
    this.tempLicensesActive = [];
    this.tempLicensesExpiring = [];
    this.tempLicensesExpired = [];
    for (var E in this.getFeatureList()) {
        var D = parseInt(this.licenseData.prop[E + "_expiry_numeric"].text);
        if (D > 0 && D < LicenseInfo.EXPIRING) {
            this.tempLicensesExpiring.push(E)
        }
        if (D > 0 && D < 254) {
            this.tempLicensesActive.push(E)
        } else {
            if (D >= 254) {
                this.tempLicensesExpired.push(E)
            }
        }
    }
    if (settings.isV3) {
        this.makeDataGrid()
    }
};
LicenseInfo.prototype.decodeExpiry = function(D) {
    if (!D || !this.licenseData || !this.licenseData.prop[D]) {
        return ""
    }
    var E = this.licenseData.getPropertyValue(D + "_numeric");
    if (E == undefined) {
        E = this.licenseData.getPropertyValue(D)
    }
    E = parseInt(E);
    var C = parseInt(this.licenseData.getPropertyValue(D + "_expiry_numeric"));
    if (C == 0) {
        return strings.licenseMgmt.expireNever
    } else {
        if (C == 255) {
            return strings.licenseMgmt.expired
        } else {
            if (C == 254) {
                return strings.licenseMgmt.expiredRenewable
            } else {
                return strings.licenseMgmt.expiresInDays(C)
            }
        }
    }
};
LicenseInfo.prototype.makeDataGrid = function() {
    if (this.dataGrid == undefined) {
        this.dataGrid = new BasicDataGrid({
            caption: strings.licenseMgmt.sysLicenses,
            meta: new APIObject([new APIProp({
                name: "licenseName",
                value: strings.licenseMgmt.licenseName,
                desc: strings.licenseMgmt.licenseNameTip
            }), new APIProp({
                name: "licenseBase",
                value: strings.licenseMgmt.licenseBase,
                desc: strings.licenseMgmt.licenseBaseTip
            }), new APIProp({
                name: "licenseValue",
                value: strings.licenseMgmt.licenseValue,
                desc: strings.licenseMgmt.licenseValueTip
            }), new APIProp({
                name: "licenseInUse",
                value: strings.licenseMgmt.licenseInUse,
                desc: strings.licenseMgmt.licenseInUseTip
            }), new APIProp({
                name: "licenseMax",
                value: strings.licenseMgmt.licenseMax,
                desc: strings.licenseMgmt.licenseMaxTip
            }), new APIProp({
                name: "licenseExpiry",
                value: strings.licenseMgmt.licenseExpiration,
                desc: strings.licenseMgmt.licenseExpirationTip
            })]),
            data: []
        })
    }
    delete this.dataGrid.data;
    this.dataGrid.data = [];
    var D = 0;
    for (var C in this.getFeatureList()) {
        if (C == "max_snapshots") {
            this.dataGrid.data.push([this.licenseData.meta.prop.max_snapshots.text, this.licenseData.getPropertyValue("base_max_snapshots"), this.licenseData.getPropertyValue("max_snapshots"), this.licenseData.getPropertyValue("in_use_snapshots"), this.licenseData.getPropertyValue("platform_max_snapshots"), this.decodeExpiry("max_snapshots")])
        } else {
            this.dataGrid.data.push([this.licenseData.meta.prop[C].text, strings.na, this.licenseData.getPropertyValue(C), strings.na, strings.na, this.decodeExpiry(C)])
        }
        D++
    }
    this.dataGrid.update({
        rows: D
    })
};
LicenseInfo.prototype.getDataGrid = function() {
    if (this.dataGrid == undefined) {
        this.makeDataGrid()
    }
    return this.dataGrid
};
LicenseInfo.prototype.nodeLicensed = function(C) {
    if (C.license == undefined) {
        return true
    }
    return this.isLicensed(C.license)
};
LicenseInfo.prototype.isLicensed = function(D) {
    if (this.licenseData == undefined) {
        return false
    }
    var C = this.licenseData.getPropertyValue(D + "_numeric");
    if (C == undefined) {
        C = this.licenseData.getPropertyValue(D)
    }
    if (C == undefined && this.synthLicense != undefined) {
        C = this.synthLicense[D]
    }
    return decodeBooleanFlag(C)
};
LicenseInfo.prototype.snapshotsAvail = function() {
    if (this.licenseData == undefined) {
        return 0
    }
    var C = this.licenseData.getInt("max_snapshots");
    var D = this.licenseData.getInt("base_max_snapshots");
    if (D > C) {
        C = D
    }
    var E = this.licenseData.getInt("in_use_snapshots");
    if (C == null || E == null) {
        return 0
    } else {
        return (C - E)
    }
};
LicenseInfo.prototype.getTempExpiring = function() {
    if (this.tempLicensesExpiring == undefined) {
        return []
    } else {
        return this.tempLicensesExpiring
    }
};
LicenseInfo.prototype.getTempActive = function() {
    if (this.tempLicensesActive == undefined) {
        return []
    } else {
        return this.tempLicensesActive
    }
};
LicenseInfo.prototype.getTempExpired = function() {
    if (this.tempLicensesExpired == undefined) {
        return []
    } else {
        return this.tempLicensesExpired
    }
};

function UserSession(C) {
    this.locales = "";
    this.brand = "";
    this.systemName = "--";
    this.ipAddr = "-.-.-.-";
    this.controller = "-";
    this.systemState = (settings.memorex ? "up" : "initializing");
    this._initializePreferences();
    this.accessed();
    this.preInit = new PreInitObject();
    if (C) {
        this.sessionKey = new SessionKey("abc123");
        this.userName = new UserName({
            value: "manage"
        });
        this._authorized()
    } else {
        this.sessionKey = new SessionKey();
        this.userName = new UserName({});
        this._unauthorized()
    }
    this.class_name = "UserSession"
}
UserSession.prototype.setBrandAndLocales = function(C) {
    if (MC.memorex) {
        this.brand = "DotHill";
        if (MC.fakeTranslations) {
            this.locales = "Unicode (Unicode), ExpanderTranslation (Expander),UnicodeExpanderBracket (Combined),English (English), Spanish (español), French (français), German (Deutsch), Italian (italiano), Japanese (日本語), Dutch (Nederlands), Chinese-Simplified (简体中文), Chinese-Traditional (繁體中文), Korean (한국어), Russian (русский), Arabic (العربية), Portuguese (português)"
        } else {
            this.locales = "English (English), Spanish (español), French (français), German (Deutsch), Italian (italiano), Japanese (日本語), Dutch (Nederlands), Chinese-Simplified (简体中文), Chinese-Traditional (繁體中文), Korean (한국어), Russian (русский), Arabic (العربية), Portuguese (português)"
        }
    } else {
        var D = C.split(":");
        this.brand = D[0];
        this.locales = D[1]
    }
    MC.infoOutput("BRAND:" + this.brand + " LOCALES:" + this.locales)
};
UserSession.prototype.handleID = function(F, E, D, C) {
    this.systemName = F;
    this.ipAddr = E;
    this.controller = D;
    if (C != this.systemState) {
        MC.infoOutput("System state changed from %s to %s.", this.systemState, C)
    }
    if (C) {
        this.systemState = C
    } else {
        this.systemState = "ok"
    }
    if (this.systemState == "down") {
        connection.sysdown()
    } else {
        connection.sysup()
    }
    this.displayID()
};
UserSession.prototype.displayID = function() {
    this.systemID = this.ipAddr + " [" + this.controller + "] (" + this.systemName + ")";
    document.title = this.systemID
};
UserSession.prototype.getSupportedLocales = function() {
    if (this.locales != undefined && this.locales != "") {
        var E = [];
        var D = this.locales.split(",");
        var G = new RegExp("^\\s*(\\S+) \\((.*)\\)\\s*$");
        var C;
        var I;
        for (var F = 0; F < D.length; F++) {
            var H = D[F].match(G);
            if (H.length == 3) {
                C = H[1];
                localeTranslated = H[2];
                E.push({
                    locale: C,
                    translated: localeTranslated
                })
            }
        }
    } else {
        if (MC.memorex && MC.memorex != "ctk") {
            var E = [{
                locale: "English",
                translated: "English"
            }, {
                locale: "Chinese-Simplified",
                translated: "Chinese-Simplified"
            }, {
                locale: "Chinese-Traditional",
                translated: "Chinese-Traditional"
            }, {
                locale: "Dutch",
                translated: "Dutch"
            }, {
                locale: "French",
                translated: "French"
            }, {
                locale: "German",
                translated: "German"
            }, {
                locale: "Italian",
                translated: "Italian"
            }, {
                locale: "Japanese",
                translated: "Japanese"
            }, {
                locale: "Korean",
                translated: "Korean"
            }, {
                locale: "Spanish",
                translated: "Spanish"
            }, {
                locale: "Russian",
                translated: "Russian"
            }, {
                locale: "Arabic",
                translated: "Arabic"
            }, {
                locale: "Portuguese",
                translated: "Portuguese"
            }]
        } else {
            var E = [{
                locale: "English",
                translated: "English"
            }]
        }
    }
    return E
};
UserSession.prototype.getLocalePath = function() {
    var C = this.getSessionPreference("locale");
    if (C == "English") {
        var D = ""
    } else {
        var D = "lang/" + C + "/"
    }
    return D
};
UserSession.prototype.accessed = function() {
    this.lastAccess = new Date()
};
UserSession.prototype.startTimer = function() {
    if (!this.timerInterval) {
        this.timerInterval = setInterval(createObjectCallback(this, this.timeoutCheck), 1000)
    }
};
UserSession.prototype.stopTimer = function() {
    if (this.timerInterval) {
        clearInterval(this.timerInterval)
    }
};
UserSession.prototype.timeoutCheck = function() {
    var D = new Date();
    var F = ((typeof this.sessionPreferences.timeout == "number") ? this.sessionPreferences.timeout : 1800);
    var E = 60;
    var C = (D.getTime() - this.lastAccess.getTime()) / 1000;
    this.displayTimeoutCounter(Math.floor(F - C));
    if (C > F) {
        this.inWarning = false;
        if (this.inTimeout) {
            return
        }
        this.inTimeout = true;
        this.sessionTimedOut()
    } else {
        if (C > (F - E)) {
            if (this.inWarning) {
                return
            }
            SessionWarningHandling();
            this.inWarning = true
        } else {
            this.inWarning = false;
            this.inTimeout = false
        }
    }
};
UserSession.prototype.displayTimeoutCounter = function(F) {
    if (!this.timeoutCounter$) {
        this.timeoutCounter$ = $(".timeoutCounter");
        if (this.timeoutCounter$.length == 0) {
            this.timeoutCounter$ = null
        }
    }
    if (!this.timeoutCounter$) {
        return
    }
    var G = "";
    if (F > 0) {
        var C = Math.floor(F / 3600);
        var E = Math.floor((F / 60) % 60);
        var D = Math.floor(F % 60);
        if (C > 0) {
            G += ((C <= 9) ? "0" + C : C) + ":";
            G += ((E <= 9) ? "0" + E : E) + ":"
        } else {
            G += E + ":"
        }
        G += (D <= 9) ? "0" + D : D
    }
    this.timeoutCounter$.html(G)
};
UserSession.prototype.getSessionKey = function() {
    return this.sessionKey.get()
};
UserSession.prototype._initializePreferences = function() {
    this.preferences = {};
    this.sessionPreferences = {
        base: "10",
        storage_size_base: 10,
        storage_size_precision: 1,
        storage_size_units: "auto"
    };
    this.addPreference("interval", 30);
    this.addSessionPreference("timeout", 1800)
};
UserSession.prototype.isAuthorized = function() {
    return this.authorized
};
UserSession.prototype._authorized = function() {
    this.authorized = true;
    connection.authorized();
    this.startTimer()
};
UserSession.prototype._unauthorized = function() {
    this.authorized = false;
    connection.unauthorized();
    this.stopTimer()
};
UserSession.prototype._subscribe = function() {
    this.userSubscription = MC.usersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._userDataHandler)
    });
    if (RI.hasFeature("ldap")) {
        this.usergroupsSubscription = MC.usergroupssSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, this._userGroupDataHandler)
        })
    }
    this.sessionSubscription = MC.sessionParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._sessionDataHandler)
    })
};
UserSession.prototype._userDataHandler = function(C) {
    var D = MC.usersSet.dataSelect({
        type: "prop",
        name: "username",
        value: this.userName.get()
    });
    if (D && D.objects && D.objects.length > 0) {
        for (var E in D.objects[0].prop) {
            this.addPreference(E, D.objects[0].prop[E].text)
        }
    }
};
UserSession.prototype._userGroupDataHandler = function(C) {
    var D = MC.usergroupssSet.dataSelect({
        type: "prop",
        name: "usergroupname",
        value: this.sessionPreferences.usergroupname
    });
    if (D && D.objects && D.objects.length > 0) {
        for (var E in D.objects[0].prop) {
            this.addPreference(E, D.objects[0].prop[E].text)
        }
    }
};
UserSession.prototype._sessionDataHandler = function(C) {
    var D = C.data;
    if (D && D.objects && typeof(D.objects[0]) != "undefined") {
        for (var E in D.objects[0].prop) {
            this.addSessionPreference(E, D.objects[0].prop[E].text)
        }
    }
};
UserSession.prototype.addPreference = function(C, D) {
    if (((C.lastIndexOf("_numeric") >= 0) || (C == "storage_size_base") || (C == "storage_size_precision")) && typeof D == "string") {
        D = parseInt(D)
    }
    this.preferences[C] = D
};
UserSession.prototype.getPreference = function(C) {
    if (this.preferences[C] != undefined) {
        return this.preferences[C]
    }
    return undefined
};
UserSession.prototype.addSessionPreference = function(C, D) {
    if (((C.lastIndexOf("_numeric") >= 0) || (C == "timeout") || (C == "storage_size_base") || (C == "storage_size_precision")) && typeof D == "string") {
        D = parseInt(D)
    }
    this.sessionPreferences[C] = D
};
UserSession.prototype.getSessionPreference = function(C) {
    if (this.sessionPreferences[C] != undefined) {
        return this.sessionPreferences[C]
    }
    return undefined
};
UserSession.prototype.addPersistedProperty = function(C, D) {
    if (C) {
        this[C] = new PersistedProperty({
            name: C,
            value: D
        })
    }
};
UserSession.prototype.getPersistedValue = function(C) {
    if (this[C] && (this[C] instanceof PersistedProperty)) {
        return this[C].get()
    }
    return undefined
};
UserSession.prototype._create = function(C, D) {
    this._authorized();
    this.sessionKey.set(C);
    this.userName.set(D)
};
UserSession.prototype._destroy = function() {
    this._unauthorized();
    this._initializePreferences();
    this.sessionKey.set("");
    this.userName.set("")
};
UserSession.prototype.lostAuthorization = function() {
    this._destroy();
    this._loggingOut();
    UnauthorizedAccessHandling()
};
UserSession.prototype.sessionTimedOut = function() {
    BC.off();
    this.logout();
    SessionTimeoutHandling()
};
UserSession.prototype.mcRestart = function() {
    this._destroy();
    this._loggingOut();
    location.reload()
};
UserSession.prototype._loggingOut = function() {
    reloader.stopReloader();
    RB.abortAll()
};
UserSession.prototype._loggingIn = function() {
    connection.authenticating()
};
UserSession.prototype.validate = function(D) {
    this.validateCallback = D;
    var C = this.sessionKey.get();
    if ((!this.authorized) && C) {
        MC.validate({
            key: C
        }, {
            dialog: false,
            callback: createObjectCallback(this, this._validationComplete)
        })
    } else {
        MC.locales({}, {
            dialog: false,
            callback: createObjectCallback(this, this._validationComplete)
        })
    }
};
UserSession.prototype._validationComplete = function(C) {
    this.setBrandAndLocales(C.message);
    var D = this.sessionKey.get();
    if ((!this.authorized) && D) {
        if (C.success) {
            this._authorized();
            this.userName.get()
        } else {
            this._destroy()
        }
    }
    if ($.isFunction(this.validateCallback)) {
        this.validateCallback.call(this)
    }
};
UserSession.prototype.logout = function(C) {
    this.logoutCallback = C;
    this._loggingOut();
    if (this.authorized) {
        MC.logout({
            key: this.sessionKey.get()
        }, {
            dialog: false,
            callback: createObjectCallback(this, this._logoutComplete)
        })
    } else {
        this._logoutComplete()
    }
};
UserSession.prototype._logoutComplete = function() {
    this._destroy();
    if ($.isFunction(this.logoutCallback)) {
        this.logoutCallback.call(this)
    }
};
UserSession.prototype.login = function(E, C, D) {
    MC.infoOutput("Session.login: " + E);
    this.loginCallback = D;
    this.pendingUser = E;
    this._loggingIn();
    this.base64Value = btoa(E + ":" + C);
    MC.login({
        dialog: false,
        callback: createObjectCallback(this, this._loginComplete)
    })
};
UserSession.prototype._loginComplete = function(C) {
    MC.infoOutput("Session._loginComplete: %o success: " + C.success, C);
    if (C.success) {
        this._create(C.message, this.pendingUser);
        if (!settings.memorex) {
            $.getScript("js/relinfo.js", createObjectCallback(this, this.preApplicationStart))
        }
    } else {
        this._unauthorized()
    }
    if ($.isFunction(this.loginCallback)) {
        this.loginCallback.call(this)
    }
};
UserSession.prototype.preApplicationStart = function() {
    if (this.base64Value == btoa("setup:")) {
        return
    }
    MC.load();
    if (settings.isV3) {
        Help.addRelInfoCss();
        Help.addEXPRCss()
    }
    if (MC.memorex) {
        if (settings.emulator == true) {
            this.requestedLocale = getCookie("language")
        }
    }
    if (this.requestedLocale && this.requestedLocale != "default") {
        MC.setSessionParameters({
            locale: this.requestedLocale
        }, {
            dialog: false,
            callback: createObjectCallback(this, this.continuePreApplicationStart1)
        });
        return
    }
    this.continuePreApplicationStart1()
};
UserSession.prototype.continuePreApplicationStart1 = function() {
    MC.sessionParametersSet.requestData({
        update: true,
        force: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this.continuePreApplicationStart2)
    })
};
UserSession.prototype.continuePreApplicationStart2 = function(F) {
    this._sessionDataHandler(F);
    if (settings.externalUI) {
        this.continuePreApplicationStart5()
    } else {
        var C = createObjectCallback(this, this.continuePreApplicationStart3);
        saveGlobalStrings = strings;
        if (MC.memorex) {
            var G = "lang/" + this.requestedLocale + "/"
        } else {
            var G = this.getLocalePath()
        }
    }
    if (MC.memorex == "ctk") {
        this.continuePreApplicationStart3(null, "n/a")
    } else {
        var E = G + "js/strings.js";
        MC.debugOutput("Attempting to load Strings: %s", E);
        MC.infoOutput("applicationTitle = %s", strings.applicationTitle);
        this.jsRequest = $.ajax({
            url: E,
            dataType: "script",
            complete: C
        });
        var D = G + "css/override.css";
        dynamicCSS(D)
    }
};
UserSession.prototype.continuePreApplicationStart3 = function(F, G) {
    if (G == "success") {
        MC.debugOutput("Global Strings was loaded, so extending old version");
        $.extend(true, saveGlobalStrings, strings);
        strings = saveGlobalStrings;
        MC.infoOutput("applicationTitle = %s", strings.applicationTitle)
    } else {
        MC.warningOutput("Global Strings NOT loaded, applicationTitle: %s", strings.applicationTitle)
    }
    delete saveGlobalStrings;
    saveBrandStrings = brandStrings;
    var E = this.getLocalePath();
    if (MC.memorex == "ctk") {
        var C = "js/brandStrings.js"
    } else {
        var C = E + "js/brandStrings.js"
    }
    var D = createObjectCallback(this, this.continuePreApplicationStart4);
    MC.debugOutput("Attempting to load Brand Strings: %s", C);
    this.jsRequest = $.ajax({
        url: C,
        dataType: "script",
        complete: D
    })
};
UserSession.prototype.continuePreApplicationStart4 = function(D, E) {
    if (E == "success") {
        MC.debugOutput("Brand Strings was loaded, so extending old version");
        $.extend(true, saveBrandStrings, brandStrings);
        brandStrings = saveBrandStrings;
        $.extend(true, strings, brandStrings);
        MC.infoOutput("applicationTitle = %s", strings.applicationTitle)
    } else {
        MC.warningOutput("Brand Strings NOT loaded, merge existing copy.");
        $.extend(true, strings, brandStrings);
        MC.infoOutput("applicationTitle = %s", strings.applicationTitle)
    }
    delete saveBrandStrings;
    if (settings.isV3) {
        NAV.initialize()
    }
    ApplicationStart();
    var C = createObjectCallback(this, this.continuePreApplicationStart5);
    MC.metaPreLoad(C)
};
UserSession.prototype.continuePreApplicationStart5 = function() {
    system = new SystemInfo();
    licenseInfo = new LicenseInfo();
    ApplicationLoadingHandling();
    MC.confirmLoadSets(MC.getDataSetsForLoad(MCObject.PRELOAD), "sessionStart4", createObjectCallback(this, this.applicationInit), false, false)
};
UserSession.prototype.applicationInit = function() {
    if (settings.isV3) {
        views.topicView.sizing({
            minWidth: -1,
            maxWidth: -1,
            width: -1,
            minHeight: -1,
            maxHeight: -1,
            height: -1,
            horizontal: "available",
            vertical: "available"
        });
        $(window).bind("resize", function(C) {
            adjustLayout()
        })
    }
    MC.confirmLoadSets(MC.getDataSetsForLoad(MCObject.INITIAL_LOAD), "applicationInit", createObjectCallback(this, this.applicationInit2), false, false)
};
UserSession.prototype.applicationInit2 = function() {
    applicationLoading = false;
    ApplicationDoneLoadingHandling();
    addPortDatasets();
    MC.confirmLoadSets(MC.getDataSetsForLoad(MCObject.LATE_LOAD), "applicationInit3", createObjectCallback(this, this.applicationInit3), false, false)
};
UserSession.prototype.applicationInit3 = function() {
    MC.allDataSetsLoaded = true;
    panels.ActivityBarPanel.display("none", new Date(), strings.notes.allDataLoaded);
    reloader.subscribe()
};
UserSession.prototype.hasManageStandardRole = function(C) {
    if (C == undefined) {
        C = session.getCurrentUser()
    }
    if (session.hasManageRole(C) || session.hasStandardRole(C)) {
        return true
    }
    return false
};
UserSession.prototype.hasManageRole = function(D) {
    if (D == undefined) {
        D = session.getCurrentUser()
    }
    var F;
    if (DC.users[D]) {
        var C = DC.users[D];
        F = C.getPropertyValue("roles")
    } else {
        if (DC.usergroups[D]) {
            var E = DC.usergroups[D];
            F = E.getPropertyValue("roles")
        }
    }
    if (F.indexOf(strings.userManagement.panelText.manage) != -1) {
        return true
    }
    return false
};
UserSession.prototype.hasDiagnosticRole = function(D) {
    if (D == undefined) {
        D = session.getCurrentUser()
    }
    var F;
    if (DC.users[D]) {
        var C = DC.users[D];
        F = C.getPropertyValue("roles")
    } else {
        if (DC.usergroups[D]) {
            var E = DC.usergroups[D];
            F = E.getPropertyValue("roles")
        }
    }
    if (F.indexOf(strings.userManagement.panelText.diagnostic) != -1) {
        return true
    }
    return false
};
UserSession.prototype.hasMonitorRole = function(D) {
    if (D == undefined) {
        D = session.getCurrentUser()
    }
    var F;
    if (DC.users[D]) {
        var C = DC.users[D];
        F = C.getPropertyValue("roles")
    } else {
        if (DC.usergroups[D]) {
            var E = DC.usergroups[D];
            F = E.getPropertyValue("roles")
        }
    }
    if (F.indexOf(strings.userManagement.panelText.monitor) != -1) {
        return true
    }
    return false
};
UserSession.prototype.hasStandardRole = function(D) {
    if (D == undefined) {
        D = session.getCurrentUser()
    }
    var F;
    if (DC.users[D]) {
        var C = DC.users[D];
        F = C.getPropertyValue("roles")
    } else {
        if (DC.usergroups[D]) {
            var E = DC.usergroups[D];
            F = E.getPropertyValue("roles")
        }
    }
    if (F.indexOf(strings.userManagement.panelText.standard) != -1) {
        return true
    }
    return false
};
UserSession.prototype.hasOnlyMonitorRole = function(C) {
    if (C == undefined) {
        C = session.getCurrentUser()
    }
    if (session.hasMonitorRole(C) && !session.hasManageRole(C) && !session.hasStandardRole(C)) {
        return true
    }
    return false
};
UserSession.prototype.hasConfigurationCapability = function(C) {
    if (C == undefined) {
        C = session.getCurrentUser()
    }
    if (session.hasManageRole(C) || session.hasDiagnosticRole(C) || session.hasStandardRole(C)) {
        return true
    }
    return false
};
UserSession.prototype.hasUserConfigCapability = function(C) {
    if (C == undefined) {
        C = session.getCurrentUser()
    }
    if (session.hasManageRole(C) || session.hasDiagnosticRole(C)) {
        return true
    }
    return false
};
UserSession.prototype.getCurrentUser = function(D) {
    var C = "";
    if (session.userName.value != "undefined" && DC.users[session.userName.value]) {
        C = session.userName.value
    } else {
        if (session.sessionPreferences.usergroupname != "undefined") {
            C = session.sessionPreferences.usergroupname
        }
    }
    return C
};

function checkAuthentication(C) {
    session = new UserSession(C);
    MC.infoOutput("CheckAuthentication - validate");
    session.validate(checkAuthenticationCallback);
    MC.infoOutput("CheckAuthentication - validate initiated")
}

function checkAuthenticationCallback() {
    if (session.isAuthorized()) {
        MC.infoOutput("checkAuthenticationCallback - start app");
        if (settings.memorex) {
            RI.modified = "0";
            RI.deleted = "false";
            RI.hardwarePlatform = "Gallium";
            RI.easyStart = "false";
            RI.hardwareArch = "moose";
            RI.mcFlashSize = "65536";
            RI.appFsSize = "47185920";
            RI.configFsSize = "19660800";
            RI.eraseBlockSize = "131072";
            RI.compilerVersion = "4.6.1";
            RI.capisdk = "capisdk";
            RI.version = "GLM220";
            RI.storageModel = "PAGED";
            RI.hostGroups = "true";
            RI.volumeGroups = "true";
            RI.iPV6 = "true";
            RI.ssdSupport = "true";
            RI.advLunMapping = "true";
            RI.burnToActive = "true";
            RI["32ByteNames"] = "true";
            RI.dms = "true";
            RI.rsr = "true";
            RI.cnc = "true";
            RI.ethConfig = "false";
            RI.releaseBuild = "false";
            RI.psReady = "true";
            RI.fde = "true";
            RI.atomicWrites = "false";
            RI.manualScrub = "false";
            RI.e2ePi = "false";
            RI.quietMode = "true";
            RI.hybridConfigurable = "true";
            RI.scrubDuration = "false";
            RI.fencedData = "false";
            RI.metadataRecovery = "false";
            RI.intelligentTrust = "true";
            RI.degradedDisk = "false";
            RI.thinProvisioning = "true";
            RI.copyServices = "true";
            RI.asyncRep = "true";
            RI.sneakernet = "true";
            RI.volTierPin = "false";
            RI.volTierPreference = "true";
            RI.autopooling = "false";
            RI.atlas = "false";
            RI.hercules = "false";
            RI.oneButtonProvision = "false";
            RI.autoStall = "true";
            RI.managementModeOverride = "DEFAULT";
            RI.hideV3fromV2 = "false";
            RI.defaultLinearOnV3 = "false";
            RI.persistentAlerts = "true";
            RI.hierarchicalLeds = "false";
            RI.controllerWithEnclLeds = "true";
            RI.slowDrivePerformance = "false";
            RI.allFlashArray = "true";
            RI.adapt = "true";
            EXPR.MaxEnclosures = 8;
            EXPR.PortsPerController = 4;
            EXPR.isISCSIPortType = true;
            EXPR.isFanOutSupported = false;
            wbiBrandDir = "";
            session.preApplicationStart()
        } else {
            $.getScript("js/relinfo.js", createObjectCallback(this, this.preApplicationStart))
        }
    } else {
        MC.infoOutput("checkAuthenticationCallback - login start");
        LoginHandling()
    }
}

function applicationAccessed() {
    if (session) {
        session.accessed()
    }
}

function addPortDatasets() {
    if (APIPort.hasPortType("IB")) {
        MC.infiniBandParametersSet = MC.register(new DataSet({
            name: "infiniBandParametersSet",
            url: "api/show/infiniband-parameters",
            memorexFile: "showInfiniBandParameters",
            basetypes: ["infiniband-parameters"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.LATE_LOAD
        }))
    }
    if (APIPort.hasPortType("iSCSI")) {
        MC.iscsiParametersSet = MC.register(new DataSet({
            name: "iscsiParametersSet",
            url: "api/show/iscsi-parameters",
            memorexFile: "showIscsiParameters",
            basetypes: ["iscsi-parameters"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.LATE_LOAD
        }));
        MC.chapRecordsSet = MC.register(new DataSet({
            name: "chapRecordsSet",
            url: "api/show/chap-records",
            memorexFile: "showChapRecords",
            basetypes: ["chap-records"],
            accessMethod: DataSet.METHOD.COUNTER,
            pollInterval: 30,
            loadOrder: MCObject.LATE_LOAD
        }))
    }
}

function Reloader(C) {
    this.compareData = null;
    this.interval = (typeof(session) != "undefined") ? session.getSessionObjectValue("interval") : 30 * 1000;
    this.intervalHandle = null;
    this.class_name = "Reloader";
    this.skips = 0;
    this.logData = false
}
Reloader.prototype.compare = function(G) {
    if (!G || !G.data || G.data.objects.length == 0) {
        MC.errorOutput("Reloader.compare(): No data received");
        return
    }
    if (!this.compareData) {
        this.updateLocalData(G);
        return
    }
    var L = {};
    if (this.logData) {
        MC.debugOutput("Reloader: REFRESH COUNTER COMPARISON:")
    }
    var J = "BASETYPE                            OLD COUNTER -  NEW COUNTER : NEED UPDATE?\n";
    for (var I in G.data.objects[0].prop) {
        var E = this.compareData[I];
        var K = G.data.objects[0].prop[I];
        if (this.logData) {
            J += sprintf("%-33s: %12s - %12s : ", I, E.text, K.text)
        }
        if (!E || (E.text == "0") || (E.text != K.text)) {
            if (this.logData) {
                J += "UPDATE\n"
            }
            var F = I.replace(/_/g, "-");
            $.extend(L, MC.getDataSetsForBase(F))
        } else {
            if (this.logData) {
                J += "ok\n"
            }
        }
    }
    if (this.logData) {
        J += "Datasets flagged for reloading:\n"
    }
    var D = new Date();
    var M = D.getTime();
    for (var C in L) {
        if (L[C].access.method != DataSet.METHOD.COUNTER) {
            if (this.logData) {
                J += sprintf("    %s : Skipped (method: %s)\n", C, L[C].access.method)
            }
            delete L[C]
        } else {
            if (M < (L[C].lastLoaded.getTime() + L[C].access.interval * 1000)) {
                if (this.logData) {
                    J += sprintf("    %s : Skipped (<interval: %s)\n", C, L[C].access.interval)
                }
                var H = L[C].basetypes[0].replace(/-/g, "_");
                G.data.objects[0].prop[H] = this.compareData[H];
                delete L[C]
            } else {
                if (this.logData) {
                    J += sprintf("    %s : Reloading\n", C)
                }
            }
        }
    }
    if (this.logData && window.console) {
        console.log(J)
    }
    for (var C in L) {
        L[C].requestData({
            update: true,
            force: true,
            classification: "background",
            requestor: this.class_name
        })
    }
    this.updateLocalData(G)
};
Reloader.prototype.updateLocalData = function(D) {
    this.compareData = {};
    for (var C in D.data.objects[0].prop) {
        this.compareData[C] = D.data.objects[0].prop[C]
    }
};
Reloader.prototype.subscribe = function() {
    this.subscription = MC.refreshCountersSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.compare)
    });
    this.startReloader()
};
Reloader.prototype.startReloader = function() {
    MC.refreshCountersSet.changeAccess(DataSet.METHOD.POLL)
};
Reloader.prototype.stopReloader = function() {
    MC.refreshCountersSet.changeAccess(DataSet.METHOD.ONDEMAND)
};
Reloader.prototype.doRequests = function(C) {
    var D = (MC.refreshCountersSet.access.method == DataSet.METHOD.POLL);
    if (D != C) {
        MC.debugOutput("Reloader: switching %s", (C ? "on" : "off"))
    }
    if (!D && C) {
        this.startReloader()
    } else {
        if (D && !C) {
            this.stopReloader()
        }
    }
};
Reloader.prototype.on = function() {
    this.doRequests(true)
};
Reloader.prototype.off = function() {
    this.doRequests(false)
};
Reloader.prototype.logOn = function() {
    this.logData = true;
    if (window.console) {
        console.log("Reloader data logging ON")
    }
};
Reloader.prototype.logOff = function() {
    this.logData = false;
    if (window.console) {
        console.log("Reloader data logging OFF")
    }
};
Reloader.prototype.callServer = function() {
    if (RB.getRequestCount() == 0) {
        this.skips = 0;
        MC.refreshCountersSet.requestData({
            update: true,
            requestor: this.class_name
        })
    } else {
        this.skips++;
        MC.infoOutput("reloader.callServer: Skipping a refresh; Request Count=%d, Skip count=%d", RB.getRequestCount(), this.skips)
    }
};
var reloader = new Reloader();

function AddStorageAction(D) {
    this.data = {};
    if (arguments.length == 0) {
        return
    }
    if (!D.name) {
        D.name = "AddStorageAction"
    }
    D.height = 350;
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = createObjectCallback(this, this.changedCallbackMethod);
    D.widgets = new ContentWidget({
        name: "AddStorageContent",
        id: "AddStorage",
        autoWidth: true,
        widgets: [this.form = new FormWidget({
            name: "AddStorageForm",
            data: this.data,
            tableLayout: true,
            widgets: [new TextWidget({
                row: 0,
                col: 0,
                colSpan: 2,
                name: "actionDescription",
                text: strings.addStorage.actionDescription
            }), new DataTable({
                name: "profiles",
                row: 1,
                col: 0,
                colSpan: 2,
                bottomMargin: true,
                topMargin: true,
                selecting: C,
                unselecting: C
            }), new OptionInputWidget({
                name: "enclosures",
                row: 2,
                col: 1,
                label: strings.addStorage.enclosuresLabel,
                labelOptions: {
                    row: 2,
                    col: 0,
                    bottomMargin: true,
                    rightSmallMargin: true
                },
                bottomMargin: true,
                disable: true,
                multiple: false,
                classes: "addStorageInput",
                changeCallback: C
            })]
        })]
    });
    ActionPanel.call(this, D);
    this.class_name = "AddStorageAction"
}
AddStorageAction.prototype = new ActionPanel();
AddStorageAction.prototype.constructor = AddStorageAction;
AddStorageAction.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.hasFeature("oneButtonProvision")) {
        return false
    } else {
        return []
    }
};
AddStorageAction.prototype.showing = function() {
    var D = {};
    this.update(D);
    var C = this;
    this.profilesSubscription = MC.showProfiles.requestData({
        requestor: this.class_name,
        update: true,
        durable: true,
        handler: createObjectCallback(this, function(G) {
            var E = G.getData();
            if (!E) {
                return
            }
            var F = {
                profiles: {
                    grid: new APIDataGrid({
                        caption: strings.addStorage.profileTable,
                        selectable: true,
                        data: E,
                        exclusive: true,
                        filter: {
                            fields: ["profile_desc", "vdisk_config", "chunk_size"]
                        }
                    })
                }
            };
            C.update(F)
        })
    });
    this.enclosuresSubscription = MC.enclosuresSet.requestData({
        update: false,
        durable: this.durable,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(I) {
            var F = I;
            if (!F || !F.data.objects) {
                return
            }
            var E = [];
            E[0] = {
                value: "next_available",
                text: "Next available"
            };
            for (var G = 0; G < F.data.objects.length; G++) {
                E[G + 1] = {
                    value: F.data.objects[G].getPropertyValue("enclosure_id"),
                    text: F.data.objects[G].getPropertyValue("enclosure_id")
                }
            }
            var H = {
                enclosures: {}
            };
            H.enclosures.values = E;
            C.update(H)
        })
    })
};
AddStorageAction.prototype.hiding = function() {
    if (this.profilesSubscription) {
        MC.showProfiles.unregister(this.profilesSubscription);
        delete this.profilesSubscription
    }
    if (this.enclosuresSubscription) {
        MC.showProfiles.unregister(this.enclosuresSubscription);
        delete this.enclosuresSubscription
    }
};
AddStorageAction.prototype.changedCallbackMethod = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (C.profiles.objects.length == 0) {
        this.okEnabled(false)
    } else {
        this.okEnabled(true)
    }
};
AddStorageAction.prototype.okCallback = function() {
    var E = {};
    this.retrieve(E);
    var D = E.profiles.getNthObject(0);
    if (!D) {
        return
    }
    var C = D.get("profile_desc");
    var F = {};
    F.profile = D.get("storage_profile");
    F.enclosure = E.enclosures.value;
    MC.addStorageByProfile(F, {
        dialog: true,
        processingMsg: strings.addStorage.processing(C),
        failureMsg: strings.addStorage.failure(C),
        noSuccessDialog: true,
        callback: createObjectCallback(this, this.addStorageCmdComplete)
    })
};
AddStorageAction.prototype.addStorageCmdComplete = function(D) {
    MC.debugOutput("returned:" + D.success + " msg:" + D.message + " code:" + D.code, "%s");
    if (D.success && D.json) {
        var F = {};
        this.retrieve(F);
        var E = F.profiles.getNthObject(0);
        if (!E) {
            return
        }
        var C = E.get("profile_desc");
        ShowActiveDialog({
            type: "success",
            dialogOverride: true,
            header: strings.addStorage.success(C),
            message: "<br />" + D.message
        });
        this.close()
    } else {
        ShowActiveDialog({
            type: "error",
            dialogOverride: true,
            message: D.message
        })
    }
    var F = {};
    F.addStorageFormSubmit = {
        disable: true
    };
    F.enclosures = {
        value: "next_available"
    };
    F.profiles = {
        selected: false
    };
    this.update(F)
};

function DateTimeWidget(D) {
    if (arguments.length == 0) {
        return
    }
    var C = new Date();
    C.setFullYear("1970");
    D.widgets = [new TableWidget({
        widgets: [new DateInputWidget({
            name: "datePicker",
            picker: {
                minDate: C
            },
            row: 0,
            col: 1,
            bottomMargin: true,
            leftMargin: true,
            label: strings.dateTimeSetup.DateLabel,
            labelOptions: {
                row: 0,
                col: 0,
                classes: "noWrap"
            },
            changeCallback: createObjectCallback(this, this.somethingChanged)
        }), new TimeInputWidget({
            name: "timePicker",
            row: 1,
            col: 1,
            bottomMargin: true,
            topMargin: true,
            leftMargin: true,
            label: strings.dateTimeSetup.TimeLabel,
            setOrig: true,
            labelOptions: {
                row: 1,
                col: 0,
                classes: "noWrap"
            },
            changeCallback: createObjectCallback(this, this.somethingChanged)
        })]
    }), new TableWidget({
        name: "ntpProps",
        border: true,
        colSpan: 2,
        topMargin: true,
        width: 670,
        widgets: [new CheckboxInputWidget({
            name: "ntp_state",
            label: strings.dateTimeSetup.NtpLabel,
            row: 0,
            col: 0,
            bottomMargin: true,
            singleCell: true,
            colSpan: 2,
            labelOptions: {
                col: 1,
                rightMargin: true,
                classes: "noWrap"
            },
            changeCallback: createObjectCallback(this, this.setNtpState)
        }), new TextInputWidget({
            name: "ntp_address",
            label: strings.dateTimeSetup.NtpServerLabel,
            row: 1,
            col: 1,
            bottomMargin: true,
            labelOptions: {
                col: 0,
                rightMargin: true,
                classes: "noWrap"
            },
            size: 15,
            rules: {
                required: false,
                ipv4Address: true
            },
            changeCallback: createObjectCallback(this, this.somethingChanged)
        }), new TextInputWidget({
            name: "time_zone_offset",
            label: strings.dateTimeSetup.TimeZoneLabel,
            row: 2,
            col: 1,
            bottomMargin: true,
            labelOptions: {
                col: 0,
                rightMargin: true,
                classes: "noWrap"
            },
            size: 6,
            changeCallback: createObjectCallback(this, this.somethingChanged)
        })]
    }), new TextWidget({
        name: "noDst",
        text: strings.dateTimeSetup.noDst,
        topMargin: true
    })];
    WidgetContainer.call(this, D);
    this.class_name = "DateTimeWidget"
}
DateTimeWidget.prototype = new WidgetContainer();
DateTimeWidget.prototype.constructor = DateTimeWidget;
DateTimeWidget.prototype.updateData = function() {
    var E = new MCDate();
    var D = MC.timeSettingsSet.data.objects[0];
    var C = decodeBooleanFlag(D.getPropertyValue("ntp_state"));
    this.update({
        datePicker: {
            value: E,
            disable: C,
            setOrig: true
        },
        timePicker: {
            value: E,
            disable: C,
            setOrig: true
        },
        ntp_state: {
            value: C,
            setOrig: true
        },
        time_zone_offset: {
            disable: !C,
            value: C ? D.getPropertyValue("time_zone_offset") : "",
            setOrig: true
        },
        ntp_address: {
            disable: !C,
            value: C ? D.getPropertyValue("ntp_address") : "",
            setOrig: true
        }
    })
};
DateTimeWidget.prototype.showing = function() {
    var C = {};
    if (RI.hasFeature("iPV6") && RI.hasFeature("DNS")) {
        C.ntp_address = {
            rules: {
                ipv4ipv6orhostname: true
            }
        }
    } else {
        if (RI.hasFeature("iPV6")) {
            C.ntp_address = {
                rules: {
                    ipv4andipv6: true
                }
            }
        } else {
            if (RI.hasFeature("DNS")) {
                C.ntp_address = {
                    rules: {
                        dnsAddress: true
                    }
                }
            }
        }
    }
    this.update(C);
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
DateTimeWidget.prototype.loadData = function() {
    this.dateTimeSubscription = MC.timeSettingsSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            this.updateData()
        })
    })
};
DateTimeWidget.prototype.hiding = function() {
    if (this.dateTimeSubscription) {
        MC.timeSettingsSet.unregister(this.dateTimeSubscription);
        delete this.dateTimeSubscription
    }
};
DateTimeWidget.prototype.setNtpState = function() {
    var D = {};
    this.retrieve(D);
    this.somethingChanged();
    if (D.ntp_state.value) {
        var C = {
            datePicker: {
                disable: true
            },
            timePicker: {
                disable: true
            },
            ntp_address: {
                disable: false
            },
            time_zone_offset: {
                disable: false
            }
        }
    } else {
        var C = {
            datePicker: {
                disable: false
            },
            timePicker: {
                disable: false
            },
            ntp_address: {
                disable: true
            },
            time_zone_offset: {
                disable: true
            }
        }
    }
    this.update(C)
};
DateTimeWidget.prototype.somethingChanged = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    this.valueChanged = false;
    var C = {};
    for (i in D) {
        if (D[i].valueChanged == true) {
            this.valueChanged = true;
            break
        }
    }
    if ($.isFunction(this.options.changeCallback) && this.name) {
        if (!C[this.name]) {
            C[this.name] = {}
        }
        C[this.name].valueChanged = this.valueChanged;
        if (session.hasConfigurationCapability()) {
            this.options.changeCallback(C, this, F)
        }
    }
};
DateTimeWidget.prototype.getCommandQueue = function() {
    var E = {};
    this.retrieve(E);
    var C = [];
    var D = {};
    D.ntp_state = E.ntp_state.value;
    if (E.ntp_state.value) {
        D.ntp_address = E.ntp_address.value;
        D.time_zone_offset = E.time_zone_offset.value
    } else {
        D.date = E.datePicker.value;
        var F = E.timePicker.value;
        D.date.setHours(F.getHours());
        D.date.setMinutes(F.getMinutes());
        D.date.setSeconds(F.getSeconds())
    }
    C.push({
        name: "dateTime",
        command: MC.setTimeValues,
        data: D,
        options: {
            processingMsg: strings.dateTimeSetup.TimeSetProcessing,
            failureMsg: strings.dateTimeSetup.TimeSetFail,
            successMsg: strings.dateTimeSetup.TimeSetSuccess
        }
    });
    return C
};
DateTimeWidget.prototype.getConfirmMsg = function() {
    var D = {};
    var C = E = "";
    this.retrieve(D);
    var F = '<div class="confirmLabel"><u>' + strings.configurationWizard.dateTimeLabel + "</u></div><br>";
    if (D.ntp_state.valueChanged) {
        C = strings.configurationWizard.summary.ntp_state;
        if (D.ntp_state.value) {
            E = strings.Enabled;
            F += C + ": " + E + "<br>";
            C = strings.configurationWizard.summary.ntp_address;
            E = D.ntp_address.value;
            F += C + ": " + E + "<br>";
            C = strings.configurationWizard.summary.time_zone_offset;
            E = D.time_zone_offset.value;
            F += C + ": " + E + "<br>"
        } else {
            var E = strings.Disabled;
            F += C + ": " + E + "<br>";
            C = strings.date;
            E = D.datePicker.textValue;
            F += C + ": " + E + "<br>";
            C = strings.Time;
            E = D.timePicker.textValue;
            F += C + ": " + E + "<br>"
        }
    } else {
        if (D.ntp_address.valueChanged || D.time_zone_offset.valueChanged) {
            C = strings.configurationWizard.summary.ntp_address;
            E = D.ntp_address.value;
            F += C + ": " + E + "<br>";
            C = strings.configurationWizard.summary.time_zone_offset;
            E = D.time_zone_offset.value;
            F += C + ": " + E + "<br>"
        } else {
            if (D.datePicker.valueChanged || D.timePicker.valueChanged) {
                C = strings.date;
                E = D.datePicker.textValue;
                F += C + ": " + E + "<br>";
                C = strings.Time;
                E = D.timePicker.textValue;
                F += C + ": " + E + "<br>"
            }
        }
    }
    return F
};

function LicenseSetupWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "LicenseSetupWidget";
    var C = [{
        sTitle: strings.licenseMgmt.licenseName,
        bVisible: true,
        bIsKey: true
    }, {
        sTitle: strings.licenseMgmt.licenseBase
    }, {
        sTitle: strings.licenseMgmt.licenseValue
    }, {
        sTitle: strings.licenseMgmt.licenseInUse
    }, {
        sTitle: strings.licenseMgmt.licenseMax
    }, {
        sTitle: strings.licenseMgmt.licenseExpiration
    }];
    this.tempLic = new FormWidget({
        name: "tempLic",
        tableLayout: true,
        widgets: [new TextWidget({
            row: 0,
            col: 0,
            name: "tmpInstructions",
            text: strings.licenseMgmt.tempInstructions,
            topMargin: true,
            bottomMargin: true
        }), new ContentWidget({
            row: 1,
            col: 0,
            name: "EULAContent",
            scrollable: true,
            border: true,
            height: 130,
            widgets: [new TextWidget({
                name: "EULA",
                text: strings.licenseMgmt.EULA
            })]
        }), new CheckboxInputWidget({
            row: 2,
            col: 0,
            name: "approveEULA",
            label: strings.licenseMgmt.tempLicenseEULA,
            labelOptions: {
                leftMargin: true,
                topMargin: true
            },
            singleCell: true,
            leftMargin: true,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        })]
    });
    this.permLic = new TableWidget({
        name: "permLic",
        widgets: [new TextWidget({
            row: 0,
            col: 0,
            name: "selectFileInstructions",
            text: strings.licenseMgmt.selectFileInstructions,
            bottomMargin: true,
            topMargin: true
        }), this.fileUploadWidget = new FileUploadWidget({
            row: 1,
            col: 0,
            name: "licenseFile",
            action: "/api/license",
            dataRefresh: ["licenseSet"],
            noButton: true,
            processingMsg: strings.licenseMgmt.processingMsg,
            failureMsg: strings.licenseMgmt.failureMsg,
            noCompletedDialog: true,
            changeCallback: createObjectCallback(this, this.changeCallback),
            finishedCallback: createObjectCallback(this, this.finishedCallback),
            submitText: strings.licenseMgmt.button
        }), new TextWidget({
            row: 2,
            col: 0,
            name: "okToCommit",
            text: strings.licenseMgmt.okToCommit,
            height: 150
        })]
    });
    D.widgets = [new WidgetContainer({
        name: "licenseContainer",
        widgets: [this.licenseTable = new TableInator({
            name: "licenseTable",
            selectable: "single",
            width: 650,
            selectable: false,
            bottomMargin: true,
            type: "rawData",
            noFeatures: true,
            metadata: C
        }), new TableWidget({
            name: "licSerVerTable",
            bottomMargin: true,
            classes: "width100pct",
            widgets: [new TextWidget({
                name: "sysSerNumDescr",
                row: 0,
                col: 1,
                singleCell: true,
                text: "",
                label: strings.licenseMgmt.serNumLabel
            }), new TextWidget({
                name: "sysVersionDescr",
                row: 0,
                col: 3,
                singleCell: true,
                text: "",
                label: strings.licenseMgmt.versionLabel,
                leftMargin: true
            })]
        })]
    })];
    if (decodeBooleanFlag(brandFlags.trialLicensing)) {
        D.widgets.push(new TextWidget({
            name: "tabInstructions",
            text: strings.licenseMgmt.tabInstructions,
            bottomMargin: true
        }));
        this.licTabs = new TabWidget({
            name: "licTabs",
            type: "Primary",
            changeCallback: createObjectCallback(this, this._tabSelected),
            tabs: [{
                name: "permLicenseTab",
                label: strings.licenseMgmt.permLic,
                labelOptions: {
                    bottomMargin: true
                }
            }, {
                name: "tempLicenseTab",
                label: strings.licenseMgmt.tempLic,
                labelOptions: {
                    bottomMargin: true
                }
            }]
        });
        D.widgets.push(this.licTabs);
        this.licTabs.add(this.permLic);
        this.licTabs.add(this.tempLic)
    } else {
        D.widgets.push(this.permLic)
    }
    WidgetContainer.call(this, D);
    this.class_name = "LicenseSetupWidget";
    if (decodeBooleanFlag(brandFlags.trialLicensing)) {
        this._tabSelected(LicenseSetupWidget.licType.PERM)
    }
}
LicenseSetupWidget.prototype = new WidgetContainer();
LicenseSetupWidget.prototype.constructor = LicenseSetupWidget;
LicenseSetupWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
LicenseSetupWidget.prototype.loadData = function() {
    this.licenseSubscription = MC.licenseSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            this.handleLicenseData()
        })
    });
    this.sysParameterSubscription = MC.systemParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(E) {
            var C = E.getData().objects[0];
            var D = {
                sysSerNumDescr: {
                    text: C.prop.serial_number.text
                }
            };
            this.update(D)
        })
    });
    this.versionsSubscription = MC.versionsSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(F) {
            var D = F.getData().objects[0];
            var C = D.get("bundle_version");
            var H;
            if (C && C != "No System Bundle") {
                C = C.replace(/Invalid Bundle \(/, "");
                C = C.replace(/\)/, "");
                var G = C.match(/^([A-Za-z]+[0-9]+)/);
                if (G && G[0]) {
                    H = C.match(/^([A-Za-z]+[0-9]+)/)[0]
                } else {
                    H = strings.NotFound
                }
            } else {
                H = strings.NotFound
            }
            var E = {
                sysVersionDescr: {
                    text: H
                }
            };
            this.update(E)
        })
    });
    if (!(session.hasUserConfigCapability())) {
        this.update({
            licenseFile: {
                disable: true,
                tooltip: strings.licenseMgmt.mustHaveManage
            }
        })
    }
};
LicenseSetupWidget.prototype.hiding = function() {
    if (this.licenseSubscription) {
        MC.licenseSet.unregister(this.licenseSubscription);
        delete this.licenseSubscription
    }
    if (this.sysParameterSubscription) {
        MC.systemParametersSet.unregister(this.sysParameterSubscription);
        delete this.sysParameterSubscription
    }
    if (this.versionsSubscription) {
        MC.versionsSet.unregister(this.versionsSubscription);
        delete this.versionsSubscription
    }
};
LicenseSetupWidget.licType = {
    PERM: 0,
    TEMP: 1
};
LicenseSetupWidget.prototype.handleLicenseData = function(H, D, G) {
    var I;
    var J = [];
    if (this.fileUploading != undefined && this.fileUploading) {
        return
    }
    var C = licenseInfo.getDataGrid();
    var K = {};
    for (I in C.data) {
        var F = I.match(/\d+/);
        if (I.match(/\d+/) !== null) {
            J.push(C.data[I])
        }
    }
    K = {
        licenseTable: {
            data: J
        },
        licenseFile: {
            value: "",
            setOrig: true
        },
        approveEULA: {
            value: false,
            setOrig: true
        }
    };
    var E = licenseInfo.getTempActive();
    if (!decodeBooleanFlag(brandFlags.trialLicensing)) {
        MC.debugOutput("SetupLicense.showing: temp licensing turned off.");
        K.tmpInstructions = {
            text: strings.licenseMgmt.instructions1noTemp
        };
        K.EULAContent = {
            visibility: "collapse",
            disable: true
        };
        K.approveEULA = {
            visibility: "collapse",
            disable: true
        }
    } else {
        if (E.length > 0) {
            MC.debugOutput("SetupLicense.showing: temp license in use.");
            K.tmpInstructions = {
                text: strings.licenseMgmt.instructions2
            };
            K.EULAContent = {
                visibility: "collapse",
                disable: true
            };
            K.approveEULA = {
                visibility: "collapse",
                disable: true
            }
        } else {
            MC.warningOutput("SetupLicense.showing: temp license not in use.");
            if (!LicenseInfo.EULAfile || LicenseInfo.EULAfile == " ") {
                RB.makeRequest({
                    url: "help/EULA.html",
                    dataType: "text",
                    httpReqType: "GET",
                    callback: createObjectCallback(this, function(L, M) {
                        if (M.textStatus == "success") {
                            MC.debugOutput("LicenseInfo.getEULAresponse %o success", M);
                            LicenseInfo.EULAfile = L;
                            var N = {
                                EULA: {
                                    visibility: "visible",
                                    text: L
                                }
                            };
                            this.update(N)
                        } else {
                            MC.warningOutput("SetupLicense.showing.getEULAresponse %o failed", M)
                        }
                    })
                })
            } else {
                K.EULA = {
                    visibility: "visible",
                    text: LicenseInfo.EULAfile
                };
                K.licForm = {
                    visibility: "visible",
                    disable: false
                }
            }
        }
    }
    this.update(K);
    if (G) {
        this.retrieve(G)
    }
    if (this.fileUploadSuccess != undefined && this.fileUploadSuccess) {
        ShowActiveDialog({
            type: "success",
            dialogOverride: true,
            message: strings.systemSettings.successMsg
        });
        this.fileUploadSuccess = undefined
    }
};
LicenseSetupWidget.prototype.cancelTempLicenseApproval = function() {
    MC.debugOutput("LicenseSetupWidget cancelTempLicenseApproval entered");
    var C = {
        approveEULA: {
            value: false
        }
    };
    this.update(C)
};
LicenseSetupWidget.prototype.changeCallback = function(H, F, G) {
    var D = {};
    var E = {};
    this.retrieve(E);
    var C = {};
    if (!decodeBooleanFlag(brandFlags.trialLicensing) || this.licTabs.selected === 0) {
        this.valueChanged = E.licenseFile.valueChanged === true;
        if (F.name == "licenseFile" && F.valueChanged) {
            this.fileUploading = true
        }
    } else {
        this.valueChanged = E.approveEULA.valueChanged === true
    }
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasUserConfigCapability()) {
        if (!C[this.name]) {
            C[this.name] = {}
        }
        C[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(C, this, G)
    }
};
LicenseSetupWidget.prototype.okCallback = function() {
    if (!decodeBooleanFlag(brandFlags.trialLicensing) || this.licTabs.selected === LicenseSetupWidget.licType.PERM) {
        this.fileUploadWidget.uploadFile()
    } else {
        this.tempLicenseApproval()
    }
};
LicenseSetupWidget.prototype.finishedCallback = function(D, C) {
    if ($.isFunction(this.options.licenseUploadComplete)) {
        this.options.licenseUploadComplete(D, C)
    }
};
LicenseSetupWidget.prototype.getTempLicenseCommand = function() {
    var C = [];
    var D = {};
    this.retrieve(D);
    C.push({
        name: "createTempLicense",
        command: MC.createTempLicense,
        data: {},
        options: {
            processingMsg: strings.licenseMgmt.tempLicenseProcessing,
            failureMsg: strings.licenseMgmt.tempLicenseError
        }
    });
    return C
};
LicenseSetupWidget.prototype.getConfirmMsg = function() {
    var C = {};
    this.retrieve(C);
    if (C.approveEULA.value && this.licTabs.selected === LicenseSetupWidget.licType.TEMP) {
        return strings.licenseMgmt.confirmTempLicenseBB
    }
};
LicenseSetupWidget.prototype._tabSelected = function(C) {
    var D = {};
    if (C == null) {
        return
    }
    if (!this.licTabs) {
        return
    }
    this.retrieve(D);
    switch (C) {
        case LicenseSetupWidget.licType.PERM:
            this.update({
                permLic: {
                    visibility: "visible"
                },
                tempLic: {
                    visibility: "collapse"
                }
            });
            break;
        case LicenseSetupWidget.licType.TEMP:
            this.update({
                permLic: {
                    visibility: "collapse"
                },
                tempLic: {
                    visibility: "visible"
                }
            });
            break;
        default:
            MC.warningOutput("_tabSelected invalid index: " + C);
            break
    }
};
LicenseSetupWidget.prototype.clearTable = function() {
    if (this.licenseTable != undefined) {
        this.licenseTable.destroy()
    }
};

function LocalUsersWidget(E) {
    if (arguments.length == 0) {
        return
    }
    var D = createObjectCallback(this, this.changedCallback);
    E.name = "LocalUsersWidget";
    this.localUsersUpdated = false;
    this.localesList = session.getSupportedLocales();
    this.localesValues = [];
    this.changedWidgets = {};
    this.valueChanged = false;
    this.createPwdRules = {
        dhPassword: true,
        characterLength: 32,
        minlength: 8,
        required: true,
        passwordComplexityCheck: true
    };
    this.modifyPwdRules = {
        dhPassword: true,
        characterLength: 32,
        minlength: 8,
        passwordComplexityCheck: true
    };
    for (var C = 0; C < this.localesList.length; C++) {
        this.localesValues.push({
            value: this.localesList[C].locale,
            text: this.localesList[C].translated
        })
    }
    E.widgets = [new WidgetContainer({
        name: "localUserTab",
        widgets: [new WidgetContainer({
            name: "usrListWC",
            bottomMargin: true,
            widgets: [this.userListTable = new TableInator({
                name: "userListTable",
                selectable: "single",
                width: 640,
                type: "rawData",
                metadata: [{
                    sTitle: strings.userManagement.panelText.UserName,
                    bIsKey: true
                }, {
                    sTitle: strings.userManagement.panelText.UserType,
                    bSortable: false
                }, {
                    sTitle: strings.userManagement.panelText.Roles,
                    bSortable: false
                }],
                dtOptions: {
                    bFilter: false,
                    bLengthChange: false,
                    bInfo: false,
                    bPaginate: true,
                    iDisplayLength: 5
                },
                intercepts: [{
                    selector: 0,
                    renderer: this.usernameIntercept
                }],
                bottomMediumMargin: true,
                selectCallback: createObjectCallback(this, this._userSelected)
            }), new WidgetContainer({
                widgets: [new ButtonContainer({
                    name: "accountActionButtons",
                    orientation: "horizontal",
                    alignment: "right",
                    widgets: [new ButtonWidget({
                        name: "btnNew",
                        size: "small",
                        text: strings.userManagement.panelText.newLabel,
                        tip: strings.userManagement.panelText.tips.btnNew,
                        click: createObjectCallback(this, this.newClicked)
                    }), new ButtonWidget({
                        name: "btnCopy",
                        size: "small",
                        text: strings.userManagement.panelText.copyLabel,
                        tip: strings.userManagement.panelText.tips.btnCopy,
                        click: createObjectCallback(this, this.copyClicked)
                    }), new ButtonWidget({
                        name: "btnDelete",
                        size: "small",
                        text: strings.userManagement.panelText.deleteLabel,
                        tip: strings.userManagement.panelText.tips.btnDelete,
                        click: createObjectCallback(this, this.deleteClicked)
                    })]
                }), new WidgetContainer({
                    classes: "clearFloats"
                })]
            })]
        }), new TableWidget({
            name: "middleTable",
            bottomMargin: true,
            widgets: [new TableWidget({
                name: "userPass",
                row: 0,
                col: 0,
                widgets: [new TextInputWidget({
                    name: "userTextbox",
                    row: 0,
                    col: 1,
                    label: strings.userManagement.panelText.UserName,
                    labelOptions: {
                        rightMargin: true,
                        col: 0,
                        classes: "noWrap"
                    },
                    rightMargin: true,
                    bottomMargin: true,
                    messages: {
                        required: strings.userManagement.validation.usernameError
                    },
                    changeCallback: createObjectCallback(this, this._usernameChanged)
                }), new TextInputWidget({
                    name: "passwordTextbox",
                    row: 1,
                    col: 1,
                    label: strings.userManagement.panelText.password,
                    labelOptions: {
                        rightMargin: true,
                        col: 0,
                        classes: "noWrap"
                    },
                    password: true,
                    rightMargin: true,
                    bottomMargin: true,
                    messages: {
                        required: strings.userManagement.validation.noEmptyPassword,
                        utf8length: strings.userManagement.validation.passwordLength
                    },
                    changeCallback: D
                }), new TextInputWidget({
                    name: "passwordConfirm",
                    row: 2,
                    col: 1,
                    label: strings.userManagement.panelText.ConfirmPassword,
                    labelOptions: {
                        rightMargin: true,
                        col: 0
                    },
                    password: true,
                    rightMargin: true,
                    bottomMargin: true,
                    messages: {
                        required: strings.userManagement.validation.confirmPassword,
                        utf8length: strings.userManagement.validation.passwordLength
                    },
                    rules: {
                        equalTo: "#passwordTextbox"
                    },
                    changeCallback: D
                })]
            }), new TableWidget({
                name: "typeAndRoles",
                row: 0,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                widgets: [new RadioButtonsInputWidget({
                    name: "accountNature",
                    row: 0,
                    col: 0,
                    singleCell: true,
                    colSpan: 4,
                    bottomMargin: true,
                    orientation: "horizontal",
                    label: strings.userManagement.panelText.UserType,
                    disable: true,
                    classes: "noWrap",
                    values: [{
                        value: "stdNature",
                        text: strings.userManagement.panelText.Standard,
                        tip: strings.userManagement.panelText.tips.stdAcctNature
                    }, {
                        value: "snmpNature",
                        text: strings.userManagement.panelText.SNMPv3,
                        tip: strings.userManagement.panelText.tips.snmpAcctNature
                    }],
                    changeCallback: createObjectCallback(this, this.accountNatureChanged)
                }), new LabelWidget({
                    name: "rolesLabel",
                    value: strings.userManagement.panelText.Roles,
                    row: 1,
                    col: 0,
                    bottomMargin: true
                }), new CheckboxInputWidget({
                    name: "manageRole",
                    row: 1,
                    col: 1,
                    singleCell: true,
                    label: strings.userManagement.panelText.Manage,
                    value: false,
                    bottomMargin: true,
                    leftMargin: true,
                    classes: "noWrap",
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "standardRole",
                    row: 1,
                    col: 2,
                    singleCell: true,
                    label: strings.userManagement.panelText.Standard,
                    value: false,
                    classes: "noWrap",
                    bottomMargin: true,
                    leftMargin: true,
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "monitorRole",
                    row: 1,
                    col: 3,
                    singleCell: true,
                    label: strings.userManagement.panelText.Monitor,
                    value: true,
                    disable: true,
                    classes: "noWrap",
                    bottomMargin: true,
                    leftMargin: true
                }), new LabelWidget({
                    name: "interfacesLabel",
                    value: strings.userManagement.panelText.Interfaces,
                    row: 2,
                    col: 0
                }), new CheckboxInputWidget({
                    name: "wbiCheckbox",
                    row: 2,
                    col: 1,
                    label: strings.userManagement.panelText.WBI,
                    value: false,
                    singleCell: true,
                    leftMargin: true,
                    classes: "noWrap",
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "cliCheckbox",
                    row: 2,
                    col: 2,
                    label: strings.userManagement.panelText.CLI,
                    value: false,
                    singleCell: true,
                    leftMargin: true,
                    classes: "noWrap",
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "ftpCheckbox",
                    row: 2,
                    col: 4,
                    label: strings.userManagement.panelText.FTP,
                    value: false,
                    singleCell: true,
                    leftMargin: true,
                    classes: "noWrap",
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "smisCheckbox",
                    row: 2,
                    col: 3,
                    label: strings.userManagement.panelText.SMIS,
                    value: false,
                    singleCell: true,
                    leftMargin: true,
                    classes: "noWrap",
                    changeCallback: D
                })]
            })]
        }), new LabeledWidgetContainer({
            name: "propsContainer",
            label: strings.userManagement.panelText.Preferences,
            widgets: [new TableWidget({
                name: "stdProps",
                widgets: [new ComboBoxWidget({
                    name: "base",
                    row: 0,
                    col: 0,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.baseLabel,
                    values: [{
                        value: "10",
                        text: strings.userManagement.panelText.base10
                    }, {
                        value: "2",
                        text: strings.userManagement.panelText.base2
                    }],
                    changeCallback: D
                }), new ComboBoxWidget({
                    name: "precision",
                    row: 1,
                    col: 0,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.precisionLabel,
                    values: [{
                        value: "1",
                        text: "1"
                    }, {
                        value: "2",
                        text: "2"
                    }, {
                        value: "3",
                        text: "3"
                    }, {
                        value: "4",
                        text: "4"
                    }, {
                        value: "5",
                        text: "5"
                    }, {
                        value: "6",
                        text: "6"
                    }, {
                        value: "7",
                        text: "7"
                    }, {
                        value: "8",
                        text: "8"
                    }, {
                        value: "9",
                        text: "9"
                    }, {
                        value: "10",
                        text: "10"
                    }],
                    changeCallback: D
                }), new ComboBoxWidget({
                    name: "units",
                    row: 2,
                    col: 0,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.unitsLabel,
                    values: [{
                        value: "Auto",
                        text: strings.auto
                    }, {
                        value: "TB",
                        text: "TB"
                    }, {
                        value: "GB",
                        text: "GB"
                    }, {
                        value: "MB",
                        text: "MB"
                    }],
                    changeCallback: D
                }), new ComboBoxWidget({
                    name: "temperature",
                    row: 0,
                    col: 2,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.temperatureLabel,
                    values: [{
                        value: "Celsius",
                        text: strings.celsius
                    }, {
                        value: "Fahrenheit",
                        text: strings.fahrenheit
                    }],
                    changeCallback: D
                }), new TextInputWidget({
                    name: "timeout",
                    row: 1,
                    col: 2,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.timeoutMinutes,
                    rules: {
                        isNumber: true,
                        range: [1, 720]
                    },
                    maxLength: 3,
                    size: 5,
                    changeCallback: D
                }), new ComboBoxWidget({
                    name: "locale",
                    row: 2,
                    col: 2,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.panelText.localeLabel,
                    changeCallback: D
                })]
            }), new TableWidget({
                name: "snmpProps",
                widgets: [new RadioButtonsInputWidget({
                    name: "snmpUserType",
                    row: 0,
                    col: 0,
                    singleCell: true,
                    colSpan: 3,
                    bottomMargin: true,
                    orientation: "horizontal",
                    label: strings.userManagement.snmp.userType,
                    values: [{
                        value: "U",
                        text: strings.userManagement.snmp.userAccess
                    }, {
                        value: "T",
                        text: strings.userManagement.snmp.target
                    }],
                    changeCallback: createObjectCallback(this, this.changeSnmpUserType)
                }), new ComboBoxWidget({
                    name: "authType",
                    row: 1,
                    col: 0,
                    singleCell: true,
                    rightMargin: true,
                    bottomMargin: true,
                    label: strings.userManagement.snmp.authType,
                    values: [{
                        value: "MD5",
                        text: "MD5"
                    }, {
                        value: "SHA",
                        text: "SHA"
                    }, {
                        value: "none",
                        text: strings.none
                    }],
                    changeCallback: createObjectCallback(this, this.changeAuthType)
                }), new ComboBoxWidget({
                    name: "privacyType",
                    row: 1,
                    col: 2,
                    singleCell: true,
                    bottomMargin: true,
                    label: strings.userManagement.snmp.privType,
                    values: [{
                        value: "none",
                        text: strings.none
                    }, {
                        value: "DES",
                        text: "DES"
                    }, {
                        value: "AES",
                        text: "AES"
                    }],
                    changeCallback: createObjectCallback(this, this.changePrivacyType)
                }), new TextInputWidget({
                    name: "privacyPassword",
                    row: 2,
                    col: 0,
                    singleCell: true,
                    rightMargin: true,
                    label: strings.userManagement.snmp.privPasswd,
                    password: true,
                    maxLength: 32,
                    size: 17,
                    rules: {
                        dhName: true,
                        utf8length: 32
                    },
                    changeCallback: D
                }), new TextInputWidget({
                    name: "trapHostAddress",
                    row: 2,
                    col: 2,
                    singleCell: true,
                    label: strings.userManagement.snmp.destination,
                    maxLength: 15,
                    size: 17,
                    messages: {
                        required: strings.userManagement.validation.trapHostAddressMsg,
                        ipv4Address: strings.userManagement.validation.trapHostAddressInvalidIp
                    },
                    changeCallback: D
                })]
            })]
        })]
    })];
    WidgetContainer.call(this, E);
    this.class_name = "LocalUsersWidget"
}
LocalUsersWidget.prototype = new WidgetContainer();
LocalUsersWidget.prototype.constructor = LocalUsersWidget;
LocalUsersWidget.prototype.showing = function() {
    if (isDellSystem()) {
        this.update({
            standardRole: {
                visibility: "collapse"
            }
        })
    }
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
LocalUsersWidget.prototype.loadData = function() {
    this.usersSubscription = MC.usersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            this.updateData()
        })
    })
};
LocalUsersWidget.prototype.hiding = function() {
    if (this.usersSubscription) {
        MC.usersSet.unregister(this.usersSubscription);
        delete this.usersSubscription
    }
};
LocalUsersWidget.prototype.updateData = function() {
    this.selectionCaller = "code";
    if (DC.users != undefined) {
        this.localUsersUpdated = true
    }
    var C = {};
    var E = "";
    if (DC.users[session.userName.value]) {
        var E = session.userName.value
    }
    var D = new DCRef("", this.usernameIntercept(E));
    if (DC.users[E] != undefined) {
        C = this._createDataObjectForUser(E)
    } else {
        C.snmpProps = {
            visibility: "hidden"
        };
        if (!(session.hasUserConfigCapability())) {
            C.btnNew = {
                disable: true,
                tooltip: strings.userManagement.panelText.tips.requiresManage
            };
            C.btnCopy = {
                disable: true,
                tooltip: strings.userManagement.panelText.tips.requiresManage
            };
            C.btnDelete = {
                disable: true,
                tooltip: strings.userManagement.panelText.tips.requiresManage
            }
        }
    }
    C.userListTable = {
        data: this._createUserlist(),
        select: D,
        selectable: ((session.hasUserConfigCapability()) ? "single" : false)
    };
    this.update(C);
    this.userListTable.pageToRow(D);
    delete this.selectionCaller
};
LocalUsersWidget.prototype._createDataObjectForUser = function(D) {
    var E = {};
    var G = DC.users[D];
    var H = session.hasManageRole();
    if (G) {
        var C = G.prop;
        var K = C.username.text;
        this.selectionCaller = "code";
        var I = this._createUserlist();
        delete this.selectionCaller;
        if (session.userName.value == K) {
            E.btnDelete = {
                disable: true
            }
        } else {
            E.btnDelete = {
                disable: false
            }
        }
        if (!(session.hasUserConfigCapability())) {
            E.btnCopy = {
                disable: true,
                tooltip: strings.userManagement.panelText.tips.requiresManage
            };
            E.btnNew = {
                disable: true,
                tooltip: strings.userManagement.panelText.tips.requiresManage
            }
        } else {
            if (I.length == 12) {
                E.btnCopy = {
                    disable: true,
                    tooltip: strings.userManagement.panelText.tips.maxUsers
                };
                E.btnNew = {
                    disable: true,
                    tooltip: strings.userManagement.panelText.tips.maxUsers
                }
            } else {
                E.btnCopy = {
                    disable: false
                };
                E.btnNew = {
                    disable: false
                }
            }
        }
        E.userTextbox = {
            value: K,
            disable: true,
            setOrig: true
        };
        E.passwordTextbox = {
            value: "",
            setOrig: true
        };
        E.passwordConfirm = {
            value: "",
            setOrig: true
        };
        if (RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && !decodeBooleanFlag(G.get("default_password_changed_numeric"))) {
            var J = $('label[for="passwordTextbox"]');
            var F = $('label[for="passwordConfirm"]');
            if (!J.find(".requiredIndicator").length > 0) {
                $('<span class="requiredIndicator">*</span>').appendTo(J)
            }
            if (!F.find(".requiredIndicator").length > 0) {
                $('<span class="requiredIndicator">*</span>').appendTo(F)
            }
        } else {
            E.passwordTextbox.rules = this.modifyPwdRules;
            E.passwordConfirm.rules = {
                equalTo: "#passwordTextbox"
            }
        }
        if (C.interface_access_SNMP.text != "") {
            E.accountNature = {
                disable: true,
                visibility: "hidden",
                value: "snmpNature"
            };
            E.rolesLabel = {
                visibility: "hidden"
            };
            E.manageRole = {
                disable: true,
                visibility: "hidden"
            };
            E.monitorRole = {
                disable: true,
                visibility: "hidden"
            };
            E.standardRole = {
                disable: true,
                visibility: "hidden"
            };
            E.interfacesLabel = {
                visibility: "hidden"
            };
            E.wbiCheckbox = {
                disable: true,
                visibility: "hidden"
            };
            E.cliCheckbox = {
                disable: true,
                visibility: "hidden"
            };
            E.smisCheckbox = {
                disable: true,
                visibility: "hidden"
            };
            E.ftpCheckbox = {
                disable: true,
                visibility: "hidden"
            };
            E.stdProps = {
                visibility: "hidden"
            };
            E.snmpProps = {
                visibility: "visible"
            };
            E.snmpUserType = {
                value: C.interface_access_SNMP.text,
                setOrig: true,
                disable: false
            };
            E.authType = {
                value: C.authentication_type.text,
                setOrig: true,
                disable: false
            };
            E.privacyType = {
                value: C.privacy_type.text,
                setOrig: true,
                disable: false
            };
            E.privacyPassword = {
                value: C.privacy_password.text,
                setOrig: true,
                disable: false,
                rules: {
                    required: false
                }
            };
            E.trapHostAddress = {
                value: (C.trap_destination.text != "" ? C.trap_destination.text : ""),
                setOrig: true,
                disable: false
            };
            E.userRoles = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.wbiCheckbox = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.cliCheckbox = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.smisCheckbox = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.ftpCheckbox = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.base = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.precision = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.units = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.temperature = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.timeout = {
                disable: true,
                value: "",
                unsetOrig: true
            };
            E.locale = {
                disable: true,
                value: "",
                unsetOrig: true
            }
        } else {
            E.rolesLabel = {
                visibility: "visible"
            };
            E.interfacesLabel = {
                visibility: "visible"
            };
            E.stdProps = {
                visibility: "visible"
            };
            E.snmpProps = {
                visibility: "hidden"
            };
            E.authType = {
                disable: true,
                unsetOrig: true
            };
            E.privacyType = {
                disable: true,
                unsetOrig: true
            };
            E.privacyPassword = {
                disable: true,
                unsetOrig: true
            };
            E.trapHostAddress = {
                disable: true,
                unsetOrig: true
            };
            E.standardAccountProps = {
                visibility: "visible"
            };
            E.accountNature = {
                disable: true,
                visibility: "hidden",
                value: "stdNature"
            };
            E.manageRole = {
                value: session.hasManageRole(D),
                setOrig: true,
                disable: (!H || session.userName.value == K),
                visibility: "visible"
            };
            if (session.userName.value == K) {
                E.manageRole.tooltip = strings.systemSettings.cannotRemoveManage
            } else {
                E.manageRole.tooltip = ""
            }
            E.monitorRole = {
                value: true,
                disable: true,
                visibility: "visible"
            };
            if (!isDellSystem() && !isDellBBSystem()) {
                E.standardRole = {
                    value: session.hasStandardRole(D),
                    setOrig: true,
                    disable: (session.userName.value == K),
                    visibility: "visible"
                }
            }
            E.wbiCheckbox = {
                value: (C.interface_access_WBI.text == "x"),
                setOrig: true,
                disable: !(session.hasUserConfigCapability()),
                visibility: "visible"
            };
            E.cliCheckbox = {
                value: (C.interface_access_CLI.text == "x"),
                setOrig: true,
                disable: !(session.hasUserConfigCapability()),
                visibility: "visible"
            };
            if (RI.hasFeature("smis")) {
                E.smisCheckbox = {
                    value: (C.interface_access_SMIS.text == "x"),
                    setOrig: true,
                    disable: !(session.hasUserConfigCapability()),
                    visibility: "visible"
                }
            } else {
                E.smisCheckbox = {
                    unsetOrig: true,
                    disable: true,
                    visibility: "hidden"
                }
            }
            E.ftpCheckbox = {
                value: (C.interface_access_FTP.text == "x"),
                setOrig: ((session.hasUserConfigCapability()) ? true : false),
                disable: !(session.hasUserConfigCapability()),
                visibility: "visible"
            };
            E.base = {
                value: C.storage_size_base.text,
                setOrig: true,
                disable: false
            };
            E.precision = {
                value: C.storage_size_precision.text,
                setOrig: true,
                disable: false
            };
            E.units = {
                value: C.storage_size_units.text,
                setOrig: true,
                disable: false
            };
            E.temperature = {
                value: C.temperature_scale.text,
                setOrig: true,
                disable: false
            };
            E.timeout = {
                value: Math.floor(parseInt(C.timeout.text, 10) / 60),
                setOrig: true,
                disable: false
            };
            E.locale = {
                values: this.localesValues,
                value: C.user_locale.text,
                setOrig: true,
                disable: false
            }
        }
    }
    if (!(session.hasUserConfigCapability())) {
        E.btnNew = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.requiresManage
        };
        E.btnCopy = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.requiresManage
        };
        E.btnDelete = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.requiresManage
        }
    }
    this.userEntered = true;
    return E
};
LocalUsersWidget.prototype.changedCallback = function(L, J, K) {
    var G = this.getUserName();
    if (J.name == "passwordTextbox" && K && K.type == "focusout" && DC.users[G] && !decodeBooleanFlag(DC.users[G].get("default_password_changed_numeric")) && RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && L[J.name].value == "") {
        var M = this.createPwdRules;
        this.update({
            passwordTextbox: {
                rules: M
            }
        })
    } else {
        if (this.state == "creating" && J.name == "passwordTextbox" && K && K.type == "focusout") {
            var M = this.createPwdRules;
            this.update({
                passwordTextbox: {
                    rules: M
                }
            })
        }
    }
    if (J.name == "passwordConfirm" && K && K.type == "focusout" && DC.users[G] && !decodeBooleanFlag(DC.users[G].get("default_password_changed_numeric")) && RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && L[J.name].value == "") {
        var E = {
            equalTo: "#passwordTextbox",
            required: true
        };
        this.update({
            passwordConfirm: {
                rules: E
            }
        })
    }
    if (this.state == "finishing") {
        this.changedWidgets = {};
        this.valueChanged = false;
        this.state = "viewing"
    }
    if (typeof L != "undefined") {
        if (L[J.name].valueChanged) {
            if (!this.changedWidgets[J.name]) {
                this.valueChanged = true;
                this.changedWidgets[J.name] = true;
                this.currentlyModifiedUser = this.getUserName()
            }
        } else {
            if (this.changedWidgets[J.name]) {
                delete this.changedWidgets[J.name];
                this.valueChanged = false;
                for (var C in this.changedWidgets) {
                    this.valueChanged = true;
                    break
                }
            }
        }
    }
    var H = {};
    var F = {};
    this.retrieve(F);
    var I = false;
    if ($.isFunction(this.options.changeCallback) && this.name) {
        if (!H[this.name]) {
            H[this.name] = {}
        }
        if (session.hasUserConfigCapability()) {
            if (J.name == "passwordConfirm") {
                if ((!F.userTextbox.invalid && F.userTextbox.value != "") && (!F.passwordTextbox.invalid && F.passwordTextbox.value != "") && (!F.passwordConfirm.invalid && F.passwordConfirm.value != "")) {
                    I = true
                }
                H[this.name].valueChanged = this.valueChanged;
                if (!I) {
                    H[this.name].valueChanged = false
                }
                this.options.changeCallback(H, this, K)
            } else {
                if ((J.name != "userTextbox" && J.name != "passwordTextbox")) {
                    H[this.name].valueChanged = this.valueChanged;
                    this.options.changeCallback(H, this, K)
                }
            }
        } else {
            if (session.hasMonitorRole()) {
                this.valueChanged = false;
                var D = this.userListTable.selected[0].key;
                if (this.userListTable.dataTable.oApi._fnDetectType(D) === "html") {
                    D = $.parseHTML(D)[0].data
                }
                if (D == session.getCurrentUser()) {
                    if (J.name == "passwordConfirm") {
                        if ((!F.userTextbox.invalid && F.userTextbox.value != "") && (!F.passwordTextbox.invalid && F.passwordTextbox.value != "") && (!F.passwordConfirm.invalid && F.passwordConfirm.value != "")) {
                            I = true
                        }
                    }
                    if (I || (F.precision.valueChanged || F.temperature.valueChanged || F.base.valueChanged || F.timeout.valueChanged || F.units.valueChanged || F.locale.valueChanged)) {
                        this.valueChanged = true
                    }
                }
                if (!H[this.name]) {
                    H[this.name] = {}
                }
                H[this.name].valueChanged = this.valueChanged;
                this.options.changeCallback(H, this, K)
            }
        }
    }
    if (this.state == "modified") {
        if (!this.valueChanged) {
            this.state = "viewing";
            if (this.currentlyModifiedUser) {
                delete this.currentlyModifedUser
            }
        }
    } else {
        if (this.state != "copying" && this.state != "creating") {
            if (this.valueChanged) {
                this.state = "modified"
            } else {
                this.state = "viewing";
                if (this.currentlyModifiedUser) {
                    delete this.currentlyModifedUser
                }
            }
        }
    }
};
LocalUsersWidget.prototype._createUserlist = function() {
    var D = DC.base.users;
    var G = [];
    for (user in D) {
        var E = D[user].get("roles").split(",");
        var F = E.find("admin");
        if (F != -1) {
            E.splice(F, 1)
        }
        var C = E.find(strings.userManagement.panelText.diagnostic);
        if (C != -1) {
            E.splice(C, 1)
        }
        var H = E.find("engineering");
        if (H != -1) {
            E.splice(H, 1)
        }
        G.push([D[user].prop.username.text, (D[user].prop.interface_access_SNMP.text == "" ? strings.userManagement.panelText.Standard : strings.userManagement.panelText.SNMPv3), E.join()])
    }
    return G
};
LocalUsersWidget.prototype.usernameIntercept = function(D) {
    var E = null;
    if (D.aData === undefined) {
        E = D
    } else {
        E = D.aData[0]
    }
    if (DC.users[E]) {
        var C = decodeBooleanFlag(DC.users[E].get("default_password_changed_numeric"));
        if (RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && !C) {
            E = E + '<span class="requiredIndicator">*</span>'
        }
    }
    return E
};
LocalUsersWidget.prototype._addNewUser = function(E) {
    var C = E || strings.userManagement.panelText.newUser;
    var D = this._createUserlist();
    D.push([C, "", ""]);
    return D
};
LocalUsersWidget.prototype.deleteClicked = function() {
    var C = {};
    this.retrieve(C, true);
    var D = this.getUserName();
    if (DC.users[D] && D == session.userName.value) {
        ShowActiveDialog({
            type: "error",
            dialogOverride: true,
            message: strings.userManagement.deleteuser.message
        })
    } else {
        MC.deleteSystemUser({
            username: D
        }, {
            dialog: true,
            confirmMsg: strings.userManagement.deleteuser.confirmMsg(D),
            processingMsg: strings.userManagement.deleteuser.processingMsg(D),
            failureMsg: strings.userManagement.deleteuser.error(D),
            successMsg: strings.userManagement.deleteuser.success(D),
            okLabel: strings.okButtonText,
            cancelLabel: strings.cancelButtonText,
            callback: createObjectCallback(this, this._userDeleted)
        })
    }
};
LocalUsersWidget.prototype._userDeleted = function(C) {
    if (C.success) {
        if (DC.users[session.userName.value] != undefined) {
            var D = this._createDataObjectForUser(session.userName.value);
            var E = new DCRef("", this.usernameIntercept(session.userName.value));
            D.userListTable = {
                data: this._createUserlist(),
                select: E,
                selectable: ((session.hasUserConfigCapability()) ? "single" : false)
            };
            this.update(D);
            this.userListTable.pageToRow(E)
        }
        this.state = "viewing";
        this.valueChanged = false
    }
};
LocalUsersWidget.prototype.newClicked = function() {
    if (this.state == "modified" || this.state == "copying") {
        this._handleAbandonment("creating")
    } else {
        this.state = "creating";
        this._createNewUser()
    }
};
LocalUsersWidget.prototype._createNewUser = function() {
    this.state = "creating";
    this.currentlyModifiedUser = strings.userManagement.panelText.newUser;
    var C = {};
    var D = this._addNewUser();
    C.userListTable = {
        data: D,
        select: new DCRef("", strings.userManagement.panelText.newUser)
    };
    C.userTextbox = {
        value: "",
        disable: false,
        setOrig: true,
        focus: true,
        skipValidation: true
    };
    this.userEntered = false;
    C.passwordTextbox = {
        value: "",
        setOrig: true
    };
    C.passwordConfirm = {
        value: "",
        disable: false
    };
    C.btnNew = {
        disable: true
    };
    C.btnCopy = {
        disable: true
    };
    C.btnDelete = {
        disable: true
    };
    C.accountNature = {
        value: "stdNature",
        disable: false,
        visibility: "visible"
    };
    C.manageRole = {
        value: false,
        setOrig: true,
        disable: false
    };
    C.monitorRole = {
        value: true,
        setOrig: true,
        disable: false
    };
    C.standardRole = {
        value: false,
        setOrig: true,
        disable: false
    };
    C.wbiCheckbox = {
        value: true,
        setOrig: true
    };
    C.cliCheckbox = {
        value: true,
        setOrig: true
    };
    if (RI.hasFeature("smis")) {
        C.smisCheckbox = {
            value: false,
            setOrig: true
        }
    } else {
        C.smisCheckbox = {
            disable: true,
            visibility: "hidden",
            value: false,
            unsetOrig: true
        }
    }
    C.ftpCheckbox = {
        value: false,
        setOrig: true
    };
    C.base = {
        value: "10",
        setOrig: true,
        disable: false
    };
    C.precision = {
        value: "1",
        setOrig: true,
        disable: false
    };
    C.units = {
        value: "Auto",
        setOrig: true,
        disable: false
    };
    C.temperature = {
        value: "Celsius",
        text: " ",
        setOrig: true,
        disable: false
    };
    C.timeout = {
        value: "30",
        setOrig: true,
        disable: false
    };
    C.locale = {
        values: this.localesValues,
        value: "English",
        setOrig: true,
        disable: false
    };
    C.btnSave = {
        disable: false,
        setOrig: true
    };
    C.btnCancel = {
        disable: false,
        setOrig: true
    };
    C.snmpUserType = {
        disable: false,
        value: "U",
        setOrig: true
    };
    C.authType = {
        disable: false,
        value: "MD5",
        setOrig: true
    };
    C.privacyType = {
        disable: false,
        value: "none",
        setOrig: true
    };
    C.privacyPassword = {
        disable: false,
        value: "",
        setOrig: true
    };
    C.trapHostAddress = {
        disable: false,
        value: "",
        setOrig: true
    };
    this.selectionCaller = "code";
    this.update(C);
    delete this.selectionCaller
};
LocalUsersWidget.prototype.copyClicked = function() {
    if (this.state == "modified" || this.state == "creating") {
        this._handleAbandonment("copying")
    } else {
        this.state = "copying";
        this._copyUser()
    }
};
LocalUsersWidget.prototype._copyUser = function() {
    this.currentlyModifiedUser = "NewUser";
    var C = {};
    var E = {};
    this.retrieve(C, true);
    var D = this.getUserName();
    E = this._createDataObjectForUser(D);
    var F = this._addNewUser(strings.userManagement.panelText.copyOf(D));
    E.userListTable = {
        data: F,
        select: new DCRef("", strings.userManagement.panelText.copyOf(D))
    };
    E.userTextbox = {
        value: strings.userManagement.panelText.copyOf(D),
        disable: false,
        setOrig: true,
        focus: true,
        rules: {
            required: true,
            dhName: true,
            utf8length: 29,
            userExists: true,
            noBannedUsers: true
        },
        messages: {
            required: strings.userManagement.validation.usernameError
        }
    };
    this.userEntered = false;
    E.passwordTextbox = {
        value: "",
        setOrig: true,
        rules: this.createPwdRules,
        skipValidation: true,
        messages: {
            required: strings.userManagement.validation.noEmptyPassword,
            utf8length: strings.userManagement.validation.passwordLength
        }
    };
    E.passwordConfirm = {
        skipValidation: true
    };
    E.manageRole = {
        disable: false
    };
    E.monitorRole = {
        disable: false
    };
    E.standardRole = {
        disable: false
    };
    E.btnNew = {
        disable: true
    };
    E.btnCopy = {
        disable: true
    };
    E.btnDelete = {
        disable: true
    };
    this.selectionCaller = "code";
    this.update(E);
    delete this.selectionCaller
};
LocalUsersWidget.prototype.getCommandQueue = function() {
    var G = {};
    this.retrieve(G);
    var C = this._getInterfaceList({
        ftp: G.ftpCheckbox.value,
        smis: G.smisCheckbox.value,
        wbi: G.wbiCheckbox.value,
        cli: G.cliCheckbox.value
    });
    var F = {};
    var E = [];
    var D = [];
    if (G.passwordTextbox.valueChanged) {
        F.password = G.passwordTextbox.value
    }
    if (G.accountNature.value != undefined && G.accountNature.value != "snmpNature") {
        if (G.manageRole.valueChanged || G.standardRole.valueChanged || (this.state == "creating" || this.state == "copying")) {
            if (G.manageRole.value) {
                E.push("manage")
            }
            if (G.monitorRole.value) {
                E.push("monitor")
            }
            if (G.standardRole.value) {
                E.push("standard")
            }
        }
        F.roles = E;
        if (G.wbiCheckbox.valueChanged || G.cliCheckbox.valueChanged || G.smisCheckbox.valueChanged || G.ftpCheckbox.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.interfaces = C
        }
        if (G.precision.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.precision = G.precision.value
        }
        if (G.units.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.units = G.units.value
        }
        if (G.base.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.base = G.base.value
        }
        if (G.temperature.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.temperatureScale = G.temperature.value
        }
        if (G.timeout.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.timeout = G.timeout.value * 60
        }
        if (G.locale.valueChanged || (this.state == "creating" || this.state == "copying")) {
            F.locale = G.locale.value
        }
    } else {
        if (G.accountNature.value != undefined && G.accountNature.value == "snmpNature") {
            F.doSnmp = G.snmpUserType.value;
            if (G.authType.valueChanged || (this.state == "creating" || this.state == "copying")) {
                F.authentication = G.authType.value;
                if (G.authType.value != "none") {
                    F.password = G.passwordTextbox.value
                }
                if (G.snmpUserType.value == "T") {
                    F.destination = G.trapHostAddress.value
                }
            }
            if (G.privacyType.valueChanged || (this.state == "creating" || this.state == "copying")) {
                F.encryption = G.privacyType.value;
                if (G.privacyType.value != "none") {
                    F.authentication = G.authType.value;
                    F.privacyPwdInput = G.privacyPassword.value
                }
            }
            if (G.privacyPassword.valueChanged || (this.state == "creating" || this.state == "copying")) {
                F.privacyPwdInput = G.privacyPassword.value
            }
            if (G.trapHostAddress.valueChanged || (this.state == "creating" || this.state == "copying")) {
                F.destination = G.trapHostAddress.value
            }
            if (F.doSnmp !== null && (this.state == "creating" || this.state == "copying" || G.snmpUserType.valueChanged)) {
                F.snmp_user_or_target = (G.snmpUserType.value == "U" ? "user" : "target")
            }
        }
    }
    if (this.state == "creating" || this.state == "copying") {
        F.username = G.userTextbox.value;
        D.push({
            name: "createUser",
            command: MC.createSystemUser,
            data: F,
            options: {
                processingMsg: strings.userManagement.create.processingMsg,
                failureMsg: strings.userManagement.create.error,
                successMsg: strings.userManagement.create.success,
                callback: createObjectCallback(this, this._saveUserCallback, F.username)
            }
        })
    } else {
        if (this.state == "modified") {
            F.username = this.getUserName();
            D.push({
                name: "modifyUser",
                command: MC.modifySystemUser,
                data: F,
                options: {
                    processingMsg: strings.userManagement.modify.processingMsg,
                    failureMsg: strings.userManagement.modify.error,
                    successMsg: strings.userManagement.modify.success,
                    callback: createObjectCallback(this, this._saveUserCallback, F.username)
                }
            })
        }
    }
    return D
};
LocalUsersWidget.prototype._userListUpdate = function(D) {
    if (settings.memorex) {
        D = session.userName.value
    }
    var C = this._createDataObjectForUser(D);
    C.userListTable = {
        data: this._createUserlist(),
        select: new DCRef("", D),
        selectable: ((session.hasUserConfigCapability()) ? "single" : false)
    };
    C.userTextbox.rules = {};
    C.passwordTextbox = {
        value: "",
        rules: {}
    };
    this.state = "finishing";
    this.selectionCaller = "code";
    this.update(C);
    this.userListTable.pageToRow(new DCRef("", D));
    delete this.selectionCaller;
    this.changedWidgets = {};
    this.valueChanged = false
};
LocalUsersWidget.prototype._saveUserCallback = function(D, C) {
    if (C.success) {
        setTimeout(createObjectCallback(this, this._userListUpdate, D), 1000)
    }
};
LocalUsersWidget.prototype._handleAbandonment = function(C) {
    var D = "";
    if (C == "userChanged") {
        D = createObjectCallback(this, this._selectAbandon, this.getUserName())
    } else {
        D = createObjectCallback(this, this._selectAbandon, C)
    }
    ShowActiveDialog({
        type: "confirm",
        message: strings.userManagement.panelText.navigateAway,
        okLabel: strings.Yes,
        cancelLabel: strings.No,
        ok: D,
        cancel: createObjectCallback(this, this._selectRevert)
    })
};
LocalUsersWidget.prototype._selectRevert = function() {
    if (this.currentlyModifiedUser == "NewUser") {
        var C = {};
        this.retrieve(C, true);
        delete C.userListTable;
        C.userListTable = {
            select: new DCRef("", this.currentlyModifiedUser)
        };
        C.userTextbox.focus = true;
        this.selectionCaller = "code";
        this.update(C);
        delete this.selectionCaller
    } else {
        this.selectionCaller = "code";
        this.update({
            userListTable: {
                select: new DCRef("", this.usernameIntercept(this.currentlyModifiedUser))
            }
        });
        delete this.selectionCaller
    }
};
LocalUsersWidget.prototype._selectAbandon = function(D) {
    if (D == "creating") {
        this.state = "creating";
        this._createNewUser()
    } else {
        if (D == "copying") {
            this.state = "copying";
            this._copyUser()
        } else {
            this._userListUpdate(D);
            this.update({
                btnNew: {
                    disable: false
                },
                btnCopy: {
                    disable: false
                },
                btnDelete: {
                    disable: false
                }
            });
            this.state = "viewing";
            delete this.currentlyModifiedUser
        }
    }
    var C = {};
    C[this.name] = {};
    C[this.name].valueChanged = false;
    this.options.changeCallback(C, this);
    return true
};
LocalUsersWidget.prototype._userSelected = function(C) {
    if (this.selectionCaller == "code") {
        return
    }
    if (this.state == "modified" || this.state == "copying" || this.state == "creating") {
        this._handleAbandonment("userChanged")
    } else {
        var E = this.getUserName();
        var D = this._createDataObjectForUser(E);
        this.update(D)
    }
};
LocalUsersWidget.prototype.manageClicked = function(F, D, E) {
    if (this.state == "viewing" && (this.state != "copying" && this.state != "creating")) {
        this.state = "modified"
    }
    var C = {};
    if (F.userRoles.value.length == 1 && F.userRoles.value[0] == "manage") {
        C = {
            userRoles: {
                value: ["manage", "monitor"]
            }
        }
    }
    this.update(C);
    this.changedCallback(F, D, E)
};
LocalUsersWidget.prototype._getInterfaceList = function(E) {
    var C = "";
    for (var D in E) {
        if (E[D] == true) {
            C += D + ","
        }
    }
    C.replace(/[,]$/g, "");
    if (C.length == 0) {
        return "none"
    } else {
        return C.replace(/[,]$/g, "")
    }
};
LocalUsersWidget.prototype.accountNatureChanged = function(F, D, E) {
    var C = {};
    if (F.accountNature.value == "snmpNature") {
        C = {
            snmpProps: {
                visibility: "visible"
            },
            stdProps: {
                visibility: "hidden"
            },
            rolesLabel: {
                visibility: "hidden"
            },
            manageRole: {
                disable: true,
                visibility: "hidden"
            },
            monitorRole: {
                visibility: "hidden"
            },
            standardRole: {
                visibility: "hidden"
            },
            interfacesLabel: {
                visibility: "hidden"
            },
            wbiCheckbox: {
                disable: true,
                visibility: "hidden"
            },
            cliCheckbox: {
                disable: true,
                visibility: "hidden"
            },
            smisCheckbox: {
                disable: true,
                visibility: "hidden"
            },
            ftpCheckbox: {
                disable: true,
                visibility: "hidden"
            }
        }
    } else {
        C = {
            snmpProps: {
                visibility: "hidden"
            },
            stdProps: {
                visibility: "visible"
            },
            rolesLabel: {
                visibility: "visible"
            },
            manageRole: {
                disable: false,
                visibility: "visible"
            },
            monitorRole: {
                visibility: "visible"
            },
            interfacesLabel: {
                visibility: "visible"
            },
            wbiCheckbox: {
                disable: false,
                visibility: "visible"
            },
            cliCheckbox: {
                disable: false,
                visibility: "visible"
            },
            ftpCheckbox: {
                disable: false,
                visibility: "visible"
            }
        };
        if (!isDellSystem() && !isDellBBSystem()) {
            C.standardRole = {
                visibility: "visible"
            }
        }
        if (RI.hasFeature("smis")) {
            C.smisCheckbox = {
                disable: false,
                visibility: "visible"
            }
        }
    }
    this.update(C)
};
LocalUsersWidget.prototype.changeSnmpUserType = function(F, D, E) {
    var C = {};
    if (F.snmpUserType.value == "T") {
        C.trapHostAddress = {
            rules: {
                required: true,
                ipv4Address: true
            },
            skipValidation: true
        }
    } else {
        C.trapHostAddress = {
            value: "",
            rules: {
                required: false,
                ipv4Address: false
            }
        }
    }
    this.update(C);
    this.changedCallback(F, D, E)
};
LocalUsersWidget.prototype.changePrivacyType = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    var C = {};
    if (G.privacyType.value != "none" && G.privacyType.valueChanged) {
        if (typeof D.privacyPassword != "undefined") {
            if (D.privacyPassword.value == "********" || D.privacyPassword.value == "") {
                C.privacyPassword = {
                    value: "",
                    rules: {
                        required: true,
                        dhName: true,
                        utf8length: 32
                    },
                    messages: {
                        required: strings.userManagement.validation.noEmptyPrivacyPassword,
                        utf8length: strings.userManagement.validation.passwordLength
                    }
                }
            }
        }
        if (typeof D.passwordTextbox != "undefined") {
            if (D.passwordTextbox.value == "********" || D.passwordTextbox.value == "") {
                C.passwordTextbox = {
                    value: "",
                    rules: this.createPwdRules,
                    messages: {
                        required: strings.userManagement.validation.noEmptyPasswordPrivacy
                    }
                }
            }
        }
    } else {
        C.privacyPassword = {
            rules: {
                required: false
            }
        };
        C.passwordTextbox = {
            rules: {}
        }
    }
    this.update(C);
    this.changedCallback(G, E, F)
};
LocalUsersWidget.prototype.changeAuthType = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    var C = {};
    if (G.authType.value != "none" && G.authType.valueChanged) {
        if (typeof D.passwordTextbox != "undefined") {
            if (D.passwordTextbox.value == "********" || D.passwordTextbox.value == "") {
                C.passwordTextbox = {
                    value: "",
                    rules: this.createPwdRules,
                    messages: {
                        required: strings.userManagement.validation.noEmptyPasswordAuth
                    }
                }
            }
        }
    } else {
        C.passwordTextbox = {
            rules: {}
        }
    }
    this.update(C);
    this.changedCallback(G, E, F)
};
LocalUsersWidget.prototype._usernameChanged = function(F, D, E) {
    if (F[D.name].value) {
        this.userEntered = true;
        if (this.state == "copying" || this.state == "creating") {
            this.userListTable.updateData(F[D.name].value, this.userListTable.getData().length - 1, 0)
        }
    } else {
        this.userEntered = false
    }
    if (E != undefined && E.type == "focusout") {
        var C = {};
        C.userTextbox = {
            rules: {
                required: true,
                dhUserName: true,
                utf8length: 29,
                userExists: true,
                noBannedUsers: true
            },
            messages: {
                required: strings.userManagement.validation.usernameError
            }
        };
        this.update(C);
        this.changedCallback(F, D, E)
    }
};
LocalUsersWidget.prototype.getConfirmMsg = function() {
    var G = "";
    var E = {};
    this.retrieve(E);
    if (this.state == "creating" || this.state == "copying") {
        G += strings.systemSettings.creatingNewUser + E.userTextbox.value + "<br>";
        if (E.accountNature.value == "snmpNature") {
            G += strings.userManagement.panelText.UserType + ": " + strings.userManagement.panelText.SNMPv3 + "<br>"
        } else {
            G += strings.userManagement.panelText.UserType + ": " + strings.userManagement.panelText.Standard + "<br>"
        }
    } else {
        if (this.state == "modified") {
            G += strings.systemSettings.modifyingUser + this.getUserName() + "<br>"
        }
    }
    if (E.passwordTextbox.valueChanged) {
        G += strings.Password + ": " + strings.Set + "<br>"
    }
    if (E.accountNature.value != "snmpNature") {
        if (E.manageRole.valueChanged || (this.state == "creating" || this.state == "copying")) {
            if (E.manageRole.value) {
                G += strings.userManagement.panelText.Roles + ": manage,monitor<br>"
            } else {
                G += strings.userManagement.panelText.Roles + ": monitor<br>"
            }
        }
        if (E.wbiCheckbox.valueChanged || E.cliCheckbox.valueChanged || E.smisCheckbox.valueChanged || E.ftpCheckbox.valueChanged || (this.state == "creating" || this.state == "copying")) {
            var D = "";
            if (E.wbiCheckbox.value) {
                D = "WBI"
            }
            if (E.cliCheckbox.value) {
                D += (D == "" ? "CLI" : ", CLI")
            }
            if (E.smisCheckbox.value) {
                D += (D == "" ? "SMIS" : ", SMIS")
            }
            if (E.ftpCheckbox.value) {
                D += (D == "" ? "FTP" : ", FTP")
            }
            G += strings.userManagement.panelText.Interfaces + ": " + D + "<br>"
        }
        if (E.precision.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.precisionLabel + ": " + E.precision.value + "<br>"
        }
        if (E.units.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.unitsLabel + ": " + E.units.value + "<br>"
        }
        if (E.base.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.baseLabel + ": " + E.base.value + "<br>"
        }
        if (E.temperature.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.temperatureLabel + ": " + E.temperature.value + "<br>"
        }
        if (E.timeout.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.timeoutMinutes + ": " + E.timeout.value + "<br>"
        }
        if (E.locale.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.panelText.localeLabel + ": " + E.locale.value + "<br>"
        }
    } else {
        if (this.state == "creating" || this.state == "copying" || E.snmpUserType.valueChanged) {
            var F = (E.snmpUserType.value == "U" ? strings.userManagement.snmp.userAccess : strings.userManagement.snmp.target);
            G += strings.userManagement.snmp.userType + ": " + F + "<br>"
        }
        if (E.authType.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.snmp.authType + ": " + E.authType.value + "<br>"
        }
        if (E.privacyType.valueChanged || (this.state == "creating" || this.state == "copying")) {
            var C = (E.privacyType.value == "none" ? strings.None : E.privacyType.value);
            G += strings.userManagement.snmp.privType + ": " + C + "<br>"
        }
        if (E.privacyPassword.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.snmp.privPasswd + ": " + strings.Set + "<br>"
        }
        if (E.trapHostAddress.valueChanged || (this.state == "creating" || this.state == "copying")) {
            G += strings.userManagement.snmp.destination + ": " + E.trapHostAddress.value
        }
    }
    return G
};
LocalUsersWidget.prototype.getUserName = function() {
    var C = this.userListTable.selected[0].key;
    if (this.userListTable.dataTable.oApi._fnDetectType(C) === "html") {
        return $.parseHTML(C)[0].data
    } else {
        return C
    }
};

function LdapUsersWidget(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "LdapUsersWidget";
    this.ldapUserGroupsUpdated = false;
    this.ldapParamsUpdated = false;
    var D = createObjectCallback(this, this.changedCallback);
    this.localesList = session.getSupportedLocales();
    this.changedWidgets = {};
    this.localesValues = [];
    this.changedWidgets = {};
    this.valueChanged = false;
    this.userGroupChanged = false;
    for (var C = 0; C < this.localesList.length; C++) {
        this.localesValues.push({
            value: this.localesList[C].locale,
            text: this.localesList[C].translated
        })
    }
    E.widgets = [new CheckboxContainer({
        name: "enableLDAP",
        label: strings.userManagement.panelText.enableLDAP,
        changeCallback: createObjectCallback(this, this.changeLDAP),
        widgets: [new TableWidget({
            name: "ldapSettings",
            widgets: [new TextInputWidget({
                name: "ldapServer",
                id: "ldapServer",
                label: strings.userManagement.panelText.ldapServer,
                topMargin: true,
                bottomMargin: true,
                rightMargin: true,
                row: 1,
                col: 1,
                singleCell: true,
                changeCallback: createObjectCallback(this, this.ldapSettingsChange)
            }), new TextInputWidget({
                name: "ldapAltServer",
                id: "ldapAltServer",
                label: strings.userManagement.panelText.ldapAltServer,
                topMargin: true,
                bottomMargin: true,
                rightMargin: true,
                row: 1,
                col: 4,
                singleCell: true,
                changeCallback: createObjectCallback(this, this.ldapSettingsChange)
            }), new TextInputWidget({
                name: "ldapPort",
                label: strings.userManagement.panelText.ldapPort,
                bottomMargin: true,
                rightMargin: true,
                row: 2,
                col: 1,
                singleCell: true,
                changeCallback: createObjectCallback(this, this.ldapSettingsChange)
            }), new TextInputWidget({
                name: "ldapAltPort",
                label: strings.userManagement.panelText.ldapAltPort,
                bottomMargin: true,
                rightMargin: true,
                row: 2,
                col: 4,
                singleCell: true,
                changeCallback: createObjectCallback(this, this.ldapSettingsChange)
            }), new TextInputWidget({
                name: "ldapSearchBase",
                label: strings.userManagement.panelText.ldapSearchBase,
                rightMargin: true,
                size: 30,
                row: 3,
                col: 1,
                singleCell: true,
                changeCallback: createObjectCallback(this, this.ldapSettingsChange)
            })]
        })]
    }), new TextWidget({
        name: "currentUserGroup",
        text: strings.userManagement.panelText.currentUserGroup,
        topMargin: true
    }), this.userGroupTable = new TableInator({
        name: "userGroupTable",
        selectable: "single",
        width: 640,
        type: "rawData",
        metadata: [{
            sTitle: strings.userManagement.panelText.UserGroup,
            bIsKey: true
        }, {
            sTitle: strings.userManagement.panelText.Roles,
            bSortable: false
        }, {
            sTitle: strings.userManagement.panelText.Interfaces,
            bSortable: false
        }],
        dtOptions: {
            bFilter: false,
            bLengthChange: false,
            bInfo: false,
            bPaginate: true,
            iDisplayLength: 5
        },
        intercepts: [{
            selector: 0,
            renderer: this.usernameIntercept
        }],
        bottomMediumMargin: true,
        selectCallback: createObjectCallback(this, this._userGroupSelected)
    }), new WidgetContainer({
        widgets: [new ButtonContainer({
            name: "groupActionButtons",
            orientation: "horizontal",
            alignment: "right",
            widgets: [new ButtonWidget({
                name: "btnNewGroup",
                size: "small",
                text: strings.userManagement.panelText.newLabel,
                tip: strings.userManagement.panelText.tips.btnNewGroup,
                click: createObjectCallback(this, this._createNewUserGroup)
            }), new ButtonWidget({
                name: "btnDeleteGroup",
                size: "small",
                text: strings.userManagement.panelText.deleteLabel,
                tip: strings.userManagement.panelText.tips.btnDelete,
                click: createObjectCallback(this, this.deleteGroupClicked)
            })]
        }), new WidgetContainer({
            classes: "clearFloats"
        })]
    }), this.newUserGroupWidget = new TableWidget({
        name: "middleTableLDAP",
        bottomMargin: true,
        widgets: [new TextInputWidget({
            name: "userGroupText",
            row: 0,
            col: 1,
            singleCell: true,
            label: strings.userManagement.panelText.UserGroup,
            labelOptions: {
                rightMargin: true,
                col: 0,
                classes: "noWrap"
            },
            rightMargin: true,
            bottomMargin: true,
            changeCallback: createObjectCallback(this, this._userGroupChanged)
        }), new TableWidget({
            name: "typeAndRolesLDAP",
            row: 0,
            col: 2,
            leftMargin: true,
            bottomMargin: true,
            widgets: [new TextWidget({
                name: "accountNatureLDAP",
                bottomMargin: true,
                row: 0,
                col: 0,
                label: strings.userManagement.panelText.UserType,
                disable: true,
                classes: "noWrap",
                value: strings.userManagement.panelText.Standard
            }), new LabelWidget({
                name: "rolesLabelLDAP",
                value: strings.userManagement.panelText.Roles,
                row: 1,
                col: 0,
                bottomMargin: true
            }), new CheckboxInputWidget({
                name: "manageRoleLDAP",
                row: 1,
                col: 1,
                singleCell: true,
                label: strings.userManagement.panelText.Manage,
                value: false,
                setOrig: true,
                bottomMargin: true,
                leftMargin: true,
                classes: "noWrap",
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new CheckboxInputWidget({
                name: "monitorRoleLDAP",
                row: 1,
                col: 2,
                singleCell: true,
                label: strings.userManagement.panelText.Monitor,
                value: false,
                setOrig: true,
                disable: true,
                classes: "noWrap",
                bottomMargin: true,
                leftMargin: true,
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new CheckboxInputWidget({
                name: "standardRoleLDAP",
                row: 1,
                col: 3,
                singleCell: true,
                label: strings.userManagement.panelText.Standard,
                value: false,
                setOrig: true,
                disable: true,
                classes: "noWrap",
                bottomMargin: true,
                leftMargin: true,
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new LabelWidget({
                name: "interfacesLabelLDAP",
                value: strings.userManagement.panelText.Interfaces,
                row: 2,
                col: 0
            }), new CheckboxInputWidget({
                name: "wbiCheckboxLDAP",
                row: 2,
                col: 1,
                label: strings.userManagement.panelText.WBI,
                value: false,
                singleCell: true,
                leftMargin: true,
                classes: "noWrap",
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new CheckboxInputWidget({
                name: "cliCheckboxLDAP",
                row: 2,
                col: 2,
                label: strings.userManagement.panelText.CLI,
                value: false,
                singleCell: true,
                leftMargin: true,
                classes: "noWrap",
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new CheckboxInputWidget({
                name: "ftpCheckboxLDAP",
                row: 2,
                col: 3,
                label: strings.userManagement.panelText.FTP,
                value: false,
                singleCell: true,
                leftMargin: true,
                classes: "noWrap",
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new CheckboxInputWidget({
                name: "smisCheckboxLDAP",
                row: 2,
                col: 4,
                label: strings.userManagement.panelText.SMIS,
                value: false,
                singleCell: true,
                leftMargin: true,
                classes: "noWrap",
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            })]
        })]
    }), new LabeledWidgetContainer({
        name: "ldapPeferencesContainer",
        label: strings.userManagement.panelText.Preferences,
        topMargin: true,
        bottomMargin: true,
        widgets: [new TableWidget({
            name: "stdPropsLDAP",
            widgets: [new ComboBoxWidget({
                name: "baseLDAP",
                row: 0,
                col: 0,
                singleCell: true,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.baseLabel,
                values: [{
                    value: "10",
                    text: strings.userManagement.panelText.base10
                }, {
                    value: "2",
                    text: strings.userManagement.panelText.base2
                }],
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new ComboBoxWidget({
                name: "precisionLDAP",
                row: 1,
                col: 0,
                singleCell: true,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.precisionLabel,
                values: [{
                    value: "1",
                    text: "1"
                }, {
                    value: "2",
                    text: "2"
                }, {
                    value: "3",
                    text: "3"
                }, {
                    value: "4",
                    text: "4"
                }, {
                    value: "5",
                    text: "5"
                }, {
                    value: "6",
                    text: "6"
                }, {
                    value: "7",
                    text: "7"
                }, {
                    value: "8",
                    text: "8"
                }, {
                    value: "9",
                    text: "9"
                }, {
                    value: "10",
                    text: "10"
                }],
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new ComboBoxWidget({
                name: "unitsLDAP",
                row: 2,
                col: 0,
                singleCell: true,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.unitsLabel,
                values: [{
                    value: "Auto",
                    text: strings.auto
                }, {
                    value: "TB",
                    text: "TB"
                }, {
                    value: "GB",
                    text: "GB"
                }, {
                    value: "MB",
                    text: "MB"
                }],
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new ComboBoxWidget({
                name: "temperatureLDAP",
                row: 0,
                col: 2,
                singleCell: true,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.temperatureLabel,
                values: [{
                    value: "Celsius",
                    text: strings.celsius
                }, {
                    value: "Fahrenheit",
                    text: strings.fahrenheit
                }],
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new TextInputWidget({
                name: "timeoutLDAP",
                row: 1,
                col: 2,
                singleCell: true,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.timeoutMinutes,
                rules: {
                    isNumber: true,
                    range: [1, 720]
                },
                maxLength: 3,
                size: 5,
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            }), new ComboBoxWidget({
                name: "localeLDAP",
                row: 2,
                col: 2,
                singleCell: true,
                values: this.localesValues,
                rightMargin: true,
                bottomMargin: true,
                label: strings.userManagement.panelText.localeLabel,
                changeCallback: createObjectCallback(this, this._userGroupChanged)
            })]
        })]
    })];
    WidgetContainer.call(this, E);
    this.class_name = "LdapUsersWidget"
}
LdapUsersWidget.prototype = new WidgetContainer();
LdapUsersWidget.prototype.constructor = LdapUsersWidget;
LdapUsersWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
LdapUsersWidget.prototype.loadData = function() {
    if (RI.hasFeature("ldap")) {
        this.ldapParameterSubscription = MC.ldapParameterSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, function() {
                this.updateLdapParameters()
            })
        });
        this.usersGroupSubscription = MC.usergroupssSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, function() {
                this.updateUserGroupData()
            })
        })
    }
};
LdapUsersWidget.prototype.hiding = function() {
    if (this.usersGroupSubscription) {
        MC.usergroupssSet.unregister(this.usersGroupSubscription);
        delete this.usersGroupSubscription
    }
    if (this.ldapParameterSubscription) {
        MC.ldapParameterSet.unregister(this.ldapParameterSubscription);
        delete this.ldapParameterSubscription
    }
};
LdapUsersWidget.prototype.updateLdapParameters = function() {
    this.selectionCaller = "code";
    var D = {};
    if (DC.ldapParameters) {
        this.ldapParamsUpdated = true;
        var E = DC.ldapParameters;
        var C = false;
        if (E.getInt("ldap_protocol_numeric") == 1) {
            C = true
        }
        D.enableLDAP = {
            value: C,
            setOrig: true
        };
        if (RI.hasFeature("iPV6") && RI.hasFeature("DNS")) {
            D.ldapServer = {
                value: E.getPropertyValue("ldap_server"),
                setOrig: true,
                rules: {
                    ipv4ipv6orhostname: true,
                    required: true
                }
            };
            D.ldapAltServer = {
                value: E.getPropertyValue("alternate_ldap_server"),
                setOrig: true,
                rules: {
                    ipv4ipv6orhostname: true,
                    notEqualTo: ["#ldapServer"]
                }
            }
        } else {
            if (RI.hasFeature("iPV6")) {
                D.ldapServer = {
                    value: E.getPropertyValue("ldap_server"),
                    setOrig: true,
                    rules: {
                        ipv4andipv6: true,
                        required: true
                    }
                };
                D.ldapAltServer = {
                    value: E.getPropertyValue("alternate_ldap_server"),
                    setOrig: true,
                    rules: {
                        ipv4andipv6: true,
                        notEqualTo: ["#ldapServer"]
                    }
                }
            } else {
                if (RI.hasFeature("DNS")) {
                    D.ldapServer = {
                        value: E.getPropertyValue("ldap_server"),
                        setOrig: true,
                        rules: {
                            dnsAddress: true,
                            required: true
                        }
                    };
                    D.ldapAltServer = {
                        value: E.getPropertyValue("alternate_ldap_server"),
                        setOrig: true,
                        rules: {
                            dnsAddress: true,
                            notEqualTo: ["#ldapServer"]
                        }
                    }
                } else {
                    D.ldapServer = {
                        value: E.getPropertyValue("ldap_server"),
                        setOrig: true,
                        rules: {
                            ipv4Address: true,
                            required: true
                        }
                    };
                    D.ldapAltServer = {
                        value: E.getPropertyValue("alternate_ldap_server"),
                        setOrig: true,
                        rules: {
                            ipv4Address: true,
                            notEqualTo: ["#ldapServer"]
                        }
                    }
                }
            }
        }
        D.ldapSearchBase = {
            value: E.getPropertyValue("user_search_base"),
            setOrig: true,
            rules: {
                required: true
            }
        };
        if (!C) {
            D.ldapServer = {
                value: E.getPropertyValue("ldap_server"),
                setOrig: true
            };
            D.ldapAltServer = {
                value: E.getPropertyValue("alternate_ldap_server"),
                setOrig: true
            };
            D.ldapSearchBase = {
                value: E.getPropertyValue("user_search_base"),
                setOrig: true
            };
            D.ldapSettings = {
                disable: true
            }
        }
        D.ldapPort = {
            value: E.getInt("ldap_port"),
            setOrig: true
        };
        D.ldapAltPort = {
            value: E.getInt("alternate_ldap_port"),
            setOrig: true
        };
        this.update(D);
        delete this.selectionCaller
    }
};
LdapUsersWidget.prototype.updateUserGroupData = function() {
    this.selectionCaller = "code";
    if (DC.usergroups != undefined) {
        this.ldapUserGroupsUpdated = true
    }
    if (this.userGroupCreated != undefined && !this.userGroupCreated) {
        return
    }
    var H = "";
    if (session.sessionPreferences.usergroupname != "undefined") {
        H = session.sessionPreferences.usergroupname
    }
    var G = this._createDataObjectForUserGroup(H);
    if (H != "" && H != undefined) {
        G.middleTableLDAP = {
            visibility: "visible"
        };
        G.userGroupTable = {
            data: this._createUserGrouplist(),
            select: new DCRef("", H),
            selectable: ((session.hasUserConfigCapability()) ? "single" : false)
        }
    } else {
        G.userGroupTable = {
            data: this._createUserGrouplist(),
            selectable: ((session.hasUserConfigCapability()) ? "single" : false)
        };
        G.middleTableLDAP = {
            visibility: "collapse"
        }
    }
    if (!(session.hasUserConfigCapability())) {
        G.btnNewGroup = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.requiresManage
        };
        G.btnDeleteGroup = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.requiresManage
        }
    }
    var F = DC.usergroups;
    var C = 0;
    for (var D in F) {
        var E = DC.usergroups[D].getPropertyValue("roles");
        if ((E.indexOf(strings.userManagement.panelText.standard) != -1) || (E.indexOf(strings.userManagement.panelText.manage) != -1) || (E.indexOf(strings.userManagement.panelText.monitor) != -1)) {
            C++
        }
    }
    if (C == 0) {
        G.btnDeleteGroup = {
            disable: true
        };
        G.middleTableLDAP = {
            visibility: "collapse"
        }
    }
    this.update(G);
    delete this.selectionCaller
};
LdapUsersWidget.prototype._createDataObjectForUserGroup = function(H) {
    var G = {};
    G.btnNewGroup = {
        disable: false
    };
    G.btnDeleteGroup = {
        disable: false
    };
    G.manageRoleLDAP = {
        value: false,
        setOrig: true,
        disable: false
    };
    G.monitorRoleLDAP = {
        value: false,
        setOrig: true,
        disable: false
    };
    G.standardRoleLDAP = {
        value: false,
        setOrig: true,
        disable: false
    };
    G.cliCheckboxLDAP = {
        value: false,
        setOrig: true
    };
    G.wbiCheckboxLDAP = {
        value: false,
        setOrig: true
    };
    G.ftpCheckboxLDAP = {
        value: false,
        setOrig: true
    };
    G.smisCheckboxLDAP = {
        value: false,
        setOrig: true
    };
    if (session.sessionPreferences.usergroupname != "undefined") {
        var F = session.sessionPreferences.usergroupname
    }
    if (F != undefined && F == H) {
        G.btnNewGroup = {
            disable: false
        };
        G.btnDeleteGroup = {
            disable: false
        }
    }
    var C = DC.usergroups[H];
    if (C) {
        var E = C.prop;
        delete this.selectionCaller;
        G.baseLDAP = {
            value: E.storage_size_base.text,
            setOrig: true,
            disable: false
        };
        G.precisionLDAP = {
            value: E.storage_size_precision.text,
            setOrig: true,
            disable: false
        };
        G.unitsLDAP = {
            value: E.storage_size_units.text,
            setOrig: true,
            disable: false
        };
        G.temperatureLDAP = {
            value: E.temperature_scale.text,
            setOrig: true,
            disable: false
        };
        G.timeoutLDAP = {
            value: Math.floor(parseInt(E.timeout.text, 10) / 60),
            setOrig: true,
            disable: false
        };
        G.localeLDAP = {
            values: this.localesValues,
            value: E.usergroup_locale.text,
            setOrig: true,
            disable: false
        };
        G.userGroupText = {
            value: H,
            setOrig: true
        };
        var D = E.roles.text;
        if (D.indexOf(strings.userManagement.panelText.manage) != -1) {
            G.manageRoleLDAP = {
                value: true,
                setOrig: true,
                disable: (session.getCurrentUser() == H)
            }
        }
        if (D.indexOf(strings.userManagement.panelText.monitor) != -1) {
            G.monitorRoleLDAP = {
                value: true,
                setOrig: true,
                disable: (session.getCurrentUser() == H)
            }
        }
        if (D.indexOf(strings.userManagement.panelText.standard) != -1) {
            G.standardRoleLDAP = {
                value: true,
                setOrig: true,
                disable: (session.getCurrentUser() == H)
            }
        }
        if (E.interface_access_CLI.text == "x") {
            G.cliCheckboxLDAP = {
                value: true,
                setOrig: true
            }
        }
        if (E.interface_access_WBI.text == "x") {
            G.wbiCheckboxLDAP = {
                value: true,
                setOrig: true
            }
        }
        if (E.interface_access_FTP.text == "x") {
            G.ftpCheckboxLDAP = {
                value: true,
                setOrig: true
            }
        }
        if (E.interface_access_SMIS.text == "x") {
            G.smisCheckboxLDAP = {
                value: true,
                setOrig: true
            }
        }
        if (!(session.hasUserConfigCapability())) {
            G.btnNewGroup = {
                disable: true
            };
            G.btnDeleteGroup = {
                disable: true
            }
        }
    }
    if (propertyCount(DC.usergroups) >= 5) {
        G.btnNewGroup = {
            disable: true,
            tooltip: strings.userManagement.panelText.tips.maxUserGroups
        }
    }
    return G
};
LdapUsersWidget.prototype.ldapSettingsChange = function(J, F, H) {
    var C = {};
    this.retrieve(C);
    var D = {};
    var G = F.name;
    var I = {};
    if (H != undefined && H.type == "focusout" && C.enableLDAP.value && G == "ldapServer") {
        if (RI.hasFeature("iPV6") && RI.hasFeature("DNS")) {
            I.ldapServer = {
                rules: {
                    ipv4ipv6orhostname: true,
                    required: true
                }
            };
            I.ldapAltServer = {
                rules: {
                    ipv4ipv6orhostname: true
                }
            }
        } else {
            if (RI.hasFeature("iPV6")) {
                I.ldapServer = {
                    rules: {
                        ipv4andipv6: true,
                        required: true
                    }
                };
                I.ldapAltServer = {
                    rules: {
                        ipv4andipv6: true
                    }
                }
            } else {
                if (RI.hasFeature("DNS")) {
                    I.ldapServer = {
                        rules: {
                            dnsAddress: true,
                            required: true
                        }
                    };
                    I.ldapAltServer = {
                        rules: {
                            dnsAddress: true
                        }
                    }
                } else {
                    I.ldapServer = {
                        rules: {
                            ipv4Address: true,
                            required: true
                        }
                    };
                    I.ldapAltServer = {
                        rules: {
                            ipv4Address: true
                        }
                    }
                }
            }
        }
        this.update(I)
    }
    if (H != undefined && H.type == "focusout" && C.enableLDAP.value && G == "ldapAltServer") {
        var K = F.rules;
        K.notEqualTo = ["#ldapServer"];
        I.ldapAltServer = {
            rules: K
        }
    }
    if (H != undefined && H.type == "focusout" && C.enableLDAP.value && G == "ldapSearchBase") {
        I.ldapSearchBase = {
            rules: {
                required: true
            }
        };
        this.update(I)
    }
    if (F.valueChanged) {
        if ((C.ldapSearchBase.value != "" && !C.ldapSearchBase.invalid) && (C.ldapServer.value != "" && !C.ldapServer.invalid)) {
            this.valueChanged = true
        } else {
            this.valueChanged = false
        }
        var E = {};
        if ($.isFunction(this.options.changeCallback) && this.name && (session.hasUserConfigCapability())) {
            if (!E[this.name]) {
                E[this.name] = {}
            }
            if (this.valueChanged) {
                E[this.name].valueChanged = this.valueChanged;
                this.options.changeCallback(E, this, H)
            }
        }
    }
};
LdapUsersWidget.prototype.changedCallback = function(G, D, E) {
    var F = session.getCurrentUser();
    var C = {};
    if (!C[this.name]) {
        C[this.name] = {}
    }
    if ($.isFunction(this.options.changeCallback) && this.name && (session.hasUserConfigCapability())) {
        if (this.valueChanged != "undefined" && this.valueChanged != undefined) {
            C[this.name].valueChanged = this.valueChanged;
            this.options.changeCallback(C, this, E)
        }
    }
};
LdapUsersWidget.prototype.changeLDAP = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    var C = {};
    if (!G.enableLDAP.value) {
        C.ldapSettings = {
            disable: true
        };
        this.update(C)
    } else {
        C.ldapSettings = {
            disable: false
        };
        C.ldapServer = {
            requiredField: true
        };
        C.ldapSearchBase = {
            requiredField: true
        };
        this.update(C)
    }
    if (E.valueChanged) {
        if ((E.currentValue && (D.ldapSearchBase.value != "" && !D.ldapSearchBase.invalid) && (D.ldapServer.value != "" && !D.ldapServer.invalid)) || !E.currentValue) {
            this.valueChanged = true
        } else {
            this.valueChanged = false
        }
        this.changedCallback(G, E, F)
    } else {
        this.valueChanged = false;
        this.changedCallback(G, E, F)
    }
};
LdapUsersWidget.prototype._createUserGrouplist = function() {
    var D = DC.usergroups;
    var F = [];
    for (group in D) {
        var E = D[group].get("roles").split(",");
        var C = E.find(strings.userManagement.panelText.diagnostic);
        if (C != -1) {
            E.splice(C, 1)
        }
        var G = "";
        if (D[group].get("interface_access_CLI") == "x") {
            if (G != "") {
                G = G + ", CLI"
            } else {
                G = G + "CLI"
            }
        }
        if (D[group].get("interface_access_FTP") == "x") {
            if (G != "") {
                G = G + ", FTP"
            } else {
                G = G + "FTP"
            }
        }
        if (D[group].get("interface_access_SMIS") == "x") {
            if (G != "") {
                G = G + ", SMIS"
            } else {
                G = G + "SMIS"
            }
        }
        if (D[group].get("interface_access_WBI") == "x") {
            if (G != "") {
                G = G + ", WBI"
            } else {
                G = G + "WBI"
            }
        }
        F.push([group, E, G])
    }
    return F
};
LdapUsersWidget.prototype.usernameIntercept = function(D) {
    var E = null;
    if (D.aData === undefined) {
        E = D
    } else {
        E = D.aData[0]
    }
    if (DC.users[E]) {
        var C = decodeBooleanFlag(DC.users[E].get("default_password_changed_numeric"));
        if (RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && !C) {
            E = E + '<span class="requiredIndicator">*</span>'
        }
    }
    return E
};
LdapUsersWidget.prototype._addNewUserGroup = function(E) {
    var C = E || strings.userManagement.panelText.newUserGroup;
    var D = this._createUserGrouplist();
    D.push([C, "", ""]);
    return D
};
LdapUsersWidget.prototype.deleteGroupClicked = function() {
    var C = {};
    this.retrieve(C, true);
    var D = this.getUserGroupName();
    if (DC.usergroups[D] && D == session.sessionPreferences.usergroupname) {
        ShowActiveDialog({
            type: "error",
            dialogOverride: true,
            message: "Cannot delete the curently logged in user."
        })
    } else {
        MC.deleteUserGroup({
            usergroupname: D
        }, {
            dialog: true,
            confirmMsg: strings.userManagement.deleteusergroup.confirmMsg(D),
            processingMsg: strings.userManagement.deleteusergroup.processingMsg(D),
            failureMsg: strings.userManagement.deleteusergroup.error(D),
            successMsg: strings.userManagement.deleteusergroup.success(D),
            okLabel: strings.okButtonText,
            cancelLabel: strings.cancelButtonText,
            callback: createObjectCallback(this, this._userGroupDeleted)
        })
    }
};
LdapUsersWidget.prototype._userGroupDeleted = function(C) {
    if (C.success) {
        var D = this._createDataObjectForUserGroup(session.sessionPreferences.usergroupname);
        var E = new DCRef("", this.usernameIntercept(session.sessionPreferences.usergroupname));
        D.userGroupTable = {
            data: this._createUserGrouplist(),
            select: E,
            selectable: ((session.hasUserConfigCapability()) ? "single" : false)
        };
        this.update(D);
        this.userGroupTable.pageToRow(E);
        this.state = "viewing";
        this.valueChanged = false
    }
};
LdapUsersWidget.prototype._createNewUserGroup = function() {
    this.state = "creatingUserGroup";
    this.currentlyModifiedUserGroup = strings.userManagement.panelText.newUserGroup;
    var C = {};
    var D = this._addNewUserGroup();
    C.userGroupTable = {
        data: D,
        select: new DCRef("", strings.userManagement.panelText.newUserGroup),
        selectable: ((session.hasUserConfigCapability()) ? "single" : false)
    };
    C.userGroupText = {
        value: "",
        disable: false,
        setOrig: true,
        focus: true
    };
    this.userGroupEntered = false;
    C.btnNewGroup = {
        disable: true
    };
    C.btnDeleteGroup = {
        disable: true
    };
    C.manageRoleLDAP = {
        value: false,
        setOrig: true,
        disable: false
    };
    C.monitorRoleLDAP = {
        value: true,
        setOrig: true,
        disable: false
    };
    C.standardRoleLDAP = {
        value: false,
        setOrig: true,
        disable: false
    };
    C.wbiCheckboxLDAP = {
        value: true,
        setOrig: true
    };
    C.cliCheckboxLDAP = {
        value: true,
        setOrig: true
    };
    if (RI.hasFeature("smis")) {
        C.smisCheckboxLDAP = {
            value: false,
            setOrig: true
        }
    } else {
        C.smisCheckboxLDAP = {
            disable: true,
            visibility: "hidden",
            value: false,
            unsetOrig: true
        }
    }
    C.ftpCheckboxLDAP = {
        value: false,
        setOrig: true
    };
    C.baseLDAP = {
        value: "10",
        setOrig: true,
        disable: false
    };
    C.precisionLDAP = {
        value: "1",
        setOrig: true,
        disable: false
    };
    C.unitsLDAP = {
        value: "Auto",
        setOrig: true,
        disable: false
    };
    C.temperatureLDAP = {
        value: "Celsius",
        setOrig: true,
        disable: false
    };
    C.timeoutLDAP = {
        value: "30",
        setOrig: true,
        disable: false
    };
    C.localeLDAP = {
        values: this.localesValues,
        value: "English",
        setOrig: true,
        disable: false
    };
    C.middleTableLDAP = {
        visibility: "visible"
    };
    this.selectionCaller = "code";
    this.update(C);
    delete this.selectionCaller
};
LdapUsersWidget.prototype.getCommandQueue = function() {
    var I = {};
    this.retrieve(I);
    var H = {};
    var G = [];
    var F = [];
    var D = {};
    var C = [];
    if (I.manageRoleLDAP.valueChanged || I.standardRoleLDAP.valueChanged || (this.state == "creatingUserGroup" || this.state == "copying")) {
        if (I.manageRoleLDAP.value) {
            C.push("manage")
        }
        if (I.monitorRoleLDAP.value) {
            C.push("monitor")
        }
        if (I.standardRoleLDAP.value) {
            C.push("standard")
        }
    }
    var E = this.getUserGroupInterfaces();
    if (I.enableLDAP.valueChanged && !I.enableLDAP.value) {
        F.push({
            name: "modifyLDAP",
            command: MC.modifyLDAPSettings,
            data: {
                ldap: "disabled"
            },
            options: {
                processingMsg: strings.userManagement.modifyLdap.processingMsg,
                failureMsg: strings.userManagement.modifyLdap.error,
                successMsg: strings.userManagement.modifyLdap.success
            }
        })
    } else {
        if ((I.enableLDAP.valueChanged && I.enableLDAP.value) || (I.ldapServer.valueChanged || I.ldapPort.valueChanged || I.ldapSearchBase.valueChanged || I.ldapAltServer.valueChanged || I.ldapAltPort.valueChanged)) {
            F.push({
                name: "modifyLDAP",
                command: MC.modifyLDAPSettings,
                data: {
                    ldap: "enabled",
                    server: I.ldapServer.value,
                    port: I.ldapPort.value,
                    altServer: I.ldapAltServer.value,
                    altPort: I.ldapAltPort.value,
                    userSearchBase: I.ldapSearchBase.value
                },
                options: {
                    processingMsg: strings.userManagement.modifyLdap.processingMsg,
                    failureMsg: strings.userManagement.modifyLdap.error,
                    successMsg: strings.userManagement.modifyLdap.success
                }
            })
        }
    }
    if (this.state == "creatingUserGroup" && I.userGroupText.valueChanged && I.userGroupText.value != "") {
        D.usergroupname = I.userGroupText.value;
        if (C.length > 0) {
            D.roles = C
        }
        if (E != "") {
            D.interfaces = E
        }
        D.type = "ldap";
        if (I.baseLDAP.valueChanged) {
            D.base = I.baseLDAP.value
        }
        if (I.baseLDAP.valueChanged) {
            D.base = I.baseLDAP.value
        }
        if (I.precisionLDAP.valueChanged) {
            D.precision = I.precisionLDAP.value
        }
        if (I.unitsLDAP.valueChanged) {
            D.units = I.unitsLDAP.value
        }
        if (I.temperatureLDAP.valueChanged) {
            D.temperatureScale = I.temperatureLDAP.value
        }
        if (I.timeoutLDAP.valueChanged) {
            D.timeout = I.timeoutLDAP.value * 60
        }
        if (I.localeLDAP.valueChanged) {
            D.locale = I.localeLDAP.value
        }
        F.push({
            name: "createUserGroup",
            command: MC.createUserGroup,
            data: D,
            options: {
                processingMsg: strings.userManagement.createGroup.processingMsg,
                failureMsg: strings.userManagement.createGroup.error,
                successMsg: strings.userManagement.createGroup.success,
                callback: createObjectCallback(this, this._saveUserGroupCallback, D.usergroupname)
            }
        })
    } else {
        if (this.state == "modifyUserGroup" && this.userGroupChanged && I.userGroupText.value != "") {
            D.usergroupname = I.userGroupText.value;
            if (C != "") {
                D.roles = C
            }
            if (E != "") {
                D.interfaces = E
            }
            if (I.baseLDAP.valueChanged) {
                D.base = I.baseLDAP.value
            }
            if (I.baseLDAP.valueChanged) {
                D.base = I.baseLDAP.value
            }
            if (I.precisionLDAP.valueChanged) {
                D.precision = I.precisionLDAP.value
            }
            if (I.unitsLDAP.valueChanged) {
                D.units = I.unitsLDAP.value
            }
            if (I.temperatureLDAP.valueChanged) {
                D.temperatureScale = I.temperatureLDAP.value
            }
            if (I.timeoutLDAP.valueChanged) {
                D.timeout = I.timeoutLDAP.value * 60
            }
            if (I.localeLDAP.valueChanged) {
                D.locale = I.localeLDAP.value
            }
            F.push({
                name: "modifyUserGroup",
                command: MC.modifyUserGroup,
                data: D,
                options: {
                    processingMsg: strings.userManagement.modifyGroup.processingMsg,
                    failureMsg: strings.userManagement.modifyGroup.error,
                    successMsg: strings.userManagement.modifyGroup.success,
                    callback: createObjectCallback(this, this._saveUserGroupCallback, D.usergroupname)
                }
            })
        }
    }
    return F
};
LdapUsersWidget.prototype._saveUserGroupCallback = function(D, C) {
    if (C.success) {
        this.userGroupCreated = true;
        setTimeout(createObjectCallback(this, this._userGroupUpdate, D), 1000)
    } else {
        this.userGroupCreated = false
    }
};
LdapUsersWidget.prototype.getUserGroupRoles = function() {
    var D = {};
    this.retrieve(D);
    var C = "";
    if (D.monitorRoleLDAP.value) {
        if (C != "") {
            C += "," + strings.userManagement.panelText.monitor
        } else {
            C = strings.userManagement.panelText.monitor
        }
    }
    if (D.manageRoleLDAP.value) {
        if (C != "") {
            C += "," + strings.userManagement.panelText.manage
        } else {
            C = strings.userManagement.panelText.manage
        }
    }
    if (D.standardRoleLDAP.value) {
        if (C != "") {
            C += "," + strings.userManagement.panelText.standard
        } else {
            C = strings.userManagement.panelText.standard
        }
    }
    return C
};
LdapUsersWidget.prototype.getUserGroupInterfaces = function() {
    var C = {};
    this.retrieve(C);
    var D = "";
    if (C.cliCheckboxLDAP.value) {
        if (D != "") {
            D += ",CLI"
        } else {
            D = "CLI"
        }
    }
    if (C.smisCheckboxLDAP.value) {
        if (D != "") {
            D += ",SMIS"
        } else {
            D = "SMIS"
        }
    }
    if (C.wbiCheckboxLDAP.value) {
        if (D != "") {
            D += ",WBI"
        } else {
            D = "WBI"
        }
    }
    if (C.ftpCheckboxLDAP.value) {
        if (D != "") {
            D += ",FTP"
        } else {
            D = "FTP"
        }
    }
    return D
};
LdapUsersWidget.prototype._userGroupUpdate = function(D) {
    if (settings.memorex) {
        D = session.sessionPreferences.usergroupname
    }
    var C = this._createDataObjectForUserGroup(D);
    C.userListTable = {
        data: this._createUserGrouplist(),
        select: new DCRef("", D),
        selectable: ((session.hasUserConfigCapability()) ? "single" : false)
    };
    C.btnDeleteGroup = {
        disable: false
    };
    C.middleTableLDAP = {
        visibility: "collapse"
    };
    this.selectionCaller = "code";
    this.update(C);
    this.userGroupTable.pageToRow(new DCRef("", D));
    delete this.selectionCaller;
    this.valueChanged = false
};
LdapUsersWidget.prototype._userGroupSelected = function(C) {
    if (this.selectionCaller == "code") {
        return
    }
    var E = this.getUserGroupName();
    var D = this._createDataObjectForUserGroup(E);
    D.middleTableLDAP = {
        visibility: "visible"
    };
    this.update(D)
};
LdapUsersWidget.prototype._userGroupChanged = function(J, F, G) {
    var E = {};
    this.retrieve(E);
    var D = F.name;
    var C = this.getUserGroupRoles();
    var H = this.getUserGroupInterfaces();
    if (J[F.name].valueChanged && this.state == undefined) {
        this.state = "modifyUserGroup"
    }
    if (G != undefined && G.type == "focusout" && D == "userGroupText" && session.hasUserConfigCapability() && this.state == "creatingUserGroup") {
        var I = {};
        I.userGroupText = {
            rules: {
                required: true,
                dhUserName: true,
                utf8length: 29,
                userExists: true,
                noBannedUsers: true
            }
        };
        this.update(I);
        var E = {};
        this.retrieve(E);
        if (!E.userGroupText.invalid) {
            this.userGroupChanged = true;
            this.valueChanged = true
        } else {
            this.userGroupChanged = false;
            this.valueChanged = false
        }
        this.changedCallback(J, F, G)
    } else {
        if (this.state == "creatingUserGroup" && D != "userGroupText" && session.hasUserConfigCapability() && E.userGroupText.value != "") {
            if (F.valueChanged) {
                this.userGroupChanged = true;
                this.valueChanged = true
            } else {
                if (E.userGroupText == "") {
                    this.userGroupChanged = false;
                    this.valueChanged = false
                }
            }
            this.changedCallback(J, F, G)
        } else {
            if (this.state == "modifyUserGroup" && session.hasUserConfigCapability()) {
                if (E.manageRoleLDAP.valueChanged || E.monitorRoleLDAP.valueChanged || E.standardRoleLDAP.valueChanged || E.cliCheckboxLDAP.valueChanged || E.ftpCheckboxLDAP.valueChanged || E.smisCheckboxLDAP.valueChanged || E.wbiCheckboxLDAP.valueChanged || E.baseLDAP.valueChanged || E.localeLDAP.valueChanged || E.precisionLDAP.valueChanged || E.temperatureLDAP.valueChanged || E.timeoutLDAP.valueChanged || E.unitsLDAP.valueChanged) {
                    this.userGroupChanged = true;
                    this.valueChanged = true
                } else {
                    this.userGroupChanged = false;
                    this.valueChanged = false
                }
                if (!E.userGroupText.valueChanged) {
                    this.changedCallback(J, F, G)
                }
            }
        }
    }
};
LdapUsersWidget.prototype.getConfirmMsg = function() {
    var E = "";
    var D = {};
    this.retrieve(D);
    if (this.state == "creatingUserGroup") {
        E += strings.systemSettings.creatingNewUserGroup + D.userGroupText.value + "<br>"
    } else {
        if (this.state == "modifyUserGroup") {
            E += strings.systemSettings.modifyingUserGroup + D.userGroupText.value + "<br>"
        }
    }
    if (this.state == "creatingUserGroup" || this.state == "modifyUserGroup") {
        var C;
        if (D.manageRoleLDAP.valueChanged || D.standardRoleLDAP.valueChanged || D.monitorRoleLDAP.valueChanged || D.standardRoleLDAP.valueChanged) {
            E += strings.userManagement.panelText.Roles + ": " + this.getUserGroupRoles() + "<br>"
        }
        if (D.wbiCheckboxLDAP.valueChanged || D.cliCheckboxLDAP.valueChanged || D.smisCheckboxLDAP.valueChanged || D.ftpCheckboxLDAP.valueChanged) {
            C = this.getUserGroupInterfaces();
            E += strings.userManagement.panelText.Interfaces + ": " + C + "<br>"
        }
        if (D.precisionLDAP.valueChanged) {
            E += strings.userManagement.panelText.precisionLabel + ": " + D.precisionLDAP.value + "<br>"
        }
        if (D.unitsLDAP.valueChanged) {
            E += strings.userManagement.panelText.unitsLabel + ": " + D.unitsLDAP.value + "<br>"
        }
        if (D.baseLDAP.valueChanged) {
            E += strings.userManagement.panelText.baseLabel + ": " + D.baseLDAP.value + "<br>"
        }
        if (D.temperatureLDAP.valueChanged) {
            E += strings.userManagement.panelText.temperatureLabel + ": " + D.temperatureLDAP.value + "<br>"
        }
        if (D.timeoutLDAP.valueChanged) {
            E += strings.userManagement.panelText.timeoutMinutes + ": " + D.timeoutLDAP.value + "<br>"
        }
        if (D.localeLDAP.valueChanged) {
            E += strings.userManagement.panelText.localeLabel + ": " + D.localeLDAP.value + "<br>"
        }
    }
    if (D.enableLDAP.valueChanged) {
        E += strings.userManagement.panelText.enableLDAP + ": " + D.enableLDAP.value + "<br>";
        if (D.enableLDAP.value) {
            if (D.ldapServer.valueChanged) {
                E += strings.userManagement.panelText.ldapServer + ": " + D.ldapServer.value + "<br>"
            }
            if (D.ldapAltServer.valueChanged) {
                E += strings.userManagement.panelText.ldapAltServer + ": " + D.ldapAltServer.value + "<br>"
            }
            if (D.ldapPort.valueChanged) {
                E += strings.userManagement.panelText.ldapPort + ": " + D.ldapPort.value + "<br>"
            }
            if (D.ldapAltPort.valueChanged) {
                E += strings.userManagement.panelText.ldapAltPort + ": " + D.ldapAltPort.value + "<br>"
            }
            if (D.ldapSearchBase.valueChanged) {
                E += strings.userManagement.panelText.ldapSearchBase + ": " + D.ldapSearchBase.value + "<br>"
            }
        }
    }
    return E
};
LdapUsersWidget.prototype.getUserGroupName = function() {
    if (this.userGroupTable.selected.length > 0) {
        var C = this.userGroupTable.selected[0].key;
        if (this.userGroupTable.dataTable.oApi._fnDetectType(C) === "html") {
            return $.parseHTML(C)[0].data
        } else {
            return C
        }
    }
    return false
};

function ManageUsersWidget(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "UserManagementAction";
    var C = createObjectCallback(this, this.changedCallback);
    var C = createObjectCallback(this, this.changedCallback);
    this.localesList = session.getSupportedLocales();
    this.localesValues = [];
    this.changedWidgets = {};
    this.valueChanged = false;
    this.userGroupChanged = false;
    this.createPwdRules = {
        dhPassword: true,
        characterLength: 32,
        minlength: 8,
        required: true,
        passwordComplexityCheck: true
    };
    this.modifyPwdRules = {
        dhPassword: true,
        characterLength: 32,
        minlength: 8,
        passwordComplexityCheck: true
    };
    var D = [{
        name: "tabLocal",
        label: strings.userManagement.panelText.localUsersTab
    }];
    if (RI.hasFeature("ldap")) {
        D.push({
            name: "tabLDAP",
            label: strings.userManagement.panelText.ldapUsersTab
        });
        E.widgets = [new TabWidget({
            name: "userTabs",
            type: "Primary",
            changeCallback: createObjectCallback(this, this.tabSelected),
            tabs: D,
            widgets: [new WidgetContainer({
                name: "localUserTab",
                widgets: [this.localUserWidget = new LocalUsersWidget({
                    changeCallback: createObjectCallback(this, this._valueChange)
                })]
            }), new WidgetContainer({
                name: "ldapUserTab",
                widgets: [this.ldapUsersWidget = new LdapUsersWidget({
                    changeCallback: createObjectCallback(this, this._valueChange)
                })]
            })]
        })]
    } else {
        E.widgets = [new WidgetContainer({
            name: "localUserTab",
            widgets: [this.localUserWidget = new LocalUsersWidget({
                changeCallback: createObjectCallback(this, this._valueChange)
            })]
        })]
    }
    WidgetContainer.call(this, E);
    this.class_name = "ManageUsersWidget";
    this.tabSelected(0)
}
ManageUsersWidget.prototype = new WidgetContainer();
ManageUsersWidget.prototype.constructor = ManageUsersWidget;
ManageUsersWidget.prototype.tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (this.widgets && this.findWidgetByName("userTabs")) {
        switch (C) {
            case 0:
                this.update({
                    localUserTab: {
                        visibility: "visible"
                    },
                    ldapUserTab: {
                        visibility: "collapse"
                    }
                });
                break;
            case 1:
                this.update({
                    localUserTab: {
                        visibility: "collapse"
                    },
                    ldapUserTab: {
                        visibility: "visible"
                    }
                });
                break;
            default:
                MC.warningOutput("ManageUsersWidget.tabSelected: bad tab number = %d", C);
                break
        }
    }
};
ManageUsersWidget.prototype._valueChange = function(F, G, E) {
    var D = G.name;
    var C = {};
    this.valueChanged = F[D].valueChanged;
    C[this.name] = {};
    C[this.name].valueChanged = this.valueChanged;
    this.options.changeCallback(C, this, E)
};
ManageUsersWidget.prototype.getCommandQueue = function() {
    var D = [];
    var C = [];
    if (this.ldapUsersWidget != undefined && this.ldapUsersWidget.valueChanged) {
        D = this.ldapUsersWidget.getCommandQueue()
    }
    if (this.localUserWidget != undefined && this.localUserWidget.valueChanged) {
        C = this.localUserWidget.getCommandQueue()
    }
    return D.concat(C)
};
ManageUsersWidget.prototype.getConfirmMsg = function() {
    var C = '<div class="confirmLabel"><u>' + strings.configurationWizard.manageUsersLabel + "</u></div><br>";
    if (this.ldapUsersWidget != undefined && this.ldapUsersWidget.valueChanged) {
        C += this.ldapUsersWidget.getConfirmMsg()
    }
    if (this.localUserWidget != undefined && this.localUserWidget.valueChanged) {
        C += this.localUserWidget.getConfirmMsg()
    }
    return C
};
ManageUsersWidget.prototype.clearTable = function() {
    if (this.userListTable != undefined) {
        this.userListTable.destroy()
    }
    if (RI.hasFeature("ldap") && this.userGroupTable != undefined) {
        this.userGroupTable.destroy()
    }
};
ManageUsersWidget.prototype.dataUpdated = function() {
    if (RI.hasFeature("ldap")) {
        return (this.localUserWidget.localUsersUpdated && this.ldapUsersWidget.ldapUserGroupsUpdated && this.ldapUsersWidget.ldapParamsUpdated)
    } else {
        return (this.localUserWidget.localUsersUpdated)
    }
};

function NotificationSetupWidget(H) {
    var G = 0,
        E = 0;
    var D = createObjectCallback(this, this.somethingChanged);
    var C = createObjectCallback(this, this.managedLogsChanged);
    var F = createObjectCallback(this, this.tabSelected);
    this.testLogButtonFlag = false;
    this.testSysLogButtonFlag = false;
    this.snmpFlag = false;
    this.emailFlag = false;
    H.name = "notificationSetupWidget";
    this.tabValues = [{
        name: "tabEmail",
        label: strings.notify.email
    }, {
        name: "tabSnmp",
        label: strings.notify.snmp
    }, {
        name: "tabManagedLogs",
        label: strings.notify.mLogs
    }, {
        name: "tabSyslog",
        label: strings.notify.syslog
    }];
    H.widgets = [this.notifyTabs = new TabWidget({
        name: "notifTabs",
        type: "Primary",
        changeCallback: F,
        tabs: this.tabValues,
        widgets: [new WidgetContainer({
            classes: "clearFloats"
        }), new TableWidget({
            name: "snmpConfigWidget",
            widgets: [new TextWidget({
                name: "snmpInstr",
                row: 0,
                col: 0,
                colSpan: 4,
                bottomMargin: true,
                text: strings.notify.snmpInst,
                classes: "formTableHeadingLeft"
            }), new ComboBoxWidget({
                name: "snmpLevel",
                width: 102,
                row: 1,
                col: 1,
                bottomMargin: true,
                rightMargin: true,
                leftMargin: true,
                label: strings.notify.levelLabel,
                labelOptions: {
                    col: 0,
                    classes: "noWrap"
                },
                changeCallback: createObjectCallback(this, this.levelChanged),
                values: [{
                    value: "none",
                    text: strings.none + " (" + strings.disabled + ")"
                }, {
                    value: "crit",
                    text: strings.critical
                }, {
                    value: "error",
                    text: strings.error
                }, {
                    value: "warn",
                    text: strings.warning
                }, {
                    value: "info",
                    text: strings.infoResol
                }]
            }), new TextInputWidget({
                name: "snmpReadComm",
                row: 2,
                col: 1,
                bottomMargin: true,
                rightMargin: true,
                leftMargin: true,
                size: 16,
                label: strings.notify.readCommLabel,
                changeCallback: D,
                rules: {
                    utf8length: 31,
                    rwCommunity: true
                },
                labelOptions: {
                    col: 0,
                    classes: "noWrap"
                }
            }), new TextInputWidget({
                name: "snmpWriteComm",
                row: 3,
                col: 1,
                bottomMargin: true,
                rightMargin: true,
                leftMargin: true,
                size: 16,
                label: strings.notify.writeCommLabel,
                changeCallback: D,
                rules: {
                    utf8length: 31,
                    rwCommunity: true
                },
                labelOptions: {
                    col: 0,
                    classes: "noWrap"
                }
            }), new TextInputWidget({
                name: "snmpHost1",
                row: 1,
                col: 3,
                bottomMargin: true,
                leftMargin: true,
                size: 15,
                label: strings.notify.host1Label,
                labelOptions: {
                    col: 2,
                    classes: "noWrap"
                },
                changeCallback: D,
                rules: {
                    ipv4Address: true
                },
                messages: {
                    ipv4address: strings.val.ipv4Address
                }
            }), new TextInputWidget({
                name: "snmpHost2",
                row: 2,
                col: 3,
                bottomMargin: true,
                leftMargin: true,
                size: 15,
                label: strings.notify.host2Label,
                labelOptions: {
                    col: 2,
                    classes: "noWrap"
                },
                changeCallback: D,
                rules: {
                    ipv4Address: true
                },
                messages: {
                    ipv4address: strings.val.ipv4Address
                }
            }), new TextInputWidget({
                name: "snmpHost3",
                row: 3,
                col: 3,
                leftMargin: true,
                size: 15,
                label: strings.notify.host3Label,
                labelOptions: {
                    col: 2,
                    classes: "noWrap"
                },
                changeCallback: D,
                rules: {
                    ipv4Address: true
                },
                messages: {
                    ipv4address: strings.val.ipv4Address
                }
            })]
        }), new TableWidget({
            name: "emailConfigWidget",
            widgets: [new TextWidget({
                text: strings.notify.emBlurb,
                bottomMargin: true,
                row: 0,
                colSpan: 4
            }), new LabeledWidgetContainer({
                row: 1,
                col: 0,
                label: strings.notify.smtpSettings,
                cellClasses: "alignTop",
                bottomMargin: true,
                widgets: [new TableWidget({
                    widgets: [new TextInputWidget({
                        name: "emServer",
                        bottomMargin: true,
                        row: 0,
                        col: 1,
                        size: 15,
                        label: strings.notify.serverLabel,
                        labelOptions: {
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        rules: {
                            ipv4Address: true
                        },
                        changeCallback: createObjectCallback(this, this.serverChanged)
                    }), new TextInputWidget({
                        name: "emDomain",
                        value: strings.notify.defaultEmailDomain,
                        bottomMargin: true,
                        row: 1,
                        col: 1,
                        size: 18,
                        maxLength: 320,
                        label: strings.notify.domainLabel,
                        labelOptions: {
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        rules: {
                            utf8length: 255,
                            emailSenderDomain: true
                        },
                        changeCallback: createObjectCallback(this, this.domainChanged),
                        messages: {
                            required: strings.notify.domainRequired
                        }
                    }), new TextInputWidget({
                        name: "emSender",
                        row: 2,
                        col: 1,
                        size: 18,
                        maxLength: 64,
                        label: strings.notify.senderLabel,
                        changeCallback: D,
                        rules: {
                            utf8length: 64,
                            emailLocalPart: true
                        },
                        labelOptions: {
                            rightMargin: true,
                            classes: "noWrap"
                        }
                    }), new TextInputWidget({
                        name: "emTlsPort",
                        width: 64,
                        row: 3,
                        col: 1,
                        rightMargin: true,
                        topMargin: true,
                        label: strings.notify.port,
                        labelOptions: {
                            col: 0,
                            classes: "noWrap"
                        },
                        rules: {
                            isInteger: true,
                            range: [1, 65535]
                        },
                        changeCallback: createObjectCallback(this, this.portChanged)
                    }), new RadioButtonsInputWidget({
                        name: "emProtocols",
                        row: 4,
                        col: 0,
                        singleCell: true,
                        topMargin: true,
                        orientation: "horizontal",
                        label: strings.notify.securityProtocol,
                        values: [{
                            value: SECURITYPROTOCOL.NONE,
                            text: strings.notify.protocolNone
                        }, {
                            value: SECURITYPROTOCOL.TLS,
                            text: strings.notify.protocolTLS
                        }, {
                            value: SECURITYPROTOCOL.SSL,
                            text: strings.notify.protocolSSL
                        }],
                        changeCallback: createObjectCallback(this, this.enableSecProtocol)
                    }), new TextInputWidget({
                        name: "emSenderPasswd",
                        row: 5,
                        col: 1,
                        size: 18,
                        maxLength: 64,
                        topMargin: true,
                        password: true,
                        label: strings.notify.senderPassword,
                        labelOptions: {
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        changeCallback: createObjectCallback(this, this.enableSecProtocol)
                    }), new TextInputWidget({
                        name: "emConfPasswd",
                        row: 6,
                        col: 1,
                        size: 18,
                        maxLength: 64,
                        topMargin: true,
                        password: true,
                        label: strings.userManagement.panelText.ConfirmPassword,
                        labelOptions: {
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        changeCallback: createObjectCallback(this, this.enableSecProtocol)
                    })]
                })]
            }), new CheckboxContainer({
                name: "emNotifSettings",
                label: strings.notify.enableEmailNotif,
                row: 2,
                col: 0,
                singleCell: true,
                topMargin: true,
                cellClasses: "alignTop",
                changeCallback: createObjectCallback(this, this.emNotifSettingsChanged),
                widgets: [new TableWidget({
                    name: "emNotifTable",
                    widgets: [new RadioButtonsInputWidget({
                        name: "emLevel",
                        label: strings.notify.levelLabel,
                        row: 1,
                        col: 1,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        orientation: "vertical",
                        bottomMargin: true,
                        topMargin: true,
                        values: [{
                            value: NOTIFICATION_LEVEL.CRITICAL,
                            text: strings.critical
                        }, {
                            value: NOTIFICATION_LEVEL.ERROR,
                            text: strings.critical + ", " + strings.error
                        }, {
                            value: NOTIFICATION_LEVEL.WARNING,
                            text: strings.critical + ", " + strings.error + ", " + strings.warning
                        }, {
                            value: NOTIFICATION_LEVEL.RESOLVED,
                            text: strings.critical + ", " + strings.error + ", " + strings.warning + ", " + strings.resolved
                        }, {
                            value: NOTIFICATION_LEVEL.INFO,
                            text: strings.critical + ", " + strings.error + ", " + strings.warning + ", " + strings.resolved + ", " + strings.informational
                        }],
                        changeCallback: createObjectCallback(this, this.somethingChanged)
                    }), new TextInputWidget({
                        name: "emEmail1",
                        row: 2,
                        col: 1,
                        bottomMargin: true,
                        size: 18,
                        maxLength: 320,
                        label: strings.notify.email1Label,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        changeCallback: D,
                        rules: {
                            newEmail: true,
                            utf8length: 320
                        },
                        requiredField: true
                    }), new TextInputWidget({
                        name: "emEmail2",
                        row: 3,
                        col: 1,
                        bottomMargin: true,
                        size: 18,
                        maxLength: 320,
                        label: strings.notify.email2Label,
                        labelOptions: {
                            col: 0,
                            classes: "noWrap"
                        },
                        changeCallback: D,
                        rules: {
                            newEmail: true,
                            utf8length: 320
                        }
                    }), new TextInputWidget({
                        name: "emEmail3",
                        row: 4,
                        col: 1,
                        size: 18,
                        maxLength: 320,
                        label: strings.notify.email3Label,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        changeCallback: D,
                        rules: {
                            newEmail: true,
                            utf8length: 320
                        }
                    })]
                })]
            }), new CheckboxContainer({
                name: "emHealthAlerts",
                label: strings.notify.healthAlerts,
                row: 3,
                col: 0,
                singleCell: true,
                topMargin: true,
                cellClasses: "alignTop",
                changeCallback: createObjectCallback(this, this.somethingChanged),
                widgets: [new TextWidget({
                    name: "emHealthInfo",
                    topMargin: true,
                    text: strings.notify.healthAlertsInfo
                })]
            })]
        }), new TableWidget({
            name: "logNotifyWidget",
            widgets: [new TextWidget({
                name: "logHeader",
                row: 0,
                col: 0,
                text: strings.notify.logsHeader,
                bottomMargin: true,
                classes: "formTableHeadingLeft"
            }), new CheckboxContainer({
                name: "managedLogs",
                row: 1,
                col: 0,
                label: strings.notify.mLogsLabel,
                singleCell: true,
                changeCallback: C,
                widgets: [new TextInputWidget({
                    name: "emEmail4",
                    leftMargin: true,
                    bottomMargin: true,
                    topTinyMargin: true,
                    size: 20,
                    maxLength: 320,
                    label: strings.notify.email4Label,
                    changeCallback: D,
                    rules: {
                        newEmail: true,
                        utf8length: 320
                    }
                }), new CheckboxInputWidget({
                    name: "emIncludeLogs",
                    label: strings.notify.includeLogsLabel,
                    changeCallback: D
                })]
            })]
        }), new TableWidget({
            name: "syslogWidget",
            widgets: [new TableWidget({
                name: "syslogTable",
                widgets: [new TextWidget({
                    name: "infoTxt",
                    text: strings.syslogConfig.infoTxt,
                    row: 0,
                    col: 0,
                    colSpan: 2,
                    bottomMargin: true
                }), new OptionInputWidget({
                    name: "syslogLevel",
                    row: 1,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true,
                    label: strings.syslogConfig.levelLabel,
                    labelOptions: {
                        row: 1,
                        col: 0,
                        bottomMargin: true
                    },
                    changeCallback: D,
                    values: [{
                        value: "none",
                        text: strings.none + " (" + strings.disabled + ")"
                    }, {
                        value: "crit",
                        text: strings.critical
                    }, {
                        value: "error",
                        text: strings.error
                    }, {
                        value: "warn",
                        text: strings.warning
                    }, {
                        value: "resolved",
                        text: strings.resolved
                    }, {
                        value: "info",
                        text: strings.informational
                    }]
                }), new TextInputWidget({
                    name: "syslogIPAddress",
                    row: 2,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true,
                    size: 16,
                    label: strings.syslogConfig.serverIPAddr,
                    changeCallback: D,
                    labelOptions: {
                        row: 2,
                        col: 0,
                        bottomMargin: true
                    },
                    rules: {
                        ipv4Address: true
                    }
                }), new TextInputWidget({
                    name: "syslogPortNumber",
                    row: 3,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true,
                    size: 16,
                    changeCallback: D,
                    label: strings.syslogConfig.syslogPortNumber,
                    labelOptions: {
                        row: 3,
                        col: 0,
                        bottomMargin: true
                    },
                    rules: {
                        isNumber: true
                    }
                })]
            })]
        })]
    })];
    if (!H.noTests) {
        H.widgets.push(new LabeledWidgetContainer({
            name: "sendValidationWidget",
            label: strings.notify.logTest1,
            topMargin: true,
            leftMargin: true,
            rightMargin: true,
            widgets: [new TableWidget({
                name: "buttonsTable",
                widgets: [new TextWidget({
                    row: 0,
                    col: 0,
                    rightMargin: true,
                    text: strings.notify.logTest2
                }), new ButtonContainer({
                    name: "sendButtons",
                    size: "small",
                    row: 0,
                    col: 2,
                    colSpan: 2,
                    orientation: "horizontal",
                    alignment: "right",
                    leftMargin: true,
                    widgets: [new ButtonWidget({
                        name: "testButton",
                        size: "medium",
                        leftMargin: true,
                        rightMargin: true,
                        bottomMargin: true,
                        click: createObjectCallback(this, this.sendTestCallback)
                    })]
                }), new WidgetContainer({
                    classes: "clearFloats"
                })]
            })]
        }))
    }
    WidgetContainer.call(this, H);
    this.class_name = "NotificationSetupWidget";
    this.emailSettings = false;
    this.snmpSettings = false
}
NotificationSetupWidget.prototype = new WidgetContainer();
NotificationSetupWidget.prototype.constructor = NotificationSetupWidget;
NotificationSetupWidget.prototype.showing = function() {
    var C = {};
    if (RI.hasFeature("iPV6") && RI.hasFeature("DNS")) {
        C.emServer = {
            rules: {
                ipv4ipv6orhostname: true
            }
        };
        C.snmpHost1 = {
            rules: {
                ipv4ipv6orhostname: true
            }
        };
        C.snmpHost2 = {
            rules: {
                ipv4ipv6orhostname: true
            }
        };
        C.snmpHost3 = {
            rules: {
                ipv4ipv6orhostname: true
            }
        };
        C.syslogIPAddress = {
            rules: {
                ipv4ipv6orhostname: true
            }
        }
    } else {
        if (RI.hasFeature("iPV6")) {
            C.emServer = {
                rules: {
                    ipv4andipv6: true
                }
            };
            C.snmpHost1 = {
                rules: {
                    ipv4andipv6: true
                }
            };
            C.snmpHost2 = {
                rules: {
                    ipv4andipv6: true
                }
            };
            C.snmpHost3 = {
                rules: {
                    ipv4andipv6: true
                }
            };
            C.syslogIPAddress = {
                rules: {
                    ipv4andipv6: true
                }
            }
        } else {
            if (RI.hasFeature("DNS")) {
                C.emServer = {
                    rules: {
                        dnsAddress: true
                    }
                };
                C.snmpHost1 = {
                    rules: {
                        dnsAddress: true
                    }
                };
                C.snmpHost2 = {
                    rules: {
                        dnsAddress: true
                    }
                };
                C.snmpHost3 = {
                    rules: {
                        dnsAddress: true
                    }
                };
                C.syslogIPAddress = {
                    rules: {
                        dnsAddress: true
                    }
                }
            }
        }
    }
    this.update(C);
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
NotificationSetupWidget.prototype.loadData = function() {
    this.protocolsSubscription = MC.protocolsSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(C, true)
        })
    });
    this.snmpSubscription = MC.snmpParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(C, true)
        })
    });
    this.emailSubscription = MC.emailParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(C, true)
        })
    });
    this.advSettingsSubscription = MC.advancedSettingsSet.requestData({
        update: true,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(C, true)
        })
    });
    this.syslogSubscription = MC.syslogParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(C, true)
        })
    })
};
NotificationSetupWidget.prototype.hiding = function() {
    if (this.protocolsSubscription) {
        MC.protocolsSet.unregister(this.protocolsSubscription);
        delete this.protocolsSubscription
    }
    if (this.emailSubscription) {
        MC.emailParametersSet.unregister(this.emailSubscription);
        delete this.emailSubscription
    }
    if (this.snmpSubscription) {
        MC.snmpParametersSet.unregister(this.snmpSubscription);
        delete this.snmpSubscription
    }
    if (this.advSettingsSubscription) {
        MC.advancedSettingsSet.unregister(this.advSettingsSubscription);
        delete this.advSettingsSubscription
    }
    if (this.syslogSubscription) {
        MC.syslogParametersSet.unregister(this.syslogSubscription);
        delete this.syslogSubscription
    }
};
NotificationSetupWidget.prototype.domainChanged = function(E, C, D) {
    if (!D) {
        return
    }
    this.somethingChanged(E, C, D)
};
NotificationSetupWidget.prototype.portChanged = function(E, C, D) {
    if (!D) {
        return
    }
    this.somethingChanged(E, C, D)
};
NotificationSetupWidget.prototype.serverChanged = function(F, D, E) {
    if (F.emServer.value != "" && !F.emServer.invalid) {
        var C = {};
        this.retrieve(C);
        this.update({
            emNotifSettings: {
                disable: false
            },
            emLevel: {
                disable: (C.emNotifSettings.value ? false : true)
            },
            emEmail1: {
                skipValidation: true,
                disable: (C.emNotifSettings.value ? false : true),
                rules: (C.emNotifSettings.value ? {
                    required: true
                } : {})
            },
            emEmail2: {
                disable: (C.emNotifSettings.value ? false : true)
            },
            emEmail3: {
                disable: (C.emNotifSettings.value ? false : true)
            }
        })
    }
    this.somethingChanged(F, D, E)
};
NotificationSetupWidget.prototype.enableSecProtocol = function(H, F, G) {
    var E = {};
    this.retrieve(E);
    var C = F.name;
    if (!G) {
        return
    }
    if (C == "emProtocols") {
        if (H.emProtocols.value == SECURITYPROTOCOL.TLS || H.emProtocols.value == SECURITYPROTOCOL.SSL) {
            this.update({
                emSenderPasswd: {
                    value: "",
                    setOrig: true,
                    requiredField: true,
                    disable: false,
                    rules: {
                        dhPassword: true,
                        minlength: 8,
                        characterLength: 32
                    }
                },
                emConfPasswd: {
                    value: "",
                    setOrig: true,
                    requiredField: true,
                    disable: false,
                    rules: {
                        equalTo: "#emSenderPasswd",
                        dhPassword: true,
                        minlength: 8,
                        characterLength: 32
                    }
                }
            })
        } else {
            this.update({
                emSenderPasswd: {
                    value: E.emSenderPasswd.value,
                    requiredField: false,
                    setOrig: true,
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                emConfPasswd: {
                    value: E.emConfPasswd.value,
                    requiredField: false,
                    setOrig: true,
                    disable: true,
                    rules: {
                        required: false
                    }
                }
            });
            this.somethingChanged(H, F, G)
        }
    }
    if (C == "emSenderPasswd" && G.type == "focusout") {
        var D = F.rules;
        D.required = true;
        this.update({
            emSenderPasswd: {
                rules: D
            }
        })
    }
    if (C == "emConfPasswd" && G.type == "focusout") {
        var D = F.rules;
        D.required = true;
        this.update({
            emConfPasswd: {
                rules: D
            }
        })
    }
    if (E.emProtocols.value != SECURITYPROTOCOL.NONE && (E.emSenderPasswd.value != "" && !E.emSenderPasswd.invalid) && (E.emConfPasswd.value != "" && !E.emConfPasswd.invalid) && (E.emSender.value.trim() != "" && !E.emSender.invalid)) {
        this.somethingChanged(H, F, G)
    }
};
NotificationSetupWidget.prototype.emNotifSettingsChanged = function(F, D, E) {
    if (!E) {
        return
    }
    var C = {};
    this.retrieve(C);
    if (F.emNotifSettings.valueChanged && F.emNotifSettings.value) {
        this.update({
            emLevel: {
                value: NOTIFICATION_LEVEL.CRITICAL,
                disable: false
            },
            emEmail1: {
                disable: false
            },
            emEmail2: {
                disable: false
            },
            emEmail3: {
                disable: false
            }
        })
    } else {
        if (F.emNotifSettings.value == false) {
            this.update({
                emLevel: {
                    disable: true
                },
                emEmail1: {
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                emEmail2: {
                    disable: true
                },
                emEmail3: {
                    disable: true
                }
            })
        } else {
            if (F.emNotifSettings.valueChanged == false && F.emNotifSettings.value) {
                this.update({
                    emLevel: {
                        disable: false
                    },
                    emEmail1: {
                        disable: false,
                        rules: {
                            required: true
                        }
                    },
                    emEmail2: {
                        disable: false
                    },
                    emEmail3: {
                        disable: false
                    }
                })
            }
        }
    }
    this.somethingChanged(F, D, E)
};
NotificationSetupWidget.prototype.managedLogsChanged = function(G, E, F) {
    var D = {};
    var C = {};
    this.retrieve(D);
    if (D.managedLogs.valueChanged && D.managedLogs.value) {
        if ((D.emServer.length != 0) && (D.emDomain.length != 0)) {
            C.emEmail4 = D.emEmail4;
            C.emIncludeLogs = D.emIncludeLogs;
            C.emEmail4.disable = false;
            C.emIncludeLogs.disable = false;
            this.update(C)
        }
    }
    this.somethingChanged(G, E, F)
};
NotificationSetupWidget.prototype.somethingChanged = function(H, E, F) {
    var D = {};
    var C;
    if (!F) {
        return
    }
    this.valueChanged = false;
    this.retrieve(D);
    for (C in D) {
        if (D[C].valueChanged == true) {
            this.valueChanged = true;
            break
        }
    }
    if (E.name == "emNotifSettings" && H.emNotifSettings.value) {
        if (H.emEmail1.value == "" && H.emEmail2.value == "" && H.emEmail3.value == "") {
            this.valueChanged = false
        }
    }
    if ((D.emServer.valueChanged && (D.emServer.value == "" || D.emServer.invalid)) || (D.emDomain.valueChanged && (D.emDomain.value == "" || D.emDomain.invalid))) {
        this.valueChanged = false
    }
    if (D.emSender.valueChanged && D.emSender.value.trim() == "" || D.emSender.invalid) {
        this.valueChanged = false
    }
    var G = {};
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
        if (!G[this.name]) {
            G[this.name] = {}
        }
        G[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(G, this, F)
    }
};
NotificationSetupWidget.prototype.levelChanged = function(F, D, E) {
    var C = (F[D.name].value == "none");
    if (D.name == "snmpLevel") {
        if (C) {
            this.update({
                snmpReadComm: {
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                snmpWriteComm: {
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                snmpHost1: {
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                snmpHost2: {
                    disable: true,
                    rules: {
                        required: false
                    }
                },
                snmpHost3: {
                    disable: true,
                    rules: {
                        required: false
                    }
                }
            })
        } else {
            this.update({
                snmpReadComm: {
                    disable: false,
                    rules: {
                        required: true,
                        utf8length: 31,
                        rwCommunity: true
                    }
                },
                snmpWriteComm: {
                    disable: false,
                    rules: {
                        required: true,
                        utf8length: 31,
                        rwCommunity: true
                    }
                },
                snmpHost1: {
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                },
                snmpHost2: {
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                },
                snmpHost3: {
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                }
            })
        }
    }
    this.somethingChanged(F, D, E)
};
NotificationSetupWidget.prototype.getConfirmMsg = function() {
    var E = {};
    this.retrieve(E);
    var G = '<div class="confirmLabel"><u>' + strings.configurationWizard.notifyStep + "</u></div><br>";
    for (var D in E) {
        if (E[D].valueChanged) {
            var C = strings.configurationWizard.summary[D];
            var F = E[D].value;
            if (typeof E[D].value == "boolean") {
                if (E[D].value) {
                    F = strings.Enabled
                } else {
                    F = strings.Disabled
                }
            }
            if (D == "snmpLevel" || D == "syslogLevel") {
                switch (E[D].value) {
                    case "none":
                        F = strings.none + " (" + strings.disabled + ")";
                        break;
                    case "crit":
                        F = strings.critical;
                        break;
                    case "error":
                        F = strings.warning;
                        break;
                    case "warn":
                        F = strings.warning;
                        break;
                    case "info":
                        F = strings.informational;
                        break;
                    default:
                        break
                }
            }
            if (D == "emConfPasswd") {
                continue
            }
            if (D == "emSenderPasswd") {
                C = strings.configurationWizard.summary.senderPasswd;
                F = "********"
            }
            G += C + ": " + F + "<br>"
        }
    }
    return G
};
NotificationSetupWidget.prototype._isTypeChanged = function(D, F) {
    var C;
    var E = new RegExp("^" + D, "i");
    var G = false;
    if (!F) {
        return G
    }
    if ((D != "snmp") && (D != "em") && (D != "managed") && (D != "syslog") && (D != "nameServer") && (D != "searchDomain")) {
        MC.warningOutput("NotificationSetupWidget::_isTypeChangedreturned bad type = %s\n", D);
        return G
    }
    this.retrieve(F);
    for (C in F) {
        if (F[C].valueChanged == true) {
            if (E.test(C)) {
                G = true;
                break
            }
        }
    }
    return G
};
NotificationSetupWidget.prototype.sendTestCallback = function() {
    switch (this.notifyTabs.selected) {
        case 0:
        case 1:
            this.sendEventCallback();
            break;
        case 2:
        case 3:
            this.sendLogEventCallback();
            break;
        default:
            break
    }
};
NotificationSetupWidget.prototype.sendEventCallback = function() {
    var D = {};
    var C = "";
    this.retrieve(D);
    if (!D.emNotifSettings.value) {
        C = strings.notify.emailWarning
    }
    if (D.emEmail1.value == "" && D.emEmail2.value == "" && D.emEmail3.value == "") {
        C = strings.notify.emailNotConfigured
    }
    MC.testNotification({}, {
        dialog: true,
        confirmMsg: C,
        processingMsg: strings.notify.eventProcessingMsg,
        failureMsg: strings.notify.eventError,
        successMsg: strings.notify.eventSuccess
    })
};
NotificationSetupWidget.prototype.sendLogEventCallback = function() {
    var C = {};
    if (this.findWidgetByName("notifTabs").selected == 3) {
        MC.testSysLogs(C, {
            dialog: true,
            processingMsg: strings.notify.syslogTestProcessing,
            failureMsg: strings.notify.syslogError,
            successMsg: strings.notify.syslogSuccess
        })
    } else {
        C.managedtype = {
            value: "managedlogs"
        };
        C.region = {
            value: "scdebug"
        };
        MC.testManagedLogs(C, {
            dialog: true,
            processingMsg: strings.notify.logsProcessing,
            failureMsg: strings.notify.logsError,
            successMsg: strings.notify.logsSuccess
        })
    }
};
NotificationSetupWidget.prototype.setSnmpInstructStr = function(C) {
    var D = {};
    if (C) {
        D.snmpInstr = {
            text: strings.notify.snmpInst
        }
    } else {
        D.snmpInstr = {
            text: strings.notify.snmpDisabled
        }
    }
    this.update(D)
};
NotificationSetupWidget.prototype.updateData = function(I, C, H) {
    var G;
    var D = null;
    var F = null;
    var J = null;
    var E = null;
    var K = {};
    if (!I || ((I.name != "protocolsSet") && (I.name != "snmpParametersSet") && (I.name != "emailParametersSet") && (I.name != "advancedSettingsSet") && (I.name != "syslogParametersSet"))) {
        MC.warningOutput("NotificationSetupWidget.updateData: bad dataSet name = %s", I.name);
        return
    }
    if (I.name == "protocolsSet") {
        this.protocolObj = I.getData().getObjectOfBasetype("security-communications-protocols");
        if (this.protocolObj == null) {
            return
        }
        if (decodeBooleanFlag(this.protocolObj.getPropertyValue("snmp_numeric"))) {
            this.setSnmpInstructStr(true)
        } else {
            this.setSnmpInstructStr(false)
        }
    } else {
        if (I.name == "snmpParametersSet") {
            this.snmpObj = I.getData().getObjectOfBasetype("snmp-parameters");
            if (this.snmpObj == null) {
                return
            }
            K.snmpLevel = {
                value: this.snmpObj.get("snmp_filter").toLowerCase()
            };
            if (K.snmpLevel.value == "none") {
                this.snmpFlag = false;
                K.snmpReadComm = {
                    value: this.snmpObj.getPropertyValue("snmp_read_community") || "",
                    disable: true,
                    rules: {
                        required: false
                    }
                };
                K.snmpWriteComm = {
                    value: this.snmpObj.getPropertyValue("snmp_read_community") || "",
                    disable: true,
                    rules: {
                        required: false
                    }
                };
                K.snmpHost1 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_1") || "",
                    disable: true,
                    rules: {
                        required: false
                    }
                };
                K.snmpHost2 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_2") || "",
                    disable: true,
                    rules: {
                        required: false
                    }
                };
                K.snmpHost3 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_3") || "",
                    disable: true,
                    rules: {
                        required: false
                    }
                }
            } else {
                this.snmpFlag = true;
                K.snmpReadComm = {
                    value: this.snmpObj.getPropertyValue("snmp_read_community") || "",
                    disable: false,
                    rules: {
                        required: true,
                        utf8length: 31,
                        rwCommunity: true
                    }
                };
                K.snmpWriteComm = {
                    value: this.snmpObj.getPropertyValue("snmp_write_community") || "",
                    disable: false,
                    rules: {
                        required: true,
                        utf8length: 31,
                        rwCommunity: true
                    }
                };
                K.snmpHost1 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_1") || "",
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                };
                K.snmpHost2 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_2") || "",
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                };
                K.snmpHost3 = {
                    value: this.snmpObj.getPropertyValue("snmp_trap_host_3") || "",
                    disable: false,
                    rules: {
                        required: true,
                        ipv4Address: true
                    }
                }
            }
            if (this.snmpObj.getPropertyValue("snmp_enabled").toLowerCase() == "disabled") {
                K.snmpLevel.value = "none"
            }
            if (C) {
                K.snmpLevel.setOrig = true;
                K.snmpReadComm.setOrig = true;
                K.snmpWriteComm.setOrig = true;
                K.snmpHost1.setOrig = true;
                K.snmpHost2.setOrig = true;
                K.snmpHost3.setOrig = true
            }
        } else {
            if (I.name == "emailParametersSet") {
                this.emObj = I.getData().getObjectOfBasetype("email-parameters");
                if (this.emObj == null) {
                    return
                }
                if (this.emObj.get("email_notification_filter") != "none") {
                    K.emLevel = {
                        value: this.emObj.get("email_notification_filter_numeric")
                    }
                } else {
                    K.emLevel = {
                        disable: true
                    }
                }
                emServer = this.emObj.get("email_server");
                K.emServer = {
                    value: emServer,
                    setOrig: true,
                    requiredField: true
                };
                K.emSender = {
                    value: this.emObj.get("email_sender"),
                    setOrig: true,
                    requiredField: true
                };
                if (this.emObj.get("email_smtp_port") != undefined) {
                    K.emTlsPort = {
                        value: this.emObj.get("email_smtp_port"),
                        setOrig: true
                    }
                }
                F = this.emObj.getPropertyValue("email_domain");
                K.emNotifSettings = {
                    value: (this.emObj.get("email_notification_filter") != "none"),
                    disable: (emServer == ""),
                    tooltip: ((emServer == "" || F == "") ? strings.notify.tips.emSmtpNotify : null)
                };
                K.emDomain = {
                    value: F || strings.notify.defaultEmailDomain,
                    requiredField: true
                };
                K.emEmail1 = {
                    value: this.emObj.getPropertyValue("email_notify_address_1"),
                    rules: (this.emObj.get("email_notification_filter") != "none" ? {
                        required: true
                    } : {})
                };
                K.emEmail2 = {
                    value: this.emObj.getPropertyValue("email_notify_address_2")
                };
                K.emEmail3 = {
                    value: this.emObj.getPropertyValue("email_notify_address_3")
                };
                K.emEmail4 = {
                    value: this.emObj.getPropertyValue("email_notify_address_4")
                };
                K.emProtocols = {
                    value: parseInt(this.emObj.getPropertyValue("email_security_protocol_numeric"))
                };
                if (K.emProtocols != undefined) {
                    if (K.emProtocols.value == SECURITYPROTOCOL.TLS || K.emProtocols.value == SECURITYPROTOCOL.SSL) {
                        K.emSenderPasswd = {
                            value: this.emObj.getPropertyValue("email_sender_password"),
                            setOrig: true,
                            visibility: "visible",
                            rules: {
                                required: true,
                                dhPassword: true,
                                minlength: 8,
                                characterLength: 32
                            }
                        };
                        K.emConfPasswd = {
                            value: this.emObj.getPropertyValue("email_sender_password"),
                            setOrig: true,
                            visibility: "visible",
                            rules: {
                                equalTo: "#emSenderPasswd",
                                required: true,
                                dhPassword: true,
                                minlength: 8,
                                characterLength: 32
                            }
                        }
                    } else {
                        K.emSenderPasswd = {
                            disable: true
                        };
                        K.emConfPasswd = {
                            disable: true
                        }
                    }
                }
                this.emIncludeLogs = decodeBooleanFlag(this.emObj.get("email_include_logs_numeric"));
                K.emIncludeLogs = {
                    value: this.emIncludeLogs
                };
                if (RI.hasFeature("persistentAlerts")) {
                    K.emHealthAlerts = {
                        value: decodeBooleanFlag(this.emObj.get("persistent_alerts_numeric")),
                        setOrig: C ? true : false,
                        visibility: "visible"
                    }
                } else {
                    K.emHealthAlerts = {
                        disable: true,
                        visibility: "collapse"
                    }
                }
                if ((this.emObj.get("email_notification_filter")) == "none" || (emServer == "")) {
                    this.emailFlag = false;
                    K.emEmail1.disable = true;
                    K.emEmail2.disable = true;
                    K.emEmail3.disable = true
                } else {
                    this.emailFlag = true;
                    K.emEmail1.disable = false;
                    K.emEmail2.disable = false;
                    K.emEmail3.disable = false
                }
                if (C) {
                    K.emLevel.setOrig = true;
                    K.emServer.setOrig = true;
                    K.emSender.setOrig = true;
                    K.emDomain.setOrig = true;
                    K.emNotifSettings.setOrig = true;
                    K.emEmail1.setOrig = true;
                    K.emEmail2.setOrig = true;
                    K.emEmail3.setOrig = true;
                    K.emEmail4.setOrig = true;
                    if (K.emTlsPort != undefined) {
                        K.emTlsPort.setOrig = true
                    }
                    if (K.emSenderPasswd != undefined) {
                        K.emSenderPasswd.setOrig = true
                    }
                    if (K.emConfPasswd != undefined) {
                        K.emConfPasswd.setOrig = true
                    }
                    K.emIncludeLogs.setOrig = true
                }
            } else {
                if (I.name == "advancedSettingsSet") {
                    this.advObj = I.getData();
                    this._updateManagedLogSetting(C, K)
                } else {
                    if (I.name == "syslogParametersSet") {
                        var G = I.getData().getObjectOfBasetype("syslog-parameters");
                        if (G == null) {
                            return
                        }
                        K.syslogLevel = {
                            value: G.getPropertyValue("syslog_notification_level").toLowerCase()
                        };
                        K.syslogIPAddress = {
                            value: G.getPropertyValue("syslog_host_ip") || ""
                        };
                        K.syslogPortNumber = {
                            value: G.getPropertyValue("syslog_host_port") || ""
                        };
                        if (C) {
                            K.syslogLevel.setOrig = true;
                            K.syslogIPAddress.setOrig = true;
                            K.syslogPortNumber.setOrig = true
                        }
                        this.testSysLogButtonFlag = (K.syslogLevel.value !== "none") ? true : false
                    }
                }
            }
        }
    }
    this.update(K);
    if (H) {
        this.retrieve(H)
    }
    this.setButtonState()
};
NotificationSetupWidget.prototype._updateManagedLogSetting = function(E, G) {
    if (!this.emObj || !this.snmpObj) {
        return
    }
    var D = decodeBooleanFlag(this.advObj.objects[0].get("managed_logs_numeric"));
    var F = decodeBooleanFlag(this.emObj.get("email_notification_numeric"));
    var H = this.snmpObj.get("snmp_filter") != "none";
    var C = "";
    if (!F && !H) {
        C = strings.notify.tips.mlDisabled
    }
    G.managedLogs = {
        value: D,
        disable: (!F && !H),
        tooltip: C
    };
    var I = "";
    if (D && F) {
        eilToolTip = strings.notify.tips.mlInclEmDisabled
    }
    G.emIncludeLogs = {
        disable: (!(D && F)),
        tooltip: I
    };
    G.emEmail4 = {
        disable: (!(D && F)),
        tooltip: I
    };
    this.testLogButtonFlag = (G.managedLogs.value);
    if (E) {
        G.managedLogs.setOrig = true
    }
};
NotificationSetupWidget.prototype.createSetCommands = function(D) {
    var C = [];
    if (D == undefined) {
        var D = {};
        this.retrieve(D)
    }
    if (this._isTypeChanged("snmp", D)) {
        C.push({
            name: "snmpParametersSet",
            command: MC.setSnmpParameters,
            data: this._getSnmpCommandData(D),
            options: {
                processingMsg: strings.notify.snmpProcessingMsg,
                failureMsg: strings.notify.snmpFailureMsg
            }
        })
    }
    if (this._isTypeChanged("em", D)) {
        C.push({
            name: "emailParametersSet",
            command: MC.setEmailParameters,
            data: this._getEmailCommandData(D),
            options: {
                processingMsg: strings.notify.emailProcessingMsg,
                failureMsg: strings.notify.emailFailureMsg
            }
        })
    }
    if (this._isTypeChanged("managed", D)) {
        C.push({
            name: "advancedSettingsSet",
            command: MC.setAdvancedSettings,
            data: this._getNotifyCommandData(D),
            options: {
                processingMsg: strings.advSet.advSetProcessing,
                failureMsg: strings.advSet.advSetFail
            }
        })
    }
    if (this._isTypeChanged("syslog", D)) {
        C.push({
            name: "syslogParametersSet",
            command: MC.setSyslogParameters,
            data: this._getSyslogCommandData(D),
            options: {
                processingMsg: strings.notify.syslogProcessing,
                failureMsg: strings.notify.syslogFailure
            }
        })
    }
    return C
};
NotificationSetupWidget.prototype._getSnmpCommandData = function(D) {
    var C = {
        level: D.snmpLevel.value,
        readCommunity: D.snmpReadComm.value,
        writeCommunity: D.snmpWriteComm.value,
        hosts: D.snmpHost1.value + "," + D.snmpHost2.value + "," + D.snmpHost3.value
    };
    return C
};
NotificationSetupWidget.prototype._getEmailCommandData = function(D) {
    var C = {};
    if (D.emNotifSettings.value) {
        var E;
        switch (parseInt(D.emLevel.value)) {
            case NOTIFICATION_LEVEL.CRITICAL:
                E = "crit";
                break;
            case NOTIFICATION_LEVEL.ERROR:
                E = "error";
                break;
            case NOTIFICATION_LEVEL.WARNING:
                E = "warn";
                break;
            case NOTIFICATION_LEVEL.INFO:
                E = "info";
                break;
            case NOTIFICATION_LEVEL.RESOLVED:
                E = "resolved";
                break;
            default:
                E = "none";
                break
        }
        C = {
            server: D.emServer.value,
            domain: D.emDomain.value,
            level: E,
            emails: D.emEmail1.value + "," + D.emEmail2.value + "," + D.emEmail3.value + "," + D.emEmail4.value
        }
    } else {
        C.level = "none";
        if (D.emServer.valueChanged || D.emServer.value) {
            C.server = D.emServer.value
        }
        if (D.emDomain.valueChanged || D.emDomain.value) {
            C.domain = D.emDomain.value
        }
        if (D.emEmail4.valueChanged) {
            C.emails = ",,," + D.emEmail4.value
        }
    }
    if (D.emTlsPort.valueChanged || D.emTlsPort.value) {
        C.port = D.emTlsPort.value
    }
    if (D.emProtocols.value == SECURITYPROTOCOL.TLS) {
        C.protocol = "tls"
    } else {
        if (D.emProtocols.value == SECURITYPROTOCOL.SSL) {
            C.protocol = "ssl"
        } else {
            C.protocol = "none"
        }
    }
    if (D.emSenderPasswd.valueChanged && (D.emProtocols.value == SECURITYPROTOCOL.TLS || D.emProtocols.value == SECURITYPROTOCOL.SSL)) {
        C.senderPassword = D.emSenderPasswd.value
    }
    if (D.emSender.valueChanged || D.emSender.value) {
        C.sender = D.emSender.value
    }
    if (D.emIncludeLogs.valueChanged) {
        C.includeLogs = D.emIncludeLogs.value
    }
    if (D.emHealthAlerts.valueChanged) {
        C.persistentAlerts = D.emHealthAlerts.value
    }
    return C
};
NotificationSetupWidget.prototype._getNotifyCommandData = function(D) {
    var C = {
        managed_logs: D.managedLogs.value
    };
    return C
};
NotificationSetupWidget.prototype._getSyslogCommandData = function(D) {
    var C = {
        level: D.syslogLevel.value,
        hostIP: D.syslogIPAddress.value,
        hostPort: D.syslogPortNumber.value
    };
    return C
};
NotificationSetupWidget.prototype.tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (this.widgets && this.findWidgetByName("notifTabs")) {
        switch (C) {
            case 0:
                this.update({
                    snmpConfigWidget: {
                        visibility: "collapse"
                    },
                    emailConfigWidget: {
                        visibility: "visible"
                    },
                    logNotifyWidget: {
                        visibility: "collapse"
                    },
                    sendValidationWidget: {
                        visibility: "visible"
                    },
                    syslogWidget: {
                        visibility: "collapse"
                    }
                });
                break;
            case 1:
                this.update({
                    snmpConfigWidget: {
                        visibility: "visible"
                    },
                    emailConfigWidget: {
                        visibility: "collapse"
                    },
                    logNotifyWidget: {
                        visibility: "collapse"
                    },
                    sendValidationWidget: {
                        visibility: "visible"
                    },
                    syslogWidget: {
                        visibility: "collapse"
                    }
                });
                break;
            case 2:
                this.update({
                    snmpConfigWidget: {
                        visibility: "collapse"
                    },
                    emailConfigWidget: {
                        visibility: "collapse"
                    },
                    logNotifyWidget: {
                        visibility: "visible"
                    },
                    sendValidationWidget: {
                        visibility: "visible"
                    },
                    syslogWidget: {
                        visibility: "collapse"
                    }
                });
                break;
            case 3:
                this.update({
                    snmpConfigWidget: {
                        visibility: "collapse"
                    },
                    emailConfigWidget: {
                        visibility: "collapse"
                    },
                    logNotifyWidget: {
                        visibility: "collapse"
                    },
                    sendValidationWidget: {
                        visibility: "visible"
                    },
                    syslogWidget: {
                        visibility: "visible"
                    }
                });
                break;
            default:
                MC.warningOutput("NotificationSetupWidget.tabSelected: bad tab number = %d", C);
                break
        }
        this.setButtonState();
        if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
            this.options.changeCallback()
        }
    }
};
NotificationSetupWidget.prototype.setButtonState = function() {
    var C;
    var D;
    switch (this.notifyTabs.selected) {
        case 0:
        case 1:
            C = !(this.emailFlag || this.snmpFlag);
            if (this.notifyTabs.selected == 0) {
                D = strings.notify.sendEmail
            } else {
                D = strings.notify.sendSnmp
            }
            break;
        case 2:
            C = !this.testLogButtonFlag;
            D = strings.notify.sendManageLogs;
            break;
        case 3:
            C = !this.testSysLogButtonFlag;
            D = strings.notify.sendSyslog;
            break;
        default:
            break
    }
    this.update({
        testButton: {
            disable: C,
            text: D
        }
    })
};
NotificationSetupWidget.prototype.dataUpdated = function() {
    if (this.emObj != undefined && this.snmpObj != undefined && this.protocolObj != undefined && this.advObj != undefined) {
        return true
    }
    return false
};

function NetworkConfigWidget(E) {
    if (arguments.length == 0 || E.name == undefined) {
        return
    }
    var C = this;
    var D = createObjectCallback(this, this.changeCallback);
    E.widgets = [new TableWidget({
        name: "nwConfigSettings",
        widgets: [new ComboBoxWidget({
            name: "nwDHCP",
            label: strings.networkConfig.nwDHCPLabel,
            row: 0,
            col: 1,
            leftMargin: true,
            bottomMargin: true,
            singleCell: true,
            size: 60,
            values: [{
                value: "DHCP",
                text: strings.networkConfig.nwDHCPValue
            }, {
                value: "Manual",
                text: strings.networkConfig.nwManualValue
            }],
            changeCallback: createObjectCallback(C, C.dhcpChange),
            showing: createObjectCallback(C, C.dhcpChange),
            setOrig: true,
            value: "DHCP"
        })]
    }), new TableWidget({
        name: "NetworkConfigTable",
        widgets: [new TableWidget({
            name: "nwConfigTableWidgetA",
            row: 0,
            col: 0,
            bottomMargin: true,
            cellClasses: "boxNoRightSideBorder",
            data: {},
            widgets: [new LabelWidget({
                name: "nwAtitle",
                row: 0,
                col: 0,
                colSpan: 2,
                value: strings.networkConfig.nwAtitleText,
                topMargin: true,
                bottomMargin: true,
                setOrig: true,
                classes: "formTableHeadingCenter"
            }), new TextInputWidget({
                name: "nwIPaddrA",
                label: strings.networkConfig.nwIPaddrLabel,
                row: 1,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rightMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            }), new TextInputWidget({
                name: "nwIPmaskA",
                label: strings.networkConfig.nwIPmaskLabel,
                row: 2,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rightMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            }), new TextInputWidget({
                name: "nwIPgatewayA",
                label: strings.networkConfig.nwIPgatewayLabel,
                row: 3,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rightMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            })]
        }), new TableWidget({
            name: "nwConfigTableWidgetB",
            row: 0,
            col: 1,
            bottomMargin: true,
            cellClasses: "nwborder3Px",
            data: {},
            widgets: [new LabelWidget({
                name: "nwBtitle",
                row: 0,
                col: 0,
                colSpan: 2,
                value: strings.networkConfig.nwBtitleText,
                topMargin: true,
                bottomMargin: true,
                setOrig: true,
                classes: "formTableHeadingCenter"
            }), new TextInputWidget({
                name: "nwIPaddrB",
                label: strings.networkConfig.nwIPaddrLabel,
                row: 2,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            }), new TextInputWidget({
                name: "nwIPmaskB",
                label: strings.networkConfig.nwIPmaskLabel,
                row: 3,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            }), new TextInputWidget({
                name: "nwIPgatewayB",
                label: strings.networkConfig.nwIPgatewayLabel,
                row: 4,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                rules: {
                    ipv4Address: true
                },
                setOrig: true,
                changeCallback: D
            })]
        })]
    })];
    TableWidget.call(this, E);
    this.class_name = "NetworkConfigWidget"
}
NetworkConfigWidget.prototype = new WidgetContainer();
NetworkConfigWidget.prototype.constructor = NetworkConfigWidget;
NetworkConfigWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
NetworkConfigWidget.prototype.loadData = function() {
    this.enclosuresSubscription = MC.enclosuresSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData(true, C)
        })
    })
};
NetworkConfigWidget.prototype.getPropertyValue = function(D, C) {
    if (D.getPropertyValue(C) == "Not Present") {
        return strings.networkConfig.nwNotPresent
    }
    return D.getPropertyValue(C)
};
NetworkConfigWidget.prototype.updateData = function(D, C) {
    if (!DC.networkParameters) {
        return
    }
    var H = {};
    var J = false;
    if (DC.base["advanced-settings-table"].singleton.getInt("single_controller_numeric") || (DC.networkParameters.mgmtport_a == undefined) || (DC.networkParameters.mgmtport_b == undefined)) {
        J = true
    }
    var E = system.local_controller;
    this.otherCntrl = (E == "A") ? "B" : "A";
    this.ctrlDown = {
        A: (J && E == "B") ? true : DC.controllers.A.getInt("status_numeric") != 0,
        B: (J && E == "A") ? true : DC.controllers.B.getInt("status_numeric") != 0
    };
    var L = {
        A: (J && E == "B") ? undefined : DC.networkParameters.mgmtport_a,
        B: (J && E == "A") ? undefined : DC.networkParameters.mgmtport_b
    };
    if (this.networkAChanged != undefined || this.networkBChanged != undefined) {
        var F = {};
        this.retrieve(F);
        if (this.networkAChanged != undefined && this.networkBChanged == undefined && (F.nwIPaddrA.value == L.A.get("ip_address") && F.nwIPmaskA.value == L.A.get("subnet_mask") && F.nwIPgatewayB.value == L.A.get("gateway"))) {
            this.networkAChanged = undefined;
            ShowActiveDialog({
                type: "success",
                dialogOverride: true,
                message: strings.networkConfig.nwSuccess
            })
        } else {
            if (this.networkBChanged != undefined && this.networkAChanged == undefined && (F.nwIPaddrB.value == L.B.get("ip_address") && F.nwIPmaskB.value == L.B.get("subnet_mask") && F.nwIPgatewayB.value == L.B.get("gateway"))) {
                this.networkBChanged = undefined;
                ShowActiveDialog({
                    type: "success",
                    dialogOverride: true,
                    message: strings.networkConfig.nwSuccess
                })
            } else {
                if (this.networkBChanged != undefined && this.networkAChanged != undefined && (F.nwIPaddrA.value == L.A.get("ip_address") && F.nwIPmaskA.value == L.A.get("subnet_mask") && F.nwIPgatewayB.value == L.A.get("gateway")) && (F.nwIPaddrB.value == L.B.get("ip_address") && F.nwIPmaskB.value == L.B.get("subnet_mask") && F.nwIPgatewayB.value == L.B.get("gateway"))) {
                    this.networkBChanged = undefined;
                    this.networkAChanged = undefined;
                    ShowActiveDialog({
                        type: "success",
                        dialogOverride: true,
                        message: strings.networkConfig.nwSuccess
                    })
                } else {
                    return
                }
            }
        }
    }
    var G = L[E].get("active_version");
    var I = L[E].getInt("addressing_mode_numeric");
    var K;
    this.aMode = (typeof L.A != "undefined") ? parseInt(L.A.getPropertyValue("addressing_mode_numeric")) : undefined;
    this.bMode = (typeof L.B != "undefined") ? parseInt(L.B.getPropertyValue("addressing_mode_numeric")) : undefined;
    switch (I) {
        case 2:
            H.nwDHCP = {
                value: "DHCP"
            };
            break;
        default:
            H.nwDHCP = {
                value: "Manual"
            };
            break
    }
    H.nwIpv6Mode = {
        value: (G == "6")
    };
    K = (H.nwIpv6Mode.value) ? {
        ipv6Address: true
    } : {
        ipv4Address: true
    };
    if (J) {
        H["nwConfigTableWidget" + this.otherCntrl] = {
            disable: true,
            visibility: "collapse"
        };
        H["nwIPaddr" + E] = {
            value: L[E].get("ip_address")
        };
        H["nwIPmask" + E] = {
            value: L[E].get("subnet_mask"),
            rules: K
        };
        H["nwIPgateway" + E] = {
            value: L[E].get("gateway"),
            rules: K
        }
    } else {
        H.nwIPaddrA = {
            value: L.A.get("ip_address")
        };
        H.nwIPmaskA = {
            value: L.A.get("subnet_mask"),
            rules: K
        };
        H.nwIPgatewayA = {
            value: L.A.get("gateway"),
            rules: K
        };
        H.nwIPaddrB = {
            value: L.B.get("ip_address"),
            rules: K
        };
        H.nwIPmaskB = {
            value: L.B.get("subnet_mask"),
            rules: K
        };
        H.nwIPgatewayB = {
            value: L.B.get("gateway"),
            rules: K
        }
    }
    if (!J && this.ctrlDown[this.otherCntrl]) {
        this.setFields(this.otherCntrl, H, true)
    }
    if (D) {
        H.nwIpv6Mode.setOrig = true;
        H.nwDHCP.setOrig = true;
        if (L.A) {
            H.nwIPaddrA.setOrig = true;
            H.nwIPmaskA.setOrig = true;
            H.nwIPgatewayA.setOrig = true
        }
        if (L.B) {
            H.nwIPaddrB.setOrig = true;
            H.nwIPmaskB.setOrig = true;
            H.nwIPgatewayB.setOrig = true
        }
    }
    this.update(H);
    if (C) {
        this.retrieve(C)
    }
    this.initialized = true
};
NetworkConfigWidget.prototype.newIPs = function() {
    var D = {};
    var C = {};
    this.retrieve(D);
    if (D.nwIPaddrA.valueChanged) {
        C.IPaddrA = D.nwIPaddrA.value
    }
    if (D.nwIPaddrB.valueChanged) {
        C.IPaddrB = D.nwIPaddrB.value
    }
    return C
};
NetworkConfigWidget.prototype.update = function(D, C) {
    TableWidget.prototype.update.call(this, D);
    if (!C) {
        this.dhcpChange()
    }
};
NetworkConfigWidget.prototype.setFields = function(C, E, D) {
    E["nwIPaddr" + C].disable = D;
    E["nwIPmask" + C].disable = D;
    E["nwIPgateway" + C].disable = D
};
NetworkConfigWidget.prototype.dhcpChange = function(M, I, J) {
    if (!this.initialized) {
        return
    }
    var D = false;
    var E = $.data($(this.elements).parents().filter("form").get(0), "dh-form");
    var H = {};
    this.retrieve(H, true);
    if (!isIndysystem() && !isHPsystem() && H.nwDHCP.valueChanged && H.nwDHCP.value == "Manual") {
        H.nwIPaddrA.value = "";
        H.nwIPmaskA.value = "";
        H.nwIPgatewayA.value = "";
        H.nwIPaddrB.value = "";
        H.nwIPmaskB.value = "";
        H.nwIPgatewayB.value = "";
        H.nwIPaddrA.skipValidation = true;
        H.nwIPmaskA.skipValidation = true;
        H.nwIPgatewayA.skipValidation = true;
        H.nwIPaddrB.skipValidation = true;
        H.nwIPmaskB.skipValidation = true;
        H.nwIPgatewayB.skipValidation = true;
        H.nwIPaddrA.setOrig = true;
        H.nwIPmaskA.setOrig = true;
        H.nwIPgatewayA.setOrig = true;
        H.nwIPaddrB.setOrig = true;
        H.nwIPmaskB.setOrig = true;
        H.nwIPgatewayB.setOrig = true;
        D = true
    }
    if (!isIndysystem() && !H.nwDHCP.valueChanged && H.nwDHCP.value == "DHCP" && !H.nwIPaddrA.value) {
        var L = DC.networkParameters.mgmtport_a;
        var K = DC.networkParameters.mgmtport_b;
        if (typeof L != "undefined") {
            H.nwIPaddrA.value = this.getPropertyValue(L, "ip_address");
            H.nwIPmaskA.value = this.getPropertyValue(L, "subnet_mask");
            H.nwIPgatewayA.value = this.getPropertyValue(L, "gateway")
        }
        if (typeof K != "undefined") {
            H.nwIPaddrB.value = this.getPropertyValue(K, "ip_address");
            H.nwIPmaskB.value = this.getPropertyValue(K, "subnet_mask");
            H.nwIPgatewayB.value = this.getPropertyValue(K, "gateway")
        }
    }
    var G = {
        A: (!this.aMode || H.nwDHCP.value == "DHCP"),
        B: (!this.bMode || H.nwDHCP.value == "DHCP")
    };
    for (var C in {
            A: true,
            B: true
        }) {
        if (G[C] || this.ctrlDown[C]) {
            this.setFields(C, H, true)
        } else {
            this.setFields(C, H, false)
        }
    }
    this.update(H, true);
    if (!D) {
        E.resetValidation()
    }
    var F = {};
    if (!F[this.name]) {
        F[this.name] = {}
    }
    this.valueChanged = false;
    if (H.nwDHCP.valueChanged) {
        if (H.nwDHCP.value == "DHCP") {
            this.valueChanged = true
        } else {
            if (H.nwDHCP.value == "Manual" && (H.nwIPaddrA.value != "" && !H.nwIPaddrA.invalid)) {
                this.valueChanged = true;
                this.valueChangedA = true
            } else {
                if (H.nwDHCP.value == "Manual" && (H.nwIPaddrB.value != "" && !H.nwIPaddrB.invalid)) {
                    this.valueChanged = true;
                    this.valueChangedB = true
                }
            }
        }
        F[this.name].valueChanged = this.valueChanged;
        if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
            this.options.changeCallback(F, this)
        }
    }
};
NetworkConfigWidget.prototype.createSetCommands = function(C, H) {
    var F = [];
    var E = false;
    var D = false;
    if (H == undefined) {
        var H = {};
        this.retrieve(H)
    }
    if (C == undefined) {
        C = system.local_controller_numeric
    }
    if (H.nwDHCP.value == "Manual" && (H.nwIPaddrA.valueChanged || H.nwIPgatewayA.valueChanged || H.nwIPmaskA.valueChanged) && (H.nwIPaddrA.value != "" && !H.nwIPaddrA.invalid) && (H.nwIPgatewayA.value != "" && !H.nwIPgatewayA.invalid) && (H.nwIPmaskA.value != "" && !H.nwIPmaskA.invalid)) {
        E = true
    }
    if (H.nwDHCP.value == "Manual" && (H.nwIPaddrB.valueChanged || H.nwIPgatewayB.valueChanged || H.nwIPmaskB.valueChanged) && (H.nwIPaddrB.value != "" && !H.nwIPaddrB.invalid) && (H.nwIPgatewayB.value != "" && !H.nwIPgatewayB.invalid) && (H.nwIPmaskB.value != "" && !H.nwIPmaskB.invalid)) {
        D = true
    }
    if (H.nwDHCP.value == "DHCP") {
        F.push({
            name: "dhcp",
            command: MC.setNetworkParameters,
            data: {
                dhcp: true
            },
            params: {
                dhcp: true
            },
            options: {
                processingMsg: strings.networkConfig.nwModifyingDHCP,
                failureMsg: strings.networkConfig.nwErrorDHCP,
                successMsg: strings.networkConfig.nwSuccess
            }
        })
    } else {
        var G = {
            name: "network_a",
            command: MC.setNetworkParameters,
            data: {
                controller: "a",
                ip: H.nwIPaddrA.value,
                netmask: H.nwIPmaskA.value,
                gateway: H.nwIPgatewayA.value
            },
            options: {
                noSuccessDialog: true,
                processingMsg: strings.networkConfig.nwModifyingA,
                failureMsg: strings.networkConfig.nwErrorA,
                successMsg: strings.networkConfig.nwSuccess,
                callback: createObjectCallback(this, this._networkCallback, "a")
            }
        };
        var I = {
            name: "network_b",
            command: MC.setNetworkParameters,
            data: {
                controller: "b",
                ip: H.nwIPaddrB.value,
                netmask: H.nwIPmaskB.value,
                gateway: H.nwIPgatewayB.value
            },
            options: {
                noSuccessDialog: true,
                processingMsg: strings.networkConfig.nwModifyingB,
                failureMsg: strings.networkConfig.nwErrorB,
                successMsg: strings.networkConfig.nwSuccess,
                callback: createObjectCallback(this, this._networkCallback, "b")
            }
        };
        if (C == 0) {
            I.options.redirectIP = this.newIPs().IPaddrB;
            if (isIndysystem() && H.nwDHCP.valueChanged) {
                F.push(G);
                F.push(I)
            } else {
                if (this.valueChangedA || E) {
                    F.push(G)
                }
                if (this.valueChangedB || D) {
                    F.push(I)
                }
            }
        } else {
            G.options.redirectIP = this.newIPs().IPaddrA;
            if (isIndysystem() && H.nwDHCP.valueChanged) {
                F.push(I);
                F.push(G)
            } else {
                if (this.valueChangedA || E) {
                    F.push(G)
                }
                if (this.valueChangedB || D) {
                    F.push(I)
                }
            }
        }
    }
    return F
};
NetworkConfigWidget.prototype._networkCallback = function(D, C) {
    if (C) {
        if (D == "a") {
            this.networkAChanged = true
        } else {
            this.networkBChanged = true
        }
    }
};
NetworkConfigWidget.prototype.changeCallback = function(M, G, I) {
    var F, E = {};
    this.valueChanged = false;
    this.retrieve(E);
    var H;
    var L = false;
    if (DC.base["advanced-settings-table"].singleton.getInt("single_controller_numeric")) {
        H = DC.controllers[system.local_controller].get("controller_id");
        L = true
    }
    if (I != undefined && I.type == "focusout") {
        this.valueChanged = false;
        var K = false;
        var J = false;
        var D = (system.local_controller_numeric == 1) ? "A" : "B";
        if (!L || (L && D == A)) {
            if ((E.nwIPaddrA.valueChanged || E.nwIPgatewayA.valueChanged || E.nwIPmaskA.valueChanged) && (E.nwIPaddrA.value != "" && !E.nwIPaddrA.invalid) && (E.nwIPgatewayA.value != "" && !E.nwIPgatewayA.invalid) && (E.nwIPmaskA.value != "" && !E.nwIPmaskA.invalid)) {
                K = true
            }
        }
        if (!L || (L && D == B)) {
            if ((E.nwIPaddrB.valueChanged || E.nwIPgatewayB.valueChanged || E.nwIPmaskB.valueChanged) && (E.nwIPaddrB.value != "" && !E.nwIPaddrB.invalid) && (E.nwIPgatewayB.value != "" && !E.nwIPgatewayB.invalid) && (E.nwIPmaskB.value != "" && !E.nwIPmaskB.invalid)) {
                J = true
            }
        }
        if (K || J) {
            this.valueChanged = true
        }
    }
    var C = {};
    if (!C[this.name]) {
        C[this.name] = {}
    }
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
        C[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(C, this)
    }
};
NetworkConfigWidget.prototype.getConfirmMsg = function() {
    var C = {};
    this.retrieve(C);
    var D = '<div class="confirmLabel"><u>' + strings.configurationWizard.nwStep + "</u></div><br>";
    if (C.nwDHCP.valueChanged) {
        D += strings.networkConfig.nwDHCPLabel + ": " + C.nwDHCP.value + "<br>"
    }
    if (C.nwIPaddrA.valueChanged) {
        D += strings.networkConfig.nwAtitleText + " " + strings.networkConfig.nwIPaddrLabel + ": " + C.nwIPaddrA.value + "<br>"
    }
    if (C.nwIPmaskA.valueChanged) {
        D += strings.networkConfig.nwAtitleText + " " + strings.networkConfig.nwIPmaskLabel + ": " + C.nwIPmaskA.value + "<br>"
    }
    if (C.nwIPgatewayA.valueChanged) {
        D += strings.networkConfig.nwAtitleText + " " + strings.networkConfig.nwIPgatewayLabel + ": " + C.nwIPgatewayA.value + "<br>"
    }
    if (C.nwIPaddrB.valueChanged) {
        D += strings.networkConfig.nwBtitleText + " " + strings.networkConfig.nwIPaddrLabel + ": " + C.nwIPaddrB.value + "<br>"
    }
    if (C.nwIPmaskB.valueChanged) {
        D += strings.networkConfig.nwBtitleText + " " + strings.networkConfig.nwIPmaskLabel + ": " + C.nwIPmaskB.value + "<br>"
    }
    if (C.nwIPgatewayB.valueChanged) {
        D += strings.networkConfig.nwBtitleText + " " + strings.networkConfig.nwIPgatewayLabel + ": " + C.nwIPgatewayB.value + "<br>"
    }
    D += strings.networkConfig.confirmMsg + "<br>";
    return D
};

function PortConfigWidget(F) {
    if (arguments.length == 0) {
        return
    }
    if (F.name == undefined) {
        return
    }
    WidgetContainer.call(this, F);
    this.class_name = "PortConfigWidget";
    this.initialized = false;
    this.iscsiGatewayRow = {};
    this.iscsiNetmaskRow = {};
    this.iscsiIpAddress = {};
    this.ctrlInfo = getControllerInfo();
    this.hasISCSI = [false, false];
    this.hasFC = [false, false];
    this.hasSAS = [false, false];
    this.hasIB = [false, false];
    this.isHybrid = [false, false];
    this.ipv6Rules = {
        ipv6Address: true
    };
    this.ipv4Rules = {
        ipv4Address: true
    };
    this.ipv6ISNSRules = {
        ipv6AddressLong: true
    };
    this.controllerStatus = {
        A: (DC.controllers.A) ? (DC.controllers.A.getInt("status_numeric") == 0) : false,
        B: (DC.controllers.B) ? (DC.controllers.B.getInt("status_numeric") == 0) : false
    };
    this.portTypes = [
        [],
        []
    ];
    var G = 0;
    for (var D in DC.controllers) {
        var E = 0;
        for (var C in DC.controllers[D].ports) {
            this.portTypes[G][E] = "noType";
            E++
        }
        G++
    }
    this.maxPortCols = Math.max(this.portTypes[0].length, this.portTypes[1].length);
    MC.enclosuresSet.requestData({
        update: false,
        durable: false,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._createFields)
    })
}
PortConfigWidget.prototype = new WidgetContainer();
PortConfigWidget.prototype.constructor = PortConfigWidget;
PortConfigWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
PortConfigWidget.prototype.loadData = function() {
    this.enclosuresSubscription = MC.enclosuresSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateData("ports", true)
        })
    });
    if (APIPort.hasPortType("iSCSI")) {
        this.iscsiParamsSubscription = MC.iscsiParametersSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, function(C) {
                this.updateData("iscsiParams", true)
            })
        })
    }
    if (APIPort.hasPortType("IB")) {
        this.iBParamsSubscription = MC.infiniBandParametersSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, function(C) {
                this.updateData("ibParams", true)
            })
        })
    }
};
PortConfigWidget.prototype.hiding = function() {
    if (this.iscsiParamsSubscription) {
        MC.iscsiParametersSet.unregister(this.iscsiParamsSubscription);
        delete this.iscsiParamsSubscription
    }
    if (this.iBParamsSubscription) {
        MC.infiniBandParametersSet.unregister(this.iBParamsSubscription);
        delete this.iBParamsSubscription
    }
    if (this.enclosuresSubscription) {
        MC.enclosuresSet.unregister(this.enclosuresSubscription);
        delete this.enclosuresSubscription
    }
};
PortConfigWidget.SPEEDMAP = {
    0: "1g",
    1: "2g",
    2: "4g",
    3: "auto",
    7: "8g",
    12: "16g"
};
PortConfigWidget.CTL = {
    A: 1,
    B: 0,
    0: "B",
    1: "A"
};
PortConfigWidget.done = -1;
PortConfigWidget.prototype._flagChange = function(D) {
    this.valueChanged = false;
    for (var C in D) {
        if (D[C].valueChanged) {
            this.valueChanged = true
        }
    }
};
PortConfigWidget.prototype._fireChange = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    this._flagChange(D);
    var C = {};
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
        if (!C[this.name]) {
            C[this.name] = {}
        }
        C[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(C, this, F)
    }
};
PortConfigWidget.prototype.updateData = function(T, I, R) {
    if (!DC || (T != "ports" && T != "iscsiParams" && T != "ibParams")) {
        return
    }
    if ((typeof I) == "object") {
        R = I;
        I = false
    }
    this.origFlag = I;
    var V = {};
    if (T == "ports" && DC.ports) {
        for (var C in DC.ports) {
            var J = DC.ports[C];
            if (J.basetype == "port") {
                var G = J.getPropertyValue("port");
                var D = J.getPropertyValue("port_type");
                var S = "port_" + G + "_";
                var O = J.get("controller");
                this.fanout = J.getInt("fan_out");
                switch (D) {
                    case "FC":
                        var U = J.getPropertyValue("configured_speed_numeric");
                        var K = J.objects[0].getPropertyValue("configured_topology").toLowerCase();
                        var F = J.get("status");
                        if (K == "ptp") {
                            K = "point-to-point"
                        }
                        V[S + "speed"] = {
                            value: PortConfigWidget.SPEEDMAP[U],
                            disable: (!this.controllerStatus[O])
                        };
                        V[S + "mode"] = {
                            value: K,
                            disable: (!this.controllerStatus[O])
                        };
                        V[S + "linkStatus"] = {
                            text: F
                        };
                        if (I) {
                            V[S + "speed"].setOrig = true;
                            V[S + "mode"].setOrig = true;
                            V[S + "linkStatus"].setOrig = true
                        }
                        break;
                    case "SAS":
                        var U = J.getPropertyValue("actual_speed");
                        var L = J.getPropertyValue("_sas_lanes_expected");
                        var E = J.getPropertyValue("_sas_active_lanes");
                        V[S + "speed"] = {
                            text: U
                        };
                        V[S + "fanout"] = {
                            text: ((this.fanout > 1) ? strings.portconfig.fanoutCable : strings.portconfig.stdCable)
                        };
                        V[S + "lanesExpected"] = {
                            text: L
                        };
                        V[S + "activeLanes"] = {
                            text: E
                        };
                        V.fanoutCheckbox = {
                            value: (this.fanout > 1) ? true : false,
                            setOrig: true
                        };
                        break;
                    case "iSCSI":
                        var P = J.objects[0];
                        var Q = P.get("ip_version");
                        V[S + "IP"] = {
                            value: P.get("ip_address"),
                            disable: (!this.controllerStatus[O])
                        };
                        V.iscsi_ip_version = {
                            value: Q
                        };
                        if (Q == "IPv4") {
                            V[S + "IP"].rules = this.ipv4Rules;
                            V[S + "maskOrRouter"] = {
                                value: P.get("netmask"),
                                rules: this.ipv4Rules,
                                disable: (!this.controllerStatus[O])
                            };
                            V[S + "gateway"] = {
                                value: P.get("gateway"),
                                rules: this.ipv4Rules,
                                disable: (!this.controllerStatus[O])
                            }
                        } else {
                            V[S + "maskOrRouter"] = {
                                value: P.get("default_router"),
                                rules: this.ipv6Rules,
                                disable: (!this.controllerStatus[O])
                            }
                        }
                        if (I) {
                            V[S + "IP"].setOrig = true;
                            V[S + "maskOrRouter"].setOrig = true;
                            (V[S + "gateway"] ? V[S + "gateway"].setOrig = true : null);
                            V.iscsi_ip_version.setOrig = true
                        }
                        break;
                    case "IB":
                        var P = J.objects[0];
                        V[S + "IP"] = {
                            value: P.get("ip_address")
                        };
                        V[S + "IP"].rules = this.ipv4Rules;
                        V[S + "netmask"] = {
                            value: P.get("netmask"),
                            rules: this.ipv4Rules
                        };
                        V[S + "guid"] = {
                            value: P.get("GUID_address")
                        };
                        if (I) {
                            V[S + "IP"].setOrig = true;
                            V[S + "netmask"].setOrig = true;
                            V[S + "guid"].setOrig = true
                        }
                        break;
                    default:
                        MC.warningOutput("Unknown port media type: %s", D);
                        break
                }
            }
        }
        this.update(V)
    } else {
        if (DC.iscsiParams && (this.hasISCSI[PortConfigWidget.CTL.A] || this.hasISCSI[PortConfigWidget.CTL.B])) {
            var J = DC.iscsiParams;
            if (J.prop) {
                var Q = J.get("iscsi_ip_version");
                var H = {};
                var M = decodeBooleanFlag(J.get("isns_numeric"));
                if (M) {
                    if (Q == "4") {
                        H = this.ipv4Rules
                    } else {
                        H = this.ipv6ISNSRules
                    }
                }
                V.iscsi_chap = {
                    value: (decodeBooleanFlag(J.get("chap_numeric")) ? true : false)
                };
                V.iscsi_jumbo = {
                    value: (decodeBooleanFlag(J.get("jumbo_frames_numeric")) ? true : false)
                };
                V.iscsi_isns = {
                    value: (M ? true : false)
                };
                V.iscsi_isns_ip = {
                    value: J.get("isns_ip"),
                    rules: H
                };
                V.iscsi_isns_alt_ip = {
                    value: J.get("isns_alt_ip"),
                    rules: H
                };
                if (I) {
                    V.iscsi_chap.setOrig = true;
                    V.iscsi_jumbo.setOrig = true;
                    V.iscsi_isns.setOrig = true;
                    V.iscsi_isns_ip.setOrig = true;
                    V.iscsi_isns_alt_ip.setOrig = true
                }
                this.update(V);
                this.isnsChange()
            }
        } else {
            if (DC.infinibandParams && (this.hasIB[PortConfigWidget.CTL.A] || this.hasIB[PortConfigWidget.CTL.B])) {
                var J = DC.infinibandParams;
                if (J.prop) {
                    var Q = "IPV" + J.get("ip_version");
                    V.IB_chap = {
                        value: (decodeBooleanFlag(J.get("chap_numeric")) ? true : false)
                    };
                    V.IB_ip_version = {
                        value: Q
                    };
                    if (I) {
                        V.IB_chap.setOrig = true
                    }
                    this.update(V)
                }
            }
        }
    }
    if (this.hostPortMode != undefined) {
        var N = {};
        switch (this.hostPortMode) {
            case "HYBRID":
                N.modeList = {
                    value: "FC-and-iSCSI",
                    setOrig: true
                };
                break;
            case "FC":
                N.modeList = {
                    value: "FC",
                    setOrig: true
                };
                break;
            case "iSCSI":
                N.modeList = {
                    value: "iSCSI",
                    setOrig: true
                };
                break;
            default:
                break
        }
        this.update(N)
    }
    if (R) {
        this.retrieve(R)
    }
    this.initialized = true;
    this.valueChanged = false
};
PortConfigWidget.prototype._createFields = function(E) {
    var H = 0,
        J = 0,
        L = 0,
        C = 0,
        G = 0,
        D = 0;
    if (this.initialized) {
        return
    }
    if (!DC.ports) {
        return
    }
    this.portTabWidget = new WidgetContainer({
        name: "portTabWidget",
        widgets: [this.portTable = new TableWidget({
            name: "portTbl",
            bottomMargin: true
        }), this.hostPortWidget = new WidgetContainer({
            name: "hostportWidget",
            topMargin: true
        })]
    });
    this._getPortTypes();
    this.hostPortMode = getHostPortMode();
    var F, I;
    if (this.ctrlInfo.count == 1) {
        F = I = PortConfigWidget.CTL[system.local_controller]
    } else {
        F = PortConfigWidget.CTL.A;
        I = PortConfigWidget.CTL.B
    }
    for (H = 0, L = F; L >= I; --L) {
        J = 1;
        D = 0;
        H = this._createPortColumnHeaders(L, H, J);
        J = 1;
        for (C = 0; C < this.maxPortCols; C++) {
            var K = ((C == 0) || ((this.portTypes[L][C] != this.portTypes[L][C - 1])));
            if (K) {
                J++
            }
            switch (this.portTypes[L][C]) {
                case "FC":
                    this._createFCfields(L, C, H, J++, K);
                    D = (D < 2) ? 2 : D;
                    break;
                case "SAS":
                    D = (D < 1) ? 1 : D;
                    this._createSASfields(L, C, H, J++, K);
                    this.sasConfigSystem = true;
                    break;
                case "iSCSI":
                    this._createISCSIfields(L, C, H, J++, K);
                    D = (D < 3) ? 3 : D;
                    break;
                case "IB":
                    this._createIBfields(L, C, H, J++, K);
                    D = (D < 3) ? 3 : D;
                    break;
                default:
                    MC.warningOutput("Unknown port media type to create column: %s", this.portTypes[L][C]);
                    break
            }
        }
        H += D
    }
    if ((this.hostPortMode != "SAS") && !EXPR.isGalliumEX3 && RI.hasFeature("hybridConfigurable")) {
        this._createHostPortMode()
    }
    if (this.hasISCSI[PortConfigWidget.CTL.A] || this.hasISCSI[PortConfigWidget.CTL.B]) {
        this.add(this.portTabs = new TabWidget({
            name: "portTabs",
            type: "Primary",
            width: this.options.width,
            changeCallback: createObjectCallback(this, this._tabSelected),
            tabs: [{
                name: "tabPortConf",
                label: strings.hostPorts.portTab
            }, {
                name: "AdvancedPortConf",
                label: strings.hostPorts.AdvTab
            }]
        }));
        this.advIscsiTable = this._createIscsiCommon();
        this.portTabs.add(this.portTabWidget);
        this.portTabs.add(this.advIscsiTable);
        this._tabSelected(0)
    } else {
        if (this.hasIB[PortConfigWidget.CTL.A] || this.hasIB[PortConfigWidget.CTL.B]) {
            this.add(this.portTabs = new TabWidget({
                name: "portTabs",
                type: "Primary",
                width: this.options.width,
                changeCallback: createObjectCallback(this, this._tabSelected),
                tabs: [{
                    name: "tabPortConf",
                    label: strings.hostPorts.portTab
                }, {
                    name: "AdvancedPortConf",
                    label: strings.hostPorts.AdvTab
                }]
            }));
            this.advIBTable = this._createIBCommon();
            this.portTabs.add(this.portTable);
            this.portTabs.add(this.advIBTable);
            this._tabSelected(0)
        } else {
            this.add(this.portTabWidget);
            if (EXPR.isFanOutSupported === true) {
                this._createFanoutSection(H)
            }
        }
    }
    setTimeout(createObjectCallback(this, this._processWidgets), 100)
};
PortConfigWidget.prototype._processWidgets = function() {
    this.form = $.data($(this.elements).parents().filter("form").get(0), "dh-form");
    this.form.processWidgets();
    this.initialized = true
};
PortConfigWidget.prototype._createFCfields = function(K, D, F, H, I) {
    var J = [{
        value: "4g",
        text: strings.portconfig.four_gb
    }, {
        value: "8g",
        text: strings.portconfig.eight_gb
    }];
    if (!(this.ctrlInfo.isEX && isHPsystem())) {
        J.push({
            value: "16g",
            text: strings.portconfig.sixteen_gb
        })
    }
    J.push({
        value: "auto",
        text: strings.portconfig.auto_gb
    });
    var C = {
        name: this._mkPortStr(K, D) + "_speed",
        row: F++,
        col: H,
        leftMargin: true,
        topSmallMargin: true,
        width: 90,
        setOrig: true,
        changeCallback: createObjectCallback(this, this._fireChange),
        values: J
    };
    var G = {
        name: this._mkPortStr(K, D) + "_mode",
        row: F++,
        col: H,
        leftMargin: true,
        topSmallMargin: true,
        width: 90,
        setOrig: true,
        changeCallback: createObjectCallback(this, this._fireChange),
        values: [{
            value: "point-to-point",
            text: strings.portconfig.p2p
        }, {
            value: "auto",
            text: strings.portconfig.auto
        }]
    };
    var E = {
        name: this._mkPortStr(K, D) + "_linkStatus",
        row: F++,
        col: H,
        leftMargin: true,
        topSmallMargin: true
    };
    if (I) {
        C.label = strings.portconfig.speedLabel;
        C.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        G.label = strings.portconfig.modeLabel;
        G.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        E.label = strings.portconfig.fcLinkStatusLabel;
        E.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        }
    }
    this.portTable.add(new ComboBoxWidget(C));
    this.portTable.add(new ComboBoxWidget(G));
    this.portTable.add(new TextWidget(E))
};
PortConfigWidget.prototype._createSASfields = function(K, D, H, I, J) {
    var C = {
        name: this._mkPortStr(K, D) + "_speed",
        row: H++,
        col: I,
        leftMargin: true,
        topSmallMargin: true,
        cssClass: "formTableNoteCenter"
    };
    var G = {
        name: this._mkPortStr(K, D) + "_fanout",
        row: H++,
        col: I,
        leftMargin: true,
        topSmallMargin: true,
        cssClass: "formTableNoteCenter"
    };
    var E = {
        name: this._mkPortStr(K, D) + "_lanesExpected",
        row: H++,
        col: I,
        leftMargin: true,
        topSmallMargin: true,
        cssClass: "formTableNoteCenter"
    };
    var F = {
        name: this._mkPortStr(K, D) + "_activeLanes",
        row: H++,
        col: I,
        leftMargin: true,
        topSmallMargin: true,
        cssClass: "formTableNoteCenter"
    };
    if (J) {
        C.label = strings.portconfig.speedLabel;
        C.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        G.label = strings.portconfig.cableTypeLabel;
        G.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        E.label = strings.portconfig.lanesExpectedLabel;
        E.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        F.label = strings.portconfig.activeLanesLabel;
        F.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        }
    }
    this.portTable.add(new TextWidget(C));
    this.portTable.add(new TextWidget(G));
    this.portTable.add(new TextWidget(E));
    this.portTable.add(new TextWidget(F))
};
PortConfigWidget.prototype._createFanoutSection = function(C) {
    this.add(new LabeledWidgetContainer({
        name: "fanoutSection",
        label: strings.portconfig.fanoutConfigLabel,
        leftMargin: true,
        rightMargin: true,
        topMargin: true,
        widgets: [new TextWidget({
            name: "fanoutDescription",
            text: strings.portconfig.fanoutDescription,
            row: C++,
            col: 0
        }), new CheckboxInputWidget({
            name: "fanoutCheckbox",
            label: strings.portconfig.fanoutLabel,
            row: C++,
            col: 0,
            topMargin: true,
            singleCell: true,
            setOrig: true,
            changeCallback: createObjectCallback(this, this._fireChange)
        })]
    }))
};
PortConfigWidget.prototype._createISCSIfields = function(O, E, J, K, M) {
    var I = (O ? "A" : "B");
    var D = E + system.physicalPositionOffset;
    var F = I + D;
    var H = {
        ip: {
            ipv4Address: strings.portconfig.ipErr(F),
            ipv6Address: strings.portconfig.ipErr(F)
        },
        netmask: {
            ipv4Address: strings.portconfig.netmaskErr(F),
            ipv6Address: strings.portconfig.defaultRouterErr(F)
        },
        gateway: {
            ipv4Address: strings.portconfig.gatewayErr(F)
        }
    };
    if (this.iscsiIpVersion == "IPv4") {
        var N = {
            ipv4Address: true
        }
    } else {
        var N = {
            ipv6Address: true
        }
    }
    var L = {
        name: this._mkPortStr(O, E) + "_IP",
        size: 12,
        row: this.iscsiIpAddress[O] = J++,
        col: K,
        leftMargin: true,
        topSmallMargin: true,
        rules: N,
        messages: H.ip,
        changeCallback: createObjectCallback(this, this._fireChange)
    };
    var G = {
        name: this._mkPortStr(O, E) + "_maskOrRouter",
        size: 12,
        row: this.iscsiNetmaskRow[O] = J++,
        col: K,
        leftMargin: true,
        topSmallMargin: true,
        rules: N,
        messages: H.netmask,
        changeCallback: createObjectCallback(this, this._fireChange)
    };
    var C = {
        name: this._mkPortStr(O, E) + "_gateway",
        size: 12,
        row: this.iscsiGatewayRow[O] = J++,
        col: K,
        leftMargin: true,
        topSmallMargin: true,
        rules: (this.iscsiIpVersion == "IPv4" ? N : null),
        messages: H.gateway,
        changeCallback: createObjectCallback(this, this._fireChange)
    };
    if (M) {
        L.label = strings.portconfig.ipLabel;
        L.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        G.label = (this.iscsiIpVersion == "IPv4" ? strings.portconfig.netmaskLabel : strings.portconfig.defaultRouterLabel);
        G.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        };
        C.label = strings.portconfig.gatewayLabel;
        C.labelOptions = {
            leftMargin: true,
            topSmallMargin: true,
            classes: "noWrap"
        }
    }
    this.portTable.add(new TextInputWidget(L));
    this.portTable.add(new TextInputWidget(G));
    this.portTable.add(new TextInputWidget(C));
    if (this.iscsiIpVersion == "IPv6") {
        this.portTable.hideRows(this.iscsiGatewayRow[O], this.iscsiGatewayRow[O])
    }
    return J
};
PortConfigWidget.prototype._createIscsiCommon = function() {
    var D = new TableWidget({
        name: "iscsiAdvancedTbl"
    });
    D.add(new LabelWidget({
        row: 0,
        Col: 0,
        bottomMediumMargin: true,
        colSpan: 4,
        value: strings.hostPorts.iscsiAdvTitle,
        classes: "formTableHeadingCenter"
    }));
    D.add(new CheckboxInputWidget({
        name: "iscsi_chap",
        label: strings.portconfig.iscsiChapLabel,
        row: 1,
        col: 1,
        leftMargin: true,
        rightMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 1,
            col: 0,
            bottomMargin: true
        },
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    if (this.iscsiIpVersion == "IPv4") {
        var E = {
            required: true,
            ipv4Address: true
        }
    } else {
        var E = {
            required: true,
            ipv6Address: true
        }
    }
    D.add(new CheckboxInputWidget({
        name: "iscsi_jumbo",
        label: strings.portconfig.iscsiJumboLabel,
        row: 2,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 2,
            col: 0,
            bottomMargin: true
        },
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    D.add(new ComboBoxWidget({
        name: "iscsi_ip_version",
        label: strings.portconfig.iscsiIpVersionLabel,
        row: 3,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        width: 60,
        labelOptions: {
            row: 3,
            col: 0,
            bottomMargin: true
        },
        changeCallback: createObjectCallback(this, this._ipVersionChange),
        values: [{
            value: "IPv4",
            text: strings.portconfig.iscsiIpVersion4
        }, {
            value: "IPv6",
            text: strings.portconfig.iscsiIpVersion6
        }]
    }));
    var C = {
        name: "iscsi_isns",
        label: strings.portconfig.iscsiIsnsLabel,
        singleCell: true,
        changeCallback: createObjectCallback(this, this.isnsChange),
        widgets: [new TableWidget({
            name: "checkBoxTable",
            widgets: [new TextInputWidget({
                name: "iscsi_isns_ip",
                size: 12,
                label: strings.portconfig.iscsiIsnsAddressLabel,
                row: 0,
                col: 1,
                leftMargin: true,
                rules: E,
                changeCallback: createObjectCallback(this, this._fireChange),
                messages: {
                    required: strings.portconfig.required,
                    ipv4Address: strings.portconfig.iscsiIsnsIPerr,
                    ipv6Address: strings.portconfig.iscsiIsnsIPerr
                }
            }), new TextInputWidget({
                name: "iscsi_isns_alt_ip",
                size: 12,
                label: strings.portconfig.iscsiIsnsAltAddressLabel,
                row: 1,
                col: 1,
                leftMargin: true,
                topMargin: true,
                rules: E,
                changeCallback: createObjectCallback(this, this._fireChange),
                messages: {
                    required: strings.portconfig.required,
                    ipv4Address: strings.portconfig.iscsiIsnsAltIPerr,
                    ipv6Address: strings.portconfig.iscsiIsnsAltIPerr
                }
            })]
        })]
    };
    if (this.ctrlInfo.isEX) {
        C.row = 5;
        C.col = 0;
        C.colSpan = 6
    } else {
        C.row = 0;
        C.col = 2;
        C.rowSpan = 4;
        C.leftMargin = true;
        C.rightMargin = true;
        C.bottomMargin = true
    }
    D.add(new CheckboxContainer(C));
    return D
};
PortConfigWidget.prototype._createHostPortMode = function() {
    this.hostPortWidget.add(new TextWidget({
        name: "hostPortTitle",
        classes: "stepNumText",
        leftMargin: true,
        rightMargin: true,
        topMargin: true,
        text: strings.portconfig.hostPortTitle
    }));
    this.hostPortWidget.add(new TextWidget({
        name: "hostPortText",
        leftMargin: true,
        rightMargin: true,
        bottomMargin: true,
        topMargin: true,
        text: strings.portconfig.hostPortText
    }));
    this.hostPortWidget.add(new OptionInputWidget({
        name: "modeList",
        label: strings.portconfig.portModeLabel,
        labelOptions: {
            leftMargin: true
        },
        setOrig: true,
        leftMargin: true,
        rightMargin: true,
        bottomMargin: true,
        topMargin: true,
        values: [{
            value: "FC",
            text: strings.portconfig.FC
        }, {
            value: "iSCSI",
            text: strings.portconfig.iSCSI
        }, {
            value: "FC-and-iSCSI",
            text: strings.portconfig.both
        }],
        changeCallback: createObjectCallback(this, this._selectHostPortMode)
    }))
};
PortConfigWidget.prototype._selectHostPortMode = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (C.modeList.value != undefined && C.modeList.valueChanged) {
        this.valueChanged = true;
        if ($.isFunction(this.options.changeCallback)) {
            this._fireChange()
        }
    }
};
PortConfigWidget.prototype._createIBfields = function(C, E, G, J) {
    var D = (C ? "A" : "B");
    var F = E + system.physicalPositionOffset;
    var I = D + F;
    var H = {
        ip: {
            required: strings.portconfig.required,
            ipv4Address: strings.portconfig.ipErr(I),
            ipv6Address: strings.portconfig.ipErr(I)
        },
        netmask: {
            required: strings.portconfig.required,
            ipv4Address: strings.portconfig.netmaskErr(I),
            ipv6Address: strings.portconfig.defaultRouterErr(I)
        },
        guid: {
            required: strings.portconfig.required
        }
    };
    this.portTable.add(new TextInputWidget({
        name: this._mkPortStr(C, E) + "_IP",
        size: 12,
        row: G++,
        col: J,
        leftMargin: true,
        topSmallMargin: true,
        messages: H.ip,
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    this.portTable.add(new TextInputWidget({
        name: this._mkPortStr(C, E) + "_netmask",
        size: 12,
        row: G++,
        col: J,
        leftMargin: true,
        topSmallMargin: true,
        messages: H.netmask,
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    this.portTable.add(new TextInputWidget({
        name: this._mkPortStr(C, E) + "_guid",
        size: 23,
        row: G++,
        col: J,
        leftMargin: true,
        topSmallMargin: true,
        messages: H.gateway,
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    return G
};
PortConfigWidget.prototype._createIBCommon = function() {
    var C = new TableWidget({
        name: "IBAdvancedTbl"
    });
    C.add(new LabelWidget({
        row: 0,
        Col: 0,
        bottomMediumMargin: true,
        colSpan: 4,
        value: strings.hostPorts.ibAdvTitle,
        classes: "formTableHeadingCenter"
    }));
    C.add(new CheckboxInputWidget({
        name: "IB_chap",
        label: strings.portconfig.iscsiChapLabel,
        row: 1,
        col: 1,
        leftMargin: true,
        rightMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 1,
            col: 0,
            bottomMargin: true
        },
        changeCallback: createObjectCallback(this, this._fireChange)
    }));
    C.add(new TextInputWidget({
        name: "IB_ip_version",
        label: strings.portconfig.ibIpVersionLabel,
        row: 4,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        width: 60,
        labelOptions: {
            row: 4,
            col: 0,
            bottomMargin: true
        }
    }));
    return C
};
PortConfigWidget.prototype.isnsChange = function() {
    var C = {};
    this.retrieve(C, true);
    if (C.iscsi_isns.value) {
        C.iscsi_isns_ip = {
            disable: false,
            rules: (C.iscsi_ip_version.value == "IPv4" ? this.ipv4Rules : this.ipv6Rules)
        };
        C.iscsi_isns_alt_ip = {
            disable: false,
            rules: (C.iscsi_ip_version.value == "IPv4" ? this.ipv4Rules : this.ipv6Rules)
        }
    } else {
        C.iscsi_isns_ip = {
            disable: true,
            rules: {}
        };
        C.iscsi_isns_alt_ip = {
            disable: true,
            rules: {}
        }
    }
    this.update(C);
    if (this.form) {
        this.form.validate()
    }
};
PortConfigWidget.prototype._ipVersionChange = function(K, E, G) {
    var C = {};
    this.retrieve(C, true);
    if (C.iscsi_ip_version.value == this.iscsiIpVersion) {
        return
    }
    this.iscsiIpVersion = C.iscsi_ip_version.value;
    var H = {};
    var J = (C.iscsi_ip_version.value == "IPv4");
    for (var L in C) {
        var F = L.match(/^port_([AB]).*/);
        if (F) {
            var D = F[1]
        } else {
            continue
        }
        if (J) {
            if (L.match(/^(port_.*_IP)|(iscsi_isns_.*ip)/)) {
                H[L] = {
                    rules: this.ipv4Rules,
                    value: (C[L].value ? ipv6ToIpv4(C[L].value) : null)
                }
            } else {
                if (L.match(/^(port_.*_(netmask|maskOrRouter))/)) {
                    H[L] = {
                        rules: this.ipv4Rules,
                        value: ""
                    }
                } else {
                    if (L.match(/^port_.*_gateway/)) {
                        H[L] = {
                            rules: this.ipv4Rules,
                            value: "",
                            setOrig: true,
                            disable: !this.controllerStatus[D]
                        }
                    }
                }
            }
        } else {
            if (L.match(/^(port_.*_(IP|maskOrRouter))|(isci_isns_.*ip)$/)) {
                H[L] = {
                    rules: this.ipv6Rules,
                    value: (C[L].value ? ipv4ToIpv6(C[L].value) : null)
                }
            } else {
                if (L.match(/^port_.*_(netmask|gateway)$/)) {
                    H[L] = {
                        rules: {}
                    }
                }
            }
        }
    }
    var I = strings.portconfig.netmaskLabel;
    for (var N in this.iscsiGatewayRow) {
        var M = this.iscsiGatewayRow[N];
        if (this.iscsiIpVersion == "IPv4") {
            this.portTable.showRows(M, M)
        } else {
            this.portTable.hideRows(M, M);
            I = strings.portconfig.defaultRouterLabel
        }
    }
    H.maskOrRouterLabel = {
        value: I,
        required: true
    };
    this.update(H);
    if (this.form) {
        this.form.validate()
    }
};
PortConfigWidget.prototype.createSetCommands = function(L) {
    if (L == undefined) {
        var L = {};
        this.retrieve(L)
    }
    var G = {};
    var J = [];
    var C = {};
    var M = {};
    var N = {};
    var O = {};
    for (var P in L) {
        if (P.match(/^iscsi.*$/) && (this.hasISCSI[PortConfigWidget.CTL.A] || this.hasISCSI[PortConfigWidget.CTL.B])) {
            if (L[P].valueChanged) {
                if (P == "iscsi_isns_ip" || P == "iscsi_isns_alt_ip") {
                    if (!M.iscsi_ip_version) {
                        M.iscsi_ip_version = L.iscsi_ip_version
                    }
                }
                M[P] = L[P]
            }
        } else {
            if (P.match(/^IB.*$/) && (this.hasIB[PortConfigWidget.CTL.A] || this.hasIB[PortConfigWidget.CTL.B])) {
                if (L[P].valueChanged) {
                    N[P] = L[P]
                }
            } else {
                if (L[P].valueChanged) {
                    O[P] = L[P]
                }
            }
        }
    }
    if (propertyCount(M) > 0) {
        J.push({
            name: "iscsiParameters",
            command: MC.setIscsiParameters,
            data: M,
            options: {
                processingMsg: strings.portconfig.processingIscsiMsg,
                failureMsg: strings.portconfig.failureIscsiMsg,
                successMsg: strings.portconfig.successIscsiMsg
            }
        })
    }
    if (propertyCount(N) > 0) {
        J.push({
            name: "ibParameters",
            command: MC.setIBParameters,
            data: N,
            options: {
                processingMsg: strings.portconfig.processingIBMsg,
                failureMsg: strings.portconfig.failureIBMsg,
                successMsg: strings.portconfig.successIBMsg
            }
        })
    }
    if (propertyCount(O) > 0) {
        for (var P in O) {
            var K = P.split("_");
            if (K.length != 3) {
                if (this.sasConfigSystem && O[P].valueChanged) {
                    G.fanout = {
                        name: "fanoutConfig",
                        command: MC.setPort,
                        data: {
                            fanout: {
                                value: O[P].value
                            }
                        },
                        options: {
                            processingMsg: strings.portconfig.processingFanoutMsg,
                            failureMsg: strings.portconfig.failureFanoutMsg,
                            successMsg: strings.portconfig.successFanoutMsg
                        }
                    };
                    J.push(G.fanout);
                    break
                }
                continue
            }
            var F = K[1];
            var E = K[2];
            var I = "";
            var D = DC.ports["hostport_" + F].getInt("port_type_numeric");
            if (E.match(/(gateway|maskOrRouter)/)) {
                if (this.iscsiIpVersion == "IPv4") {
                    if (E.match(/gateway/)) {
                        I = "gateway"
                    }
                    if (E.match(/maskOrRouter/)) {
                        I = "netmask"
                    }
                } else {
                    if (E.match(/maskOrRouter/)) {
                        I = "defaultRouter"
                    }
                }
            } else {
                I = E
            }
            if (!G[F]) {
                G[F] = {
                    name: "port" + F,
                    command: MC.setPort,
                    data: {
                        port: F,
                        params: {}
                    },
                    options: {
                        processingMsg: strings.portconfig.processing(F),
                        failureMsg: strings.portconfig.failure(F),
                        successMsg: strings.portconfig.success(F)
                    }
                };
                G[F].data.params[I] = O[P].value;
                if (D == PORT_TYPES.ISCSI) {
                    G[F].data.params.ipVersion = this.iscsiIpVersion
                }
                J.push(G[F])
            } else {
                G[F].data.params[I] = O[P].value
            }
        }
    }
    if ((L.modeList != undefined) && L.modeList.valueChanged) {
        var H = {
            mode: L.modeList.value
        };
        J.push({
            name: "hostportMode",
            command: MC.setHostPortMode,
            data: H,
            options: {
                dialog: true,
                processingMsg: strings.portconfig.processingHostPort,
                failureMsg: strings.portconfig.failureHostPortMode,
                successMsg: strings.portconfig.successHostPortMode,
                closeActionOn: "success"
            }
        })
    }
    return J
};
PortConfigWidget.prototype._getPortTypes = function() {
    var I, H, C, D, E, G;
    for (G in DC.ports) {
        I = DC.ports[G];
        if (I.basetype == "port") {
            H = parseInt(I.getPropertyValue("port")[1], 10);
            if (system.physicalPositionOffset) {
                H = parseInt(I.getPropertyValue("port")[1], 10) - system.physicalPositionOffset
            }
            C = I.getPropertyValue("port_type");
            D = I.getPropertyValue("controller_numeric");
            switch (C) {
                case "FC":
                    this.portTypes[D][H] = "FC";
                    this.hasFC[D] = true;
                    break;
                case "iSCSI":
                    E = I.objects[0];
                    if (E.basetype == "iscsi-port") {
                        this.portTypes[D][H] = "iSCSI";
                        this.hasISCSI[D] = true;
                        this.iscsiIpVersion = E.getPropertyValue("ip_version")
                    }
                    break;
                case "SAS":
                    this.portTypes[D][H] = "SAS";
                    this.hasSAS[D] = true;
                    break;
                case "IB":
                    E = I.objects[0];
                    if (E.basetype == "IB-port") {
                        this.portTypes[D][H] = "IB";
                        this.hasIB[D] = true;
                        this.ibIpVersion = E.getPropertyValue("ip_version")
                    }
                    break;
                default:
                    MC.warningOutput("Unknown port media type: %s", C);
                    break
            }
        }
    }
    var F = getHostPortMode();
    if (this.maxPortCols == 4) {
        if (getHostPortMode() == "HYBRID") {
            if (propertyCount(DC.controllers) > 1) {
                this.isHybrid[PortConfigWidget.CTL.A] = true;
                this.isHybrid[PortConfigWidget.CTL.B] = true
            } else {
                this.isHybrid[PortConfigWidget.CTL.A] = true
            }
        } else {
            if (propertyCount(DC.controllers) > 1) {
                this.isHybrid[PortConfigWidget.CTL.A] = false;
                this.isHybrid[PortConfigWidget.CTL.B] = false
            } else {
                this.isHybrid[PortConfigWidget.CTL.A] = false
            }
        }
    } else {
        this.isHybrid[PortConfigWidget.CTL.A] = false;
        this.isHybrid[PortConfigWidget.CTL.B] = false
    }
};
PortConfigWidget.prototype._hasAllSAS = function(C) {
    var D;
    for (D = 0; D < this.maxPortCols; D++) {
        if (this.portTypes[C][D] != "SAS") {
            return false
        }
    }
    this.hasAllSAS = true;
    return true
};
PortConfigWidget.prototype._mkPortStr = function(D, C) {
    return ("port_" + PortConfigWidget.CTL[D] + (parseInt(C) + parseInt(system.physicalPositionOffset)).toString())
};
PortConfigWidget.prototype._createPortColumnHeaders = function(C, E, H) {
    var F = PortConfigWidget.CTL[C];
    var D = 0;
    var G = (this.hasAllSAS) ? 4 : false;
    if (C == PortConfigWidget.CTL.B) {
        E += 3
    }
    this.portTable.add(new TextWidget({
        row: E,
        col: H++,
        topMargin: true,
        leftMargin: true,
        rightMargin: true,
        colSpan: G,
        text: this.portTypes[C][0] + strings.hostPorts.param,
        classes: "formTableHeadingCenter"
    }));
    for (D = 0; D < 2; D++) {
        this.portTable.add(new TextWidget({
            row: E,
            col: H++,
            topMargin: true,
            leftMargin: true,
            colSpan: G,
            text: F + (D + system.physicalPositionOffset).toString(),
            classes: "formTableHeadingCenter"
        }))
    }
    if (this.isHybrid[C]) {
        this.portTable.add(new TextWidget({
            row: E,
            col: H++,
            topMargin: true,
            leftMargin: true,
            text: this.portTypes[C][2] + strings.hostPorts.param,
            classes: "formTableHeadingCenter"
        }))
    }
    for (D = 2; D < this.maxPortCols; D++) {
        this.portTable.add(new TextWidget({
            row: E,
            col: H++,
            topMargin: true,
            leftMargin: true,
            colSpan: G,
            text: F + (D + system.physicalPositionOffset).toString(),
            classes: "formTableHeadingCenter"
        }))
    }
    return (E + 1)
};
PortConfigWidget.prototype._tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (!this.portTabs) {
        return
    }
    switch (C) {
        case 0:
            if ((this.hasISCSI[PortConfigWidget.CTL.A] || this.hasISCSI[PortConfigWidget.CTL.B])) {
                this.update({
                    portTabWidget: {
                        visibility: "visible"
                    },
                    iscsiAdvancedTbl: {
                        visibility: "collapse"
                    }
                });
                break
            } else {
                if ((this.hasIB[PortConfigWidget.CTL.A] || this.hasIB[PortConfigWidget.CTL.B])) {
                    this.update({
                        portTabWidget: {
                            visibility: "visible"
                        },
                        IBAdvancedTbl: {
                            visibility: "collapse"
                        }
                    });
                    break
                }
            }
            case 1:
                if ((this.hasISCSI[PortConfigWidget.CTL.A] || this.hasISCSI[PortConfigWidget.CTL.B])) {
                    this.update({
                        portTabWidget: {
                            visibility: "collapse"
                        },
                        iscsiAdvancedTbl: {
                            visibility: "visible"
                        }
                    });
                    break
                } else {
                    if ((this.hasIB[PortConfigWidget.CTL.A] || this.hasIB[PortConfigWidget.CTL.B])) {
                        this.update({
                            portTabWidget: {
                                visibility: "collapse"
                            },
                            IBAdvancedTbl: {
                                visibility: "visible"
                            }
                        });
                        break
                    }
                }
                default:
                    break
    }
    this._fireChange()
};
PortConfigWidget.prototype.getConfirmMsg = function() {
    var F = {};
    this.retrieve(F);
    var I = '<div class="confirmLabel"><u>' + strings.Ports + "</u></div><br>";
    var D = "";
    for (var E in F) {
        if (F[E].valueChanged) {
            D = E;
            var H = F[E].value;
            if (E.indexOf("port_") > -1) {
                var G = E.split("_");
                switch (G[2]) {
                    case "speed":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.speedLabel;
                        break;
                    case "mode":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.modeLabel;
                        break;
                    case "fanout":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.cableTypeLabel;
                        break;
                    case "lanesExpected":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.lanesExpectedLabel;
                        break;
                    case "activeLanes":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.activeLanesLabel;
                        break;
                    case "IP":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.ipLabel;
                        break;
                    case "maskOrRouter":
                        var C = (this.iscsiIpVersion == "IPv4" ? strings.portconfig.netmaskLabel : strings.portconfig.defaultRouterLabel);
                        D = strings.port + " " + G[1] + " " + C;
                        break;
                    case "gateway":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.gatewayLabel;
                        break;
                    case "netmask":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.netmaskLabel;
                        break;
                    case "guid":
                        D = strings.port + " " + G[1] + " " + strings.portconfig.guidLabel;
                        break;
                    default:
                        break
                }
            } else {
                if (E !== "modeList") {
                    D = strings.configurationWizard.summary[E]
                } else {
                    if (E == "modeList") {
                        D = strings.portconfig.portModeLabel
                    }
                }
            }
            if (typeof F[E].value == "boolean") {
                if (F[E].value) {
                    H = strings.Enabled
                } else {
                    H = strings.Disabled
                }
            }
            I += D + ": " + H + "<br>"
        }
    }
    if ((F.modeList != undefined) && F.modeList.valueChanged) {
        D = strings.portconfig.confirmHostPortMode;
        I += D + "<br>"
    }
    return I
};

function ServicesConfigWidget(F) {
    if (arguments.length == 0 || F.name == undefined) {
        return
    }
    var E = 0;
    this.wbiWarningMsg = "";
    this.replicationMode = replicationSetup();
    var D = strings.servicesSetup.legacyInfoTxt(strings.servicesSetup.linearRep);
    var C = new TableWidget({
        name: "networkWidgets",
        width: 250,
        widgets: [new TextWidget({
            name: "servNMStext",
            row: E++,
            col: 0,
            bottomMargin: true,
            text: strings.servicesSetup.nmsText,
            classes: "formTableHeadingCenter"
        }), new TextWidget({
            name: "servWBI",
            text: strings.servicesSetup.wbiLabel,
            cssClass: "textNoPadding",
            row: E++,
            col: 0,
            bottomSmallMargin: true
        }), new TableWidget({
            name: "servWBIboxes",
            row: E++,
            col: 0,
            leftMediumMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "http",
                row: 0,
                col: 0,
                label: strings.servicesSetup.httpLabel,
                leftMargin: true,
                bottomMediumMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._wbiChange)
            }), new CheckboxInputWidget({
                name: "https",
                row: 0,
                col: 1,
                label: strings.servicesSetup.httpsLabel,
                leftMargin: true,
                bottomMediumMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._wbiChange)
            })]
        }), new TextWidget({
            name: "servCLI",
            text: strings.servicesSetup.cliLabel,
            cssClass: "textNoPadding",
            row: E++,
            col: 0,
            bottomSmallMargin: true
        }), new TableWidget({
            name: "servCLIboxes",
            row: E++,
            col: 0,
            leftMediumMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "telnet",
                label: strings.servicesSetup.telnetLabel,
                row: 0,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "ssh",
                label: strings.servicesSetup.sshLabel,
                row: 1,
                col: 0,
                leftMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, function(G, I, H) {
                    this.update({
                        sshPort: {
                            disable: (G.ssh.value ? false : true)
                        }
                    });
                    this._fireChange(G, I, H)
                })
            }), new TextInputWidget({
                name: "sshPort",
                label: strings.servicesSetup.port,
                classes: "portIndent",
                row: 2,
                col: 0,
                bottomMediumMargin: true,
                singleCell: true,
                size: 6,
                changeCallback: createObjectCallback(this, this._fireChange)
            })]
        }), new TextWidget({
            name: "interfaceSmis",
            text: strings.servicesSetup.smisLabel,
            cssClass: "textNoPadding",
            row: E++,
            col: 0,
            bottomSmallMargin: true
        }), new TableWidget({
            name: "interfacesSmisBoxes",
            row: E++,
            col: 0,
            leftMediumMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "smisEnable",
                label: strings.Enable,
                row: 0,
                col: 0,
                leftMargin: true,
                bottomMediumMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._toggleSmis)
            }), new CheckboxInputWidget({
                name: "smisEncrypt",
                label: strings.Encrypted,
                row: 0,
                col: 1,
                leftMargin: true,
                bottomMediumMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            })]
        }), new TextWidget({
            name: "servOther",
            text: strings.servicesSetup.otherIFSLabel,
            cssClass: "textNoPadding",
            row: E++,
            col: 0,
            bottomSmallMargin: true
        }), new TableWidget({
            name: "servOtherboxes",
            row: E++,
            col: 0,
            leftMediumMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "slp",
                label: strings.servicesSetup.slpLabel,
                row: 1,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "ftp",
                label: strings.servicesSetup.ftpLabel,
                row: 2,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "sftp",
                label: strings.servicesSetup.sftpLabel,
                row: 3,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, function(G, I, H) {
                    this.update({
                        sftpPort: {
                            disable: (G.sftp.value ? false : true)
                        }
                    });
                    this._fireChange(G, I, H)
                })
            }), new TextInputWidget({
                name: "sftpPort",
                label: strings.servicesSetup.port,
                classes: "portIndent",
                row: 4,
                col: 0,
                bottomMediumMargin: true,
                singleCell: true,
                size: 6,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "snmp",
                label: strings.servicesSetup.snmpLabel,
                row: 5,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "debug",
                label: strings.servicesSetup.debugLabel,
                row: 6,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            }), new CheckboxInputWidget({
                name: "activity",
                label: strings.servicesSetup.activityLabel,
                row: 7,
                col: 0,
                leftMargin: true,
                bottomMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            })]
        }), new TextWidget({
            name: "servIMStext",
            row: E++,
            col: 0,
            bottomMargin: true,
            topMargin: true,
            text: strings.servicesSetup.imsText,
            classes: "formTableHeadingCenter"
        }), new TableWidget({
            name: "servIMSboxes",
            row: E++,
            col: 0,
            leftMediumMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "ses",
                label: strings.servicesSetup.sesLabel,
                row: 1,
                col: 0,
                leftMargin: true,
                bottomSmallMargin: true,
                singleCell: true,
                changeCallback: createObjectCallback(this, this._fireChange)
            })]
        })]
    });
    F.valueChanged;
    if (!RI.hasFeature("supportsWbiV2") || RI.pagedOnly() || this.replicationMode == "rsr" || this.replicationMode == "ar") {
        F.widgets = [C]
    } else {
        F.widgets = [this.notifyTabs = new TabWidget({
            name: "servicesTabs",
            type: "Primary",
            changeCallback: createObjectCallback(this, this.tabSelected),
            tabs: [{
                name: "tabNetwork",
                label: strings.servicesSetup.tabNetwork
            }, {
                name: "tabLegacy",
                label: strings.servicesSetup.tabLegacy
            }],
            widgets: [C, new TableWidget({
                name: "legacyWidgets",
                widgets: [new TableWidget({
                    name: "replicationModeTable",
                    row: E++,
                    col: 0,
                    leftMediumMargin: true,
                    widgets: [new TextWidget({
                        name: "legacyInfoTxt",
                        row: 0,
                        col: 0,
                        colSpan: 2,
                        text: D
                    }), new CheckboxContainer({
                        name: "legacyCheckbox",
                        row: 1,
                        col: 1,
                        topMargin: true,
                        label: strings.servicesSetup.legacyCheckbox,
                        changeCallback: createObjectCallback(this, this._fireChange),
                        widgets: [new TextWidget({
                            name: "txt",
                            text: strings.servicesSetup.legacyInfoTxt2
                        })]
                    })]
                })]
            })]
        })]
    }
    TableWidget.call(this, F);
    this.class_name = "ServicesConfigWidget"
}
ServicesConfigWidget.prototype = new TableWidget();
ServicesConfigWidget.prototype.constructor = ServicesConfigWidget;
ServicesConfigWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
ServicesConfigWidget.prototype.loadData = function() {
    this.protocolsSubscription = MC.protocolsSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateWithDataSet(C, true)
        })
    })
};
ServicesConfigWidget.prototype.hiding = function() {
    if (this.protocolsSubscription) {
        MC.protocolsSet.unregister(this.protocolsSubscription);
        delete this.protocolsSubscription
    }
};
ServicesConfigWidget.prototype.updateWithDataSet = function(G, C, D) {
    if (!G || G.name != "protocolsSet") {
        return
    }
    var F = G.getData().getObjectOfBasetype("security-communications-protocols");
    if (F == null) {
        return
    }
    var E = {
        legacyWidgets: {
            visibility: "collapse"
        }
    };
    if (!RI.hasFeature("supportsWbiV2") || RI.pagedOnly() || this.replicationMode == "rsr" || this.replicationMode == "ar") {
        E.servNMStext = {
            visibility: "visible"
        }
    } else {
        E.servNMStext = {
            visibility: "collapse"
        };
        if (F.getInt("management_mode_numeric") == MANAGEMENT_MODE.VIRTUAL) {
            E.legacyCheckbox = {
                value: false,
                setOrig: true
            }
        } else {
            E.legacyCheckbox = {
                value: true,
                setOrig: true
            }
        }
    }
    E.http = {
        value: decodeBooleanFlag(F.getPropertyValue("wbi_http_numeric"))
    };
    E.https = {
        value: decodeBooleanFlag(F.getPropertyValue("wbi_https_numeric"))
    };
    E.telnet = {
        value: decodeBooleanFlag(F.getPropertyValue("cli_telnet_numeric"))
    };
    E.ssh = {
        value: decodeBooleanFlag(F.getPropertyValue("cli_ssh_numeric"))
    };
    if (RI.hasFeature("smis")) {
        if (decodeBooleanFlag(F.getPropertyValue("smis_numeric"))) {
            E.smisEncrypt = {
                disable: false,
                value: true
            };
            E.smisEnable = {
                value: true
            }
        } else {
            if (decodeBooleanFlag(F.getPropertyValue("usmis_numeric"))) {
                E.smisEncrypt = {
                    disable: false,
                    value: false
                };
                E.smisEnable = {
                    value: true
                }
            } else {
                E.smisEncrypt = {
                    disable: true
                };
                E.smisEnable = {
                    value: false
                }
            }
        }
    } else {
        E.interfaceSmis = {
            visibility: "collapse"
        };
        E.interfaceSmisBoxes = {
            visibility: "collapse"
        };
        E.smisEnable = {
            visibility: "collapse",
            value: false,
            disable: true
        };
        E.smisEncrypt = {
            visibility: "collpase",
            value: false,
            disable: true
        }
    }
    if (RI.hasFeature("slp")) {
        E.slp = {
            value: decodeBooleanFlag(F.getPropertyValue("slp_numeric"))
        }
    } else {
        E.slp = {
            visibility: "collapse"
        }
    }
    if (RI.hasFeature("sftp")) {
        var H = G.getData().getObjectOfBasetype("communication-ports");
        E.sftp = {
            value: decodeBooleanFlag(F.getPropertyValue("sftp_numeric")),
            setOrig: true
        };
        E.sftpPort = {
            value: H.get("sftp_port"),
            setOrig: true,
            rules: {
                range: [1, 65535]
            }
        };
        E.sshPort = {
            value: H.get("ssh_port"),
            setOrig: true,
            rules: {
                range: [1, 65535]
            }
        }
    } else {
        E.sftp = {
            visibility: "collapse"
        };
        E.sftpPort = {
            visibility: "collapse"
        };
        E.sshPort = {
            visibility: "collapse"
        }
    }
    E.ftp = {
        value: decodeBooleanFlag(F.getPropertyValue("ftp_numeric"))
    };
    E.snmp = {
        value: decodeBooleanFlag(F.getPropertyValue("snmp_numeric"))
    };
    E.debug = {
        value: decodeBooleanFlag(F.getPropertyValue("debug_interface_numeric"))
    };
    E.activity = {
        value: decodeBooleanFlag(F.getPropertyValue("activity_progress_numeric"))
    };
    E.ses = {
        value: decodeBooleanFlag(F.getPropertyValue("inband_ses_numeric"))
    };
    if (C) {
        E.http.setOrig = true;
        E.https.setOrig = true;
        E.telnet.setOrig = true;
        E.ssh.setOrig = true;
        E.smisEnable.setOrig = true;
        E.smisEncrypt.setOrig = true;
        E.slp.setOrig = true;
        E.ftp.setOrig = true;
        E.snmp.setOrig = true;
        E.debug.setOrig = true;
        E.activity.setOrig = true;
        E.ses.setOrig = true
    }
    this.update(E);
    if (D) {
        this.retrieve(D)
    }
};
ServicesConfigWidget.prototype._wbiChange = function(E, D, F) {
    if (!F) {
        return
    }
    var E = {};
    this.wbiWarningMsg = "";
    var C = window.location.protocol;
    this.retrieve(E, true);
    if ((C == "https:" && !E.https.value) || (C == "http:" && !E.http.value)) {
        this.wbiWarningMsg = strings.servicesSetup.disableCurrentProtoMsg(C)
    }
    if (!E.http.value && !E.https.value) {
        this.wbiWarningMsg = strings.servicesSetup.disableBothWebProtosMsg
    }
    this.update(E);
    this._fireChange()
};
ServicesConfigWidget.prototype.anyFalse = function(E) {
    var C = "";
    var D = ["CLI", "FTP", "SMI-S", "SNMP", "SLP"];
    if (!E.telnet.value && !E.ssh.value) {
        C = D[0]
    }
    if (!E.ftp.value) {
        C = (C == "") ? D[1] : (C + strings.servicesSetup.separator + D[1])
    }
    if (RI.hasFeature("smis") && !E.smisEnable.value) {
        C = (C == "") ? D[2] : (C + strings.servicesSetup.separator + D[2])
    }
    if (!E.snmp.value) {
        C = (C == "") ? D[3] : (C + strings.servicesSetup.separator + D[3])
    }
    if (RI.hasFeature("slp") && !E.slp.value) {
        C = (C == "") ? D[4] : (C + strings.servicesSetup.separator + D[4])
    }
    return C
};
ServicesConfigWidget.prototype.getCommandQueue = function() {
    var D = {};
    var E = [];
    var C = [];
    this.retrieve(D);
    if (D.legacyCheckbox && D.legacyCheckbox.valueChanged) {
        if (D.legacyCheckbox.value) {
            MENUS.topics.replications.topic = "RsrTopic";
            MENUS.VolumesTopic = RSRVOLTOPIC;
            panels.TopicMenuPanel.topicList.RsrTopic = "replications";
            delete panels.TopicMenuPanel.topicList.RepsTopic;
            E["management-mode"] = "v2"
        } else {
            MENUS.topics.replications.topic = "RepsTopic";
            MENUS.VolumesTopic = ARVOLTOPIC;
            panels.TopicMenuPanel.topicList.RepsTopic = "replications";
            delete panels.TopicMenuPanel.topicList.RsrTopic;
            E["management-mode"] = "v3"
        }
    }
    if (D.smisEnable.valueChanged || D.smisEncrypt.valueChanged) {
        if (D.smisEnable.value == true) {
            if (D.smisEncrypt.value == true) {
                E.smis = {
                    value: true
                };
                E.usmis = {
                    value: false
                }
            } else {
                if (D.smisEncrypt.value == false) {
                    E.smis = {
                        value: false
                    };
                    E.usmis = {
                        value: true
                    }
                }
            }
        } else {
            E.smis = {
                value: false
            };
            E.usmis = {
                value: false
            }
        }
    }
    for (name in D) {
        if (name != "legacyCheckbox" || name != "smisEncrypt" || name != "smisEnable") {
            if (D[name].valueChanged) {
                E[name] = D[name]
            }
        }
    }
    C.push({
        name: "setProtocols",
        command: MC.setProtocols,
        data: E,
        options: {
            processingMsg: strings.servicesSetup.processingMsg,
            failureMsg: strings.servicesSetup.failureMsg,
            successMsg: strings.servicesSetup.successMsg
        }
    });
    return C
};
ServicesConfigWidget.prototype.getConfirmMsg = function(F, E) {
    if (!F) {
        var F = {};
        this.retrieve(F, true)
    }
    if (E) {
        var H = '<div class="confirmLabel"><u>' + strings.configurationWizard.servStep + "</u></div><br>";
        for (var D in F) {
            if (F[D].valueChanged) {
                var C = strings.configurationWizard.summary[D];
                if (F[D].value) {
                    var G = strings.Enabled
                } else {
                    var G = strings.Disabled
                }
                H += C + ": " + G + "<br>"
            }
        }
    } else {
        var H = ""
    }
    if (this.wbiWarningMsg) {
        H += this.wbiWarningMsg + "<br>"
    }
    if (F.http.value == true && F.http.valueChanged) {
        H += strings.servicesSetup.httpConfirmMsg + "<br>"
    }
    if (F.ftp.value == true && F.ftp.valueChanged) {
        H += strings.servicesSetup.ftpConfirmMsg + "<br>"
    }
    if (F.telnet.value == true && F.telnet.valueChanged) {
        H += strings.servicesSetup.telnetConfirmMsg + "<br>"
    }
    if (F.snmp.value == true && F.snmp.valueChanged) {
        H += strings.servicesSetup.snmpConfirmMsg + "<br>"
    }
    if ((F.smisEnable.value && !F.smisEncrypt.value) && (F.smisEnable.valueChanged || F.smisEncrypt.valueChanged)) {
        H += strings.servicesSetup.usmisConfirmMsg + "<br>"
    }
    if (isHPsystem() && F.debug.value == true && F.debug.valueChanged) {
        H += strings.servicesSetup.debugConfirmMsg + "<br>"
    }
    if ((result = this.anyFalse(F)) != "") {
        H += strings.servicesSetup.commonOffConfirmMsg(result) + "<br>"
    }
    if (H && typeof E == "undefined") {
        H += "<br/><br/>" + strings.servicesSetup.confirmQuestion
    }
    return H
};
ServicesConfigWidget.prototype._flagChange = function(D) {
    this.valueChanged = false;
    for (var C in D) {
        if (D[C].valueChanged == true) {
            this.valueChanged = true
        }
    }
};
ServicesConfigWidget.prototype._fireChange = function(G, D, E) {
    var C = {};
    this.retrieve(C);
    this._flagChange(C);
    var F = {};
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
        if (!F[this.name]) {
            F[this.name] = {}
        }
        F[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(F, this, E)
    }
};
ServicesConfigWidget.prototype._toggleSmis = function(F, D, E) {
    var C = {};
    if (F && F.smisEnable.value == true) {
        C.smisEncrypt = {
            disable: false
        };
        C.smisEncrypt.value = true
    } else {
        if (F && F.smisEnable.value == false) {
            C.smisEncrypt = {
                disable: true
            }
        }
    }
    this.update(C);
    this._fireChange()
};
ServicesConfigWidget.prototype.tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (this.widgets && this.findWidgetByName("servicesTabs")) {
        switch (C) {
            case 0:
                this.update({
                    networkWidgets: {
                        visibility: "visible"
                    },
                    legacyWidgets: {
                        visibility: "collapse"
                    }
                });
                break;
            case 1:
                this.update({
                    networkWidgets: {
                        visibility: "collapse"
                    },
                    legacyWidgets: {
                        visibility: "visible"
                    }
                });
                break;
            default:
                MC.warningOutput("NotificationSetupWidget.tabSelected: bad tab number = %d", C);
                break
        }
    }
};

function SystemInfoWidget(C) {
    if (arguments.length == 0 || C.name == undefined) {
        return
    }
    C.valueChanged;
    C.width = 400;
    C.widgets = [new TextInputWidget({
        name: "siName",
        size: 20,
        label: strings.systeminfo.siNameLabel,
        row: 0,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 0,
            col: 0,
            bottomMargin: true
        },
        rules: {
            dhNameWithComma: true,
            utf8length: 79
        },
        changeCallback: createObjectCallback(this, this.changeCallback)
    }), new TextInputWidget({
        name: "siContact",
        size: 30,
        label: strings.systeminfo.siContactLabel,
        row: 1,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 1,
            col: 0,
            bottomMargin: true
        },
        rules: {
            dhNameWithComma: true,
            utf8length: 79
        },
        changeCallback: createObjectCallback(this, this.changeCallback)
    }), new TextInputWidget({
        name: "siLocation",
        size: 30,
        label: strings.systeminfo.siLocationLabel,
        row: 2,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 2,
            col: 0,
            bottomMargin: true
        },
        rules: {
            dhNameWithComma: true,
            utf8length: 79
        },
        changeCallback: createObjectCallback(this, this.changeCallback)
    }), new TextInputWidget({
        name: "siInfo",
        size: 30,
        label: strings.systeminfo.siInfoLabel,
        row: 3,
        col: 1,
        leftMargin: true,
        bottomMargin: true,
        labelOptions: {
            row: 3,
            col: 0,
            bottomMargin: true
        },
        rules: {
            dhNameWithComma: true,
            utf8length: 79
        },
        changeCallback: createObjectCallback(this, this.changeCallback)
    })];
    TableWidget.call(this, C);
    this.class_name = "SystemInfoWidget"
}
SystemInfoWidget.prototype = new TableWidget();
SystemInfoWidget.prototype.constructor = SystemInfoWidget;
SystemInfoWidget.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this.loadData), 100)
};
SystemInfoWidget.prototype.loadData = function() {
    this.systemInfoSubscription = MC.systemInfoSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.updateWithDataSet(C, true)
        })
    })
};
SystemInfoWidget.prototype.hiding = function() {
    if (this.systemInfoSubscription) {
        MC.systemInfoSet.unregister(this.systemInfoSubscription);
        delete this.systemInfoSubscription
    }
};
SystemInfoWidget.prototype.updateWithDataSet = function(F, C, D) {
    if (D == undefined) {
        var D = {}
    }
    var E;
    if (!F || F.name != "systemInfoSet") {
        return
    }
    E = F.getData().getObjectOfBasetype("system");
    if (E == null) {
        return
    }
    D.siName = {
        value: E.getPropertyValue("system_name")
    };
    D.siContact = {
        value: E.getPropertyValue("system_contact")
    };
    D.siLocation = {
        value: E.getPropertyValue("system_location")
    };
    D.siInfo = {
        value: E.getPropertyValue("system_information")
    };
    if (C) {
        D.siName.setOrig = true;
        D.siContact.setOrig = true;
        D.siLocation.setOrig = true;
        D.siInfo.setOrig = true
    }
    this.update(D);
    if (D) {
        this.retrieve(D)
    }
};
SystemInfoWidget.prototype.changeCallback = function(H, E, F) {
    var C, D = {};
    this.valueChanged = false;
    this.retrieve(D);
    for (C in D) {
        if (D[C].valueChanged == true) {
            this.valueChanged = true;
            break
        }
    }
    var G = {};
    if ($.isFunction(this.options.changeCallback) && this.name && session.hasConfigurationCapability()) {
        if (!G[this.name]) {
            G[this.name] = {}
        }
        G[this.name].valueChanged = this.valueChanged;
        this.options.changeCallback(G, this, F)
    }
};
SystemInfoWidget.prototype.getCommandQueue = function() {
    var E = {};
    var D = {};
    var C = [];
    this.retrieve(E);
    for (var F in E) {
        if (E[F] && E[F].valueChanged) {
            D[F] = E[F]
        }
    }
    C.push({
        name: "setSystemInfo",
        command: MC.setSystemInfo,
        data: D,
        options: {
            processingMsg: strings.systemInformation.processing,
            failureMsg: strings.systemInformation.failure,
            successMsg: strings.systemInformation.success
        }
    });
    return C
};
SystemInfoWidget.prototype.getConfirmMsg = function() {
    var E = {};
    this.retrieve(E);
    var G = '<div class="confirmLabel"><u>' + strings.systeminfo.siInfoLabel + "</u></div><br>";
    for (var D in E) {
        if (E[D].valueChanged) {
            var C = strings.configurationWizard.summary[D];
            var F = E[D].value;
            G += C + ": " + F + "<br>"
        }
    }
    return G
};

function SystemSettings(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "SystemSettings";
    D.width = 300;
    D.okCallback = createObjectCallback(this, this.okCallback);
    D.okButtonText = strings.applyAndClose;
    D.applyCallback = createObjectCallback(this, this.applyCallback);
    D.cancelCallback = createObjectCallback(this, this.cancelCallback);
    var C = [{
        name: "dateTime",
        label: strings.configurationWizard.dateTimeLabel
    }, {
        name: "manageUsers",
        label: strings.configurationWizard.manageUsersLabel
    }, {
        name: "network",
        label: strings.configurationWizard.nwStep
    }, {
        name: "services",
        label: strings.configurationWizard.servStep
    }, {
        name: "systemInfo",
        label: strings.configurationWizard.siTitle
    }, {
        name: "notifications",
        label: strings.configurationWizard.notifyStep
    }];
    if (!isDellSystem()) {
        C.splice(2, 0, {
            name: "license",
            label: strings.menus.licenseSetup
        })
    }
    if (!APIPort.hasPortType("SAS")) {
        C.push({
            name: "ports",
            label: strings.Ports
        })
    }
    D.widgets = [new TextWidget({
        name: "waitingWidget",
        text: '<div class="processIndicator" style="display: inline-block; width: 200px"></div>'
    }), this.tabWidget = new VerticalTabWidget({
        name: "tabs",
        changeCallback: createObjectCallback(this, this.tabSelected),
        tabs: C,
        widgets: [this.systemSettingsForm = new FormWidget({
            name: "configForm",
            widgets: [this.dateTimeWidget = new DateTimeWidget({
                name: "dateTime",
                changeCallback: createObjectCallback(this, this.somethingChanged)
            }), new WidgetContainer({
                name: "manage",
                width: 690,
                widgets: [new WidgetContainer({
                    name: "manageUsersRequired",
                    classes: "requiredContainer",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new TextWidget({
                        text: '<span style="font-size: 15px;" class="requiredIndicator">*</span>&nbsp;' + strings.systemSettings.manageUsersRequired
                    })]
                }), this.manageUsersWidget = new ManageUsersWidget({
                    name: "manageUsers",
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            }), new WidgetContainer({
                name: "license",
                width: 690,
                widgets: [new WidgetContainer({
                    name: "licenseRequired",
                    classes: "requiredContainer",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new TextWidget({
                        text: '<span style="font-size: 15px;" class="requiredIndicator">*</span>&nbsp;' + (isHPsystem() ? strings.systemSettings.licenseRequiredHP : strings.systemSettings.licenseRequiredLenovo) + (isHPsystem() ? '<a class="linkColor" href=" https://marketplace.hpe.com" target="_blank" >https://marketplace.hpe.com</a>.' : "")
                    }), new CheckboxInputWidget({
                        name: "skipLicenseConfig",
                        topMargin: true,
                        bottomMargin: true,
                        label: (isHPsystem() ? strings.systemSettings.skipLicenseRequirementHP : strings.systemSettings.skipLicenseRequirementLenovo),
                        changeCallback: createObjectCallback(this, this.bypassLicenseConfig)
                    })]
                }), this.licenseWidget = new LicenseSetupWidget({
                    name: "licenseWidget",
                    changeCallback: createObjectCallback(this, this.somethingChanged),
                    licenseUploadComplete: createObjectCallback(this, this.licenseUploadComplete)
                })]
            }), new WidgetContainer({
                name: "network",
                widgets: [new TextWidget({
                    name: "wizConfNetworkText",
                    text: strings.configurationWizard.nwText1,
                    bottomMargin: true,
                    rightMargin: true
                }), this.networkWidget = new NetworkConfigWidget({
                    name: "networkWidget",
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            }), new WidgetContainer({
                name: "services",
                widgets: [new TextWidget({
                    name: "wizConfServicesText",
                    text: strings.configurationWizard.servText1,
                    bottomMargin: true,
                    rightMargin: true
                }), this.servicesWidget = new ServicesConfigWidget({
                    name: "wizConfServConfig",
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            }), new WidgetContainer({
                name: "sysInfo",
                widgets: [new TextWidget({
                    name: "wizConfSysInfoText",
                    text: strings.configurationWizard.siText1,
                    bottomMargin: true,
                    rightMargin: true
                }), this.sysInfoWidget = new SystemInfoWidget({
                    name: "sysInfo",
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            }), new WidgetContainer({
                name: "notification",
                width: 690,
                widgets: [new WidgetContainer({
                    name: "notifRequired",
                    id: "notifRequired",
                    classes: "requiredContainer",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new TextWidget({
                        text: '<span style="font-size: 15px;" class="requiredIndicator">*</span>&nbsp;' + strings.systemSettings.notifRequired
                    }), new CheckboxInputWidget({
                        name: "skipNotifications",
                        topMargin: true,
                        bottomMargin: true,
                        label: strings.systemSettings.bypassNotifications,
                        changeCallback: createObjectCallback(this, this.bypassNotifications)
                    })]
                }), new TextWidget({
                    name: "wizConfNotificationText",
                    text: strings.configurationWizard.notifyText1,
                    bottomMargin: true
                }), this.notificationWidget = new NotificationSetupWidget({
                    name: "notificationSetupWidget",
                    bottomMargin: true,
                    noTests: false,
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            }), new WidgetContainer({
                name: "ports",
                width: 690,
                widgets: [new WidgetContainer({
                    name: "portsRequired",
                    classes: "requiredContainer",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new TextWidget({
                        text: '<span style="font-size: 15px;" class="requiredIndicator">*</span>&nbsp;' + strings.systemSettings.portsRequired
                    }), new CheckboxInputWidget({
                        name: "skipPortConfig",
                        topMargin: true,
                        bottomMargin: true,
                        label: strings.systemSettings.skipPortsRequirement,
                        changeCallback: createObjectCallback(this, this.bypassRequiredPorts)
                    })]
                }), this.portWidget = new PortConfigWidget({
                    name: "portWidget",
                    changeCallback: createObjectCallback(this, this.somethingChanged)
                })]
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "SystemSettings";
    $(".actionTray", this.elements).css("display", "block")
}
SystemSettings.prototype = new ActionPanel();
SystemSettings.prototype.constructor = SystemSettings;
SystemSettings.getMenuState = function(D) {
    if (RI.hasFeature("easyStartFirmware") && session.hasConfigurationCapability()) {
        var C = EZStartManager.bypassFirmware;
        if (!C) {
            return strings.easyStart.mustCompleteFirmware
        }
    } else {
        return []
    }
};
SystemSettings.prototype.showing = function() {
    this.usersSubscription = MC.usersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            var E = $(".requiredIndicator", "#manageUsers");
            if (E.length && !EZStartManager.isStepRequired("manageUsers")) {
                this.tabWidget.setLabelComplete("manageUsers");
                this.update({
                    manageUsersRequired: {
                        visibility: "collapse"
                    }
                });
                this.checkConfigComplete()
            }
        })
    });
    this.emailSubscription = MC.emailParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            var E = $(".requiredIndicator", "#notifications");
            if (E.length && !EZStartManager.isStepRequired("notifications")) {
                this.tabWidget.setLabelComplete("setLabelComplete");
                if (!EZStartManager.bypassNotifications) {
                    this.bypassNotificationsStep();
                    this.update({
                        notifRequired: {
                            visibility: "collapse"
                        }
                    });
                    this.checkConfigComplete()
                }
            }
        })
    });
    this.snmpSubscription = MC.snmpParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(F) {
            var E = $(".requiredIndicator", "#notifications");
            if (E.length && !EZStartManager.isStepRequired("notifications")) {
                this.tabWidget.setLabelComplete("setLabelComplete");
                if (!EZStartManager.bypassNotifications) {
                    this.bypassNotificationsStep();
                    this.update({
                        notifRequired: {
                            visibility: "collapse"
                        }
                    });
                    this.checkConfigComplete()
                }
            }
        })
    });
    this.syslogSubscription = MC.syslogParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(F) {
            var E = $(".requiredIndicator", "#notifications");
            if (E.length && !EZStartManager.isStepRequired("notifications")) {
                this.tabWidget.setLabelComplete("setLabelComplete");
                if (!EZStartManager.bypassNotifications) {
                    this.bypassNotificationsStep();
                    this.update({
                        notifRequired: {
                            visibility: "collapse"
                        }
                    });
                    this.checkConfigComplete()
                }
            }
        })
    });
    if (APIPort.hasPortType("iSCSI")) {
        this.iscsiParamsSubscription = MC.iscsiParametersSet.requestData({
            update: false,
            durable: "all",
            requestor: this.class_name,
            handler: createObjectCallback(this, function() {
                var E = $(".requiredIndicator", "#ports");
                if (E.length && !EZStartManager.isStepRequired("ports")) {
                    this.tabWidget.setLabelComplete("ports");
                    if (!EZStartManager.bypassPortConfig) {
                        this.bypassRequiredPortsStep();
                        this.update({
                            portsRequired: {
                                visibility: "collapse"
                            }
                        });
                        this.checkConfigComplete()
                    }
                }
            })
        })
    }
    this.licenseSubscription = MC.licenseSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            var E = $(".requiredIndicator", "#license");
            if (E.length && !EZStartManager.isStepRequired("license")) {
                this.tabWidget.setLabelComplete("license");
                if (!EZStartManager.bypassLicenseConfig) {
                    this.bypassRequiredLicenseStep();
                    this.update({
                        licenseRequired: {
                            visibility: "collapse"
                        }
                    });
                    this.checkConfigComplete()
                }
            }
        })
    });
    this.update({
        tabs: {
            visibility: "hidden"
        },
        SystemSettings_ok: {
            visibility: "collapse"
        },
        SystemSettings_apply: {
            visibility: "collapse"
        },
        SystemSettings_cancel: {
            visibility: "collapse"
        }
    });
    var D = this;
    this.interval = setInterval(function() {
        D.datasetsLoaded()
    }, 2000);
    setTimeout(createObjectCallback(this, this.loadData), 100);
    this.okEnabled(false);
    if (!session.hasManageStandardRole()) {
        var C = {};
        C.skipPortConfig = {
            disable: true
        };
        C.skipSupportAssist = {
            disable: true
        };
        C.skipNotifications = {
            disable: true
        };
        C.skipLicenseConfig = {
            disable: true
        };
        this.update(C)
    }
};
SystemSettings.prototype.datasetsLoaded = function() {
    var C = this.manageUsersWidget.dataUpdated();
    var D = this.notificationWidget.dataUpdated();
    if (C && D) {
        clearInterval(this.interval);
        this.resetSize({
            width: 900,
            height: 600
        });
        this.update({
            waitingWidget: {
                visibility: "collapse"
            },
            tabs: {
                visibility: "visible"
            },
            SystemSettings_ok: {
                visibility: "visible"
            },
            SystemSettings_apply: {
                visibility: "visible"
            },
            SystemSettings_cancel: {
                visibility: "visible"
            }
        });
        if ($(".actionButtons").find(".requiredIndicator").length == 0 && this.requiredHtml != undefined) {
            $(".actionButtons").append(this.requiredHtml)
        }
    }
};
SystemSettings.prototype.tabSelected = function(C, E) {
    if (C == null) {
        return
    }
    if (this.htmlLoaded) {
        E = E.replace(/(\r\n|\n|\r)/gm, "");
        if (E.indexOf("*") != -1) {
            E = E.substring(0, E.length - 2)
        }
        E = E.trim();
        switch (E) {
            case strings.configurationWizard.dateTimeLabel:
                this.update({
                    dateTime: {
                        visibility: "visible"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.configurationWizard.manageUsersLabel:
                var D = EZStartManager.isStepRequired("manageUsers");
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manageUsersRequired: {
                        visibility: (D ? "visible" : "collapse")
                    },
                    manage: {
                        visibility: "visible"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.menus.licenseSetup:
                var D = EZStartManager.isStepRequired("license");
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    licenseRequired: {
                        visibility: (D ? "visible" : "collapse")
                    },
                    license: {
                        visibility: "visible"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.configurationWizard.nwStep:
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "visible"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.configurationWizard.servStep:
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "visible"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.configurationWizard.siTitle:
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "visible"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.configurationWizard.notifyStep:
                var D = EZStartManager.isStepRequired("notifications");
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notifRequired: {
                        visibility: (D ? "visible" : "collapse")
                    },
                    notification: {
                        visibility: "visible"
                    },
                    ports: {
                        visibility: "collapse"
                    }
                });
                break;
            case strings.Ports:
                var D = EZStartManager.isStepRequired("ports");
                this.update({
                    dateTime: {
                        visibility: "collapse"
                    },
                    manage: {
                        visibility: "collapse"
                    },
                    license: {
                        visibility: "collapse"
                    },
                    network: {
                        visibility: "collapse"
                    },
                    services: {
                        visibility: "collapse"
                    },
                    sysInfo: {
                        visibility: "collapse"
                    },
                    notification: {
                        visibility: "collapse"
                    },
                    portsRequired: {
                        visibility: (D ? "visible" : "collapse")
                    },
                    ports: {
                        visibility: "visible"
                    }
                });
                break;
            default:
                break
        }
    }
};
SystemSettings.prototype.bypassLicenseConfig = function() {
    ShowActiveDialog({
        type: "confirm",
        message: (isHPsystem() ? strings.systemSettings.bypassLicenseConfirmHP : strings.systemSettings.bypassLicenseConfirmLenovo),
        ok: createObjectCallback(this, function() {
            MC.setUserInteraction({
                bypassLicense: true
            }, {
                dialog: true,
                processingMsg: strings.systemSettings.bypassLicenseProcessing,
                failureMsg: strings.systemSettings.bypassLicenseFailure,
                successMsg: (isHPsystem() ? strings.systemSettings.bypassLicenseHPE : strings.systemSettings.bypassLicenseSuccess),
                callback: createObjectCallback(this, this.bypassLicenseComplete)
            })
        }),
        cancel: createObjectCallback(this, function() {
            this.update({
                skipLicenseConfig: {
                    value: false
                }
            })
        })
    })
};
SystemSettings.prototype.bypassNotificationsStep = function(C) {
    MC.setUserInteraction({
        bypassNotifications: true
    }, {
        dialog: (C ? true : false),
        processingMsg: strings.systemSettings.bypassNotificationsProcessing,
        failureMsg: strings.systemSettings.bypassNotificationsFailure,
        successMsg: strings.systemSettings.bypassNotificationsSuccess,
        callback: createObjectCallback(this, this.bypassNotificationsComplete)
    })
};
SystemSettings.prototype.bypassNotifications = function() {
    ShowActiveDialog({
        type: "confirm",
        message: strings.systemSettings.bypassNotificationsConfirm,
        ok: createObjectCallback(this, this.bypassNotificationsStep, true),
        cancel: createObjectCallback(this, function() {
            this.update({
                skipNotifications: {
                    value: false
                }
            })
        })
    })
};
SystemSettings.prototype.bypassNotificationsComplete = function(C) {
    if (C.success) {
        EZStartManager.bypassNotifications = true;
        this.tabWidget.setLabelComplete("notifications");
        this.update({
            notifRequired: {
                visibility: "collapse"
            }
        });
        this.checkConfigComplete()
    } else {
        this.update({
            skipNotifications: {
                value: false
            }
        })
    }
};
SystemSettings.prototype.bypassRequiredPortsStep = function() {
    MC.setUserInteraction({
        bypassPort: true
    }, {
        dialog: true,
        processingMsg: strings.systemSettings.bypassPortProcessing,
        failureMsg: strings.systemSettings.bypassPortFailure,
        successMsg: strings.systemSettings.bypassPortSuccess,
        callback: createObjectCallback(this, this.bypassPortComplete)
    })
};
SystemSettings.prototype.bypassRequiredPorts = function() {
    ShowActiveDialog({
        type: "confirm",
        message: strings.systemSettings.bypassPortConfirm,
        ok: createObjectCallback(this, this.bypassRequiredPortsStep),
        cancel: createObjectCallback(this, function() {
            this.update({
                skipPortConfig: {
                    value: false
                }
            })
        })
    })
};
SystemSettings.prototype.bypassPortComplete = function(C) {
    if (C.success) {
        EZStartManager.bypassPortConfig = true;
        this.tabWidget.setLabelComplete("ports");
        this.update({
            portsRequired: {
                visibility: "collapse"
            }
        });
        this.checkConfigComplete()
    } else {
        this.update({
            skipPortConfig: {
                value: false
            }
        })
    }
};
SystemSettings.prototype.bypassRequiredLicenseStep = function() {
    MC.setUserInteraction({
        bypassLicense: true
    }, {
        dialog: false,
        processingMsg: strings.systemSettings.bypassLicenseProcessing,
        failureMsg: strings.systemSettings.bypassLicenseFailure,
        successMsg: strings.systemSettings.bypassLicenseSuccess,
        callback: createObjectCallback(this, this.bypassLicenseComplete)
    })
};
SystemSettings.prototype.bypassLicenseComplete = function(C) {
    if (C.success) {
        EZStartManager.bypassLicenseConfig = true;
        this.tabWidget.setLabelComplete("license");
        this.update({
            licenseRequired: {
                visibility: "collapse"
            }
        });
        this.checkConfigComplete()
    } else {
        this.update({
            skipLicenseConfig: {
                value: false
            }
        })
    }
};
SystemSettings.prototype.somethingChanged = function(D) {
    for (var C in D) {
        if (D[C].valueChanged) {
            this.okEnabled(true);
            this.applyEnabled(true)
        } else {
            this.okEnabled(false);
            this.applyEnabled(false)
        }
    }
};
SystemSettings.prototype.loadData = function() {
    if (RI.hasFeature("easyStart") && !EZStartManager.bypassEasyStart && !EZStartManager.isConfigurationComplete()) {
        for (var C = 0; C < EZStartManager.requiredSteps.length; C++) {
            this.tabWidget.setLabelRequired(EZStartManager.requiredSteps[C])
        }
        this.requiredHtml = '<div id="configRequiredLegend" style="margin-left:10px"><span style="font-size: 15px;" class="requiredIndicator">*</span>&nbsp;<span style="display: inline-block;" class="textWidget">' + strings.configurationWizard.configRequired + "</span>"
    }
    this.notificationWidget.tabSelected(0);
    $("#" + this.actionOptions.tab).click()
};
SystemSettings.prototype.hiding = function() {
    if (this.usersSubscription) {
        MC.usersSet.unregister(this.usersSubscription);
        delete this.usersSubscription
    }
};
SystemSettings.prototype.checkConfigComplete = function() {
    var C = $(".requiredIndicator", "#configRequiredLegend");
    if (EZStartManager.isConfigurationComplete() && C.length) {
        var D = '<span class="completed"></span>&nbsp;<span style="display: inline-block; padding-bottom: 5px;" class="textWidget">' + strings.configurationWizard.configComplete + "</span>";
        $("#configRequiredLegend").html(D);
        panels.EasyStartTopic.generalUpdate()
    }
};
SystemSettings.prototype.okCallback = function() {
    this.okOrApply = "ok";
    var C = this.systemSettingsForm.validate();
    if (C) {
        this.sendCommands()
    } else {
        this.okEnabled(false);
        this.applyEnabled(false)
    }
};
SystemSettings.prototype.applyCallback = function() {
    this.okOrApply = "apply";
    var C = this.systemSettingsForm.validate();
    if (C) {
        this.sendCommands()
    } else {
        this.okEnabled(false);
        this.applyEnabled(false)
    }
};
SystemSettings.prototype.cancelCallback = function() {
    this.manageUsersWidget.clearTable();
    this.licenseWidget.clearTable();
    panels.actionDialog.close(true)
};
SystemSettings.prototype.licenseUploadComplete = function(E, D) {
    var C = parseInt(D.statusObject.getPropertyValue("response_type_numeric"));
    if (C) {
        ShowActiveDialog({
            dialogOverride: true,
            type: "failure",
            message: strings.enhanceOn + strings.licenseMgmt.failureMsg + strings.enhanceOff + "<br />" + D.statusObject.getPropertyValue("response")
        });
        $("#licenseFile").val("")
    } else {
        this.licenseWidget.fileUploadSuccess = true;
        if (this.licenseWidget.fileUploading != undefined) {
            this.licenseWidget.fileUploading = undefined
        }
        this.sendCommands()
    }
};
SystemSettings.prototype.sendCommands = function() {
    var D = [];
    if (this.licenseWidget.valueChanged) {
        if (this.licenseWidget.fileUploadWidget.valueChanged) {
            this.licenseWidget.fileUploadWidget.uploadFile();
            this.licenseWidget.valueChanged = false;
            return
        } else {
            D = D.concat(this.licenseWidget.getTempLicenseCommand())
        }
    }
    if (this.dateTimeWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.dateTimeWidget.getCommandQueue())
    }
    if (this.manageUsersWidget.valueChanged) {
        D = D.concat(this.manageUsersWidget.getCommandQueue())
    }
    if (this.networkWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.networkWidget.createSetCommands())
    }
    if (this.servicesWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.servicesWidget.getCommandQueue())
    }
    if (this.sysInfoWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.sysInfoWidget.getCommandQueue())
    }
    if (this.notificationWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.notificationWidget.createSetCommands())
    }
    if (RI.hasFeature("supportAssist") && this.supportAssistWidget.valueChanged && session.hasConfigurationCapability()) {
        this.supportAssistWidget.valueChanged = false
    }
    if (this.portWidget.valueChanged && session.hasConfigurationCapability()) {
        D = D.concat(this.portWidget.createSetCommands())
    }
    var C = {
        confirmMsg: this.generateConfirmMsg(),
        confirm2Msg: this.generateConfirm2Msg(),
        successMsg: strings.systemSettings.successMsg,
        callback: createObjectCallback(this, function(E) {
            if (E.success) {
                this.checkConfigComplete();
                this.resetValueChanged();
                if (this.okOrApply == "apply") {
                    this.update({
                        configForm: {
                            resetValidation: true
                        }
                    });
                    this.okEnabled(false);
                    this.applyEnabled(false)
                } else {
                    this.cancelCallback()
                }
            }
        })
    };
    if (D.length) {
        MC.execCommandList(D, C)
    } else {
        if (this.okOrApply == "ok") {
            this.close()
        } else {
            this.okEnabled(false);
            this.applyEnabled(false)
        }
    }
};
SystemSettings.prototype.resetValueChanged = function() {
    if (this.dateTimeWidget.valueChanged) {
        this.dateTimeWidget.valueChanged = false
    }
    if (this.manageUsersWidget.valueChanged) {
        this.manageUsersWidget.valueChanged = false
    }
    if (this.networkWidget.valueChanged) {
        this.networkWidget.valueChanged = false
    }
    if (this.servicesWidget.valueChanged) {
        this.servicesWidget.valueChanged = false
    }
    if (this.sysInfoWidget.valueChanged) {
        this.sysInfoWidget.valueChanged = false
    }
    if (this.notificationWidget.valueChanged) {
        this.notificationWidget.valueChanged = false
    }
    if (RI.hasFeature("supportAssist") && this.supportAssistWidget.valueChanged) {
        this.supportAssistWidget.valueChanged = false
    }
    if (this.portWidget.valueChanged) {
        this.portWidget.valueChanged = false
    }
    if (this.licenseWidget.valueChanged) {
        this.licenseWidget.valueChanged = false
    }
};
SystemSettings.prototype.generateConfirmMsg = function() {
    var C = {};
    var E = [];
    var D = strings.configurationWizard.confirmMsg;
    if (this.dateTimeWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.dateTimeWidget.getConfirmMsg() + "<br>"
    }
    if (this.manageUsersWidget.valueChanged) {
        D += this.manageUsersWidget.getConfirmMsg() + "<br>"
    }
    if (this.networkWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.networkWidget.getConfirmMsg() + "<br>"
    }
    if (this.servicesWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.servicesWidget.getConfirmMsg(false, true) + "<br>"
    }
    if (this.sysInfoWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.sysInfoWidget.getConfirmMsg() + "<br>"
    }
    if (this.notificationWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.notificationWidget.getConfirmMsg() + "<br>"
    }
    if (this.supportAssistWidget != undefined && this.supportAssistWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.supportAssistWidget.getConfirmMsg() + "<br>"
    }
    if (this.portWidget.valueChanged && session.hasConfigurationCapability()) {
        D += this.portWidget.getConfirmMsg() + "<br>"
    }
    if (this.licenseWidget.valueChanged) {
        D += this.licenseWidget.getConfirmMsg() + "<br>"
    }
    D += strings.configurationWizard.confirmMsg2;
    return D
};
SystemSettings.prototype.generateConfirm2Msg = function() {
    var C = {};
    this.retrieve(C);
    var D = "";
    if (this.portWidget.valueChanged && (C.modeList != undefined) && C.modeList.valueChanged && !EZStartManager.isConfigurationComplete()) {
        D = strings.portconfig.confirm2HostPortMode
    }
    return D
};

function ResetHostPortAction(J) {
    if (arguments.length == 0) {
        return
    }
    J.name = "ResetHostPortAction";
    J.title = strings.resetHostPort.title;
    J.okCallback = createObjectCallback(this, this.okCallback);
    var I = [];
    for (var E in DC.ports) {
        I.push({
            name: DC.ports[E].get("port"),
            type: DC.ports[E].get("port_type")
        })
    }
    I.sort(function(L, K) {
        return L.name - K.name
    });
    var H = [{
        value: I[0].name,
        text: I[0].name
    }];
    for (var G = 1, C = I.length; G < C; G++) {
        var D = I[G].name;
        var F = D.charAt(1) - system.physicalPositionOffset;
        if (F % 2 != 0 && ((I[G].type == "SAS" && I[G - 1].type == "SAS") || (I[G].type == "iSCSI" && I[G - 1].type == "iSCSI"))) {
            H[H.length - 1].text += (", " + D)
        } else {
            H.push({
                value: D,
                text: D
            })
        }
    }
    J.widgets = [new TextWidget({
        name: "selectPort",
        text: strings.resetHostPort.selectPort
    }), new OptionInputWidget({
        name: "ports",
        label: strings.resetHostPort.port,
        labelOptions: {
            rightMargin: true,
            bottomMargin: true
        },
        row: 0,
        col: 1,
        topMargin: true,
        values: H
    })];
    ActionPanel.call(this, J);
    this.class_name = "ResetHostPortAction"
}
ResetHostPortAction.prototype = new ActionPanel();
ResetHostPortAction.prototype.constructor = ResetHostPortAction;
ResetHostPortAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
ResetHostPortAction.prototype.showing = function() {
    this.okEnabled(true)
};
ResetHostPortAction.prototype.okCallback = function() {
    var C = {
        dialog: true,
        confirmMsg: strings.resetHostPort.confirmMsg,
        processingMsg: strings.resetHostPort.processingMsg,
        failureMsg: strings.resetHostPort.error,
        successMsg: strings.resetHostPort.success,
        closeActionOn: "success"
    };
    var D = {};
    this.retrieve(D);
    MC.resetHostChannel({
        ports: D.ports.value
    }, C)
};

function RescanDiskChannelAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RescanDiskChannelAction";
    C.width = 350;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.okButtonText = strings.rescan.button;
    C.widgets = [new TextWidget({
        name: "rescanText",
        text: strings.rescan.instructions
    })];
    ActionPanel.call(this, C);
    this.class_name = "RescanDiskChannelAction"
}
RescanDiskChannelAction.prototype = new ActionPanel();
RescanDiskChannelAction.prototype.constructor = RescanDiskChannelAction;
RescanDiskChannelAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
RescanDiskChannelAction.prototype.showing = function() {
    this.okEnabled(true, true)
};
RescanDiskChannelAction.prototype.okCallback = function() {
    MC.rescanDiskChannel({}, {
        dialog: true,
        confirmMsg: strings.rescan.confirmMsg,
        processingMsg: strings.rescan.processingMsg,
        failureMsg: strings.rescan.error,
        successMsg: strings.rescan.success,
        closeActionOn: "success"
    })
};

function ClearMetadataAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ClearMetadataAction";
    C.width = 610;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "clearMetadataForm",
        data: {},
        widgets: [new TextWidget({
            name: "description",
            text: strings.clearMetadataAction.description,
            row: 0,
            col: 0,
            bottomMargin: true
        }), new TableInator({
            name: "disks",
            row: 1,
            col: 0,
            selectable: "multiple",
            type: "apiData",
            noFeatures: true,
            metadata: "drives",
            criteria: {
                type: "prop",
                name: "usage_numeric",
                value: DRIVE_USAGE.LEFTOVER
            },
            fields: ["enclosure_id", "slot", "serial_number", "vendor", "model", "size"],
            selectCallback: createObjectCallback(this, this.changedCallback)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ClearMetadataAction"
}
ClearMetadataAction.prototype = new ActionPanel();
ClearMetadataAction.prototype.constructor = ClearMetadataAction;
ClearMetadataAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = MC.disksSet.dataSelect({
        type: "prop",
        name: "usage_numeric",
        value: DRIVE_USAGE.LEFTOVER
    });
    if (C.objects.length > 0) {
        return []
    } else {
        return strings.menuTips.noMetadataTip
    }
};
ClearMetadataAction.prototype.showing = function() {
    var C = {};
    C.disks = {
        data: MC.disksSet.data.objects
    };
    this.update(C)
};
ClearMetadataAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var G = {};
    G.disks = [];
    var E = [];
    if (C.disks && C.disks.selected.length > 0) {
        for (var D = 0; D < C.disks.selected.length; D++) {
            var F = C.disks.selected[D].getObject().get("durable_id");
            G.disks[D] = F.replace(/disk_/, "");
            E.push(F)
        }
        MC.clearMetadata(G, {
            dialog: true,
            confirmMsg: strings.clearMetadataAction.confirmMsg(MC.getItemList(E, true)),
            processingMsg: strings.clearMetadataAction.processing,
            failureMsg: strings.clearMetadataAction.failure,
            successMsg: strings.clearMetadataAction.success,
            cancelLabel: strings.cancelButtonText,
            closeActionOn: "success"
        })
    }
};
ClearMetadataAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (C.clearMetadataForm.valid && C.disks.selected.length > 0) {
        this.okEnabled(true, true)
    } else {
        this.okEnabled(false)
    }
};

function UpdateFirmwareAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "UpdateFirmwareAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    D.cancelCallback = createObjectCallback(this, this.cancelCallback);
    var F = createObjectCallback(this, this.startingCallback);
    var G = createObjectCallback(this, this.finishedCallback);
    var I = createObjectCallback(this, this.fileSelected);
    var E = createObjectCallback(this, this._changedCallback);
    var L = createObjectCallback(this, this.resetAction);
    this.uCtrlAction = "/api/updateFirmware";
    this.uEmpAction = "/api/updateExpansionFirmware";
    this.uDisksAction = "/api/updateDiskFirmware";
    this.action = "";
    var K = false;
    this.tabValues = [{
        name: "tabUpdateController",
        label: strings.updateFirmware.UpdateController
    }, {
        name: "tabUpdateEMP",
        label: (EXPR.is12GBackend ? strings.updateFirmware.expanderFirmware : strings.updateFirmware.UpdateExpansionModule)
    }, {
        name: "tabUpdateDisks",
        label: strings.updateFirmware.UpdateDiskDriveFirmware
    }];
    if (EXPR.is12GBackend) {
        var N = strings.updateFirmware.instructions12gig;
        var C = false;
        this.columns = [{
            sTitle: "keyRow",
            bVisible: false,
            bIsKey: true
        }, {
            sTitle: strings.updateFirmware.enclosureCol
        }, {
            sTitle: strings.updateFirmware.moduleCol
        }, {
            sTitle: strings.updateFirmware.locationCol
        }, {
            sTitle: strings.updateFirmware.codeVersionCol
        }]
    } else {
        var N = strings.updateFirmware.iomInstructions;
        var C = "multiple";
        this.columns = [{
            sTitle: "keyRow",
            bVisible: false,
            bIsKey: true
        }, {
            sTitle: strings.updateFirmware.enclosureCol
        }, {
            sTitle: strings.updateFirmware.moduleCol
        }, {
            sTitle: strings.updateFirmware.positionCol
        }, {
            sTitle: strings.updateFirmware.partNumberCol
        }, {
            sTitle: strings.updateFirmware.codeVersionCol
        }, {
            sTitle: strings.updateFirmware.busIdCol
        }, {
            sTitle: strings.updateFirmware.targetIdCol
        }]
    }
    if (isVistaSystem()) {
        var J = new LabeledWidgetContainer({
            name: "pfuGroup",
            label: strings.updateFirmware.PartnerFirmwareUpgrade,
            widgets: [new TextWidget({
                name: "pfuInfo",
                text: strings.updateFirmware.pfuInfo,
                bottomMargin: true
            }), new TextWidget({
                name: "pfuStatus",
                bottomMargin: true
            })]
        })
    } else {
        var J = new FormWidget({
            name: "pfuForm",
            widgets: [new CheckboxContainer({
                name: "pfuGroup",
                label: strings.updateFirmware.PartnerFirmwareUpgrade,
                changeCallback: createObjectCallback(this, this.handlePfuChange),
                widgets: [new TextWidget({
                    name: "pfuInfo",
                    text: strings.updateFirmware.pfuInfo,
                    bottomMargin: true
                }), new TextWidget({
                    name: "pfuStatus",
                    bottomMargin: true
                })]
            })]
        })
    }
    var M = [new TextWidget({
        name: "uEmpInstructions",
        text: N,
        topMargin: true,
        bottomSmallMargin: true
    }), this.uEmpTable = new TableInator({
        name: "uEmpTable",
        type: "rawData",
        selectable: C,
        bottomMargin: true,
        metadata: this.columns,
        dtOptions: {
            bFilter: false,
            bLengthChange: false,
            bInfo: false,
            bPaginate: false,
            aaSorting: [
                [1, "asc"],
                [2, "asc"]
            ]
        },
        selectCallback: E
    })];
    if (isHPsystem()) {
        M.push(this.uEmpFile = new FileUploadWidget({
            name: "uEmpFile",
            label: strings.updateFirmware.empFWLabel,
            labelOptions: {
                rightMargin: true
            },
            action: this.uEmpAction,
            submitText: strings.Update,
            noCompletedDialog: true,
            noButton: true,
            size: 25,
            changeCallback: I,
            startingCallback: F,
            finishedCallback: G,
            resetAction: L
        }))
    }
    var H = [new WidgetContainer({
        classes: "clearFloats"
    }), new WidgetContainer({
        name: "uCtrlContainer",
        widgets: [new TextWidget({
            name: "uCtrlInstructions",
            text: strings.updateFirmware.controllerInstructions(""),
            topMargin: true,
            bottomSmallMargin: true
        }), new TableInator({
            name: "uCtrlTable",
            type: "rawData",
            bottomMargin: true,
            metadata: [{
                sTitle: strings.updateFirmware.componentCol
            }, {
                sTitle: strings.updateFirmware.controllerACol
            }, {
                sTitle: strings.updateFirmware.controllerBCol
            }],
            noFeatures: true
        }), this.uCtrlFile = new FileUploadWidget({
            name: "uCtrlFile",
            label: strings.updateFirmware.ctrlFWLabel,
            labelOptions: {
                rightMargin: true
            },
            action: this.uCtrlAction,
            submitText: strings.Update,
            noCompletedDialog: true,
            noButton: true,
            size: 25,
            changeCallback: I,
            startingCallback: F,
            finishedCallback: G,
            resetAction: L
        }), J]
    }), this.uEmpContainer = new WidgetContainer({
        name: "uEmpContainer",
        widgets: M
    }), new WidgetContainer({
        name: "uDisksContainer",
        widgets: [new TextWidget({
            name: "uDisksTitle",
            text: strings.updateFirmware.diskInstructions,
            topMargin: true,
            bottomSmallMargin: true
        }), this.uDisksTable = new TableInator({
            name: "uDisksTable",
            type: "apiData",
            data: MC.disksSet.data.objects,
            metadata: "drives",
            fields: ["enclosure_id", "slot", "health", "owner", "vendor", "model", "serial_number", "description", "revision"],
            columnOverrides: {
                enclosure_id: {
                    sTitle: strings.updateFirmware.enclosureCol
                },
                slot: {
                    sTitle: strings.updateFirmware.slot,
                    bFilterMenu: false
                },
                health: {
                    sTitle: strings.updateFirmware.health
                },
                vendor: {
                    sTitle: strings.updateFirmware.vendor
                },
                model: {
                    sTitle: strings.updateFirmware.model
                },
                serial_number: {
                    sTitle: strings.updateFirmware.serialnumber
                },
                description: {
                    sTitle: strings.Description
                },
                revision: {
                    sTitle: strings.updateFirmware.revision
                },
                owner: {
                    sTitle: strings.updateFirmware.ownerCol
                }
            },
            dtOptions: {
                bLengthChange: false,
                aaSorting: [
                    [0, "asc"],
                    [1, "asc"]
                ]
            },
            selectable: "multiple",
            bottomMargin: true,
            selectCallback: E
        }), this.uDisksFile = new FileUploadWidget({
            name: "uDisksFile",
            label: strings.updateFirmware.diskFWLabel,
            labelOptions: {
                rightMargin: true
            },
            action: this.uDisksAction,
            submitText: strings.Update,
            noCompletedDialog: true,
            noButton: true,
            size: 25,
            changeCallback: I,
            startingCallback: F,
            finishedCallback: G,
            resetAction: L
        })]
    })];
    if (isQuantumSystem()) {
        this.tabValues.splice(1, 1);
        H.splice(2, 1)
    }
    D.widgets = [new WidgetContainer({
        name: "updateFirmwareWC",
        widgets: [new WidgetContainer({
            name: "checkFirmware",
            widgets: [new TextWidget({
                text: strings.updateFirmware.hpe1
            }), new TextWidget({
                name: "currentVersion",
                label: strings.updateFirmware.hpe2,
                topMargin: true
            }), new TextWidget({
                text: strings.updateFirmware.hpe3Part1 + '<a class="linkColor" href=" https://www.hpe.com/storage/msafirmware" target="_blank">https://www.hpe.com/storage/msafirmware </a>' + strings.updateFirmware.hp3Part2,
                topMargin: true,
                bottomMargin: true
            })]
        }), new TabWidget({
            name: "updateFirwareTabs",
            type: "Primary",
            changeCallback: createObjectCallback(this, this.tabSelected),
            tabs: this.tabValues,
            noButton: true,
            widgets: H
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "UpdateFirmwareAction"
}
UpdateFirmwareAction.prototype = new ActionPanel();
UpdateFirmwareAction.prototype.constructor = UpdateFirmwareAction;
UpdateFirmwareAction.getMenuState = function() {
    if (session.hasConfigurationCapability()) {
        return []
    } else {
        return false
    }
};
UpdateFirmwareAction.prototype.showing = function() {
    var P = MC.versionsSet.data.objects;
    var R = "";
    var E = [];
    var Y = [];
    var K = {};
    var O = {};
    this.advSettingSubscription = MC.advancedSettingsSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updatePFU)
    });
    if (P && P.length > 0) {
        var V = P[0].meta.prop;
        var K = P[0];
        var O = P[1];
        if (system.local_controller_numeric == 1) {
            R = K.get("bundle_version")
        } else {
            R = O.get("bundle_version")
        }
        E.push([V.bundle_version.text, K.get("bundle_version"), O.get("bundle_version")], [V.sc_fw.text, K.get("sc_fw"), O.get("sc_fw")], [V.sc_loader.text, K.get("sc_loader"), O.get("sc_loader")], [V.sc_memory.text, K.get("sc_memory"), O.get("sc_memory")], [V.mc_fw.text, K.get("mc_fw"), O.get("mc_fw")], [V.mc_loader.text, K.get("mc_loader"), O.get("mc_loader")], [V.ec_fw.text, K.get("ec_fw"), O.get("ec_fw")], [V.pld_rev.text, K.get("pld_rev"), O.get("pld_rev")])
    }
    var M = DC.ioModules;
    for (var W in M) {
        var N = M[W].parentObject;
        var F = M[W];
        var T = F.get("controller_id");
        var S = M[W].expanders;
        for (var U in S) {
            var C = S[U].get("fw_revision");
            var H = S[U].get("location")
        }
        if (EXPR.is12GBackend) {
            Y.push([F.get("durable_id"), N.get("enclosure_id"), "IOM-" + T, H, C])
        } else {
            Y.push([F.get("durable_id"), N.get("enclosure_id"), "IOM-" + T, F.get("position"), F.get("part_number"), (T == "A") ? N.get("emp_a_rev") : N.get("emp_b_rev"), (T == "A") ? N.get("emp_a_busid") : N.get("emp_b_busid"), (T == "A") ? N.get("emp_a_targetid") : N.get("emp_b_targetid")])
        }
    }
    for (var c in DC.enclosures) {
        var J = DC.enclosures[c];
        if (!J.drawers) {
            continue
        }
        for (var L in J.drawers) {
            var b = J.drawers[L];
            if (b.sideplanes) {
                for (var U in b.sideplanes) {
                    var a = b.sideplanes[U];
                    var G = a.expanders;
                    for (var U in G) {
                        var D = {
                            id: G[U].get("dom_id"),
                            sideplane: G[U].get("path_id"),
                            drawer: G[U].get("drawer_id"),
                            location: G[U].get("location"),
                            version: G[U].get("fw_revision")
                        };
                        Y.push([c + "_" + L + "_", J.get("enclosure_id"), "Drawer " + D.drawer + ", Sideplane " + D.sideplane + ", Expander-" + D.id, D.location, D.version])
                    }
                }
            } else {
                var X = b.getInt("drawer_id");
                switch (X) {
                    case 0:
                        modPosition = strings.updateFirmware.leftDrawer;
                        break;
                    case 1:
                        modPosition = strings.updateFirmware.midDrawer;
                        break;
                    case 2:
                    default:
                        modPosition = strings.updateFirmware.rightDrawer;
                        break
                }
                for (var Q in {
                        A: 1,
                        B: 1
                    }) {
                    Y.push([c + "_" + L + "_" + Q, J.get("enclosure_id"), X + "-" + Q, modPosition, b.get("part_number"), (Q == "A") ? b.get("emp_a_rev") : b.get("emp_b_rev"), (Q == "A") ? b.get("emp_a_busid") : b.get("emp_b_busid"), (Q == "A") ? b.get("emp_a_targetid") : b.get("emp_b_targetid")])
                }
            }
        }
    }
    var Z = (RI.hasFeature("easyStartFirmware"));
    var I = {
        checkFirmware: {
            visibility: Z
        },
        currentVersion: {
            text: R
        },
        uCtrlInstructions: {
            text: strings.updateFirmware.controllerInstructions(system.local_controller)
        },
        uCtrlTable: {
            data: E
        },
        uEmpTable: {
            data: Y
        },
        updateFirmwareTabs: {
            tab: "tabUpdateController"
        },
        uEmpContainer: {
            visibility: "hidden"
        },
        uDisksContainer: {
            visibility: "hidden"
        }
    };
    if (!(session.hasUserConfigCapability())) {
        I.uCtrlFile = {
            disable: true,
            tooltip: strings.userManagement.panelText.requiresManage
        };
        I.uDisksFile = {
            disable: true,
            tooltip: strings.userManagement.panelText.requiresManage
        };
        if (isHPsystem()) {
            I.uEmpFile = {
                disable: true,
                tooltip: strings.userManagement.panelText.requiresManage
            }
        }
    }
    this.update(I);
    this._changedCallback()
};
UpdateFirmwareAction.prototype.hiding = function() {
    if (this.advSettingSubscription) {
        MC.advancedSettingsSet.unregister(this.advSettingsSubscription);
        delete this.advSettingSubscription
    }
};
UpdateFirmwareAction.prototype._updatePFU = function(H) {
    var G = decodeBooleanFlag(MC.advancedSettingsSet.data.objects[0].get("partner_firmware_upgrade_numeric"));
    var D = ((G) ? strings.enabled : strings.disabled);
    if (G === false) {
        var C = system.local_controller_numeric ? strings.updateFirmware.controllerAOnly : strings.updateFirmware.controllerBOnly;
        var I = strings.updateFirmware.pfuController(C);
        var F = strings.updateFirmware.pfuEnable
    } else {
        var I = strings.updateFirmware.pfuController(strings.updateFirmware.bothControllers);
        var F = strings.updateFirmware.pfuDisable
    }
    var E = {
        pfuGroup: {
            value: G,
            setOrig: true
        },
        pfuStatus: {
            text: strings.updateFirmware.pfuStatus(D, I)
        },
        pfuChangeButton: {
            text: F
        }
    };
    this.update(E)
};
UpdateFirmwareAction.prototype.handlePfuChange = function(I) {
    var H = I.pfuGroup.value;
    var D = ((H) ? strings.enabled : strings.disabled);
    if (H) {
        var J = strings.updateFirmware.pfuController(strings.updateFirmware.bothControllers)
    } else {
        var C = system.local_controller_numeric ? strings.updateFirmware.controllerAOnly : strings.updateFirmware.controllerBOnly;
        var J = strings.updateFirmware.pfuController(C)
    }
    this.update({
        pfuStatus: {
            text: strings.updateFirmware.pfuStatus(D, J)
        }
    });
    var H = decodeBooleanFlag(MC.advancedSettingsSet.data.objects[0].get("partner_firmware_upgrade_numeric"));
    var G = {
        partner_firmware_upgrade: {
            value: !H
        }
    };
    var F = strings.updateFirmware.pfuConfirm(D) + "<br><br>" + J;
    var E = {
        dialog: true,
        closeActionOn: "none",
        confirmMsg: F,
        cancel: createObjectCallback(this, this.cancelPfu),
        processingMsg: strings.updateFirmware.setPfuProcessingMsg,
        failureMsg: strings.updateFirmware.setPfuFailureMsg,
        successMsg: strings.updateFirmware.setPfuSuccessMsg
    };
    MC.setAdvancedSettings(G, E)
};
UpdateFirmwareAction.prototype.cancelPfu = function() {
    var F = {};
    this.retrieve(F);
    var E = F.pfuGroup.value;
    var D = (!E ? strings.enabled : strings.disabled);
    if (!E) {
        var G = strings.updateFirmware.pfuController(strings.updateFirmware.bothControllers)
    } else {
        var C = system.local_controller_numeric ? strings.updateFirmware.controllerAOnly : strings.updateFirmware.controllerBOnly;
        var G = strings.updateFirmware.pfuController(C)
    }
    this.update({
        pfuGroup: {
            value: !E
        },
        pfuStatus: {
            text: strings.updateFirmware.pfuStatus(D, G)
        }
    })
};
UpdateFirmwareAction.prototype.resetAction = function() {
    if (this.action) {
        var K = {};
        this.retrieve(K);
        var L = this.action;
        var H = 6;
        var E = 7;
        switch (this.action) {
            case "/api/updateExpansionFirmware":
                var F = this.uEmpTable.getData();
                var G = K.uEmpTable;
                L += " ";
                for (var I = 0; I < F.length; I++) {
                    for (var O = 0; O < G.selected.length; O++) {
                        if (F[I][0] == G.selected[O].key) {
                            L += ":" + F[I][H] + ":" + F[I][E]
                        }
                    }
                }
                break;
            case "/api/updateDiskFirmware":
                var D = K.uDisksTable.selected;
                L += " ";
                for (var J = 0; J < D.length; J++) {
                    var N = DC.base.drives[D[J].key];
                    var C = N.get("enclosure_id");
                    var M = N.get("slot");
                    L += ":" + C + ":" + M
                }
                break;
            default:
                break
        }
        return L
    } else {
        return null
    }
};
UpdateFirmwareAction.prototype.startingCallback = function(E) {
    if (this.action == "/api/updateFirmware") {
        var D = E.split(".");
        var C = (D.length > 0 ? D[D.length - 1] : "");
        if ((C == "bin") || (C == "fla") || (C == "enc")) {
            reloader.off();
            return true
        } else {
            ShowActiveDialog({
                type: "failure",
                message: strings.updateFirmware.badFileExtensionError
            });
            return false
        }
    }
    return true
};
UpdateFirmwareAction.prototype.finishedCallback = function(E, C) {
    if (MC.memorex) {
        ShowActiveDialog({
            type: "success",
            message: "Successfully simulated success.",
            dialogOverride: true
        });
        return
    }
    if (C.statusObject.prop.response_type_numeric.text != "0") {
        var D = {
            type: "failure",
            message: C.statusObject.prop.response.text,
            dialogOverride: true
        };
        ShowActiveDialog(D)
    }
};
UpdateFirmwareAction.prototype.okCallback = function() {
    switch (this.action) {
        case "/api/updateExpansionFirmware":
            this.uEmpFile.uploadFile();
            break;
        case "/api/updateDiskFirmware":
            this.uDisksFile.uploadFile();
            break;
        default:
            this.uCtrlFile.uploadFile();
            break
    }
};
UpdateFirmwareAction.prototype.cancelCallback = function() {
    if (RI.hasFeature("easyStartFirmware") && !EZStartManager.bypassFirmware) {
        MC.setUserInteraction({
            bypassFirmware: true
        }, {
            dialog: false
        });
        EZStartManager.bypassFirmware = true;
        panels.EasyStartTopic.generalUpdate()
    }
    this.close()
};
UpdateFirmwareAction.prototype.tabSelected = function(C) {
    if (C == undefined) {
        return
    }
    this.selectedTab = C;
    this._changedCallback()
};
UpdateFirmwareAction.prototype.fileSelected = function(E, C, D) {
    if (!E) {
        return
    }
    this._changedCallback()
};
UpdateFirmwareAction.prototype._changedCallback = function() {
    var C = {};
    this.retrieve(C, true);
    var D = this.tabValues[this.selectedTab].name;
    switch (D) {
        case "tabUpdateController":
            this.update({
                updateFirmwareTabs: {
                    tab: "tabUpdateController"
                },
                uCtrlContainer: {
                    visibility: "visible"
                },
                uEmpContainer: {
                    visibility: "hidden"
                },
                uDisksContainer: {
                    visibility: "hidden"
                }
            });
            this.action = this.uCtrlAction;
            if (C.uCtrlFile && C.uCtrlFile.value && session.hasUserConfigCapability()) {
                this.okEnabled(true, true)
            } else {
                this.okEnabled(false)
            }
            this.resetSize({
                shrink: true
            });
            break;
        case "tabUpdateEMP":
            this.update({
                updateFirmwareTabs: {
                    tab: "tabUpdateEMP"
                },
                uCtrlContainer: {
                    visibility: "hidden"
                },
                uEmpContainer: {
                    visibility: "visible"
                },
                uDisksContainer: {
                    visibility: "hidden"
                }
            });
            this.action = this.uEmpAction;
            if (C.uEmpFile && C.uEmpFile.value && C.uEmpTable.selected.length > 0 && session.hasUserConfigCapability) {
                this.okEnabled(true, true)
            } else {
                this.okEnabled(false)
            }
            this.resetSize({
                shrink: true
            });
            break;
        case "tabUpdateDisks":
            this.update({
                updateFirmwareTabs: {
                    tab: "tabUpdateDisks"
                },
                uCtrlContainer: {
                    visibility: "hidden"
                },
                uEmpContainer: {
                    visibility: "hidden"
                },
                uDisksContainer: {
                    visibility: "visible"
                }
            });
            this.action = this.uDisksAction;
            if (C.uDisksFile && C.uDisksFile.value && C.uDisksTable.selected.length > 0 && session.hasUserConfigCapability) {
                this.okEnabled(true, true)
            } else {
                this.okEnabled(false)
            }
            this.resetSize({
                shrink: true
            });
            break;
        default:
            break
    }
    if (!session.hasManageRole()) {
        this.update({
            UpdateFirmwareAction_ok: {
                tooltip: strings.updateFirmware.noManageRole
            }
        })
    }
};

function FullDiskEncryptionAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "FullDiskEncryptionAction";
    D.okCallback = createObjectCallback(this, this._handleOk);
    this.setWidgetsCallback = createObjectCallback(this, this._setWidgets);
    this.pPhraseChangedCallback = createObjectCallback(this, this._pPhraseChanged);
    this.fdeSecured = false;
    var C = 0;
    D.widgets = [this.tabWidget = new TabWidget({
        name: "fdeTabs",
        type: "Primary",
        changeCallback: createObjectCallback(this, this.tabSelected),
        tabs: [{
            name: "fdeGeneralConfig",
            label: strings.fde.generalConfigLabel
        }, {
            name: "repurposeDisks",
            label: strings.fde.repurposeDisksLabel
        }, {
            name: "importDisks",
            label: strings.fde.importDisksLabel
        }],
        widgets: [this.configTabContent = new TableWidget({
            name: "fdeConfigTable",
            widgets: [this.fdeForm = new FormWidget({
                name: "fdeConfigForm",
                row: 0,
                col: 0,
                tableLayout: true,
                topMargin: true,
                widgets: [new TextWidget({
                    name: "fdeInstructions",
                    row: C,
                    text: strings.fde.Instructions,
                    bottomMargin: true,
                    colSpan: 4
                }), new TextWidget({
                    name: "fdeStateText",
                    row: ++C,
                    col: 0,
                    rightMargin: true,
                    label: strings.fde.FDEStateLabel,
                    classes: "noWrap",
                    text: "FDE State Text Placeholder",
                    bottomMargin: true,
                    singleCell: true
                }), new TextInputWidget({
                    name: "currentPphrase",
                    row: (this.curPphraseRow = C),
                    col: 2,
                    label: strings.fde.CurrentPphraseLabel,
                    maxLength: 32,
                    bottomMargin: true,
                    changeCallback: createObjectCallback(this, this._currentPphraseChanged),
                    singleCell: true,
                    classes: "overflowRight"
                }), new TextWidget({
                    name: "lockKeyId",
                    row: (this.lockKeyRow = ++C),
                    col: 0,
                    text: "placeholder text",
                    label: strings.fde.LockKeyIDLabel,
                    bottomMargin: true,
                    singleCell: true
                }), new LabeledWidgetContainer({
                    name: "setPassphraseSection",
                    row: ++C,
                    col: 0,
                    bottomMargin: true,
                    topMargin: true,
                    label: strings.fde.SetPassphraseLabel,
                    colSpan: 3,
                    widgets: [new TableWidget({
                        widgets: [new TextWidget({
                            name: "setPassBlurb",
                            text: strings.fde.messages.setPassphrase,
                            row: 0,
                            col: 0,
                            bottomMargin: true,
                            colSpan: 4
                        }), new TableWidget({
                            row: 1,
                            col: 0,
                            colSpan: 2,
                            widgets: [new TextInputWidget({
                                name: "passphrase",
                                row: 0,
                                col: 1,
                                label: strings.fde.PassphraseLabel,
                                rules: {
                                    dhFdePassword: true,
                                    rangelength: [8, 32]
                                },
                                topMargin: true,
                                leftMargin: true,
                                rightMargin: true,
                                bottomMargin: true,
                                changeCallback: this.pPhraseChangedCallback,
                                classes: "noWrap"
                            }), new TextInputWidget({
                                name: "passphraseConfirm",
                                row: 1,
                                col: 1,
                                label: strings.fde.confirmPassPhraseLabel,
                                rules: {
                                    dhFdePassword: true,
                                    rangelength: [8, 32],
                                    equalTo: "#passphrase"
                                },
                                maxLength: 32,
                                messages: {
                                    equalTo: strings.fde.passVerEqual
                                },
                                leftMargin: true,
                                rightMargin: true,
                                bottomMargin: true,
                                changeCallback: this.pPhraseChangedCallback,
                                classes: "noWrap"
                            }), new CheckboxInputWidget({
                                name: "immediatelySecure",
                                row: 2,
                                col: 1,
                                label: strings.fde.SecureLabel,
                                leftMargin: true,
                                rightMargin: true,
                                changeCallback: createObjectCallback(this, this._secureCheckboxChanged)
                            })]
                        })]
                    })]
                })]
            }), new LabeledWidgetContainer({
                name: "clearKeysSection",
                row: ++C,
                col: 0,
                label: strings.fde.ClearKeysLabel,
                bottomMargin: true,
                colSpan: 2,
                widgets: [new TableWidget({
                    widgets: [new TextWidget({
                        name: "clearKeysBlurb",
                        row: 0,
                        col: 0,
                        text: strings.fde.messages.clearKeys,
                        bottomMargin: true,
                        colSpan: 2
                    }), new ButtonContainer({
                        name: "clearKeysBc",
                        row: 1,
                        col: 0,
                        alignment: "right",
                        widgets: [new ButtonWidget({
                            name: "clearKeysButton",
                            text: strings.fde.Clear,
                            click: createObjectCallback(this, this._clearKeysHandler)
                        })]
                    })]
                })]
            }), new LabeledWidgetContainer({
                name: "secureSystemSection",
                row: ++C,
                col: 0,
                label: strings.fde.secureSystemLabel,
                colSpan: 3,
                widgets: [new TableWidget({
                    widgets: [new TextWidget({
                        name: "secureBlurb",
                        row: 0,
                        col: 0,
                        bottomMargin: true,
                        text: strings.fde.messages.secureSystem,
                        colSpan: 2
                    }), new ButtonContainer({
                        row: 1,
                        col: 0,
                        alignment: "right",
                        widgets: [new ButtonWidget({
                            name: "secureSystemButton",
                            text: strings.fde.Secure,
                            click: createObjectCallback(this, this._secureSystemHandler)
                        })]
                    })]
                })]
            }), new LabeledWidgetContainer({
                name: "repurposeSystemSection",
                row: ++C,
                col: 0,
                label: strings.fde.repurposeSystemLabel,
                colSpan: 3,
                widgets: [new TableWidget({
                    widgets: [new TextWidget({
                        name: "repurposeBlurb",
                        row: 0,
                        col: 0,
                        bottomMargin: true,
                        text: strings.fde.messages.repurposeSystem
                    }), new ButtonContainer({
                        row: 1,
                        col: 2,
                        alignment: "right",
                        widgets: [new ButtonWidget({
                            name: "repurposeSystemButton",
                            text: strings.fde.Repurpose,
                            click: createObjectCallback(this, this._repurposeSystemHandler)
                        })]
                    })]
                })]
            })]
        }), this.importTabContent = new TableWidget({
            name: "importKeyTable",
            widgets: [this.importKeyForm = new FormWidget({
                name: "importKeyForm",
                row: 0,
                col: 0,
                tableLayout: true,
                bottomMargin: true,
                topMargin: true,
                leftMargin: true,
                widgets: [new TextWidget({
                    name: "importKeyBlurb",
                    row: 0,
                    col: 0,
                    text: strings.fde.messages.importKey,
                    bottomMargin: true,
                    colSpan: 2
                }), new TextWidget({
                    name: "importKey",
                    row: 1,
                    col: 0,
                    colSpan: 2,
                    text: "placeholder text",
                    label: strings.fde.importLockKey,
                    bottomMargin: true,
                    singleCell: true
                }), new TableWidget({
                    row: 2,
                    col: 0,
                    widgets: [new TextInputWidget({
                        name: "importPphrase",
                        row: 0,
                        col: 1,
                        label: strings.fde.PassphraseLabel,
                        size: 20,
                        rules: {
                            dhName: true,
                            utf8length: 32,
                            rangelength: [8, 32]
                        },
                        rightMargin: true,
                        leftMargin: true,
                        bottomMargin: true,
                        changeCallback: createObjectCallback(this, this._importPphraseChange)
                    }), new TextInputWidget({
                        name: "importPphraseConfirm",
                        row: 1,
                        col: 1,
                        label: strings.fde.confirmPassPhraseLabel,
                        size: 20,
                        rules: {
                            dhName: true,
                            utf8length: 32,
                            rangelength: [8, 32],
                            equalTo: "#importPphrase"
                        },
                        rightMargin: true,
                        leftMargin: true,
                        bottomMargin: true,
                        changeCallback: createObjectCallback(this, this._importPphraseChange)
                    })]
                })]
            })]
        }), this.repurposeTabContent = new TableWidget({
            name: "repurposeDisksTable",
            widgets: [this.repurposeDisksForm = new FormWidget({
                name: "repurposeDisksForm",
                row: 0,
                col: 0,
                tableLayout: true,
                bottomMargin: true,
                topMargin: true,
                leftMargin: true,
                widgets: [new TextWidget({
                    name: "repurposeDisksMessage",
                    row: 0,
                    col: 0,
                    text: strings.fde.messages.repurposeDisks,
                    bottomMargin: true
                }), new CheckboxInputWidget({
                    name: "all",
                    row: 0,
                    col: 0,
                    label: strings.fde.selectAll,
                    leftMargin: true,
                    row: 1,
                    col: 0,
                    bottomMargin: true,
                    leftSmallMargin: true,
                    singleCell: true,
                    changeCallback: createObjectCallback(this, this._selectAll)
                }), this.repurposableDisksTable = new TableInator({
                    name: "repurposableDisksTable",
                    row: (this.repurposableDisksTableRow = 2),
                    col: 0,
                    bottomMargin: true,
                    selectable: "multiple",
                    type: "apiData",
                    metadata: "drives",
                    fields: ["enclosure_id", "slot", "serial_number", "fde_state", "lock_key_id"],
                    columnOverrides: {
                        enclosure_id: {
                            sTitle: strings.fde.enclID
                        },
                        slot: {
                            sTitle: strings.updateFirmware.slot
                        },
                        serial_number: {
                            sTitle: strings.updateFirmware.serialnumber
                        },
                        fde_state: {
                            sTitle: strings.fde.FDEStateLabel
                        },
                        lock_key_id: {
                            sTitle: strings.fde.LockKeyIDLabel
                        }
                    },
                    criteria: createObjectCallback(this, this._isRepurposableDisk),
                    dtOptions: {
                        bFilter: false,
                        bLengthChange: false,
                        bInfo: false,
                        bPaginate: true,
                        iDisplayLength: 12
                    },
                    selectCallback: createObjectCallback(this, this._driveChange)
                })]
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "FullDiskEncryptionAction";
    this.fdeTable = this.fdeForm.tableWidget
}
FullDiskEncryptionAction.prototype = new ActionPanel();
FullDiskEncryptionAction.prototype.constructor = FullDiskEncryptionAction;
FullDiskEncryptionAction.getMenuState = function() {
    if (!RI.hasFeature("fde") || !session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
FullDiskEncryptionAction.prototype.showing = function() {
    this.update({
        fdeConfigTable: {
            visibility: "collapse"
        },
        importKeyTable: {
            visibility: "collapse"
        },
        repurposeDisksTable: {
            visibility: "collapse"
        }
    });
    this.importPphraseChanged = false;
    this.importPphraseConfirmChanged = false;
    this.pPhraseChanged = false;
    this.pPhraseConfChanged = false;
    this.setPphraseBtnEnable = false;
    this.pPhraseInputsEnable = false;
    this.fdeSubscriptionHandlerCompleted = false;
    this.disksSubscriptionHandlerCompleted = false;
    this.fdeSubscription = MC.fdeStateSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._fdeSubscriptionHandler)
    });
    this.drivesSubscription = MC.disksSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._disksSubscriptionHandler)
    });
    this.tabWidget.select("fdeGeneralConfig")
};
FullDiskEncryptionAction.prototype._fdeSubscriptionHandler = function(C) {
    this.fdeStateObj = C.getData().getNthObject(0);
    this.fdeState = ((this.fdeStateObj) ? this.fdeStateObj.get("fde_security_status_numeric") : 0);
    this.fdeSecured = (this.fdeStateObj && this.fdeState == FDE_STATES.SECURED ? true : false);
    this.fdeSubscriptionHandlerCompleted = true;
    if (this.disksSubscriptionHandlerCompleted) {
        this._setWidgets()
    }
};
FullDiskEncryptionAction.prototype._disksSubscriptionHandler = function(C) {
    this.disksSubscriptionHandlerCompleted = true;
    if (this.fdeSubscriptionHandlerCompleted) {
        this._setWidgets()
    }
};
FullDiskEncryptionAction.prototype._setWidgets = function() {
    if (!this.fdeSubscriptionHandlerCompleted || !this.disksSubscriptionHandlerCompleted) {
        return
    }
    this.pPhraseChanged = false;
    this.pPhraseConfChanged = false;
    this.secureBtnEnable = false;
    this.setPphraseBtnEnable = false;
    this.pPhraseInputsEnable = false;
    this.importPphraseChanged = false;
    this.importPphraseConfirmChanged = false;
    var C = {};
    C.fdeConfigTable = {
        visibility: "visible"
    };
    C.fdeConfigForm = {
        resetValidation: true
    };
    this.okEnabled((this.pPhraseChanged) && (this.pPhraseConfChanged), false);
    C.setPassphraseSection = {
        visibility: "visible"
    };
    if (this.fdeStateObj) {
        var E = this.fdeStateObj.get("lock_key_id");
        var D = parseInt(E, 16);
        if (D > 10) {
            this.fdeTable.showRows(this.lockKeyRow, this.curPphraseRow);
            C.setPassBlurb = {
                text: strings.fde.messages.setPassphrase
            };
            C.clearKeysSection = {
                visibility: "visible"
            };
            C.currentPphrase = {
                visibility: "visible",
                value: "",
                setOrig: true
            };
            C.passphrase = {
                value: "",
                setOrig: true,
                disable: true
            };
            C.passphraseConfirm = {
                value: "",
                setOrig: true,
                disable: true
            };
            C.lockKeyId = {
                visibility: "visible",
                text: this.fdeStateObj.get("lock_key_id")
            };
            C.immediatelySecure = {
                visibility: "collapse",
                disable: true
            };
            C.fdeInstructions = {
                text: (strings.fde.Instructions + strings.fde.instructionsContd)
            };
            if (this.fdeSecured) {
                C.secureSystemSection = {
                    visibility: "collapse"
                };
                C.repurposeSystemSection = {
                    visibility: "visible"
                };
                C.repurposeSystemButton = {
                    disable: ((propertyCount(DC.vdisks) != 0) || (propertyCount(DC.diskGroups) != 0))
                };
                C.clearKeysButton = {
                    disable: true
                };
                this.secureBtnEnable = false;
                this.clearKeysBtnEnable = false
            } else {
                C.secureSystemSection = {
                    visibility: "visible"
                };
                C.repurposeSystemSection = {
                    visibility: "collapse"
                };
                C.passphraseForm = {
                    resetValidation: true
                };
                C.secureSystemButton = {
                    disable: (!this.secureBtnEnable)
                };
                this.clearKeysBtnEnable = true
            }
        } else {
            this.fdeTable.hideRows(this.lockKeyRow, this.curPphraseRow);
            C.lockKeyId = {
                visibility: "collapse"
            };
            C.immediatelySecure = {
                visibility: "visible",
                value: false,
                setOrig: true
            };
            C.passphrase = {
                value: "",
                setOrig: true,
                disable: false
            };
            C.passphraseConfirm = {
                value: "",
                setOrig: true,
                disable: false
            };
            C.setPassBlurb = {
                text: strings.fde.messages.passphraseNeedsSet
            };
            C.clearKeysSection = {
                visibility: "collapse"
            };
            C.secureSystemSection = {
                visibility: "collapse"
            };
            C.repurposeSystemSection = {
                visibility: "collapse"
            };
            C.fdeInstructions = {
                text: strings.fde.Instructions
            };
            C.currentPphrase = {
                visibility: "collapse"
            }
        }
        var F = this.fdeStateObj.get("fde_security_status_numeric");
        if (F == FDE_DRIVE_STATES.SECURED_UNLOCKED || F == FDE_DRIVE_STATES.SECURED_LOCKED || F == FDE_DRIVE_STATES.PROTOCOL_FAILURE) {
            C.immediatelySecure = {
                visibility: "collapse",
                disable: true
            }
        }
        C.importKey = {
            text: this.fdeStateObj.get("import_lock_key_id")
        };
        C.fdeStateText = {
            text: this.fdeStateObj.get("fde_security_status")
        }
    }
    C.importPphrase = {
        value: "",
        setOrig: true
    };
    C.importPphraseConfirm = {
        value: "",
        setOrig: true
    };
    C.repurposableDisksTable = {
        data: MC.disksSet.data.objects
    };
    this.okEnabled(false);
    this.update(C)
};
FullDiskEncryptionAction.prototype.hiding = function() {
    if (this.fdeSubscription) {
        MC.fdeStateSet.unregister(this.fdeSubscription);
        delete this.fdeSubscription
    }
    if (this.drivesSubscription) {
        MC.disksSet.unregister(this.drivesSubscription);
        delete this.drivesSubscription
    }
};
FullDiskEncryptionAction.prototype._handleOk = function() {
    switch (this.selectedTab) {
        case "general":
            this._setPassphraseHandler();
            break;
        case "repurposeDisks":
            this._repurposeDrivesHandler();
            break;
        case "importDisks":
            this._setImportKeyHandler();
            break;
        default:
            break
    }
};
FullDiskEncryptionAction.prototype._setPassphraseHandler = function() {
    var F = {};
    this.retrieve(F);
    var E = {
        passphrase: F.passphrase.value,
        currentPphrase: F.currentPphrase.value
    };
    var D = false;
    var C = [];
    C.push({
        name: "setPphrase",
        command: MC.setPassphrase,
        data: E,
        options: {
            processingMsg: strings.fde.passphraseProcessing,
            failureMsg: strings.fde.passphraseFail
        }
    });
    if (F.immediatelySecure.value) {
        D = true;
        E.currentPphrase = {
            value: F.passphrase.value
        };
        C.push({
            name: "secureSystem",
            command: MC.secureFdeSystem,
            data: E,
            options: {
                processingMsg: strings.fde.secureFdeProcessing,
                failureMsg: strings.fde.secureFdeFail
            }
        })
    }
    MC.execCommandList(C, {
        dialog: true,
        successMsg: (D ? strings.fde.setAndSecureSuccessMsg : strings.fde.passphraseSuccess),
        callback: this.setWidgetsCallback,
        closeActionOn: "success"
    })
};
FullDiskEncryptionAction.prototype._clearKeysHandler = function() {
    var C = {};
    this.retrieve(C, true);
    if (!this.fdeSecured) {
        C.noPass = true
    }
    MC.clearFDEKeys(C, {
        dialog: true,
        confirmMsg: strings.fde.clearKeysConfirm,
        processingMsg: strings.fde.clearKeysProcessingMsg,
        failureMsg: strings.fde.clearKeysFailureMsg,
        successMsg: strings.fde.clearKeysSuccessMsg,
        callback: this.setWidgetsCallback,
        closeActionOn: "success"
    })
};
FullDiskEncryptionAction.prototype._repurposeSystemHandler = function() {
    var C = {};
    MC.repurposeFdeSystem(C, {
        dialog: true,
        confirmMsg: strings.fde.repurposeSysConfirm,
        processingMsg: strings.fde.repurposeSystemProcessing,
        failureMsg: strings.fde.repurposeSystemFail,
        successMsg: strings.fde.repurposeSystemSuccess,
        callback: this.setWidgetsCallback,
        closeActionOn: "success"
    })
};
FullDiskEncryptionAction.prototype._secureSystemHandler = function() {
    var C = {};
    this.retrieve(C, true);
    MC.secureFdeSystem(C, {
        dialog: true,
        processingMsg: strings.fde.secureFdeProcessing,
        failureMsg: strings.fde.secureFdeFail,
        successMsg: strings.fde.secureFdeSuccess,
        callback: this.setWidgetsCallback,
        closeActionOn: "success"
    })
};
FullDiskEncryptionAction.prototype._setImportKeyHandler = function() {
    var C = {};
    this.retrieve(C);
    MC.importLockKeyId(C, {
        dialog: true,
        processingMsg: strings.fde.importProcessing,
        failureMsg: strings.fde.importFail,
        successMsg: strings.fde.importSuccess,
        callback: this.setWidgetsCallback,
        closeActionOn: "success"
    })
};
FullDiskEncryptionAction.prototype._repurposeDrivesHandler = function() {
    var C = {};
    this.retrieve(C);
    var D = [];
    if (C.repurposableDisksTable && C.repurposableDisksTable.selected.length) {
        for (var E = 0; E < C.repurposableDisksTable.selected.length; E++) {
            var F = C.repurposableDisksTable.selected[E].getObject();
            var H = F.get("enclosure_id") + "." + F.get("slot");
            var G = {
                disks: [H]
            };
            D.push({
                name: "repurposeDisk" + H,
                command: MC.repurposeFDEDisks,
                data: G,
                options: {
                    processingMsg: strings.fde.repurposeDisksProcessing,
                    failureMsg: strings.fde.repurposeDisksFail
                }
            })
        }
        MC.execCommandList(D, {
            dialog: true,
            confirmMsg: strings.fde.repurposeDisksConfirm,
            successMsg: strings.fde.repurposeDisksSuccess,
            closeActionOn: "success"
        })
    }
};
FullDiskEncryptionAction.prototype._isRepurposableDisk = function(C) {
    var G = false;
    var F = C.get("lock_key_id");
    var E = parseInt(F, 16);
    var D = parseInt(C.get("fde_state_numeric"), 10);
    var H = C.getInt("usage_numeric");
    if (D != FDE_DRIVE_STATES.NOT_CAPABLE && D != FDE_DRIVE_STATES.PROTOCOL_FAILURE && H != DRIVE_USAGE.LINEAR_POOL && H != DRIVE_USAGE.VIRTUAL_POOL) {
        G = true
    }
    return G
};
FullDiskEncryptionAction.prototype._setPphraseInputsStateFlag = function() {
    var C = {};
    this.retrieve(C);
    return (this.setPphraseInputsEnable = (C.fdeConfigForm.valid && C.currentPphrase.valueChanged))
};
FullDiskEncryptionAction.prototype._secureCheckboxChanged = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    var C = this._setPphraseInputsStateFlag();
    if (G[E.name].value) {
        this.setButtonText("ok", strings.fde.SetAndSecure)
    } else {
        this.setButtonText("ok", strings.fde.Set)
    }
    this.resetSize({
        shrink: true
    })
};
FullDiskEncryptionAction.prototype._currentPphraseChanged = function(K, E, H) {
    this.secureBtnEnable = K[E.name].valueChanged;
    var D = {};
    this.retrieve(D);
    var C;
    var G;
    var J;
    if (this.fdeStateObj) {
        C = this.fdeStateObj.get("lock_key_id");
        G = parseInt(C, 16);
        J = this.fdeStateObj.get("fde_security_status_numeric")
    }
    this.clearKeysBtnEnable = ((K[E.name].valueChanged && C && G > 10) || J == FDE_STATES.UNSECURED);
    var F = this._setPphraseInputsStateFlag();
    this.okEnabled(this.setPphraseBtnEnable, false);
    var I = {
        secureSystemButton: {
            disable: (!this.secureBtnEnable)
        },
        clearKeysButton: {
            disable: (!this.clearKeysBtnEnable)
        },
        passphrase: {
            disable: (!F)
        },
        passphraseConfirm: {
            disable: (!F)
        }
    };
    this.update(I)
};
FullDiskEncryptionAction.prototype._pPhraseChanged = function(F, D, E) {
    if (D.name == "passphrase") {
        this.pPhraseChanged = F.passphrase.valueChanged
    } else {
        this.pPhraseConfChanged = F.passphraseConfirm.valueChanged
    }
    if (this.pPhraseChanged && this.pPhraseConfChanged) {
        var C = {};
        this.retrieve(C);
        this.setPphraseBtnEnable = C.fdeConfigForm.valid;
        this.okEnabled(this.setPphraseBtnEnable, false)
    }
};
FullDiskEncryptionAction.prototype._driveChange = function(C) {
    var D = {};
    this.retrieve(D, true);
    if (D.repurposableDisksTable && D.repurposableDisksTable.selected.length) {
        this.okEnabled(true, true)
    } else {
        this.okEnabled(false)
    }
};
FullDiskEncryptionAction.prototype._selectAll = function(D, F, H) {
    var G = this.repurposableDisksTable.getNumVisibleRows();
    if (D.all.value) {
        var I = 0;
        var C = this.repurposableDisksTable.dataTable[0].rows.length - 1;
        var J = 0;
        while (I < G) {
            for (var E = J; E < C; E++) {
                var K = this.repurposableDisksTable._selectRow(E);
                I++
            }
            this.repurposableDisksTable.dataTable.fnPageChange("next", true);
            J = C;
            C = C + this.repurposableDisksTable.dataTable[0].rows.length - 1
        }
        this.repurposableDisksTable.dataTable.fnPageChange("first", true)
    } else {
        this.repurposableDisksTable._clearSelectAll()
    }
    if (this.repurposableDisksTable && this.repurposableDisksTable.selected.length) {
        this.okEnabled(true, true)
    } else {
        this.okEnabled(false)
    }
};
FullDiskEncryptionAction.prototype._selectAll = function(D, F, H) {
    var G = this.repurposableDisksTable.getNumVisibleRows();
    if (D.all.value) {
        var I = 0;
        var C = this.repurposableDisksTable.dataTable[0].rows.length - 1;
        var J = 0;
        while (I < G) {
            for (var E = J; E < C; E++) {
                var K = this.repurposableDisksTable._selectRow(E);
                I++
            }
            this.repurposableDisksTable.dataTable.fnPageChange("next", true);
            J = C;
            C = C + this.repurposableDisksTable.dataTable[0].rows.length - 1
        }
        this.repurposableDisksTable.dataTable.fnPageChange("first", true)
    } else {
        this.repurposableDisksTable._clearSelectAll()
    }
    if (this.repurposableDisksTable && this.repurposableDisksTable.selected.length) {
        this.okEnabled(true, true)
    } else {
        this.okEnabled(false)
    }
};
FullDiskEncryptionAction.prototype._importPphraseChange = function(E, C, D) {
    if (C.name == "importPphrase") {
        this.importPphraseChanged = E.importPphrase.valueChanged
    } else {
        this.importPphraseConfirmChanged = E.importPphraseConfirm.valueChanged
    }
    if (this.importPphraseChanged && this.importPphraseConfirmChanged) {
        this.importKeyForm.validate();
        this.setImportPphraseBtnEnable = this.importKeyForm.valid;
        this.okEnabled(this.setImportPphraseBtnEnable, false)
    }
};
FullDiskEncryptionAction.prototype.tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (!this.tabWidget) {
        return
    }
    if (C == 0) {
        this.selectedTab = "general";
        this.setButtonText("cancel", strings.Cancel);
        this.setButtonText("ok", strings.set);
        this.tabWidget.update({
            tabDesc: {
                text: strings.fde.changePassphraseDescription
            },
            fdeConfigTable: {
                visibility: "visible"
            },
            importKeyTable: {
                visibility: "collapse"
            },
            repurposeDisksTable: {
                visibility: "collapse"
            }
        });
        this.resetSize({
            shrink: true
        })
    } else {
        if (C == 1) {
            this.selectedTab = "repurposeDisks";
            this.actionOkButton.setVisibility("visible");
            this.okEnabled(false);
            this.setButtonText("ok", strings.fde.Repurpose);
            this.setButtonText("cancel", strings.Cancel);
            this.tabWidget.update({
                tabDesc: {
                    text: strings.fde.repurposeDisksDescription
                },
                fdeConfigTable: {
                    visibility: "collapse"
                },
                importKeyTable: {
                    visibility: "collapse"
                },
                repurposeDisksTable: {
                    visibility: "visible"
                }
            });
            this.resetSize({
                shrink: true
            })
        } else {
            if (C == 2) {
                this.selectedTab = "importDisks";
                this.actionOkButton.setVisibility("visible");
                this.okEnabled(false);
                this.setButtonText("ok", strings.set);
                this.setButtonText("cancel", strings.Cancel);
                this.tabWidget.update({
                    tabDesc: {
                        text: strings.fde.importFDEDescription
                    },
                    fdeConfigTable: {
                        visibility: "collapse"
                    },
                    importKeyTable: {
                        visibility: "visible"
                    },
                    repurposeDisksTable: {
                        visibility: "collapse"
                    }
                });
                this.resetSize({
                    shrink: true
                })
            }
        }
    }
};

function AdvancedSettingsAction(G) {
    if (arguments.length == 0) {
        return
    }
    G.name = "AdvancedSettingsAction";
    G.title = strings.advSet.advSettingsText;
    G.okCallback = createObjectCallback(this, this.okCallback);
    G.applyCallback = createObjectCallback(this, this.applyCallback);
    var F = createObjectCallback(this, this.tabSelected);
    var D = createObjectCallback(this, this.somethingChanged);
    var H = 0;
    var E = [];
    E.push(new RadioButtonsInputWidget({
        name: "sync_cache_mode",
        orientation: "horizontal",
        label: strings.advSet.syncCache,
        labelOptions: {
            leftMargin: true,
            bottomMargin: true,
            col: 0
        },
        values: [{
            value: "immediate",
            text: strings.advSet.syncCacheImmed
        }, {
            value: "flush",
            text: strings.advSet.syncCacheFlush
        }],
        row: H++,
        col: 1,
        changeCallback: D
    }), new RadioButtonsInputWidget({
        name: "missing_lun_response",
        orientation: "horizontal",
        label: strings.advSet.missingLun,
        labelOptions: {
            leftMargin: true,
            bottomMargin: true,
            col: 0
        },
        values: [{
            value: "notready",
            text: strings.advSet.missingLunNR
        }, {
            value: "illegal",
            text: strings.advSet.missingLunIR
        }],
        row: H++,
        col: 1,
        changeCallback: D
    }), new CheckboxInputWidget({
        name: "host_cache_control",
        label: strings.advSet.hostCtlCache,
        labelOptions: {
            leftMargin: true,
            bottomMargin: true
        },
        bottomMargin: true,
        leftMargin: true,
        rules: {
            required: false
        },
        row: H++,
        col: 1,
        changeCallback: D
    }));
    if (!isHPsystem()) {
        E.push(new CheckboxInputWidget({
            name: "independent_cache",
            label: strings.advSet.indepCache,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            leftMargin: true,
            rules: {
                required: false
            },
            row: H++,
            col: 1,
            changeCallback: D
        }))
    }
    E.push(new LabeledWidgetContainer({
        row: H++,
        col: 0,
        colSpan: 2,
        label: strings.advSet.awtTriggerText,
        cellClasses: "alignTop",
        widgets: [new CheckboxInputWidget({
            name: "controller_failure",
            label: strings.advSet.awtTrCtlrFail,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "super_cap_failure",
            label: strings.advSet.awtTrCachePower,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "compact_flash_failure",
            label: strings.advSet.awtTrFlash,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "power_supply_failure",
            label: strings.advSet.awtTrPSFail,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "fan_failure",
            label: strings.advSet.awtTrFanFail,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "temperature_exceeded",
            label: strings.advSet.awtTrOverTemp,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        })]
    }), new LabeledWidgetContainer({
        row: H++,
        col: 0,
        colSpan: 2,
        label: strings.advSet.awtBehaviorText,
        cellClasses: "alignTop",
        bottomMargin: true,
        widgets: [new CheckboxInputWidget({
            name: "auto_write_back",
            label: strings.advSet.awtRevert,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        }), new CheckboxInputWidget({
            name: "partner_notify",
            label: strings.advSet.awtNotifyOther,
            labelOptions: {
                leftMargin: true,
                bottomMargin: true
            },
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: D
        })]
    }));
    var C = [{
        name: "tabDisk",
        label: strings.advSet.disk
    }, {
        name: "tabCache",
        label: strings.advSet.cache
    }, {
        name: "tabFirmware",
        label: strings.advSet.firmware
    }, {
        name: "tabUtilities",
        label: strings.advSet.utilities
    }];
    if (RI.hasFeature("e2ePi") && !RI.supportsPaged()) {
        C.push({
            name: "tabSystemCache",
            label: strings.advSet.sysCache
        })
    }
    G.widgets = [new WidgetContainer({
        classes: "clearFloats"
    }), this.settingsForm = new FormWidget({
        name: "settingsForm",
        data: {},
        widgets: [this.settingsTabs = new TabWidget({
            name: "settingsTabs",
            type: "Primary",
            changeCallback: F,
            tabs: C,
            width: 400,
            widgets: [new TableWidget({
                name: "advDisk",
                widgets: [new OptionInputWidget({
                    name: "smart",
                    label: strings.advSet.smartConfig,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true
                    },
                    bottomMargin: true,
                    row: 1,
                    col: 1,
                    values: [{
                        value: "detect-only",
                        text: strings.advSet.smartNoMod
                    }, {
                        value: "enabled",
                        text: strings.Enabled
                    }, {
                        value: "disabled",
                        text: strings.Disabled
                    }],
                    multiple: false,
                    changeCallback: D
                }), new OptionInputWidget({
                    name: "emp_poll_rate",
                    label: strings.advSet.pollRate,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true
                    },
                    bottomMargin: true,
                    row: 2,
                    col: 1,
                    values: [{
                        value: "5",
                        text: "5 " + strings.advSet.seconds
                    }, {
                        value: "10",
                        text: "10 " + strings.advSet.seconds
                    }, {
                        value: "30",
                        text: "30 " + strings.advSet.seconds
                    }, {
                        value: "60",
                        text: "1 " + strings.advSet.minute
                    }, {
                        value: "300",
                        text: "5 " + strings.advSet.minutes
                    }, {
                        value: "600",
                        text: "10 " + strings.advSet.minutes
                    }, {
                        value: "900",
                        text: "15 " + strings.advSet.minutes
                    }, {
                        value: "1200",
                        text: "20 " + strings.advSet.minutes
                    }, {
                        value: "1500",
                        text: "25 " + strings.advSet.minutes
                    }, {
                        value: "1800",
                        text: "30 " + strings.advSet.minutes
                    }, {
                        value: "2700",
                        text: "45 " + strings.advSet.minutes
                    }, {
                        value: "3600",
                        text: "60 " + strings.advSet.minutes
                    }],
                    multiple: false,
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "dynamic_spares",
                    label: strings.advSet.dynamSpare,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true
                    },
                    bottomMargin: true,
                    row: 3,
                    col: 1,
                    changeCallback: D
                }), new CheckboxContainer({
                    name: "disk_dsd_enable",
                    label: strings.advSet.driveSpinDownEnable,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true,
                        rightMargin: true
                    },
                    bottomMargin: true,
                    row: 4,
                    col: 0,
                    colSpan: 2,
                    changeCallback: createObjectCallback(this, this.dsdChanged),
                    widgets: [new TextInputWidget({
                        name: "disk_dsd_delay",
                        size: 5,
                        label: strings.advSet.driveSpinDownDelay,
                        labelOptions: {
                            rightMargin: true,
                            bottomMargin: true
                        },
                        bottomMargin: true,
                        rules: {
                            range: [1, 360]
                        },
                        changeCallback: D
                    })]
                }), new CheckboxContainer({
                    name: "vdisk_dsd_suspension",
                    label: strings.advSet.dsdSuspendPeriod,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true
                    },
                    bottomMargin: true,
                    row: 6,
                    col: 0,
                    colSpan: 2,
                    width: 350,
                    changeCallback: createObjectCallback(this, this.dsdSuspendChanged),
                    widgets: [new TableWidget({
                        widgets: [new TextWidget({
                            name: "suspendTimeLabel",
                            classes: "inline ARRightSmallMargin",
                            bottomMargin: true,
                            text: strings.advSet.dsdSuspendStartTime,
                            row: 0,
                            col: 1
                        }), new TimeInputWidget({
                            name: "suspendTime",
                            classes: "inline ARRightSmallMargin",
                            size: 8,
                            bottomMargin: true,
                            rules: {
                                required: false
                            },
                            hourBox: {
                                rules: {
                                    required: false
                                }
                            },
                            minuteBox: {
                                rules: {
                                    required: false
                                }
                            },
                            row: 0,
                            col: 2,
                            changeCallback: D
                        }), new TextWidget({
                            name: "resumeTimeLabel",
                            classes: "inline ARRightSmallMargin",
                            bottomMargin: true,
                            text: strings.advSet.dsdSuspendResumeTime,
                            row: 1,
                            col: 1
                        }), new TimeInputWidget({
                            name: "resumeTime",
                            classes: "inline ARRightSmallMargin",
                            size: 8,
                            bottomMargin: true,
                            rules: {
                                required: false
                            },
                            hourBox: {
                                rules: {
                                    required: false
                                }
                            },
                            minuteBox: {
                                rules: {
                                    required: false
                                }
                            },
                            row: 1,
                            col: 2,
                            changeCallback: D
                        }), new CheckboxInputWidget({
                            name: "vdisk_dsd_weekdays",
                            label: strings.advSet.dsdSuspendWeekdays,
                            labelOptions: {
                                bottomMargin: true
                            },
                            bottomMargin: true,
                            leftMargin: true,
                            row: 2,
                            col: 2,
                            changeCallback: D
                        })]
                    })]
                })]
            }), new TableWidget({
                name: "advCache",
                widgets: E
            }), new TableWidget({
                name: "advFirmware",
                widgets: [new CheckboxInputWidget({
                    name: "partner_firmware_upgrade",
                    label: strings.advSet.pfu,
                    labelOptions: {
                        leftMargin: true,
                        bottomMargin: true
                    },
                    bottomMargin: true,
                    leftMargin: true,
                    rules: {
                        required: false
                    },
                    changeCallback: D
                })]
            }), new TableWidget({
                name: "advUtilities",
                widgets: [new CheckboxContainer({
                    name: "background_scrub",
                    label: strings.advSet.bgScrub,
                    bottomMargin: true,
                    leftMargin: true,
                    row: 0,
                    col: 0,
                    colSpan: 2,
                    changeCallback: D,
                    widgets: [new TextInputWidget({
                        name: "background_scrub_interval",
                        size: 5,
                        label: strings.advSet.bgScrubInterval,
                        bottomMargin: true,
                        leftMargin: true,
                        rules: {
                            range: [0, 360]
                        },
                        messages: {
                            range: strings.vdiskScrubRangeError
                        },
                        changeCallback: D
                    })]
                }), new CheckboxInputWidget({
                    name: "background_disk_scrub",
                    label: strings.advSet.diskScrub,
                    bottomMargin: true,
                    leftMargin: true,
                    row: 1,
                    col: 1,
                    changeCallback: D
                }), new OptionInputWidget({
                    name: "utility_priority",
                    label: strings.advSet.utilPriority,
                    bottomMargin: true,
                    leftMargin: true,
                    rules: {
                        required: false
                    },
                    values: [{
                        value: "high",
                        text: strings.advSet.high
                    }, {
                        value: "medium",
                        text: strings.advSet.medium
                    }, {
                        value: "low",
                        text: strings.advSet.low
                    }],
                    multiple: false,
                    row: 2,
                    col: 1,
                    changeCallback: D
                }), new CheckboxInputWidget({
                    name: "managed_logs",
                    label: strings.advSet.managedLogsEnable,
                    bottomMargin: true,
                    leftMargin: true,
                    row: 3,
                    col: 1,
                    changeCallback: D
                })]
            }), new TableWidget({
                name: "sysCacheSettings",
                widgets: [new OptionInputWidget({
                    name: "pi_status",
                    label: strings.advSet.piMode,
                    bottomMargin: true,
                    leftMargin: true,
                    rules: {
                        required: false
                    },
                    values: [{
                        value: "enabled",
                        text: strings.enabled
                    }, {
                        value: "disabled",
                        text: strings.disabled
                    }],
                    multiple: false,
                    row: 1,
                    col: 1,
                    changeCallback: D
                }), new OptionInputWidget({
                    name: "cache_block_size",
                    label: strings.advSet.cacheBlockSize,
                    bottomMargin: true,
                    leftMargin: true,
                    rules: {
                        required: false
                    },
                    values: [{
                        value: "4096 bytes",
                        text: "4096 bytes"
                    }, {
                        value: "512 bytes",
                        text: "512 bytes"
                    }],
                    multiple: false,
                    row: 2,
                    col: 1,
                    changeCallback: D
                })]
            })]
        })]
    })];
    ActionPanel.call(this, G);
    this.class_name = "AdvancedSettingsAction"
}
AdvancedSettingsAction.prototype = new ActionPanel();
AdvancedSettingsAction.prototype.constructor = AdvancedSettingsAction;
AdvancedSettingsAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
AdvancedSettingsAction.prototype.showing = function() {
    this.advSetSubscription = MC.advancedSettingsSet.requestData({
        update: true,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this.handleAdvSetData)
    });
    this.schedSubscription = MC.schedulesSet.requestData({
        update: true,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this.handleSchedData)
    });
    this.cacheParameterSubscription = MC.cacheParametersSet.requestData({
        update: true,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this.handleCacheData)
    });
    this.tabSelected(0)
};
AdvancedSettingsAction.prototype.hiding = function() {
    if (this.advSetSubscription) {
        MC.advancedSettingsSet.unregister(this.advSetSubscription);
        delete this.advSetSubscription
    }
    if (this.schedSubscription) {
        MC.advancedSettingsSet.unregister(this.schedSubscription);
        delete this.schedSubscription
    }
};
AdvancedSettingsAction.prototype.handleAdvSetData = function(F) {
    var E = F.data.objects[0];
    var H = decodeBooleanFlag(E.get("disk_dsd_enable_numeric"));
    var D = parseInt(DC.system.redundancy.get("redundancy_mode_numeric"), 10);
    var C = {
        smart: {
            value: E.get("smart").toLowerCase(),
            setOrig: true
        },
        emp_poll_rate: {
            value: E.get("emp_poll_rate"),
            setOrig: true
        },
        dynamic_spares: {
            value: decodeBooleanFlag(E.get("dynamic_spares")),
            setOrig: true
        },
        disk_dsd_enable: {
            value: H,
            setOrig: true
        },
        disk_dsd_delay: {
            value: E.get("disk_dsd_delay"),
            disable: (!H),
            setOrig: true
        },
        sync_cache_mode: {
            value: SYNC_CACHE_MODE[E.get("sync_cache_mode_numeric")],
            setOrig: true
        },
        missing_lun_response: {
            value: MISSING_LUN_RESPONSE[E.get("missing_lun_response_numeric")],
            setOrig: true
        },
        host_cache_control: {
            value: decodeBooleanFlag(E.get("host_cache_control_numeric")),
            setOrig: true
        },
        super_cap_failure: {
            value: decodeBooleanFlag(E.get("super_cap_failure_numeric")),
            setOrig: true
        },
        compact_flash_failure: {
            value: decodeBooleanFlag(E.get("compact_flash_failure_numeric")),
            setOrig: true
        },
        power_supply_failure: {
            value: decodeBooleanFlag(E.get("power_supply_failure_numeric")),
            setOrig: true
        },
        fan_failure: {
            value: decodeBooleanFlag(E.get("fan_failure_numeric")),
            setOrig: true
        },
        temperature_exceeded: {
            value: decodeBooleanFlag(E.get("temperature_exceeded_numeric")),
            setOrig: true
        },
        auto_write_back: {
            value: decodeBooleanFlag(E.get("auto_write_back_numeric")),
            setOrig: true
        },
        partner_firmware_upgrade: {
            value: decodeBooleanFlag(E.get("partner_firmware_upgrade_numeric")),
            setOrig: true
        },
        background_scrub: {
            value: decodeBooleanFlag(E.get("background_scrub_numeric")),
            setOrig: true
        },
        background_scrub_interval: {
            value: E.get("background_scrub_interval"),
            setOrig: true
        },
        background_disk_scrub: {
            value: decodeBooleanFlag(E.get("background_disk_scrub_numeric")),
            setOrig: true
        },
        managed_logs: {
            value: decodeBooleanFlag(E.get("managed_logs_numeric")),
            setOrig: true
        }
    };
    if (D != REDUNDANCY_MODE.SINGLE_CONTROLLER) {
        if (!isHPsystem()) {
            C.independent_cache = {
                value: decodeBooleanFlag(E.get("independent_cache_numeric")),
                disable: false,
                setOrig: true
            }
        }
        C.controller_failure = {
            value: decodeBooleanFlag(E.get("controller_failure_numeric")),
            setOrig: true
        };
        C.partner_notify = {
            value: decodeBooleanFlag(E.get("partner_notify_numeric")),
            setOrig: true
        }
    } else {
        if (!isHPsystem()) {
            C.independent_cache = {
                value: false,
                disable: true
            }
        }
        C.partner_notify = {
            value: false,
            disable: true
        };
        C.controller_failure = {
            value: false,
            disable: true
        }
    }
    var G = parseInt(E.get("utility_priority_numeric"));
    switch (G) {
        case 0:
            C.utility_priority = {
                value: "high"
            };
            break;
        case 1:
            C.utility_priority = {
                value: "medium"
            };
            break;
        default:
            C.utility_priority = {
                value: "low"
            };
            break
    }
    C.utility_priority.setOrig = true;
    this.update(C)
};
AdvancedSettingsAction.prototype.handleSchedData = function(H) {
    var J = false;
    var M = new Date(1970, 1, 1, 0, 0, 0);
    var L = false;
    var O = H.dataSelect({
        type: "prop",
        name: "name",
        value: "schedDSDsuspend"
    });
    if (O.objects.length != 0) {
        J = true;
        var I = O.objects[0].get("next_time").split(" ");
        var F = I[0].split("-");
        var G = I[1].split(":");
        var D = new Date(F[0], F[1], F[2], G[0], G[1], G[2]);
        var N = D.getTime();
        if (O.objects[0].get("schedule_specification").indexOf("Only Any Weekday Of Year") > -1) {
            L = true
        }
        D.setTime(N)
    }
    var C = H.dataSelect({
        type: "prop",
        name: "name",
        value: "schedDSDresume"
    });
    if (C.objects.length != 0) {
        var I = C.objects[0].get("next_time").split(" ");
        var F = I[0].split("-");
        var G = I[1].split(":");
        var E = new Date(F[0], F[1], F[2], G[0], G[1], G[2]);
        var N = E.getTime();
        E.setTime(N)
    }
    var K = {
        vdisk_dsd_weekdays: {
            value: L,
            setOrig: true
        }
    };
    if (J) {
        K.vdisk_dsd_suspension = {
            value: true,
            setOrig: true
        };
        K.suspendTime = {
            value: D,
            setOrig: true
        };
        K.resumeTime = {
            value: E,
            setOrig: true
        }
    } else {
        K.vdisk_dsd_suspension = {
            value: false,
            setOrig: true
        };
        K.suspendTime = {
            value: M,
            disable: true
        };
        K.resumeTime = {
            value: M,
            disable: true
        };
        K.vdisk_dsd_weekdays.disable = true
    }
    this.update(K)
};
AdvancedSettingsAction.prototype.handleCacheData = function(F) {
    var E = {};
    if (F.name == "cacheParametersSet") {
        this.cacheData = F.getData()
    }
    if (this.cacheData) {
        var D = this.cacheData.objects[0];
        var G = D.getInt("pi_format_numeric");
        switch (G) {
            case 0:
                E.pi_status = {
                    value: "disabled"
                };
                break;
            case 1:
                E.pi_status = {
                    value: "disabled"
                };
                break;
            case 2:
                E.pi_status = {
                    value: "enabled"
                };
                break;
            default:
                E.pi_status = {
                    value: "disabled"
                };
                break
        }
        E.pi_status.setOrig = true;
        var C = D.getInt("cache_block_size");
        switch (C) {
            case 512:
                E.cache_block_size = {
                    value: "512 bytes"
                };
                break;
            case 4096:
                E.cache_block_size = {
                    value: "4096 bytes"
                };
                break;
            default:
                E.cache_block_size = {
                    value: "4096 bytes"
                };
                break
        }
        E.cache_block_size.setOrig = true;
        E.setAdvancedSettingsFormSubmit = {
            disable: (propertyCount(DC.vdisks) > 0)
        };
        this.update(E)
    }
};
AdvancedSettingsAction.prototype.tabSelected = function(C) {
    if (C == null) {
        return
    }
    if (this.htmlLoaded) {
        switch (C) {
            case 0:
                this.update({
                    advDisk: {
                        visibility: "visible"
                    },
                    advCache: {
                        visibility: "collapse"
                    },
                    advFirmware: {
                        visibility: "collapse"
                    },
                    advUtilities: {
                        visibility: "collapse"
                    },
                    sysCacheSettings: {
                        visibility: "collapse"
                    }
                });
                break;
            case 1:
                this.update({
                    advDisk: {
                        visibility: "collapse"
                    },
                    advCache: {
                        visibility: "visible"
                    },
                    advFirmware: {
                        visibility: "collapse"
                    },
                    advUtilities: {
                        visibility: "collapse"
                    },
                    sysCacheSettings: {
                        visibility: "collapse"
                    }
                });
                break;
            case 2:
                this.update({
                    advDisk: {
                        visibility: "collapse"
                    },
                    advCache: {
                        visibility: "collapse"
                    },
                    advFirmware: {
                        visibility: "visible"
                    },
                    advUtilities: {
                        visibility: "collapse"
                    },
                    sysCacheSettings: {
                        visibility: "collapse"
                    }
                });
                break;
            case 3:
                this.update({
                    advDisk: {
                        visibility: "collapse"
                    },
                    advCache: {
                        visibility: "collapse"
                    },
                    advFirmware: {
                        visibility: "collapse"
                    },
                    advUtilities: {
                        visibility: "visible"
                    },
                    sysCacheSettings: {
                        visibility: "collapse"
                    }
                });
                break;
            case 4:
                if (RI.hasFeature("e2ePi") && !RI.supportsPaged()) {
                    this.update({
                        advDisk: {
                            visibility: "collapse"
                        },
                        advCache: {
                            visibility: "collapse"
                        },
                        advFirmware: {
                            visibility: "collapse"
                        },
                        advUtilities: {
                            visibility: "collapse"
                        },
                        sysCacheSettings: {
                            visibility: "visible"
                        }
                    })
                }
                break;
            default:
                MC.warningOutput("AdvancedSettingsAction.tabSelected: bad tab number = %d", C);
                break
        }
        this.resetSize({
            shrink: true
        })
    }
};
AdvancedSettingsAction.prototype.somethingChanged = function(I, G, H) {
    var F = {};
    var E;
    if (!H) {
        return
    }
    var D = false;
    var C = false;
    this.retrieve(F);
    for (E in F) {
        if ((E == "pi_status" || E == "cache_block_size") && F[E].valueChanged == true) {
            for (index in DC.pools) {
                if (DC.pools[index].getInt("storage_type_numeric") == 0) {
                    var D = true;
                    break
                }
            }
            if (!D) {
                C = true
            }
            break
        } else {
            if (F[E].valueChanged == true) {
                C = true;
                break
            }
        }
    }
    if (C) {
        this.okEnabled(true);
        this.applyEnabled(true)
    } else {
        this.okEnabled(false);
        this.applyEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
AdvancedSettingsAction.prototype.dsdChanged = function(G, E, F) {
    var C = this;
    if (G && G.disk_dsd_enable) {
        if (G.disk_dsd_enable.value) {
            var D = {
                disk_dsd_delay: {
                    disable: false
                }
            };
            if (G.disk_dsd_enable.valueChanged) {
                D.disk_dsd_delay.value = 15
            }
        } else {
            var D = {
                disk_dsd_delay: {
                    disable: true,
                    value: 0
                }
            }
        }
        C.update(D)
    }
    this.somethingChanged(G, E, F)
};
AdvancedSettingsAction.prototype.dsdSuspendChanged = function(G, E, F) {
    var C = this;
    if (G && G.vdisk_dsd_suspension) {
        if (G.vdisk_dsd_suspension.value == true) {
            var D = {
                suspendTime: {
                    disable: false
                },
                resumeTime: {
                    disable: false
                },
                vdisk_dsd_weekdays: {
                    disable: false
                }
            }
        } else {
            var D = {
                suspendTime: {
                    disable: true
                },
                resumeTime: {
                    disable: true
                },
                vdisk_dsd_weekdays: {
                    disable: true
                }
            }
        }
        C.update(D)
    }
    this.somethingChanged(G, E, F)
};
AdvancedSettingsAction.prototype.getConfirmMsg = function(C) {
    var F = "";
    var E = "";
    var D = strings.advSet.separator;
    if (!C.dynamic_spares.value && C.dynamic_spares.valueChanged) {
        F = strings.advSet.dynamSpare
    }
    if (C.smart.value == "disabled" && C.smart.valueChanged) {
        F = (F == "") ? strings.advSet.smartconfig : F + D + strings.advSet.smartconfig
    }
    if (!C.super_cap_failure.value && C.super_cap_failure.valueChanged) {
        F = (F == "") ? strings.advSet.cachePower : F + D + strings.advSet.cachePower
    }
    if (!C.compact_flash_failure.value && C.compact_flash_failure.valueChanged) {
        F = (F == "") ? strings.advSet.awtTrFlash : F + D + strings.advSet.awtTrFlash
    }
    if (isHPsystem() && !C.background_scrub.value && C.background_scrub.valueChanged) {
        F = (F == "") ? strings.advSet.bgScrub : F + D + strings.advSet.bgScrub
    }
    if (F != "") {
        E = strings.advSet.confirmMsg(F)
    }
    return E
};
AdvancedSettingsAction.prototype.createCommands = function(Y) {
    var D = [];
    var U = {};
    var H = {};
    for (i in Y) {
        if (Y[i].valueChanged == true && (i == "pi_status" || i == "cache_block_size")) {
            H[i] = Y[i];
            if (i == "cache_block_size") {
                if (H[i].value == "4096 bytes") {
                    H.cache_block_size.value = "4K"
                } else {
                    H.cache_block_size.value = "512"
                }
            }
        } else {
            if (Y[i].valueChanged == true && i != "vdisk_dsd_suspension" && i != "suspendTime" && i != "resumeTime" && i != "vdisk_dsd_weekdays") {
                U[i] = Y[i]
            }
        }
    }
    if (!$.isEmptyObject(U)) {
        D.push({
            name: "advancedSettings",
            command: MC.setAdvancedSettings,
            data: U,
            options: {
                processingMsg: strings.advSet.advSetProcessing,
                failureMsg: strings.advSet.advSetFail,
                successMsg: strings.advSet.advSetSuccess
            }
        })
    } else {
        if (!$.isEmptyObject(H)) {
            MC.setSystemCacheParameters(H, {
                dialog: true,
                includeInfo: true,
                confirmMsg: strings.advSet.systemCacheConfirmMsg,
                processingMsg: strings.advSet.cacheSetProcessing,
                failureMsg: strings.advSet.cacheSetFail,
                successMsg: strings.advSet.cacheSetSuccess
            })
        }
    }
    var F = false;
    var E = false;
    var M = false;
    var L = false;
    if (DC.schedules.schedDSDsuspend != undefined) {
        L = true
    }
    if (DC.schedules.schedDSDresume != undefined) {
        M = true
    }
    if (DC.tasks.taskDSDresume != undefined) {
        F = true
    }
    if (DC.tasks.taskDSDsuspend != undefined) {
        E = true
    }
    var N = MC.timeSettingsSet.getData();
    var Z = N.getNthObject(0);
    var X = new String();
    X = Z.getPropertyValue("date_time").toString();
    var G = Z.getPropertyValue("date_time_numeric");
    currentDate = X.substr(0, 10);
    currentTime = X.substr(11, 5);
    if ((Y.vdisk_dsd_suspension != undefined) && (Y.vdisk_dsd_suspension.value == true)) {
        if (Y.suspendTime) {
            if (Y.suspendTime.textValue.charAt(1) == ":") {
                suspendTimeVal = "0" + Y.suspendTime.textValue
            } else {
                suspendTimeVal = Y.suspendTime.textValue
            }
            var S = suspendTimeVal.substr(0, 5).split(":");
            if (suspendTimeVal.search(" pm") > 0) {
                if (S[0] == "12") {
                    var W = S[0] + ":" + S[1]
                } else {
                    var W = (Number(S[0]) + 12) + ":" + S[1]
                }
            } else {
                if (suspendTimeVal.search(" am") > 0) {
                    if (S[0] == "12") {
                        var W = "00:" + S[1]
                    } else {
                        var W = suspendTimeVal.substr(0, 5)
                    }
                } else {
                    var W = suspendTimeVal
                }
            }
            if (W > currentTime) {
                var O = "start " + currentDate + " " + W + " every 1 days"
            } else {
                var C = (Number(G) + 24 * 3600) * 1000;
                var J = new Date(C);
                var O = "start " + J.getFullYear() + "-" + Number(parseInt(J.getMonth()) + 1) + "-" + J.getDate() + " " + W + " every 1 days"
            }
        }
        if (Y.resumeTime) {
            if (Y.resumeTime.textValue.charAt(1) == ":") {
                resumeTimeVal = "0" + Y.resumeTime.textValue
            } else {
                resumeTimeVal = Y.resumeTime.textValue
            }
            var S = resumeTimeVal.substr(0, 5).split(":");
            if (resumeTimeVal.search(" pm") > 0) {
                if (S[0] == "12") {
                    var W = S[0] + ":" + S[1]
                } else {
                    var W = (Number(S[0]) + 12) + ":" + S[1]
                }
            } else {
                if (resumeTimeVal.search(" am") > 0) {
                    if (S[0] == "12") {
                        var W = "00:" + S[1]
                    } else {
                        var W = resumeTimeVal.substr(0, 5)
                    }
                } else {
                    var W = resumeTimeVal
                }
            }
            if (W > currentTime) {
                var P = "start " + currentDate + " " + W + " every 1 days"
            } else {
                var C = (Number(G) + 24 * 3600) * 1000;
                var J = new Date(C);
                var P = "start " + J.getFullYear() + "-" + Number(parseInt(J.getMonth()) + 1) + "-" + J.getDate() + " " + W + " every 1 days"
            }
        }
        if (Y.vdisk_dsd_weekdays.value == true) {
            O += ", only any weekday of year";
            P += ", only any weekday of year"
        }
        if (!F) {
            var V = {
                name: "taskDSDresume",
                type: "EnableDSD"
            };
            D.push({
                name: "taskR",
                command: MC.createTask,
                data: V,
                options: {
                    processingMsg: strings.advSet.dsdCreateTaskProcessing,
                    failureMsg: strings.advSet.dsdCreateTaskFail,
                    successMsg: strings.advSet.dsdCreateTaskSuccess
                }
            })
        }
        if (!E) {
            var T = {
                name: "taskDSDsuspend",
                type: "DisableDSD"
            };
            D.push({
                name: "taskS",
                command: MC.createTask,
                data: T,
                options: {
                    processingMsg: strings.advSet.dsdCreateTaskProcessing,
                    failureMsg: strings.advSet.dsdCreateTaskFail,
                    successMsg: strings.advSet.dsdCreateTaskSuccess
                }
            })
        }
        var Q = {
            name: "schedDSDsuspend",
            scheduleSpecification: O,
            taskName: "taskDSDsuspend"
        };
        var R = {
            name: "schedDSDresume",
            scheduleSpecification: P,
            taskName: "taskDSDresume"
        };
        D.push({
            name: "schedS",
            command: (L) ? MC.setSchedule : MC.createSchedule,
            data: Q,
            options: {
                processingMsg: strings.advSet.advSetProcessing,
                failureMsg: strings.advSet.advSetFail
            }
        });
        D.push({
            name: "schedR",
            command: (M) ? MC.setSchedule : MC.createSchedule,
            data: R,
            options: {
                processingMsg: strings.advSet.advSetProcessing,
                failureMsg: strings.advSet.advSetFail
            }
        })
    } else {
        if (L) {
            var I = {
                name: "schedDSDsuspend"
            };
            D.push({
                name: "delSchedS",
                command: MC.deleteSchedule,
                data: I,
                options: {
                    processingMsg: strings.advSet.advSetProcessing,
                    failureMsg: strings.advSet.advSetFail
                }
            })
        }
        if (M) {
            var K = {
                name: "schedDSDresume"
            };
            D.push({
                name: "delSchedR",
                command: MC.deleteSchedule,
                data: K,
                options: {
                    processingMsg: strings.advSet.advSetProcessing,
                    failureMsg: strings.advSet.advSetFail
                }
            })
        }
    }
    return D
};
AdvancedSettingsAction.prototype.sendCommands = function(E) {
    var F = {};
    this.retrieve(F);
    var G = this.getConfirmMsg(F);
    var D = {
        okLabel: strings.applyButtonText,
        cancelLabel: strings.cancelButtonText,
        successMsg: strings.advSet.successMsg,
        closeActionOn: (E == "ok") ? "success" : "none"
    };
    if (F.settingsForm.valid) {
        if (G) {
            D.confirmMsg = G
        }
        var C = this.createCommands(F);
        MC.execCommandList(C, D);
        if (E === "apply") {
            this.update(F);
            this.okEnabled(false);
            this.applyEnabled(false)
        }
    }
};
AdvancedSettingsAction.prototype.okCallback = function() {
    this.sendCommands("ok")
};
AdvancedSettingsAction.prototype.applyCallback = function() {
    this.sendCommands("apply")
};

function RestartSystemAction(E) {
    var D = 0;
    var C;
    if (arguments.length == 0) {
        return
    }
    E.name = "RestartSystemAction";
    E.width = 420;
    E.okCallback = createObjectCallback(this, this.okCallback);
    C = createObjectCallback(this, this.changeCallback);
    E.widgets = [new TextWidget({
        name: "restartText",
        text: strings.restartAction.descText
    }), new FormWidget({
        name: "restartForm",
        data: {},
        widgets: [new TableWidget({
            name: "restartTable",
            widgets: [new RadioButtonsInputWidget({
                name: "operation",
                row: D,
                col: 1,
                colSpan: 2,
                orientation: "horizontal",
                label: strings.restartAction.operationLabel,
                classes: "noWrap",
                labelOptions: {
                    row: D++,
                    col: 0,
                    classes: "noWrap",
                    rightMargin: true
                },
                values: [{
                    value: "restart",
                    text: strings.restartAction.restart
                }, {
                    value: "shutdown",
                    text: strings.restartAction.shutdown
                }],
                changeCallback: createObjectCallback(this, this.operationChangeCallback)
            }), new RadioButtonsInputWidget({
                name: "contType",
                row: D,
                col: 1,
                colSpan: 2,
                orientation: "horizontal",
                label: strings.restartAction.typeLabel,
                classes: "noWrap",
                topMargin: true,
                labelOptions: {
                    row: D++,
                    col: 0,
                    classes: "noWrap",
                    rightMargin: true
                },
                values: [{
                    value: "mc",
                    text: strings.restartAction.mcType
                }, {
                    value: "sc",
                    text: strings.restartAction.scType
                }],
                changeCallback: C
            }), new LabelWidget({
                name: "controllerSelectionLabel",
                row: D,
                col: 0,
                topMargin: true,
                rightMargin: true,
                value: strings.restartAction.controllerLabel
            }), new CheckboxInputWidget({
                name: "selContA",
                row: D,
                col: 1,
                label: strings.restartAction.controller("A"),
                value: false,
                singleCell: true,
                topMargin: true,
                changeCallback: C
            }), new CheckboxInputWidget({
                name: "selContB",
                row: D++,
                col: 2,
                label: strings.restartAction.controller("B"),
                value: false,
                singleCell: true,
                leftMargin: true,
                topMargin: true,
                changeCallback: C
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "RestartSystemAction"
}
RestartSystemAction.prototype = new ActionPanel();
RestartSystemAction.prototype.constructor = RestartSystemAction;
RestartSystemAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
RestartSystemAction.LOCAL = 1;
RestartSystemAction.REMOTE = 2;
RestartSystemAction.BOTH = 3;
RestartSystemAction.A = 1;
RestartSystemAction.B = 0;
RestartSystemAction.prototype.showing = function() {
    var C = {
        selContA: {
            value: false,
            setOrig: true
        },
        selContB: {
            value: false,
            setOrig: true
        },
        contType: {
            value: "mc",
            setOrig: true
        },
        operation: {
            value: "restart",
            setOrig: true
        }
    };
    this.update(C);
    this.okEnabled(false);
    this.getShutdownStatus()
};
RestartSystemAction.prototype.okCallback = function() {
    var G = {};
    var D;
    var H;
    var F;
    var C;
    var E = null;
    this.retrieve(G);
    if (G.selContA.value && G.selContB.value) {
        D = strings.restartAction.bothControllers;
        H = "both"
    } else {
        if (G.selContA.value) {
            D = strings.restartAction.controller("A");
            H = "A"
        } else {
            if (G.selContB.value) {
                D = strings.restartAction.controller("B");
                H = "B"
            }
        }
    }
    if (H === "both") {
        this.controller = RestartSystemAction.BOTH
    } else {
        if ((G.selContA.value == true && system.local_controller_numeric == 1) || (G.selContB.value == true && system.local_controller_numeric == 0)) {
            this.controller = RestartSystemAction.LOCAL
        } else {
            this.controller = RestartSystemAction.REMOTE
        }
    }
    if (G.operation.value == "shutdown") {
        if (this.controller === RestartSystemAction.BOTH) {
            F = strings.restartAction.confirmShutdownBoth
        } else {
            if (this.controller === RestartSystemAction.LOCAL) {
                F = strings.restartAction.confirmLocalShutdownMsg;
                F += strings.restartAction.confirmShutdownMsg(D)
            } else {
                if (this.controller === RestartSystemAction.REMOTE) {
                    F = strings.restartAction.confirmPartnerShutdownMsg;
                    F += strings.restartAction.confirmShutdownMsg(D)
                }
            }
            this.IsPartnerControllerActive(H === "A" ? "B" : "A") === true ? C = "" : C = strings.restartAction.confirmLastAvailableSystemShutdownMsg
        }
        MC.shutdownSC({
            controller: H
        }, {
            dialog: true,
            confirmMsg: F,
            confirm2Msg: C,
            processingMsg: strings.restartAction.processingShutdownMsg(D),
            failureMsg: strings.restartAction.failureShutdownMsg(D),
            successMsg: strings.restartAction.successShutdownMsg(D),
            closeActionOn: "success"
        })
    } else {
        if (G.contType.value == "mc") {
            F = strings.restartAction.confirmMCmsg(D);
            if (this.controller != RestartSystemAction.REMOTE) {
                F = strings.restartAction.confirmLocalMCmsg + F
            } else {
                F = strings.restartAction.confirmPartnerRestartMsg + F
            }
        } else {
            F = strings.restartAction.confirmSCmsg(D);
            if (this.controller == RestartSystemAction.BOTH) {
                F = strings.restartAction.confirmBothSCmsg + F
            } else {
                if (this.controller != RestartSystemAction.REMOTE) {
                    F = strings.restartAction.confirmLocalSCmsg + F
                } else {
                    F = strings.restartAction.confirmPartnerRestartMsg + F
                }
            }
            this.IsPartnerControllerActive(H === "A" ? "B" : "A") === true ? C = "" : C = strings.restartAction.confirmLastAvailableSystemShutdownMsg
        }
        if (G.contType.value == "mc" && this.controller == RestartSystemAction.BOTH) {
            E = function() {
                reloader.off();
                BC.off();
                setTimeout("RB.abortAll()", 5000);
                setTimeout("session.mcRestart()", 120000)
            }
        }
        MC.restartController({
            type: G.contType.value,
            controller: H
        }, {
            dialog: true,
            confirmMsg: F,
            confirm2Msg: C,
            processingMsg: (G.contType.value == "mc") ? strings.restartAction.processingRestartMCmsg(D) : strings.restartAction.processingRestartSCmsg(D),
            failureMsg: (G.contType.value == "mc") ? strings.restartAction.failureRestartMCmsg(D) : strings.restartAction.failureRestartSCmsg(D),
            noSuccessDialog: (this.controller != RestartSystemAction.REMOTE),
            successMsg: (G.contType.value == "mc") ? strings.restartAction.successRestartMCmsg(D) : strings.restartAction.successRestartSCmsg(D),
            sending: E,
            callback: createObjectCallback(this, this._restartStarted),
            closeActionOn: "success"
        })
    }
};
RestartSystemAction.prototype._restartStarted = function(D) {
    var F = "";
    var E;
    var C;
    MC.warningOutput("Restart succeeded: %b, message = %s", D.success, D.message);
    if (this.controller != RestartSystemAction.REMOTE && D.success) {
        if (this.controller == RestartSystemAction.BOTH && D.json.statusObjects.length == 3) {
            E = D.json.statusObjects[0];
            if (E) {
                C = E.prop.response.text;
                F = strings.restartAction.successRemoteMsg(C)
            }
        }
        F += strings.restartAction.successLocalMsg;
        ShowActiveDialog({
            type: "message",
            message: F,
            okState: "hidden",
            cancelState: "hidden",
            dialogOverride: true
        });
        reloader.off();
        BC.off();
        setTimeout("session.mcRestart()", 120000)
    }
};
RestartSystemAction.prototype.changeCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if ((C.selContA.value == true) || (C.selContB.value == true)) {
        this.okEnabled(true, true)
    } else {
        this.okEnabled(false)
    }
};
RestartSystemAction.prototype.operationChangeCallback = function(G, E, F) {
    var C = {};
    var D = {};
    this.retrieve(D);
    if ((D.operation.value == "shutdown") && (D.contType.disable != true)) {
        C.contType = {
            value: "sc",
            disable: true
        };
        this.update(C)
    } else {
        if ((D.operation.value == "restart") && (D.contType.disable == true)) {
            C.contType = {
                value: "mc",
                disable: false
            };
            this.update(C)
        }
    }
    this.changeCallback(G, E, F)
};
RestartSystemAction.prototype.getShutdownStatus = function(C) {
    this.shutdownStatusSetSubscription = MC.shutdownStatusSet.requestData({
        update: true,
        durable: true,
        handler: createObjectCallback(this, function(G) {
            var F = G.getData();
            if (!F) {
                return
            }
            var D = null;
            for (var E in F.objects) {
                D = F.objects[E];
                if (D instanceof APIShutdownStatus) {
                    if (D.getPropertyValue("controller") === "A") {
                        this.SC_A_Status = D.getPropertyValue("status_numeric")
                    } else {
                        this.SC_B_Status = D.getPropertyValue("status_numeric")
                    }
                }
            }
        })
    })
};
RestartSystemAction.prototype.IsPartnerControllerActive = function(C) {
    if ((DC.advSettings.getInt("single_controller_numeric") == 1) || DC.controllers[C].getInt("status_numeric") !== CONTROLLER_STATUS.UP || DC.controllers[C].getInt("health_numeric") !== HEALTH.OK) {
        return false
    }
    if (C === "A") {
        if (this.SC_A_Status != 0 || DC.system.getPropertyValue("other_MC_status") !== "Operational") {
            return false
        }
    } else {
        if (this.SC_B_Status != 0 || DC.system.getPropertyValue("other_MC_status") !== "Operational") {
            return false
        }
    }
    return true
};
RestartSystemAction.prototype.hiding = function() {
    if (this.shutdownStatusSetSubscription) {
        MC.shutdownStatusSet.unregister(this.shutdownStatusSetSubscription);
        delete this.shutdownStatusSetSubscription
    }
};

function EventListAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "EventListAction";
    C.width = 300;
    C.widgets = new WidgetContainer({
        widgets: [new TextWidget({
            name: "waitingWidget",
            text: '<div class="processIndicator" style="display: inline-block; width: 200px"></div>'
        }), new TableInator({
            name: "eventsTable",
            id: "eventsTableInator",
            type: "apiData",
            selectable: false,
            width: 985,
            fields: ["severity_numeric", "time_stamp", "event_id", "event_code", "message", "controller"],
            metadata: "events",
            dtOptions: {
                bLengthChange: false,
                aaSorting: [
                    [1, "desc"],
                    [2, "desc"]
                ]
            },
            columnOverrides: {
                severity_numeric: {
                    sWidth: "62px",
                    sTitle: strings.eventList.sevCol,
                    sType: "string",
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                time_stamp: {
                    sWidth: "70px",
                    sTitle: strings.eventList.timeCol,
                    sType: "string",
                    bFilterMenu: false
                },
                event_id: {
                    sWidth: "42px",
                    sTitle: strings.eventList.idCol,
                    bFilterMenu: false
                },
                event_code: {
                    sWidth: "65px",
                    sTitle: strings.eventList.eventCodeLabel,
                    sType: "numeric",
                    bFilterMenu: {
                        numItems: 0
                    }
                },
                message: {
                    bSortable: false,
                    sTitle: strings.eventList.messageLabel,
                    bFilterMenu: false
                },
                controller: {
                    sWidth: "45px",
                    sTitle: strings.eventList.ctrlCol,
                    bSortable: false
                }
            },
            intercepts: [{
                selector: "time_stamp",
                renderer: this.timeStampHandler
            }, {
                selector: "severity_numeric",
                renderer: this.severityHandler
            }, {
                selector: "message",
                renderer: this.messageHandler
            }]
        })]
    });
    ActionPanel.call(this, C);
    this.class_name = "EventListAction";
    this.eventsTableinator$ = $("#eventsTableInator", this.elements);
    this.eventsTableinator$.on("click", createObjectCallback(this, this.messageClicked))
}
EventListAction.prototype = new ActionPanel();
EventListAction.prototype.constructor = EventListAction;
EventListAction.open = function(C) {
    NAV.navTo("EventBarPanel", "eventList", null, C)
};
EventListAction.getMenuState = function() {
    return []
};
EventListAction.prototype.showing = function() {
    var C = this;
    this.update({
        eventsTable: {
            visibility: "hidden"
        }
    });
    var E = {
        global: ""
    };
    if (this.previousSelection) {
        for (var D = 0; D < this.previousSelection.length; D++) {
            if (this.previousSelection[D].basetype == "events") {
                if (E.global == "") {
                    E.global += "/"
                }
                E.global += this.previousSelection[D].key
            }
            if (E.global != "") {
                E.global += "/"
            }
        }
    }
    this.eventsSubscription = MC.eventsSet.requestData({
        update: true,
        durable: false,
        requestor: this.class_name,
        handler: function(H) {
            var G = {
                waitingWidget: {
                    visibility: "hidden"
                },
                eventsTable: {
                    visibility: "visible",
                    data: H.data.objects,
                    filters: E
                }
            };
            C.update(G);
            C.resetSize({
                width: 1030,
                shrink: true
            });
            var F = detectBrowser();
            if (F.mozilla) {
                $(".actionTray", this.elements).css("overflow-y", "scroll")
            }
        }
    });
    this.okEnabled(true)
};
EventListAction.prototype.severityHandler = function(C) {
    return '<div class="severity' + C.aData.prop.severity_numeric.text + '"></div>'
};
EventListAction.prototype.timeStampHandler = function(D) {
    var C = new MCDate(parseInt(D.aData.prop.time_stamp_numeric.text, 10) * 1000);
    return '<div class="time_stamp">' + MCDate.toUTCDateString(C) + "<br />" + MCDate.toUTCTimeString(C) + "</div>"
};
EventListAction.prototype.hiding = function() {
    if (this.eventsSubscription) {
        MC.eventsSet.unregister(this.eventsSubscription);
        delete this.eventsSubscription
    }
    this.isVisible = false
};
EventListAction.prototype.messageHandler = function(D) {
    var C = D.aData.prop.message.text;
    return '<div class="eventMessage" title="' + strings.eventList.messageTip + '"><div class="eventMessageText">' + C + '</div><div class="eventMessageSub" style="display:none"><div class="eventAiHeader">' + strings.eventList.aiHeader + '</div><div class="eventAiText">' + D.aData.prop.additional_information.text + '</div><div class="eventRaHeader">' + strings.eventList.raHeader + '</div><div class="eventRaText">' + D.aData.prop.recommended_action.text + "</div></div></div>"
};
EventListAction.prototype.messageClicked = function(C) {
    var D = $(C.target).parents(".eventMessage").children(".eventMessageSub");
    if (D) {
        D.toggle()
    }
};

function NoteDisplayAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "NoteDisplayAction";
    C.cancelButtonText = strings.closeButtonText;
    C.widgets = new WidgetContainer({
        widgets: [this.table = new TableInator({
            name: "notesTable",
            id: "notesTableInator",
            type: "rawData",
            selectable: false,
            displayLength: 12,
            metadata: [{
                sTitle: strings.noteDisplayAction.noteCol
            }],
            dtOptions: {
                bFilter: false,
                bLengthChange: false,
                bSort: false
            }
        })]
    });
    ActionPanel.call(this, C);
    this.class_name = "NoteDisplayAction"
}
NoteDisplayAction.prototype = new ActionPanel();
NoteDisplayAction.prototype.constructor = NoteDisplayAction;
NoteDisplayAction.getMenuState = function() {
    return []
};
NoteDisplayAction.prototype.showing = function() {
    this.update({
        notesTable: {
            data: panels.ActivityBarPanel.notes
        }
    });
    this.resetSize({
        shrink: true
    });
    this.table.dataTable.fnPageChange("last")
};
HostConstants = {
    MAX_INITIATORS_PER_HOST: 128,
    MAX_INITIATORS: 1024,
    MAX_HOSTS: 512,
    MAX_HOST_GROUPS: 32,
    MAX_HOSTS_PER_GROUP: 256,
    MAX_INITIATORS_STR_LEN: 900
};

function AddToHostAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AddToHostAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [this.addToHostForm = new FormWidget({
        name: "addToHostForm",
        classes: "heightHostComboBox",
        widgets: [new TextWidget({
            name: "actionDescription",
            text: strings.addToHost.actionDescription
        }), new TextWidget({
            name: "initiatorNames",
            classes: "scrollText100",
            label: strings.addToHost.initatorNamesLabel,
            width: 280,
            topMargin: true
        }), new ComboBoxWidget({
            name: "hostList",
            label: strings.addToHost.hostListLabel,
            topMargin: true,
            allowInput: true,
            rules: {
                required: true,
                utf8length: 32,
                dhHostName: true
            },
            values: this._generateComboBoxHostList(),
            changeCallback: createObjectCallback(this, this.changedCallback)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "AddToHostAction";
    this.hostName = "";
    this.selected = null;
    this.multiple = true;
    this.initiatorNames = {}
}
AddToHostAction.prototype = new ActionPanel();
AddToHostAction.prototype.constructor = AddToHostAction;
AddToHostAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D;
    var F;
    var E = HostConstants.MAX_INITIATORS_PER_HOST;
    var C = TopicPanel.getSelected(["initiator"], HostConstants.MAX_INITIATORS_PER_HOST);
    if (!C) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_INITIATORS_PER_HOST, strings.initiators)
    }
    for (F = 0; F < C.length; F++) {
        D = C[F].getObject();
        if (D.get("host_id") != "NOHOST") {
            return strings.menuTips.initiatorAlreadyGrouped
        }
        if (!D.get("nickname")) {
            return strings.menuTips.initiatorNotNamed
        }
    }
    return C
};
AddToHostAction.prototype.showing = function() {
    var F;
    var E;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    var C = [];
    for (F = 0; F < this.selected.length; F++) {
        E = DC.initiatorsId[this.selected[F].key];
        if (E.get("nickname")) {
            var D = E.get("nickname");
            var G = E.get("id");
            this.initiatorNames[D] = G;
            C.push(D)
        }
    }
    this.update({
        initiatorNames: {
            text: MC.getItemList(C, true)
        }
    });
    this.resetSize({
        shrink: true
    });
    this.okEnabled(false)
};
AddToHostAction.prototype._generateComboBoxHostList = function() {
    var E;
    var C = DC.hosts;
    var D = "bogus";
    hostList = new Array;
    for (E in C) {
        D = C[E].get("name");
        if (D != strings.hostNotGrouped) {
            hostList.push({
                value: D,
                text: D
            })
        }
    }
    return hostList
};
AddToHostAction.prototype.changedCallback = function(E, C, D) {
    this.hostName = E.hostList.value;
    this.okEnabled(this.addToHostForm.valid);
    this.resetSize({
        shrink: true
    })
};
AddToHostAction.prototype.okCallback = function() {
    var D = [];
    for (initNick in this.initiatorNames) {
        D.push(this.initiatorNames[initNick])
    }
    var C = {
        initiators: D,
        hostName: this.hostName
    };
    if (DC.hosts[this.hostName]) {
        MC.addHostMembers(C, {
            dialog: true,
            processingMsg: strings.addToHost.processing,
            failureMsg: strings.addToHost.failure,
            successMsg: ((this.multiple) ? strings.addToHost.successPlural : strings.addToHost.successSingular),
            closeActionOn: "success"
        })
    } else {
        MC.createHost(C, {
            dialog: true,
            processingMsg: strings.addToHost.processing,
            failureMsg: strings.addToHost.failure,
            successMsg: ((this.multiple) ? strings.addToHost.successPlural : strings.addToHost.successSingular),
            closeActionOn: "success"
        })
    }
};

function RemoveFromHostAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveFromHostAction";
    this.initiatorNames = {};
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "removeFromHostForm",
        widgets: [new TextWidget({
            name: "actionDescription",
            text: strings.removeFromHost.actionDescription,
            topMargin: true
        }), new TextWidget({
            classes: "scrollText100",
            name: "initiatorNames",
            label: strings.removeFromHost.initatorNamesLabel,
            width: 250,
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveFromHostAction";
    this.hostList = {}
}
RemoveFromHostAction.prototype = new ActionPanel();
RemoveFromHostAction.prototype.constructor = RemoveFromHostAction;
RemoveFromHostAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var F;
    var C;
    var H;
    var D = {};
    var G;
    var E = TopicPanel.getSelected(["initiator"], HostConstants.MAX_INITIATORS);
    if (!E) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_INITIATORS, strings.initiators)
    }
    for (G = 0; G < E.length; G++) {
        F = DC.initiatorsId[E[G].key];
        H = F.get("host_id");
        C = F.get("nickname");
        if (H == "NOHOST") {
            return strings.menuTips.initiatorNotGrouped
        } else {
            if (!D[H]) {
                D[H] = 0
            }
            D[H]++
        }
    }
    for (H in D) {
        if (DC.hostsSerial[H].get("member_count") - D[H] < 1) {
            return strings.menuTips.only1InitLeftInHost
        }
    }
    return E
};
RemoveFromHostAction.prototype.showing = function() {
    var E;
    var G;
    var D;
    var C = [];
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    this.hostList = {};
    for (var F = 0; F < this.selected.length; F++) {
        E = DC.initiatorsId[this.selected[F].key];
        hId = E.get("host_id");
        iNick = E.get("nickname");
        C.push(iNick);
        if (!this.hostList[hId]) {
            this.hostList[hId] = [iNick]
        } else {
            this.hostList[hId].push(iNick)
        }
    }
    this.update({
        initiatorNames: {
            text: MC.getItemList(C, true)
        }
    });
    this.resetSize({
        shrink: true
    });
    this.okEnabled(true)
};
RemoveFromHostAction.prototype.okCallback = function() {
    var D = 0;
    var C = [];
    for (var E in this.hostList) {
        var F = DC.hostsSerial[E].get("name");
        C.push({
            name: "removeFromHost",
            command: MC.removeHostMembers,
            data: {
                initiators: this.hostList[E],
                hostName: F
            },
            options: {
                processingMsg: strings.removeFromHost.processing(F),
                failureMsg: strings.removeFromHost.failure(F)
            }
        })
    }
    MC.execCommandList(C, {
        closeActionOn: "success",
        successMsg: (this.multiple) ? strings.removeFromHost.successPlural : strings.removeFromHost.successSingular
    })
};

function RemoveHostAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveHostAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new WidgetContainer({
        name: "rhWC",
        widgets: [new TextWidget({
            name: "rhActionDescription",
            text: strings.removeHost.actionDescription,
            topMargin: true
        }), new TextWidget({
            classes: "scrollText100",
            name: "rhHostNames",
            label: strings.removeHost.hostNamesLabel,
            width: 260,
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveHostAction";
    this.multiple = null;
    this.selected = []
}
RemoveHostAction.prototype = new ActionPanel();
RemoveHostAction.prototype.constructor = RemoveHostAction;
RemoveHostAction.getMenuState = function() {
    var D;
    var E;
    var C;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    C = APIInitiator.selectedHosts(TopicPanel.selection, true, HostConstants.MAX_HOSTS);
    if ((!C) || ((C.length == 1) && (DC.hostsId[C[0].key].get("name") == strings.hostNotGrouped))) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_HOSTS, strings.hosts)
    }
    for (var E = 0; E < C.length; E++) {
        D = DC.hostsId[C[E].key];
        if (D.get("host_group") != "UNGROUPEDHOSTS") {
            return strings.menuTips.hostGrouped
        }
    }
    return C
};
RemoveHostAction.prototype.showing = function() {
    var E;
    var C;
    var D;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    this.hostNames = [];
    for (E = 0; E < this.selected.length; E++) {
        C = DC.hostsId[this.selected[E].key];
        D = C.get("name");
        if (D != strings.hostNotGrouped) {
            this.hostNames.push(D)
        }
    }
    this.update({
        rhHostNames: {
            text: MC.getItemList(this.hostNames, true)
        }
    });
    this.okEnabled(true)
};
RemoveHostAction.prototype.okCallback = function() {
    var C = {
        list: this.hostNames
    };
    MC.deleteHost(C, {
        dialog: true,
        processingMsg: strings.removeHost.processing,
        confirmMsg: strings.removeHost.confrimMsg(((this.multiple) ? strings.hosts : strings.host)),
        failureMsg: strings.removeHost.failure,
        successMsg: ((this.multiple) ? strings.removeHost.successPlural : strings.removeHost.successSingular),
        closeActionOn: "success"
    })
};

function RenameHostAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RenameHostAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "renameHostForm",
        tableLayout: true,
        widgets: [new TextWidget({
            row: 0,
            col: 0,
            name: "actionDescription",
            text: strings.renameHost.actionDescription,
            topMargin: true
        }), new TextWidget({
            row: 1,
            col: 1,
            name: "oldName",
            label: strings.renameHost.oldNameLabel,
            topMargin: true
        }), new TextInputWidget({
            row: 2,
            col: 1,
            name: "newName",
            rules: {
                required: true,
                utf8length: 32,
                dhHostName: true,
                hostExists: true
            },
            label: strings.renameHost.newNameLabel,
            changeCallback: createObjectCallback(this, this.changedCallback),
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RenameHostAction";
    this.oldName = null;
    this.newName = null
}
RenameHostAction.prototype = new ActionPanel();
RenameHostAction.prototype.constructor = RenameHostAction;
RenameHostAction.getMenuState = function() {
    var D;
    var E;
    var C;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    C = APIInitiator.selectedHosts(TopicPanel.selection, true, 1);
    if (!C) {
        return strings.menuTips.selectSingle(strings.host)
    }
    return C
};
RenameHostAction.prototype.showing = function() {
    var C = this.previousSelection;
    var D = C[0].getObject();
    if (D) {
        this.oldName = D.get("name")
    }
    this.update({
        oldName: {
            text: this.oldName
        }
    });
    this.okEnabled(false)
};
RenameHostAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.newName = F.newName.value;
    this.retrieve(C);
    if (!C.renameHostForm) {
        return
    }(C.renameHostForm.valid) ? this.okEnabled(true): this.okEnabled(false);
    this.resetSize({
        shrink: true
    })
};
RenameHostAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.renameHostForm.valid) {
        var D = {
            nickname: this.oldName,
            newName: this.newName
        };
        MC.setHost(D, {
            dialog: true,
            processingMsg: strings.renameHost.processing,
            failureMsg: strings.renameHost.failure,
            successMsg: strings.renameHost.success,
            closeActionOn: "success"
        })
    } else {
        this.okEnabled(false)
    }
};

function AddToHostGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AddToHostGroupAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "addToHostGroupForm",
        classes: "heightHostComboBox",
        widgets: [new TextWidget({
            name: "actionDescription",
            text: strings.addToHostGroup.actionDescription
        }), new TextWidget({
            name: "hostNames",
            classes: "scrollText100",
            label: strings.addToHostGroup.hostNamesLabel,
            width: 240,
            topMargin: true
        }), new ComboBoxWidget({
            name: "hostGroupList",
            label: strings.addToHostGroup.hostGroupListLabel,
            topMargin: true,
            allowInput: true,
            rules: {
                required: true,
                utf8length: 32,
                dhHostName: true
            },
            values: this._generateComboBoxHostGroupList(),
            changeCallback: createObjectCallback(this, this.changedCallback)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "AddToHostGroupAction";
    this.selected = null;
    this.multiple = true;
    this.hostNames = [];
    this.hostGroupName = null
}
AddToHostGroupAction.prototype = new ActionPanel();
AddToHostGroupAction.prototype.constructor = AddToHostGroupAction;
AddToHostGroupAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D;
    var E;
    var C = APIInitiator.selectedHosts(TopicPanel.selection, true, HostConstants.MAX_HOSTS_PER_GROUP);
    if (!C) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_HOSTS_PER_GROUP, strings.hosts)
    }
    for (E = 0; E < C.length; E++) {
        D = C[E].getObject();
        if (D) {
            if (D.get("host_group") != "UNGROUPEDHOSTS") {
                return strings.menuTips.hostAlreadyGrouped
            }
        }
    }
    return C
};
AddToHostGroupAction.prototype.showing = function() {
    var D;
    var C;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    this.hostNames = [];
    for (D = 0; D < this.selected.length; D++) {
        C = DC.hostsId[this.selected[D].key];
        C = this.selected[D].getObject();
        this.hostNames.push(C.get("name"))
    }
    this.update({
        hostNames: {
            text: MC.getItemList(this.hostNames, true)
        }
    });
    this.okEnabled(false)
};
AddToHostGroupAction.prototype._generateComboBoxHostGroupList = function() {
    var C;
    var E = DC.hostGroups;
    var D = "bogus";
    this.hostList = [];
    for (C in E) {
        D = E[C].get("name");
        if (D != strings.hostUnGrouped) {
            this.hostList.push({
                value: D,
                text: D
            })
        }
    }
    return this.hostList
};
AddToHostGroupAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.hostGroupName = F.hostGroupList.value;
    this.retrieve(C);
    if (!C.addToHostGroupForm) {
        return
    }(C.addToHostGroupForm.valid) ? this.okEnabled(true): this.okEnabled(false);
    this.resetSize({
        shrink: true
    })
};
AddToHostGroupAction.prototype.okCallback = function() {
    var C = {
        hosts: this.hostNames,
        hostGroupName: this.hostGroupName
    };
    if (DC.hostGroups[this.hostGroupName]) {
        MC.addHostGroupMembers(C, {
            dialog: true,
            processingMsg: strings.addToHostGroup.processing,
            failureMsg: strings.addToHostGroup.failure,
            successMsg: ((this.multiple) ? strings.addToHostGroup.successPlural : strings.addToHostGroup.successSingular),
            closeActionOn: "success"
        })
    } else {
        MC.createHostGroup(C, {
            dialog: true,
            processingMsg: strings.addToHostGroup.processing,
            failureMsg: strings.addToHostGroup.failure,
            successMsg: ((this.multiple) ? strings.addToHostGroup.successPlural : strings.addToHostGroup.successSingular),
            closeActionOn: "success"
        })
    }
};

function RemoveFromHostGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveFromHostGroupAction";
    C.width = 350;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "removeFromHostGroupForm",
        widgets: [new TextWidget({
            name: "actionDescription",
            text: strings.removeFromHostGroup.actionDescription
        }), new TextWidget({
            name: "hostNames",
            classes: "scrollText100",
            label: strings.removeFromHostGroup.hostNamesLabel,
            width: 240,
            topMargin: true
        }), new TextWidget({
            name: "warningText",
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveFromHostGroupAction";
    this.selected = null;
    this.multiple = true;
    this.hostNames = [];
    this.hostGroupNames = [];
    this.hostGroupList = {}
}
RemoveFromHostGroupAction.prototype = new ActionPanel();
RemoveFromHostGroupAction.prototype.constructor = RemoveFromHostGroupAction;
RemoveFromHostGroupAction.getMenuState = function() {
    var H;
    var E;
    var I;
    var G;
    var F = {};
    var C;
    var D = APIInitiator.selectedHosts(TopicPanel.selection, true, HostConstants.MAX_HOSTS_PER_GROUP);
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!D) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_HOSTS_PER_GROUP, strings.hosts)
    }
    for (H = 0; H < D.length; H++) {
        E = D[H].getObject();
        if (E) {
            if (E.get("host_group") == "UNGROUPEDHOSTS") {
                return strings.menuTips.hostsNotGrouped
            } else {
                G = E.get("host_group");
                I = E.get("serial_number");
                if (!F[G]) {
                    F[G] = 0
                }
                F[G]++
            }
        }
    }
    for (G in F) {
        C = parseInt(DC.hostGroupsSerial[G].get("member_count"), 10);
        if (C - F[G] < 1) {
            return strings.menuTips.only1HostLeftInGroup
        }
    }
    return D
};
RemoveFromHostGroupAction.prototype.showing = function() {
    var H;
    var G;
    var J;
    var F;
    var I;
    var E;
    var D = [];
    var C;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    for (H = 0; H < this.selected.length; H++) {
        G = this.selected[H].getObject();
        J = G.get("name");
        F = G.get("host_group");
        I = DC.hostGroupsSerial[F].get("name");
        C = (typeof C != "undefined") ? (C + ", " + I) : I;
        this.hostNames.push(J);
        if (!this.hostGroupList[I]) {
            this.hostGroupList[I] = []
        }
        this.hostGroupList[I].push(J)
    }
    this.update({
        hostNames: {
            text: MC.getItemList(this.hostNames, true)
        },
        warningText: {
            text: strings.removeFromHostGroup.panelWarning(((this.multiple) ? strings.hosts : strings.host), C)
        }
    });
    this.okEnabled(true)
};
RemoveFromHostGroupAction.prototype.okCallback = function() {
    var E = 0;
    var D = [];
    for (var C in this.hostGroupList) {
        D.push({
            name: "removeFromGroupHost",
            command: MC.removeHostGroupMembers,
            data: {
                hosts: this.hostGroupList[C],
                hostGroupName: C
            },
            options: {
                successMsg: (this.multiple) ? strings.removeFromHostGroup.successPlural : strings.removeFromHostGroup.successSingular
            }
        })
    }
    MC.execCommandList(D, {
        closeActionOn: "success",
        successMsg: (this.multiple) ? strings.removeFromHostGroup.successPlural : strings.removeFromHostGroup.successSingular
    })
};

function RemoveHostGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveHostGroupAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "rhGWC",
        widgets: [new TextWidget({
            name: "rhGActionDescription",
            text: strings.removeHostGroup.actionDescription,
            topMargin: true
        }), new TextWidget({
            classes: "scrollText100",
            name: "rhGHostGroupNames",
            label: strings.removeHostGroup.hostGroupNamesLabel,
            width: 230,
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveHostGroupAction";
    this.multiple = null;
    this.selected = []
}
RemoveHostGroupAction.prototype = new ActionPanel();
RemoveHostGroupAction.prototype.constructor = RemoveHostGroupAction;
RemoveHostGroupAction.getMenuState = function() {
    var D;
    var E;
    var C;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    C = APIInitiator.selectedHostGroups(TopicPanel.selection, true, HostConstants.MAX_HOST_GROUPS);
    if (!C) {
        return strings.menuTips.selectRange(1, HostConstants.MAX_HOST_GROUPS, strings.hostGroups)
    }
    return C
};
RemoveHostGroupAction.prototype.showing = function() {
    var D;
    var C;
    var E;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    this.hostGroupNames = [];
    for (D = 0; D < this.selected.length; D++) {
        C = DC.hostGroupsId[this.selected[D].key];
        E = C.get("name");
        this.hostGroupNames.push(E)
    }
    this.update({
        rhGHostGroupNames: {
            text: MC.getItemList(this.hostGroupNames, true)
        }
    });
    this.okEnabled(true)
};
RemoveHostGroupAction.prototype.okCallback = function() {
    var C = {
        groupList: this.hostGroupNames
    };
    MC.deleteHostGroups(C, {
        dialog: true,
        confirmMsg: strings.removeHostGroup.confirmMsg,
        processingMsg: strings.removeHostGroup.processing,
        failureMsg: strings.removeHostGroup.failure,
        successMsg: ((this.multiple) ? strings.removeHostGroup.successPlural : strings.removeHostGroup.successSingular),
        closeActionOn: "success"
    })
};

function RenameHostGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RenameHostGroupAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "renameHostGroupForm",
        tableLayout: true,
        widgets: [new TextWidget({
            row: 0,
            col: 0,
            name: "actionDescription",
            text: strings.renameHostGroup.actionDescription,
            topMargin: true
        }), new TextWidget({
            row: 1,
            col: 1,
            name: "oldName",
            label: strings.renameHostGroup.oldNameLabel,
            topMargin: true
        }), new TextInputWidget({
            row: 2,
            col: 1,
            name: "newName",
            rules: {
                required: true,
                utf8length: 32,
                dhHostName: true,
                hostGroupExists: true
            },
            label: strings.renameHostGroup.newNameLabel,
            labelOptions: {
                rightMargin: true
            },
            changeCallback: createObjectCallback(this, this.changedCallback),
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RenameHostGroupAction";
    this.selected = [];
    this.oldName = null;
    this.newName = null
}
RenameHostGroupAction.prototype = new ActionPanel();
RenameHostGroupAction.prototype.constructor = RenameHostGroupAction;
RenameHostGroupAction.getMenuState = function() {
    var D;
    var E;
    var C;
    var F;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = APIInitiator.selectedHostGroups(TopicPanel.selection, true, 1);
    if (!C) {
        return strings.menuTips.selectSingle(strings.hostGroup)
    }
    return C
};
RenameHostGroupAction.prototype.showing = function() {
    this.selected = this.previousSelection;
    var C = this.selected[0].getObject();
    if (C) {
        this.oldName = C.get("name")
    }
    this.update({
        oldName: {
            text: this.oldName
        }
    });
    this.okEnabled(false)
};
RenameHostGroupAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.newName = F.newName.value;
    this.retrieve(C);
    if (!C.renameHostGroupForm) {
        return
    }(C.renameHostGroupForm.valid) ? this.okEnabled(true): this.okEnabled(false);
    this.resetSize({
        shrink: true
    })
};
RenameHostGroupAction.prototype.okCallback = function() {
    var C = {
        name: this.oldName,
        newName: this.newName
    };
    MC.setHostGroup(C, {
        dialog: true,
        processingMsg: strings.renameHostGroup.processing,
        failureMsg: strings.renameHostGroup.failure,
        successMsg: strings.renameHostGroup.success,
        closeActionOn: "success"
    })
};

function CreateInitAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "CreateInitAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    this.changedWidgets = {};
    var C = [new TextWidget({
        name: "ciaInfo",
        row: 0,
        col: 0,
        colSpan: 2,
        text: strings.createInit.infoText,
        bottomMargin: true
    }), new TextInputWidget({
        name: "ciaId",
        row: 1,
        col: 1,
        size: 30,
        label: strings.createInit.idLabel,
        labelOptions: {
            rightMargin: true
        },
        bottomMargin: true,
        rules: {
            required: true,
            wwn_iqn: true
        },
        changeCallback: createObjectCallback(this, this.changedCallback)
    }), new TextInputWidget({
        name: "ciaNick",
        row: 2,
        col: 1,
        labelOptions: {
            rightMargin: true
        },
        label: strings.createInit.nickLabel,
        rules: {
            required: true,
            utf8length: 32,
            initNicknameExists: true,
            dhHostName: true
        },
        changeCallback: createObjectCallback(this, this.changedCallback)
    })];
    if (system.profilesEnabled) {
        C.push(new OptionInputWidget({
            name: "ciaProfile",
            row: 3,
            col: 1,
            label: strings.createInit.profileLabel,
            labelOptions: {
                rightMargin: true,
                topMargin: true
            },
            bottomMargin: true,
            topMargin: true,
            values: [{
                value: HOST_PROFILES.STANDARD,
                text: strings.createInit.standard
            }, {
                value: HOST_PROFILES.HPUX,
                text: strings.createInit.hpux
            }, {
                value: HOST_PROFILES.OPENVMS,
                text: strings.createInit.openVMS
            }]
        }))
    }
    D.widgets = [this.ciaForm = new FormWidget({
        name: "ciaForm",
        tableLayout: true,
        widgets: C
    })];
    ActionPanel.call(this, D);
    this.class_name = "CreateInitAction"
}
CreateInitAction.prototype = new ActionPanel();
CreateInitAction.prototype.constructor = CreateInitAction;
CreateInitAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
CreateInitAction.prototype.showing = function() {
    var C = {};
    C.ciaId = {
        focus: true
    };
    C.ciaNick = {
        setOrig: true
    };
    C.ciaProfile = {
        setOrig: true
    };
    C.ciaForm = {
        resetValidation: true
    };
    this.update(C)
};
CreateInitAction.prototype.changedCallback = function(E, C, D) {
    this.resetSize({
        shrink: true
    });
    this.okEnabled(this.ciaForm.valid)
};
CreateInitAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var F = C.ciaId.value;
    var D = C.ciaNick.value;
    var E = {
        id: F,
        nickname: D
    };
    if (system.profilesEnabled) {
        switch (parseInt(C.ciaProfile.value)) {
            case HOST_PROFILES.STANDARD:
                E.profile = "standard";
                break;
            case HOST_PROFILES.HPUX:
                E.profile = "hp-ux";
                break;
            case HOST_PROFILES.OPENVMS:
                E.profile = "openvms";
                break;
            default:
                break
        }
    }
    MC.setInitiator(E, {
        dialog: true,
        processingMsg: strings.createInit.processingMsg(D),
        successMsg: strings.createInit.successMsg(D),
        failureMsg: strings.createInit.failureMsg(D),
        closeActionOn: "success"
    })
};

function ModifyInitAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ModifyInitAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    this.changedWidgets = {};
    var C = [new TextWidget({
        name: "miaInfo",
        row: 0,
        col: 0,
        colSpan: 2,
        text: strings.modifyInit.infoText,
        bottomMargin: true
    }), new TextWidget({
        text: "",
        name: "miaId",
        row: 1,
        col: 1,
        size: 30,
        label: strings.modifyInit.idLabel,
        labelOptions: {
            rightMargin: true
        },
        bottomMargin: true
    }), new TextInputWidget({
        name: "miaNick",
        row: 2,
        col: 1,
        labelOptions: {
            rightMargin: true
        },
        label: strings.modifyInit.nickLabel,
        rules: {
            required: true,
            utf8length: 32,
            dhHostName: true
        },
        changeCallback: createObjectCallback(this, this.changedCallback)
    })];
    if (system.profilesEnabled) {
        C.push(new OptionInputWidget({
            name: "miaProfile",
            row: 3,
            col: 1,
            label: strings.createInit.profileLabel,
            labelOptions: {
                rightMargin: true,
                topMargin: true
            },
            bottomMargin: true,
            topMargin: true,
            values: [{
                value: HOST_PROFILES.STANDARD,
                text: strings.createInit.standard
            }, {
                value: HOST_PROFILES.HPUX,
                text: strings.createInit.hpux
            }, {
                value: HOST_PROFILES.OPENVMS,
                text: strings.createInit.openVMS
            }],
            changeCallback: createObjectCallback(this, this.changedCallback)
        }))
    }
    D.widgets = [new FormWidget({
        name: "miaForm",
        tableLayout: true,
        widgets: C
    })];
    ActionPanel.call(this, D);
    this.class_name = "ModifyInitAction"
}
ModifyInitAction.prototype = new ActionPanel();
ModifyInitAction.prototype.constructor = ModifyInitAction;
ModifyInitAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        var C = TopicPanel.getSelected(["initiator"], 1);
        if (C) {
            return C
        } else {
            return strings.menuTips.selectSingle(strings.initiator)
        }
    }
};
ModifyInitAction.prototype.showing = function() {
    var E = this.previousSelection[0];
    var D = {};
    var C = E.getObject();
    if (C) {
        this.initId = C.get("id");
        this.origNick = C.get("nickname");
        D.miaId = {
            text: this.initId
        };
        D.miaNick = {
            focus: true,
            value: this.origNick,
            setOrig: true
        };
        D.miaProfile = {
            value: C.getInt("profile_numeric"),
            setOrig: true
        };
        D.miaForm = {
            resetValidation: true
        };
        this.update(D)
    }
};
ModifyInitAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (F[D.name].valueChanged) {
        if (!this.changedWidgets[D.name]) {
            this.changed = true;
            this.changedWidgets[D.name] = true
        }
    } else {
        if (this.changedWidgets[D.name]) {
            delete this.changedWidgets[D.name];
            this.changed = false;
            for (var D in this.changedWidgets) {
                this.changed = true;
                break
            }
        }
    }
    if (C.miaForm.valid) {
        if (this.changed) {
            this.okEnabled(true)
        } else {
            this.okEnabled(false)
        }
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
ModifyInitAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var D = {
        id: this.initId
    };
    if (C.miaNick.valueChanged) {
        D.nickname = C.miaNick.value
    }
    if (C.miaProfile.valueChanged) {
        switch (parseInt(C.miaProfile.value)) {
            case HOST_PROFILES.STANDARD:
                D.profile = "standard";
                break;
            case HOST_PROFILES.HPUX:
                D.profile = "hp-ux";
                break;
            case HOST_PROFILES.OPENVMS:
                D.profile = "openvms";
                break;
            default:
                break
        }
    }
    MC.setInitiator(D, {
        dialog: true,
        processingMsg: strings.modifyInit.processingMsg(this.origNick),
        successMsg: strings.modifyInit.successMsg(this.origNick),
        failureMsg: strings.modifyInit.failureMsg(this.origNick),
        closeActionOn: "success"
    })
};

function DeleteInitAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DeleteInitAction";
    this.nicks = [];
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new WidgetContainer({
        name: "diaWC",
        widgets: [new TextWidget({
            name: "diaInitsToDelete",
            label: strings.Initiators,
            classes: "scrollText100",
            bottomMargin: true
        }), new TextWidget({
            name: "diaConfirmation",
            text: strings.deleteInit.warningText
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteInitAction"
}
DeleteInitAction.prototype = new ActionPanel();
DeleteInitAction.prototype.constructor = DeleteInitAction;
DeleteInitAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var E = TopicPanel.getSelected(["initiator"], 1024);
    if (E) {
        if (E.length > 100) {
            return strings.menuTips.selectRange(1, 100, strings.initiators)
        }
        for (var D = 0; D < E.length; D++) {
            var C = E[D].getObject();
            if (C) {
                if (decodeBooleanFlag(C.get("mapped"))) {
                    return strings.menuTips.unDiscoveredButMapped
                }
                if (C.get("host_id") != "NOHOST") {
                    return strings.menuTips.initiatorGrouped
                }
            } else {
                return strings.menuTips.selectRange(1, 100, strings.initiators)
            }
        }
        return E
    } else {
        return strings.menuTips.selectNum(1, strings.initiator)
    }
};
DeleteInitAction.prototype.showing = function() {
    var E = {};
    var G = this.previousSelection;
    for (var F = 0; F < G.length; F++) {
        var D = G[F].getObject();
        if (D) {
            var C = D.get("nickname");
            var H = D.get("id");
            if (decodeBooleanFlag(D.get("discovered"))) {
                this.discovered = true
            }
            if (C == "") {
                this.nicks.push(H)
            } else {
                this.nicks.push(C)
            }
        }
    }
    E.diaInitsToDelete = {
        text: MC.getItemList(this.nicks, true)
    };
    this.update(E);
    this.okEnabled(true)
};
DeleteInitAction.prototype.okCallback = function() {
    var C = [];
    for (var D = 0; D < this.nicks.length; D++) {
        C.push({
            name: "delete" + D,
            command: MC.deleteInitiatorNickname,
            data: {
                target: this.nicks[D]
            },
            options: {
                confirmMsg: this.discovered ? strings.deleteInit.confirmMsg : "",
                processingMsg: strings.deleteInit.processingMsg(this.nicks[D]),
                failureMsg: strings.deleteInit.itemFailureMsg(this.nicks[D])
            }
        })
    }
    MC.execCommandList(C, {
        successMsg: strings.deleteInit.successMsg,
        failureMsg: strings.deleteInit.failureMsg,
        closeActionOn: "success"
    })
};

function ConfigureChapAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ConfigureChapAction";
    D.applyCallback = createObjectCallback(this, this.applyCallback);
    D.okCallback = createObjectCallback(this, this.okCallback);
    this.tiw = new Array();
    this.tiw.hostName = {
        rules: {
            required: true,
            utf8length: 223
        },
        value: "",
        addRules: false,
        removeRules: false,
        validateEnabled: false
    };
    this.tiw.hostSecret = {
        rules: {
            required: true,
            chapSecret: true
        },
        value: "",
        addRules: false,
        removeRules: false,
        validateEnabled: false
    };
    this.tiw.mutualName = {
        rules: {
            required: true,
            utf8length: 223,
            chapName: true
        },
        value: "",
        addRules: false,
        removeRules: false,
        validateEnabled: false
    };
    this.tiw.mutualSecret = {
        rules: {
            required: true,
            chapSecret: true
        },
        value: "",
        addRules: false,
        removeRules: false,
        validateEnabled: false
    };
    var C = createObjectCallback(this, this.changedCallback);
    D.widgets = [this.form = new FormWidget({
        name: "configureChapForm",
        widgets: [new TextWidget({
            name: "actionDescription",
            text: strings.configureChap.panelText.actionDescription
        }), new CheckboxInputWidget({
            topMargin: true,
            name: "iscsi_chap",
            label: strings.portconfig.iscsiChapLabel,
            labelOptions: {
                row: 1,
                col: 0,
                bottomMargin: true
            },
            changeCallback: createObjectCallback(this, this.changeChapAuthentication)
        }), new TableInator({
            name: "chapRecordTable",
            selectable: "single",
            type: "apiData",
            metadata: "chap-records",
            fields: ["initiator_name", "initiator_secret", "oname", "osecret"],
            columnOverrides: {
                initiator_name: {
                    sTitle: strings.modifyInit.nickLabel
                },
                initiator_secret: {
                    sTitle: strings.configureChap.panelText.iniatiatorSecret
                },
                oname: {
                    sTitle: strings.configureChap.panelText.mutualNameLabel
                },
                osecret: {
                    sTitle: strings.configureChap.panelText.mutualSecretLabel
                }
            },
            dtOptions: {
                bLengthChange: false
            },
            topMargin: true,
            selectCallback: createObjectCallback(this, this.selectChanged)
        }), new WidgetContainer({
            topMargin: true,
            name: "WTFITN",
            widgets: [new ButtonContainer({
                name: "configureChapActionButtons",
                orientation: "horizontal",
                topMargin: true,
                widgets: [new ButtonWidget({
                    name: "buttonNew",
                    size: "small",
                    text: strings.configureChap.panelText.newLabel,
                    tip: strings.configureChap.panelText.tips.buttonNew,
                    click: createObjectCallback(this, this.newClicked)
                }), new ButtonWidget({
                    name: "buttonDelete",
                    size: "small",
                    text: strings.configureChap.panelText.deleteLabel,
                    tip: strings.configureChap.panelText.tips.buttonDelete,
                    click: createObjectCallback(this, this.deleteClicked)
                })]
            })]
        }), new TableWidget({
            topMargin: true,
            name: "userInputs",
            widgets: [this.tiw.hostName.widget = new TextInputWidget({
                name: "hostName",
                size: 60,
                maxLength: 224,
                row: 0,
                col: 1,
                messages: {
                    required: strings.configureChap.validation.hostNameError,
                    chapExists: strings.configureChap.validation.chapAlreadyExists
                },
                label: strings.configureChap.panelText.hostNameLabel,
                topMargin: true,
                changeCallback: C
            }), this.tiw.hostSecret.widget = new TextInputWidget({
                name: "hostSecret",
                size: 16,
                label: strings.configureChap.panelText.hostSecretLabel,
                topMargin: true,
                bottomMargin: true,
                row: 1,
                col: 1,
                messages: {
                    required: strings.configureChap.validation.noEmptySecret
                },
                changeCallback: C
            }), this.mutualContainer = new CheckboxContainer({
                name: "mutualContainer",
                row: 2,
                col: 0,
                colSpan: 2,
                value: false,
                label: strings.configureChap.panelText.mutualCheckBoxLabel,
                changeCallback: createObjectCallback(this, this.toggleMutual),
                topMargin: true,
                widgets: [this.tiw.mutualName.widget = new TextInputWidget({
                    name: "mutualName",
                    size: 60,
                    maxLength: 224,
                    messages: {
                        required: strings.configureChap.validation.mutualNameError
                    },
                    label: strings.configureChap.panelText.mutualNameLabel,
                    topMargin: true,
                    changeCallback: C
                }), this.tiw.mutualSecret.widget = new TextInputWidget({
                    name: "mutualSecret",
                    size: 16,
                    label: strings.configureChap.panelText.mutualSecretLabel,
                    topMargin: true,
                    changeCallback: C
                })]
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "ConfigureChapAction"
}
ConfigureChapAction.prototype = new ActionPanel();
ConfigureChapAction.prototype.constructor = ConfigureChapAction;
ConfigureChapAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!(APIPort.hasPortType("iSCSI") && !(APIPort.hasPortType("IB")))) {
        return false
    }
    return []
};
ConfigureChapAction.prototype.changeChapAuthentication = function(D, C, E) {
    if (D == undefined) {
        var D = {};
        this.retrieve(D)
    }
    MC.setIscsiParameters(D, {
        dialog: true,
        confirmMsg: strings.systemports.confirmIscsiMsg,
        okLabel: strings.okButtonText,
        cancelLabel: strings.cancelButtonText,
        cancel: createObjectCallback(this, this.cancelChapChange),
        processingMsg: strings.portconfig.processingIscsiMsg,
        failureMsg: strings.portconfig.failureIscsiMsg,
        successMsg: strings.portconfig.successIscsiMsg
    })
};
ConfigureChapAction.prototype.cancelChapChange = function() {
    var C = {};
    this.retrieve(C);
    this.update({
        iscsi_chap: {
            value: !C.iscsi_chap.value
        }
    })
};
ConfigureChapAction.prototype.showing = function() {
    this.formValid = true;
    this._enterUnselectedState();
    this.chapSubscription = MC.chapRecordsSet.requestData({
        update: false,
        durable: true,
        requestor: "ConfigureChapAction",
        handler: createObjectCallback(this, this.updateTableData)
    });
    this.okEnabled(false)
};
ConfigureChapAction.prototype.updateTableData = function(C) {
    this.update({
        chapRecordTable: {
            data: C.data.objects
        }
    });
    this.resetSize({
        shrink: true
    })
};
ConfigureChapAction.prototype._updateData = function(F) {
    var C = {};
    this.retrieve(C, true);
    var D = {
        hostName: {
            disable: (this.state != "new"),
            skipValidation: this.tiw.hostName.value == "" && !this.tiw.hostName.validateEnabled ? true : false
        },
        hostSecret: {
            disable: (this.state == "unselected"),
            skipValidation: this.tiw.hostSecret.value == "" && !this.tiw.hostSecret.validateEnabled ? true : false
        },
        mutualName: {
            disable: ((this.state == "unselected") || !this.mutualSelected),
            skipValidation: this.tiw.mutualName.value == "" && !this.tiw.mutualName.validateEnabled ? true : false
        },
        mutualSecret: {
            disable: ((this.state == "unselected") || !this.mutualSelected),
            skipValidation: this.tiw.mutualSecret.value == "" && !this.tiw.mutualSecret.validateEnabled ? true : false
        },
        mutualContainer: {
            value: this.mutualSelected,
            disable: (this.state == "unselected")
        },
        buttonDelete: {
            disable: (this.state != "selected")
        }
    };
    var G = false;
    for (var E in this.tiw) {
        if (E == "hostName" || E == "hostSecret" || E == "mutualName" || E == "mutualSecret") {
            if (C[E].value != this.tiw[E].value || F) {
                D[E].value = this.tiw[E].value;
                if (F) {
                    D[E].setOrig = true
                }
            }
            if (this.tiw[E].addRules) {
                D[E].rules = this.tiw[E].rules;
                G = true;
                this.tiw[E].addRules = false
            }
            if (this.tiw[E].removeRules) {
                D[E].rules = {};
                this.tiw[E].removeRules = false
            }
        }
    }
    if (DC.iscsiParams) {
        D.iscsi_chap = {
            value: (decodeBooleanFlag(DC.iscsiParams.get("chap_numeric")) ? true : false),
            setOrig: ((F) ? true : null)
        }
    }
    if (G) {
        D.configureChapForm = {
            resetValidation: true
        }
    }
    this.update(D);
    this.formValid = this.form.valid;
    this._setOKEnabled();
    this.resetSize({
        shrink: true
    })
};
ConfigureChapAction.prototype.changedCallback = function(E, C, D) {
    if (!D) {
        return
    }
    if (D.type == "focusout" || !C.invalid) {
        this.tiw[C.name].validateEnabled = true
    }
    this.tiw[C.name].value = E[C.name].value;
    this._updateData(false)
};
ConfigureChapAction.prototype.toggleMutual = function(F, C, D) {
    this.mutualSelected = F.mutualContainer.value;
    if (this.mutualSelected) {
        this.tiw.mutualName.addRules = true;
        this.tiw.mutualSecret.addRules = true;
        if (this.state == "selected") {
            var E = this.currentSelected[0].getObject();
            if (E.get("oname") != "") {
                this.tiw.mutualName.value = E.get("oname");
                this.tiw.mutualSecret.value = E.get("osecret");
                this.tiw.mutualName.validateEnabled = true;
                this.tiw.mutualSecret.validateEnabled = true;
                this._updateData(false)
            }
        } else {
            this.tiw.mutualName.value = "";
            this.tiw.mutualSecret.value = ""
        }
    } else {
        this.tiw.mutualName.value = "";
        this.tiw.mutualSecret.value = "";
        this.tiw.mutualName.removeRules = true;
        this.tiw.mutualSecret.removeRules = true
    }
    this._updateData(false)
};
ConfigureChapAction.prototype.selectChanged = function(C) {
    this.newSelected = C;
    if (this._isDirty()) {
        ShowActiveDialog({
            type: "confirm",
            message: strings.userManagement.panelText.navigateAway,
            okLabel: strings.Yes,
            cancelLabel: strings.No,
            ok: createObjectCallback(this, this._enterSelectedState),
            cancel: createObjectCallback(this, this._selectRevert)
        })
    } else {
        this._enterSelectedState()
    }
};
ConfigureChapAction.prototype._selectRevert = function(E, C, D) {
    this.update({
        chapRecordTable: {
            select: new DCRef("chap-records", this.tiw.hostName.value)
        }
    })
};
ConfigureChapAction.prototype._setOKEnabled = function() {
    if (((this.state == "new") && (!this.tiw.hostName.validateEnabled)) || !this.tiw.hostSecret.validateEnabled || (this.mutualSelected && (!this.tiw.mutualName.validateEnabled || !this.tiw.mutualSecret.validateEnabled)) || !this._isDirty() || !this.formValid) {
        this.okEnabled(false);
        this.applyEnabled(false)
    } else {
        this.okEnabled(true);
        this.applyEnabled(true)
    }
};
ConfigureChapAction.prototype.newClicked = function() {
    if (this._isDirty()) {
        ShowActiveDialog({
            type: "confirm",
            message: strings.userManagement.panelText.navigateAway,
            okLabel: strings.Yes,
            cancelLabel: strings.No,
            ok: createObjectCallback(this, this._enterNewState)
        })
    } else {
        this._enterNewState()
    }
};
ConfigureChapAction.prototype._enterSelectedState = function() {
    if (this.newSelected.length == 0) {
        return
    }
    this.currentSelected = this.newSelected;
    this.state = "selected";
    var C = this.currentSelected[0].getObject();
    this.tiw.hostName.value = C.get("initiator_name");
    this.tiw.hostSecret.value = C.get("initiator_secret");
    this.tiw.hostName.validateEnabled = true;
    this.tiw.hostSecret.validateEnabled = true;
    this.tiw.hostName.addRules = true;
    this.tiw.hostSecret.addRules = true;
    if (C.get("oname") == "") {
        this.tiw.mutualName.value = "";
        this.tiw.mutualSecret.value = "";
        this.tiw.mutualName.validateEnabled = false;
        this.tiw.mutualSecret.validateEnabled = false;
        this.tiw.mutualName.removeRules = true;
        this.tiw.mutualSecret.removeRules = true;
        this.mutualSelected = false
    } else {
        this.tiw.mutualName.value = C.get("oname");
        this.tiw.mutualSecret.value = C.get("osecret");
        this.tiw.mutualName.validateEnabled = true;
        this.tiw.mutualSecret.validateEnabled = true;
        this.tiw.mutualName.addRules = true;
        this.tiw.mutualSecret.addRules = true;
        this.mutualSelected = true
    }
    this._updateData(true)
};
ConfigureChapAction.prototype._enterNewState = function() {
    this.state = "new";
    this.tiw.hostName.value = "";
    this.tiw.hostSecret.value = "";
    this.tiw.mutualName.value = "";
    this.tiw.mutualSecret.value = "";
    this.tiw.hostName.validateEnabled = false;
    this.tiw.hostSecret.validateEnabled = false;
    this.tiw.hostName.addRules = true;
    this.tiw.hostSecret.addRules = true;
    this.tiw.mutualName.validateEnabled = false;
    this.tiw.mutualSecret.validateEnabled = false;
    this.mutualSelected = false;
    this._updateData(true)
};
ConfigureChapAction.prototype._enterUnselectedState = function() {
    this.dirty = false;
    this.state = "unselected";
    this.tiw.hostName.value = "";
    this.tiw.hostSecret.value = "";
    this.tiw.mutualName.value = "";
    this.tiw.mutualSecret.value = "";
    this.tiw.hostName.validateEnabled = false;
    this.tiw.hostSecret.validateEnabled = false;
    this.tiw.mutualName.validateEnabled = false;
    this.tiw.mutualSecret.validateEnabled = false;
    this.tiw.hostName.removeRules = true;
    this.tiw.hostSecret.removeRules = true;
    this.tiw.mutualName.removeRules = true;
    this.tiw.mutualSecret.removeRules = true;
    this.mutualSelected = false;
    this._updateData(true)
};
ConfigureChapAction.prototype._newRevert = function(E, C, D) {
    this.update({
        chapRecordTable: {
            select: new DCRef("chap-records", this.tiw.hostName.value)
        }
    })
};
ConfigureChapAction.prototype.deleteClicked = function() {
    ShowActiveDialog({
        type: "confirm",
        message: strings.configureChap.remove.confirmMsg(this.tiw.hostName.value),
        okLabel: strings.Yes,
        cancelLabel: strings.No,
        ok: createObjectCallback(this, this._deleteChap())
    })
};
ConfigureChapAction.prototype._isDirty = function() {
    return (this.tiw.hostName.widget.valueChanged || this.tiw.hostSecret.widget.valueChanged || this.tiw.mutualName.widget.valueChanged || this.tiw.mutualSecret.widget.valueChanged)
};
ConfigureChapAction.prototype.applyCallback = function() {
    this._initiateConfigureChap(false)
};
ConfigureChapAction.prototype.okCallback = function() {
    this._initiateConfigureChap(true)
};
ConfigureChapAction.prototype._initiateConfigureChap = function(C) {
    if (this.state == "new") {
        this._createChap(C)
    } else {
        if (this.state == "selected") {
            this._modifyChap(C)
        }
    }
};
ConfigureChapAction.prototype._createChap = function(D) {
    var C = {
        hostId: this.tiw.hostName.value,
        hostSecret: this.tiw.hostSecret.value,
        mutualId: this.tiw.mutualName.value,
        mutualSecret: this.tiw.mutualSecret.value
    };
    MC.configureCHAPEntry(C, {
        dialog: true,
        processingMsg: strings.configureChap.create.processing,
        failureMsg: strings.configureChap.create.failure,
        successMsg: strings.configureChap.create.success,
        closeActionOn: ((D) ? "success" : "none"),
        callback: createObjectCallback(this, function(E) {
            if (E.success) {
                this._enterUnselectedState()
            }
        })
    })
};
ConfigureChapAction.prototype._chapRecordAdded = function(C) {
    if (C.success) {
        this.newSelected = new DCRef("chap-records", this.tiw.hostName.value);
        this.update({
            chapRecordTable: {
                select: this.newSelected
            }
        });
        this._enterSelectedState()
    }
};
ConfigureChapAction.prototype._modifyChap = function(D) {
    var C = {
        hostId: this.tiw.hostName.value,
        hostSecret: this.tiw.hostSecret.value,
        mutualId: this.tiw.mutualName.value,
        mutualSecret: this.tiw.mutualSecret.value
    };
    MC.configureCHAPEntry(C, {
        dialog: true,
        processingMsg: strings.configureChap.modify.processing,
        failureMsg: strings.configureChap.modify.failure,
        successMsg: strings.configureChap.modify.success,
        closeActionOn: ((D) ? "success" : "none"),
        callback: createObjectCallback(this, this._enterUnselectedState)
    })
};
ConfigureChapAction.prototype._deleteChap = function() {
    MC.deleteCHAPEntry({
        hostId: this.tiw.hostName.value
    }, {
        dialog: true,
        confirmMsg: strings.configureChap.remove.confirmMsg(this.tiw.hostName.value),
        processingMsg: strings.configureChap.remove.processing,
        failureMsg: strings.configureChap.remove.failure,
        successMsg: strings.configureChap.remove.success,
        okLabel: strings.okButtonText,
        cancelLabel: strings.cancelButtonText,
        callback: createObjectCallback(this, this._chapRecordDeleted)
    })
};
ConfigureChapAction.prototype._chapRecordDeleted = function(C) {
    if (C.success) {
        this.update({
            chapRecordTable: {
                select: []
            }
        });
        this._enterUnselectedState()
    }
};

function ManageSchedulesAction(G) {
    if (arguments.length == 0) {
        return
    }
    var F = 0;
    var C = [];
    var H = DC.systemParameters.getInt("max_task_retention_count");
    for (var D = 1; D <= H; D++) {
        C[C.length] = {
            value: "" + D,
            text: "" + D
        }
    }
    G.name = "ManageSchedulesAction";
    G.okCallback = createObjectCallback(this, this.okCallback);
    G.applyCallback = createObjectCallback(this, this.applyCallback);
    G.cancelCallback = createObjectCallback(this, this.cancelCallback);
    G.closing = createObjectCallback(this, this.closingCallback);
    var E = createObjectCallback(this, this.scheduleChangedCallback);
    this.panelState = "baseState";
    this.changedWidgets = {};
    this.changed = false;
    this.currentScheduleSelection = null;
    this.clickedScheduleSelection = null;
    G.widgets = [new WidgetContainer({
        name: "scheduleTableFixedBox",
        classes: "scheduleMgmtTableBox",
        widgets: [this.scheduleTable = new TableInator({
            name: "scheduleTable",
            selectable: "single",
            width: 550,
            displayLength: 5,
            type: "apiData",
            criteria: createObjectCallback(this, this._schedulesCriteria),
            selectCallback: createObjectCallback(this, this.selectChange),
            metadata: "schedules",
            dtOptions: {
                bLengthChange: false
            },
            fields: ["name", "schedule_specification", "status", "task_type"]
        })]
    }), new WidgetContainer({
        name: "buttonContainerFixit",
        widgets: [new ButtonContainer({
            name: "bc",
            orientation: "horizontal",
            alignment: "right",
            topMargin: true,
            widgets: [new ButtonWidget({
                name: "deleteScheduleFormSubmit",
                text: strings.manageSchedules.deleteButtonText,
                disable: true,
                click: createObjectCallback(this, this.deleteSchedule)
            })]
        }), new WidgetContainer({
            classes: "clearFloats"
        })]
    }), new ContentHorizontalRule({
        name: "hr1",
        topMargin: true,
        colSpan: 4
    }), this.manageScheduleForm = new FormWidget({
        name: "modifyScheduleForm",
        row: F++,
        col: 0,
        data: {},
        label: strings.schedule.editScheduleLabel,
        widgets: [this.snapshot = new TableWidget({
            name: "snapshot",
            visibility: "hidden",
            topMargin: true,
            bottomMargin: true,
            widgets: [new TextInputWidget({
                name: "snapshotPrefix",
                row: 1,
                col: 1,
                label: strings.createSnapshot.snapshotPrefixLabel,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: (RI.getMaxNameLength() - 6)
                },
                messages: {
                    required: strings.createSnapshot.enterName
                },
                changeCallback: E
            }), new OptionInputWidget({
                name: "retentionCount",
                row: 2,
                col: 1,
                topMargin: true,
                leftMargin: true,
                label: strings.createSnapshot.retentionLabel,
                values: C,
                width: 40,
                changeCallback: E
            })]
        }), this.volCopy = new TableWidget({
            name: "volCopy",
            visibility: "hidden",
            topMargin: true,
            bottomMargin: true,
            widgets: [new TextInputWidget({
                name: "volcopyPrefix",
                row: 1,
                col: 1,
                leftMargin: true,
                label: strings.copyVolumeAction.prefixLabel,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: (RI.getMaxNameLength() - 6)
                },
                messages: {
                    required: strings.copyVolumeAction.enterPrefix
                },
                changeCallback: E
            }), new CheckboxInputWidget({
                name: "modifiedData",
                row: 3,
                col: 1,
                topMargin: true,
                leftMargin: true,
                label: strings.copyVolumeAction.modifiedSnap,
                rules: {
                    required: false
                },
                disable: true,
                changeCallback: E
            })]
        }), this.repVol = new TableWidget({
            name: "repVol",
            visibility: "hidden",
            topMargin: true,
            bottomMargin: true,
            widgets: [new TextInputWidget({
                name: "repImagePrefix",
                row: 0,
                col: 1,
                leftMargin: true,
                bottomMargin: true,
                label: strings.createLinearRepSet.imagePrefix,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: RI.getMaxNameLength()
                },
                disable: true,
                changeCallback: E
            }), new RadioButtonsInputWidget({
                name: "replicationMode",
                bottomMargin: true,
                label: strings.createLinearRepSet.repMode,
                row: 2,
                col: 1,
                labelOptions: {
                    bottomMargin: true,
                    rightSmallMargin: true
                },
                changeCallback: E,
                value: "new-snapshot",
                values: [{
                    value: "new-snapshot",
                    text: strings.createLinearRepSet.newSnap
                }, {
                    value: "last-snapshot",
                    text: strings.createLinearRepSet.lastSnap
                }]
            }), new OptionInputWidget({
                name: "repRetentionCount",
                bottomMargin: true,
                label: strings.createLinearRepSet.retCount,
                row: 3,
                col: 1,
                changeCallback: E,
                labelOptions: {
                    bottomMargin: true,
                    rightSmallMargin: true
                },
                values: C,
                width: 40
            })]
        }), this.lastSnapshot = new TableWidget({
            name: "lastSnap",
            visibility: "hidden",
            topMargin: true,
            bottomMargin: true,
            widgets: [new CheckboxInputWidget({
                name: "lastSnapshot",
                row: 4,
                col: 0,
                label: strings.replicate.lastSnapshot,
                singleCell: true,
                bottomMargin: true,
                changeCallback: E
            })]
        }), this.scheduleBox = new LabeledWidgetContainer({
            name: "scheduleLabelBox",
            label: strings.copyVolumeAction.scheduleLabel,
            topMargin: true,
            widgets: [this.scheduleWidget = new ScheduleInputWidget({
                name: "scheduleWidget",
                label: strings.copyVolumeAction.scheduleDataLabel,
                changeCallback: E,
                disable: true
            })]
        })]
    })];
    ActionPanel.call(this, G);
    this.class_name = "ManageSchedulesAction";
    this.okEnabled(true)
}
ManageSchedulesAction.prototype = new ActionPanel();
ManageSchedulesAction.prototype.constructor = ManageSchedulesAction;
ManageSchedulesAction.REPEAT_HEIGHT = 130;
ManageSchedulesAction.getMenuState = function(H) {
    if (!RI.hasFeature("copyServices")) {
        return false
    }
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var I = function() {
        if (currentPanel instanceof VolumesTopic) {
            return strings.menuTips.snapsVolsWithScheds
        } else {
            return strings.menuTips.repsWithScheds
        }
    };
    var E = TopicPanel.getSelected(["snapshots", "volumes", "cs-replication-set", "replication-set"]);
    if (H.actionOptions && H.actionOptions.all) {
        if (MC.schedulesSet.data && MC.schedulesSet.data.objects.length > 0) {
            return []
        } else {
            return strings.menuTips.noScheds
        }
    } else {
        if (E) {
            if (!MC.schedulesSet.data) {
                return strings.menuTips.snapsVolsWithScheds
            }
            for (var D = 0; D < MC.schedulesSet.data.objects.length; D++) {
                var G = MC.schedulesSet.data.objects[D];
                for (var F = 0; F < E.length; F++) {
                    if (E[F].basetype == "replication-set") {
                        var J = E[F].getObject();
                        var L = getRepSetInfo(J);
                        var K = L.vol.get("serial_number")
                    } else {
                        var K = E[F].key
                    }
                    if (G.get("associated_volume_serial") == K) {
                        return E
                    }
                    if (G.get("task_replication_set_serialnum") == K) {
                        return E
                    }
                    if (E[F].basetype == "volumes") {
                        var C = E[F].getObject();
                        if (C.get("replication_set")) {
                            if (G.get("task_replication_set_serialnum") == C.get("replication_set")) {
                                return E
                            }
                        }
                    }
                }
            }
            return I()
        } else {
            return I()
        }
    }
};
ManageSchedulesAction.prototype.showing = function() {
    this.subscription = MC.schedulesSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    });
    this.manageScheduleForm.setVisibility("hidden")
};
ManageSchedulesAction.prototype._schedulesCriteria = function(G) {
    if (this.previousSelection.length == 0) {
        return true
    }
    for (var D = 0; D < this.previousSelection.length; D++) {
        if (this.previousSelection[D].basetype == "replication-set") {
            var H = this.previousSelection[D].getObject();
            var E = getRepSetInfo(H);
            var C = E.vol.get("serial_number")
        } else {
            var C = this.previousSelection[D].key
        }
        if (G.get("associated_volume_serial") == C) {
            return true
        }
        if (G.get("task_replication_set_serialnum") == C) {
            return true
        }
        if (this.previousSelection[D].basetype == "volumes") {
            var F = this.previousSelection[D].getObject();
            if (F.get("replication_set") && F.get("replication_set") == G.get("task_replication_set_serialnum")) {
                return true
            }
        }
    }
    return false
};
ManageSchedulesAction.prototype.hiding = function() {
    if (this.subscription) {
        MC.schedulesSet.unregister(this.subscription);
        delete this.subscription
    }
};
ManageSchedulesAction.prototype.closing = function() {
    this.scheduleTable.destroy()
};
ManageSchedulesAction.prototype._updateData = function(D) {
    var C = D.select(function(E) {
        if (E.prop.task_type != undefined) {
            return true
        } else {
            return false
        }
    });
    this.update({
        snapshotPrefix: {
            disable: true
        },
        volcopyPrefix: {
            disable: true
        },
        repImagePrefix: {
            disable: true
        },
        lastSnapshot: {
            disable: true
        },
        modifyScheduleFormSubmit: {
            disable: false
        },
        modifiedData: {
            disable: true,
            value: false
        },
        scheduleTable: {
            data: C.objects
        },
        snapshot: {
            visibility: "collapse"
        },
        volCopy: {
            visibility: "collapse"
        },
        repVol: {
            visibility: "collapse"
        },
        lastSnap: {
            visibility: "collapse"
        },
        scheduleLabelBox: {
            visibility: "collapse"
        },
        scheduleWidget: {
            visibility: "collapse",
            disable: true
        },
        deleteScheduleFormSubmit: {
            disable: true
        }
    });
    if (this.currentScheduleSelection) {
        this.scheduleTable.selectRows(this.currentScheduleSelection);
        this._select(this.currentScheduleSelection)
    } else {
        this.okEnabled(false);
        this.applyEnabled(false);
        this.changed = false
    }
};
ManageSchedulesAction.prototype._selectAbandonChanges = function() {
    this._select(this.clickedScheduleSelection);
    this.manageScheduleForm.validate()
};
ManageSchedulesAction.prototype._selectRevert = function() {
    this.scheduleTable.selectRows(this.currentScheduleSelection);
    this.changed = true;
    this.applyEnabled(true);
    this.okEnabled(true)
};
ManageSchedulesAction.prototype._select = function(F) {
    var H = {};
    var D = DC.schedules[F[0].key];
    var E = D.getPropertyValue("task_type");
    var C;
    this.snapshot.setVisibility("hidden");
    this.volCopy.setVisibility("hidden");
    this.repVol.setVisibility("hidden");
    this.lastSnapshot.setVisibility("hidden");
    this.currentScheduleSelection = F.slice(0);
    this.clickedScheduleSelection = F.slice(0);
    var G = D.getPropertyValue("schedule_specification");
    this.changedWidgets = {};
    this.changed = false;
    switch (E) {
        case "TakeSnapshot":
            this.snapshot.setVisibility("show");
            H = {
                snapshotPrefix: {
                    value: D.getPropertyValue("task_snapshot_prefix"),
                    disable: false,
                    setOrig: true
                },
                retentionCount: {
                    value: D.getPropertyValue("task_retention_count"),
                    disable: false,
                    setOrig: true
                },
                modifyScheduleFormSubmit: {
                    disable: false
                }
            };
            this.panelState = "takeSnapState";
            break;
        case "VolumeCopy":
            this.volCopy.setVisibility("show");
            H = {
                volcopyPrefix: {
                    value: D.getPropertyValue("task_destination_volume_prefix"),
                    disable: false,
                    setOrig: true
                },
                snapshotPrefix: {
                    disable: true
                },
                modifyScheduleFormSubmit: {
                    disable: false
                }
            };
            C = D.getPropertyValue("task_include_modified_data");
            if (C == "preserved") {
                H.modifiedData = {
                    value: false,
                    disable: false,
                    setOrig: true
                }
            } else {
                H.modifiedData = {
                    value: true,
                    disable: false,
                    setOrig: true
                }
            }
            this.panelState = "volCopyState";
            break;
        case "ResetSnapshot":
            H = {
                retentionCount: {
                    disable: true
                },
                snapshotPrefix: {
                    disable: true
                },
                volcopyPrefix: {
                    disable: true
                },
                modifyScheduleFormSubmit: {
                    disable: false
                }
            };
            this.panelState = "resetSnapState";
            break;
        case "Replicate":
            if (!decodeBooleanFlag(DC.virtualReplicationSets[D.get("task_replication_set_name")].get("group_numeric"))) {
                this.lastSnapshot.setVisibility("show");
                H = {
                    lastSnapshot: {
                        value: D.getInt("task_replicate_last_snapshot_numeric") == 1 ? true : false,
                        disable: false,
                        setOrig: true
                    }
                }
            }
            break;
        case "ReplicateVolume":
            this.repVol.setVisibility("show");
            H = {
                repImagePrefix: {
                    value: D.getPropertyValue("task_snapshot_prefix"),
                    disable: false,
                    setOrig: true
                },
                replicationMode: {
                    value: D.get("task_replication_mode"),
                    disable: false,
                    setOrig: true
                },
                repRetentionCount: {
                    value: D.get("task_retention_count"),
                    disable: false,
                    setOrig: true
                }
            };
            break;
        default:
            MC.debugOutput("_select bad task type is %s .", E);
            break
    }
    H.scheduleLabelBox = {
        visibility: "visible"
    };
    H.scheduleWidget = {
        visibility: "visible",
        setOrig: true,
        value: G
    };
    H.deleteScheduleFormSubmit = {
        disable: false
    };
    this.update(H);
    this.applyEnabled(false);
    this.okEnabled(false);
    var I = {};
    this.retrieve(I);
    this.resetSize()
};
ManageSchedulesAction.prototype.selectChange = function(C, D) {
    if (D && D === true) {
        return
    }
    if (this.changed) {
        this.clickedScheduleSelection = C.slice(0);
        ShowActiveDialog({
            type: "confirm",
            message: strings.manageSchedules.navigateAway,
            okLabel: strings.Yes,
            cancelLabel: strings.No,
            ok: createObjectCallback(this, this._selectAbandonChanges),
            cancel: createObjectCallback(this, this._selectRevert)
        })
    } else {
        if (C.length) {
            this.manageScheduleForm.setVisibility("show");
            this._select(C)
        } else {
            this.manageScheduleForm.setVisibility("hidden");
            this.changed = false;
            this.update({
                deleteScheduleFormSubmit: {
                    disable: true
                }
            })
        }
    }
};
ManageSchedulesAction.prototype.scheduleChangedCallback = function(J, F, G) {
    var H = false;
    if (J[F.name].valueChanged) {
        H = true;
        if (!this.changedWidgets[F.name]) {
            this.changedWidgets[F.name] = true
        }
    } else {
        if (this.changedWidgets[F.name]) {
            var I = 0;
            delete this.changedWidgets[F.name];
            for (var D in this.changedWidgets) {
                I++
            }
            if (!I) {
                H = false
            }
        }
    }
    var C = {};
    this.retrieve(C);
    if (!C.modifyScheduleForm) {
        return
    }
    var E = C.modifyScheduleForm.valid;
    this.changed = H;
    this.resetSize();
    this.okEnabled((this.changed && E));
    this.applyEnabled((this.changed && E))
};
ManageSchedulesAction.prototype._modifySchedule = function(F) {
    var H = {};
    var C;
    var K;
    var L;
    var I;
    var G;
    var D = false;
    var E = [];
    this.retrieve(H);
    if (!H.modifyScheduleForm.valid) {
        return
    }
    var J = DC.schedules[H.scheduleTable.selected[0].key];
    if (!J) {
        return
    }
    L = J.getPropertyValue("name");
    K = H.scheduleWidget.value;
    if (J.prop.task_name) {
        C = J.getPropertyValue("task_name");
        taskType = J.getPropertyValue("task_type")
    }
    G = {
        name: L,
        scheduleSpecification: K
    };
    if (C) {
        I = {
            name: C
        };
        if (taskType == "TakeSnapshot") {
            I.snapshotPrefix = H.snapshotPrefix.value;
            I.retentionCount = H.retentionCount.value;
            D = true
        } else {
            if (taskType == "VolumeCopy") {
                I.destPrefix = H.volcopyPrefix.value;
                if (H.modifiedData.value) {
                    I.modifiedSnapshot = "yes"
                } else {
                    I.modifiedSnapshot = "no"
                }
                D = true
            } else {
                if (taskType == "ReplicateVolume") {
                    I.snapshotPrefix = H.repImagePrefix.value;
                    I.replicationMode = H.replicationMode.value;
                    I.retentionCount = H.repRetentionCount.value;
                    D = true
                } else {
                    if (taskType == "Replicate") {
                        for (schedule in DC.schedules) {
                            if (schedule == H.scheduleTable.selected[0].key) {
                                I.replicationSet = DC.schedules[schedule].get("task_replication_set_serialnum");
                                break
                            }
                        }
                        if (!H.lastSnapshot.value) {
                            I.lastSnapshot = "disabled"
                        } else {
                            I.lastSnapshot = "enabled"
                        }
                        D = true
                    }
                }
            }
        }
    }
    if (D) {
        E[E.length] = {
            name: "task",
            command: MC.setTask,
            data: I,
            options: {
                processingMsg: strings.manageSchedules.taskProcessing(C),
                failureMsg: strings.manageSchedules.taskFailure(C),
                successMsg: strings.manageSchedules.taskSuccess(C)
            }
        }
    }
    if (this.scheduleWidget.valueChanged) {
        E[E.length] = {
            name: "schedules",
            command: MC.setSchedule,
            data: G,
            options: {
                processingMsg: strings.manageSchedules.scheduleProcessing(J.prop.name.text),
                failureMsg: strings.manageSchedules.scheduleFailure(J.prop.name.text),
                successMsg: strings.manageSchedules.scheduleSuccess(J.prop.name.text)
            }
        }
    }
    MC.execCommandList(E, {
        closeActionOn: ((F == "ok") ? "success" : "none"),
        confirmMsg: strings.manageSchedules.confirmMsg(J.prop.name.text)
    })
};
ManageSchedulesAction.prototype.cancelCallback = function() {
    var C = {};
    this.retrieve(C, true);
    if (this.changed || (this.scheduleWidget.valueChanged && this.currentScheduleSelection)) {
        this.panelState = "baseState";
        ShowActiveDialog({
            type: "confirm",
            message: strings.manageSchedules.navigateAway,
            okLabel: strings.Yes,
            cancelLabel: strings.No,
            ok: createObjectCallback(this, this.close)
        });
        return false
    }
    return true
};
ManageSchedulesAction.prototype.okCallback = function() {
    this._modifySchedule("ok");
    this.changed = false
};
ManageSchedulesAction.prototype.applyCallback = function() {
    this._modifySchedule("apply");
    this.changed = false;
    this.applyEnabled(false);
    this.okEnabled(false)
};
ManageSchedulesAction.prototype.deleteSchedule = function() {
    var I = {};
    var E = [];
    var C;
    var H;
    var D;
    var F = [];
    this.retrieve(I);
    var G = DC.schedules[I.scheduleTable.selected[0].key];
    if (G.prop.task_name) {
        C = G.prop.task_name.text;
        D = DC.tasks[C]
    }
    H = G.prop.name.text;
    E = [{
        name: "schedules",
        command: MC.deleteSchedule,
        data: {
            name: I.scheduleTable.selected[0].key
        },
        options: {
            processingMsg: strings.manageSchedules.delScheduleProcessing(H),
            failureMsg: strings.manageSchedules.delScheduleFailure(H),
            successMsg: strings.manageSchedules.delScheduleSuccess(H)
        }
    }];
    MC.execCommandList(E, {
        closeActionOn: "none",
        confirmMsg: strings.manageSchedules.delConfirmMsg(H),
        successMsg: strings.manageSchedules.delScheduleSuccess(H),
        failureMsg: strings.manageSchedules.delScheduleFailure(H),
        callback: createObjectCallback(this, this.deleteScheduleComplete)
    })
};
ManageSchedulesAction.prototype.deleteScheduleComplete = function(C) {
    this.currentScheduleSelection = null;
    this.clickedScheduleSelection = null;
    this._updateData(MC.schedulesSet)
};

function DownloadCSVAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DownloadCSVAction";
    C.title = strings.downloadCSV.title;
    C.width = 325;
    C.height = 155;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "dataChoiceText"
    }), new RadioButtonsInputWidget({
        name: "dataChoice",
        orientation: "horizontal",
        label: strings.downloadCSV.dataChoiceLabel,
        values: [{
            value: "all",
            text: strings.downloadCSV.all
        }, {
            value: "selected",
            text: strings.downloadCSV.selected
        }]
    }), new TextWidget({
        name: "formatText"
    }), new RadioButtonsInputWidget({
        name: "format",
        orientation: "horizontal",
        label: strings.downloadCSV.formatLabel,
        values: [{
            value: "rows",
            text: strings.downloadCSV.rows
        }, {
            value: "columns",
            text: strings.downloadCSV.columns
        }]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DownloadCSVAction"
}
DownloadCSVAction.prototype = new ActionPanel();
DownloadCSVAction.prototype.constructor = DownloadCSVAction;
DownloadCSVAction.prototype.showing = function() {
    var E, C;
    switch (this.csvObj.name) {
        case "tVolumesVolumes":
            E = strings.downloadCSV.dataChoiceText(strings.volumes);
            C = strings.downloadCSV.formatText(strings.volume);
            break;
        case "tHostsInits":
            E = strings.downloadCSV.dataChoiceText(strings.initiators);
            C = strings.downloadCSV.formatText(strings.initiator);
            break;
        case "tHostsMaps":
        case "tVolumesMaps":
        case "tMapsMaps":
            E = strings.downloadCSV.dataChoiceText(strings.maps);
            C = strings.downloadCSV.formatText(strings.maps);
            break;
        case "tPoolsPools":
            E = strings.downloadCSV.dataChoiceText(strings.pools);
            C = strings.downloadCSV.formatText(strings.pools);
            break;
        case "tPoolsDiskGroups":
            E = strings.downloadCSV.dataChoiceText(strings.diskgroups);
            C = strings.downloadCSV.formatText(strings.diskgroup);
            break;
        case "tPoolsDisks":
            E = strings.downloadCSV.dataChoiceText(strings.disks);
            C = strings.downloadCSV.formatText(strings.disks);
            break;
        case "tVolumesSnaps":
            E = strings.downloadCSV.dataChoiceText(strings.snapshot);
            C = strings.downloadCSV.formatText(strings.snapshot);
            break;
        case "repsTopicPeerTable":
            E = strings.downloadCSV.dataChoiceText(strings.peers);
            C = strings.downloadCSV.formatText(strings.peer);
            break;
        case "repsTopicRepSetTable":
            E = strings.downloadCSV.dataChoiceText(strings.replicationSets);
            C = strings.downloadCSV.formatText(strings.replicationSet);
            break;
        case "systemRackRackTable":
            E = strings.downloadCSV.dataChoiceText(strings.downloadCSV.systemInfo);
            C = strings.downloadCSV.dataChoiceText(strings.downloadCSV.systemInfo);
            break;
        default:
            break
    }
    var D = {
        dataChoiceText: {
            text: E
        },
        formatText: {
            text: C
        }
    };
    if (!this.csvObj.selected.length) {
        D.dataChoice = {
            disable: true
        }
    }
    this.okEnabled(true);
    this.update(D)
};
DownloadCSVAction.prototype.okCallback = function() {
    var H = {};
    this.retrieve(H);
    this.prepareCSVData();
    var I = this.getData(H);
    var C = this.generateCSV(I, H);
    var D = new Blob([C], {
        type: "text/csv;charset=utf-8"
    });
    var F = detectBrowser();
    if (F.ie) {
        navigator.msSaveBlob(D, this.csvObj.fileName)
    } else {
        var G = document.createElement("a");
        var E = URL.createObjectURL(D);
        G.setAttribute("href", E);
        G.setAttribute("download", this.csvObj.fileName);
        G.style.visibility = "hidden";
        document.body.appendChild(G);
        G.click();
        document.body.removeChild(G)
    }
    ShowActiveDialog({
        type: "message",
        message: strings.downloadCSV.downloadStarted,
        cancelState: "hidden",
        ok: panels.actionDialog.close(true)
    })
};
DownloadCSVAction.prototype.prepareCSVData = function() {
    switch (this.csvObj.name) {
        case "tVolumesVolumes":
            this.csvObj.allDataSource = DC.volumes;
            this.csvObj.headerValues = [strings.volumeHover.nameLabel, strings.volumeHover.poolLabel, strings.volumeHover.sizeLabel, strings.volumeHover.allocSizeLabel, strings.volumeHover.classLabel, strings.volumeHover.serialLabel, strings.volumeHover.writePolicyLabel, strings.volumeHover.optimizationLabel, strings.volumeHover.readAheadSizeLabel, strings.volumeHover.typeLabel, strings.volumeHover.tierAffinity, strings.snapHover.retentionPriorityLabel, "WWN", strings.rack.health, strings.healthWidget.reasonLabel, strings.healthWidget.recommendLabel];
            this.csvObj.getProperties = this.getVolumeProperties;
            this.csvObj.fileName = "VolumeData.csv";
            break;
        case "tHostsInits":
            var D = meta.initiator;
            this.csvObj.allDataSource = DC.initiators;
            this.csvObj.headerValues = [strings.hostsTopic.groupCol, strings.hostsTopic.hostCol, strings.hostsTopic.nickname, strings.ID, strings.hostsTopic.profile, strings.hostsTopic.discovered, strings.hostsTopic.mapped, strings.hostsTopic.hosttype];
            this.csvObj.getProperties = this.getInitiatorProperties;
            this.csvObj.fileName = "InitiatorData.csv";
            break;
        case "tHostsMaps":
        case "tVolumesMaps":
        case "tMapsMaps":
            var J = {};
            var C = MC.mapsSet.data.objects;
            var H = 0;
            for (var G = 0; G < C.length; G++) {
                var I = C[G];
                for (var F = 0; F < I.objects.length; F++) {
                    J[H++] = I.objects[F]
                }
            }
            this.csvObj.allDataSource = J;
            this.csvObj.headerValues = [strings.mapDetailAction.hostGroupCol, strings.mapDetailAction.hostCol, strings.mapDetailAction.nickCol, strings.mapDetailAction.idCol, strings.mapDetailAction.volGroupCol, strings.mapDetailAction.volumeCol, strings.mapDetailAction.accessCol, strings.mapDetailAction.lunCol, strings.mapDetailAction.portsCol];
            this.csvObj.getProperties = this.getMapsProperties;
            this.csvObj.fileName = "MapData.csv";
            break;
        case "tPoolsPools":
            this.csvObj.allDataSource = DC.pools;
            this.csvObj.headerValues = [strings.Name, strings.rack.health, strings.volumeHover.classLabel, strings.storageHover.totalSize, strings.storageHover.usedSize, strings.Volumes, strings.DiskGroups, strings.volumeHover.serialLabel, strings.diskGroupHover.sectorFormatLabel];
            this.csvObj.getProperties = this.getPoolProperties;
            this.csvObj.fileName = "PoolData.csv";
            break;
        case "tPoolsDiskGroups":
            this.csvObj.allDataSource = DC.diskGroups;
            this.csvObj.headerValues = [strings.Name, strings.rack.health, strings.Pool, strings.addDiskGroup.levelLabel, strings.volumeHover.classLabel, strings.rack.diskType, strings.storageHover.totalSize, strings.volumeHover.freeLabel, strings.volumeHover.statusLabel, strings.rack.meter, strings.volumeHover.serialLabel, strings.diskGroupHover.sectorFormatLabel];
            this.csvObj.getProperties = this.getDiskGroupProperties;
            this.csvObj.fileName = "DiskGroupData.csv";
            break;
        case "tPoolsDisks":
            this.csvObj.allDataSource = DC.disks;
            this.csvObj.headerValues = [strings.diskHover.locationLabel, strings.rack.health, strings.diskHover.typeLabel, strings.diskHover.sizeLabel, strings.diskHover.usageLabel, strings.DiskGroup, strings.volumeHover.statusLabel, strings.diskHover.serialLabel, strings.diskHover.rpmLabel, strings.diskHover.vendorLabel, strings.diskHover.modelLabel, strings.diskHover.revisionLabel, strings.diskHover.powerOnHours, strings.diskHover.fdeStateLabel, strings.diskHover.fdeLockKeyLabel, strings.diskHover.sectorFormatLabel];
            this.csvObj.getProperties = this.getDiskProperties;
            this.csvObj.fileName = "DiskData.csv";
            break;
        case "tVolumesSnaps":
            var E = meta.snapshots;
            this.csvObj.allDataSource = DC.snapshots;
            this.csvObj.headerValues = [E.prop.name.text, E.prop.base_volume.text, E.prop.volume_parent.text, E.prop.creation_date_time.text, strings.snapHover.statusLabel, strings.snapHover.statusReasonLabel, E.prop.snap_data.text, E.prop.snapshot_type.text, E.prop.serial_number.text, strings.snapHover.snapDataLabel, strings.snapHover.uniqueDataLabel, strings.snapHover.sharedDataLabel, strings.snapHover.storagePool, strings.snapHover.classLabel];
            this.csvObj.getProperties = this.getSnapshotProperties;
            this.csvObj.fileName = "SnapshotData.csv";
            break;
        case "repsTopicPeerTable":
            this.csvObj.allDataSource = DC.peerConnections;
            this.csvObj.headerValues = [strings.repsTopic.namestr, strings.repsTopic.conStatus, strings.repsTopic.peerConnHealth, strings.repsTopic.mediaType, strings.repsTopic.localPorts, strings.repsTopic.remotePorts, strings.repsTopic.serNum];
            this.csvObj.getProperties = this.getPeerProperties;
            this.csvObj.fileName = "PeerConnectionData.csv";
            break;
        case "repsTopicRepSetTable":
            this.csvObj.allDataSource = DC.virtualReplicationSets;
            this.csvObj.headerValues = [strings.repsTopic.namestr, strings.repsTopic.serNum, strings.replicationSetsHover.peerConnection, strings.repsTopic.primaryVol, strings.replicationSetsHover.primaryVolumeSerial, strings.repsTopic.secondaryVol, strings.replicationSetsHover.secondaryVolumeSerial, strings.replicationSetsHover.progress, strings.replicationSetsHover.currRunTimeStart, strings.replicationSetsHover.eTC, strings.replicationSetsHover.currRunData, strings.replicationSetsHover.lastSuccess, strings.replicationSetsHover.lastRunStartTime, strings.replicationSetsHover.lastRunEndTime, strings.replicationSetsHover.lastRunData, strings.replicationSetsHover.lastRunStatus, strings.replicationSetsHover.lastRunErrorStatus];
            this.csvObj.getProperties = this.getRepSetProperties;
            this.csvObj.fileName = "ReplicationSetData.csv";
            break;
        default:
            break
    }
    for (var G = 0; G < this.csvObj.headerValues.length; G++) {
        this.csvObj.headerValues[G] = this.csvObj.headerValues[G].replace("&nbsp;", " ")
    }
};
DownloadCSVAction.prototype.getData = function(D) {
    var E = [];
    if (D.dataChoice.value == "selected") {
        for (var C = 0; C < this.csvObj.selected.length; C++) {
            E.push(this.csvObj.selected[C].getObject())
        }
    } else {
        for (obj in this.csvObj.allDataSource) {
            E.push(this.csvObj.allDataSource[obj])
        }
    }
    return E
};
DownloadCSVAction.prototype.generateCSV = function(H, G) {
    var C = "";
    if (G.format.value == "rows") {
        for (var F = 0; F < this.csvObj.headerValues.length; F++) {
            C += this.csvObj.headerValues[F] + ","
        }
        C = C.slice(0, -1) + "\r\n";
        for (var F = 0; F < H.length; F++) {
            var E = this.csvObj.getProperties(H[F]);
            for (var D = 0; D < E.length; D++) {
                C += E[D] + ","
            }
            C = C.slice(0, -1) + "\r\n"
        }
    } else {
        for (var F = 0; F < this.csvObj.headerValues.length; F++) {
            C += this.csvObj.headerValues[F] + ",";
            for (var D = 0; D < H.length; D++) {
                var E = this.csvObj.getProperties(H[D]);
                C += E[F] + ","
            }
            C = C.slice(0, -1) + "\r\n"
        }
    }
    return C
};
DownloadCSVAction.prototype.getVolumeProperties = function(C) {
    return [C.get("volume_name"), C.get("storage_pool_name"), C.get("size"), C.get("allocated_size"), C.get("storage_type"), C.get("serial_number"), C.get("write_policy"), C.get("cache_optimization"), C.get("read_ahead_size"), C.get("volume_type"), C.get("tier_affinity"), C.get("snapshot_retention_priority"), C.get("wwn"), C.get("health"), C.get("health_reason"), C.get("health_recommendation")]
};
DownloadCSVAction.prototype.getInitiatorProperties = function(C) {
    host = DC.hostsSerial[C.get("host_id")];
    group = DC.hostGroupsSerial[host.get("host_group")];
    return [group.get("name"), host.get("name"), C.get("nickname"), C.get("id"), C.get("profile"), C.get("discovered"), C.get("mapped"), C.get("host_bus_type")]
};
DownloadCSVAction.prototype.getMapsProperties = function(C) {
    hostID = C.get("mapped_id");
    var J, H, I, D, F, P, M, E, L;
    if (hostID == "AOI") {
        J = H = I = "-";
        D = strings.allOtherInits
    } else {
        if (hostID.indexOf("HG") == 0) {
            hgObj = DC.hostGroupsId[hostID];
            H = hgObj.get("name");
            for (var O in hgObj.hosts) {
                hObj = hgObj.hosts[O];
                I = hObj.get("name");
                for (var N in hObj.initiators) {
                    iObj = hObj.initiators[N];
                    J = iObj.get("nickname");
                    D = iObj.get("id")
                }
            }
        } else {
            if (hostID.indexOf("H") == 0) {
                hObj = DC.hostsId[hostID];
                I = hObj.get("name");
                H = "-";
                for (var N in hObj.initiators) {
                    iObj = hObj.initiators[N];
                    J = iObj.get("nickname");
                    D = iObj.get("id")
                }
            } else {
                iObj = DC.initiatorsId[hostID];
                H = I = "-";
                J = iObj.get("nickname");
                D = iObj.get("id")
            }
        }
    }
    F = C.get("access");
    M = C.get("ports");
    if (C instanceof APIVolumeViewMappings) {
        E = "-";
        L = C.parentObject.get("volume_name");
        P = C.get("lun")
    } else {
        E = C.parentObject.get("group_name");
        for (var G = 0; G < C.objects.length; G++) {
            var K = C.objects[G];
            L = K.get("volume_name");
            P = K.get("lun")
        }
    }
    return [H, I, J, D, E, L, F, P, M]
};
DownloadCSVAction.prototype.getPoolProperties = function(D) {
    var C = [D.get("name"), D.get("health"), D.get("storage_type"), D.get("total_size"), D.get("total_avail"), D.get("volumes"), D.get("disk_groups"), D.get("serial_number"), D.get("pool_sector_format")];
    return C
};
DownloadCSVAction.prototype.getDiskGroupProperties = function(D) {
    var C = [D.get("name"), D.get("health"), D.get("pool"), D.get("raidtype"), D.get("storage_type"), D.get("array_drive_type"), D.get("size"), D.get("freespace"), D.get("status"), D.get("diskcount"), D.get("serial_number"), D.get("pool_sector_format")];
    return C
};
DownloadCSVAction.prototype.getDiskProperties = function(F) {
    var C = F.get("virtual_disk_serial");
    if (C) {
        var E = DC.diskGroupsSerial[C].get("name")
    } else {
        var E = "-"
    }
    var D = [F.get("location"), F.get("health"), F.get("description"), F.get("size"), F.get("usage"), E, F.get("status"), F.get("serial_number"), F.get("rpm") + "k", F.get("vendor"), F.get("model"), F.get("revision"), F.get("power_on_hours"), F.get("fde_state"), F.get("lock_key_id"), F.get("sector_format")];
    return D
};
DownloadCSVAction.prototype.getSnapshotProperties = function(C) {
    var D = [C.get("name"), C.get("base_volume"), C.get("volume_parent"), C.get("creation_date_time"), C.get("status"), C.get("status_reason"), C.get("snap_data"), C.get("snapshot_type"), C.get("serial_number"), C.get("snap_data"), C.get("uniquedata"), C.get("shareddata"), C.get("storage_pool_name"), C.get("storage_type")];
    return D
};
DownloadCSVAction.prototype.getPeerProperties = function(F) {
    var E = "";
    var G = "";
    for (var D = 0; D < F.objects.length; D++) {
        if (F.objects[D] instanceof APILocalPorts) {
            if (E) {
                E += " & "
            }
            E += F.objects[D].get("local_host_port") + " (" + F.objects[D].get("port_address") + ")"
        } else {
            if (G) {
                G += " & "
            }
            G += F.objects[D].get("remote_host_port") + " (" + F.objects[D].get("port_address") + ")"
        }
    }
    var C = [F.get("peer_connection_name"), F.get("connection_status"), F.get("health"), F.get("connection_type"), E, G, F.get("serial_number")];
    return C
};
DownloadCSVAction.prototype.getRepSetProperties = function(D) {
    var C = [D.get("name"), D.get("serial_number"), D.get("peer_connection_name"), D.get("primary_volume_name"), D.get("primary_volume_serial"), D.get("secondary_volume_name"), D.get("secondary_volume_serial"), D.getRepObjProp(REPLICATION_STATE.CURRENT, "progress"), D.getRepObjProp(REPLICATION_STATE.CURRENT, "time_start"), D.getRepObjProp(REPLICATION_STATE.CURRENT, "estimated_time_completion"), D.getRepObjProp(REPLICATION_STATE.CURRENT, "total_data_transferred"), D.get("last_success_time"), D.getRepObjProp(REPLICATION_STATE.LAST, "time_start"), D.getRepObjProp(REPLICATION_STATE.LAST, "time_end"), D.getRepObjProp(REPLICATION_STATE.LAST, "total_data_transferred"), D.get("last_run_status"), D.getRepObjProp(REPLICATION_STATE.LAST, "run_errror")];
    return C
};

function ShowCertificateInfoAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ShowCertificateInfoAction";
    C.widgets = [new WidgetContainer({
        name: "showCertificateWC",
        widgets: [new TextWidget({
            name: "waitingWidget",
            visibility: "visible",
            text: '<div class="processIndicator" style="display: inline-block; width: 200px"></div>'
        }), new TabWidget({
            name: "showCertificateTabs",
            type: "Primary",
            visibility: "collapse",
            changeCallback: createObjectCallback(this, this.tabSelected),
            tabs: [{
                name: "tabShowCertA",
                label: strings.certInfo.controllerA
            }, {
                name: "tabShowCertB",
                label: strings.certInfo.controllerB
            }],
            noButton: true,
            widgets: [new WidgetContainer({
                classes: "clearFloats"
            }), new WidgetContainer({
                name: "ctrlACertContainer",
                widgets: [new TextWidget({
                    name: "a_certStatus",
                    size: 30,
                    label: strings.certInfo.certStatus,
                    row: 0,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true
                }), new TextWidget({
                    name: "a_certCreated",
                    size: 30,
                    label: strings.certInfo.certCreated,
                    row: 1,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true
                }), new WidgetContainer({
                    name: "a_certContainer",
                    classes: "certificateScroll",
                    topMargin: true,
                    row: 3,
                    col: 0,
                    colSpan: 2,
                    border: true,
                    widgets: [new TextWidget({
                        name: "a_certText"
                    })]
                })]
            }), new WidgetContainer({
                name: "ctrlBCertContainer",
                widgets: [new TextWidget({
                    name: "b_certStatus",
                    size: 30,
                    label: strings.certInfo.certStatus,
                    row: 0,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true
                }), new TextWidget({
                    name: "b_certCreated",
                    size: 30,
                    label: strings.certInfo.certCreated,
                    row: 1,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true
                }), new WidgetContainer({
                    name: "b_certContainer",
                    classes: "certificateScroll",
                    topMargin: true,
                    row: 3,
                    col: 0,
                    colSpan: 2,
                    border: true,
                    widgets: [new TextWidget({
                        name: "b_certText"
                    })]
                })]
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ShowCertificateInfoAction"
}
ShowCertificateInfoAction.prototype = new ActionPanel();
ShowCertificateInfoAction.prototype.constructor = ShowCertificateInfoAction;
ShowCertificateInfoAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        return []
    }
};
ShowCertificateInfoAction.prototype.showing = function() {
    MC.certSet.requestData({
        update: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateWidgets)
    })
};
ShowCertificateInfoAction.prototype._updateWidgets = function(G) {
    var E = {};
    var F = G.getData();
    if (F == null) {
        return
    }
    var D = F.getNthObject(0);
    if (D != null && D.basetype == "certificate-status") {
        E.a_certStatus = {
            text: D.get("certificate_status")
        };
        E.a_certCreated = {
            text: D.get("certificate_time")
        };
        E.a_certText = {
            text: D.get("certificate_text")
        }
    }
    var C = F.getNthObject(1);
    if (C != null && C.basetype == "certificate-status") {
        E.b_certStatus = {
            text: C.get("certificate_status")
        };
        E.b_certCreated = {
            text: C.get("certificate_time")
        };
        E.b_certText = {
            text: C.get("certificate_text")
        }
    }
    E.showCertificateTabs = {
        tab: "tabShowCertA"
    };
    E.ctrlACertContainer = {
        visibility: "visible"
    };
    E.ctrlBCertContainer = {
        visibility: "hidden"
    };
    E.waitingWidget = {
        visibility: "collapse"
    };
    E.showCertificateTabs = {
        visibility: "visible"
    };
    this.update(E);
    this.resetSize({
        shrink: true
    })
};
ShowCertificateInfoAction.prototype.tabSelected = function(C) {
    if (C == undefined || C == null) {
        return
    }
    if (this.selectedTab == C) {
        return
    }
    this.selectedTab = C;
    switch (this.selectedTab) {
        case 0:
            this.update({
                showCertificateTabs: {
                    tab: "tabShowCertA"
                },
                ctrlACertContainer: {
                    visibility: "visible"
                },
                ctrlBCertContainer: {
                    visibility: "hidden"
                }
            });
            break;
        case 1:
            this.update({
                showCertificateTabs: {
                    tab: "tabShowCertB"
                },
                ctrlACertContainer: {
                    visibility: "hidden"
                },
                ctrlBCertContainer: {
                    visibility: "visible"
                }
            });
            break;
        default:
            break
    }
};

function SaveLogsAction(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "SaveLogsAction";
    E.okCallback = createObjectCallback(this, this.okCallback);
    E.width = 360;
    var C = createObjectCallback(this, this.changedCallback);
    var D = 0;
    E.widgets = [new WidgetContainer({
        name: "slaWC",
        widgets: [this.slaForm = new FormWidget({
            name: "slaForm",
            tableLayout: true,
            widgets: [new TextWidget({
                name: "slaInstructions",
                col: 0,
                row: D,
                text: strings.saveLogs.instructions,
                bottomMargin: true,
                colSpan: 2
            }), new TextInputWidget({
                name: "slaName",
                col: 1,
                row: ++D,
                size: 30,
                maxLength: 100,
                label: strings.saveLogs.yourName,
                rules: {
                    required: true,
                    dhLogName: true,
                    utf8length: 100
                },
                labelOptions: {
                    col: 0,
                    rightMargin: true,
                    bottomMargin: true,
                    classes: "noWrap"
                },
                bottomMargin: true,
                changeCallback: C
            }), new TextInputWidget({
                name: "slaEmail",
                col: 1,
                row: ++D,
                size: 30,
                maxLength: 100,
                label: strings.saveLogs.yourEmailAddress,
                rules: {
                    required: true,
                    newEmail: true
                },
                labelOptions: {
                    col: 0,
                    rightMargin: true,
                    bottomMargin: true,
                    classes: "noWrap"
                },
                bottomMargin: true,
                changeCallback: C
            }), new TextInputWidget({
                name: "slaPhone",
                col: 1,
                row: ++D,
                size: 30,
                maxLength: 100,
                label: strings.saveLogs.yourPhoneNumber,
                rules: {
                    required: true,
                    isValidPhoneNumber: true
                },
                labelOptions: {
                    col: 0,
                    rightMargin: true,
                    bottomMargin: true,
                    classes: "noWrap"
                },
                bottomMargin: true,
                changeCallback: C
            }), new TextInputWidget({
                name: "slaComments",
                col: 1,
                row: ++D,
                size: 30,
                maxLength: 500,
                label: strings.saveLogs.additionalComments,
                rules: {
                    utf8length: 500,
                    dhLogName: true
                },
                labelOptions: {
                    col: 0,
                    rightMargin: true,
                    bottomMargin: true,
                    classes: "noWrap"
                },
                bottomMargin: true,
                changeCallback: C
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "SaveLogsAction"
}
SaveLogsAction.prototype = new ActionPanel();
SaveLogsAction.prototype.constructor = SaveLogsAction;
SaveLogsAction.getMenuState = function() {
    return []
};
SaveLogsAction.prototype.showing = function() {
    var C = {};
    C.slaName = {
        focus: true,
        value: "",
        setOrig: true
    };
    C.slaEmail = {
        value: "",
        setOrig: true
    };
    C.slaPhone = {
        value: "",
        setOrig: true
    };
    C.slaComments = {
        value: "",
        setOrig: true
    };
    C.slaForm = {
        resetValidation: true
    };
    this.update(C)
};
SaveLogsAction.prototype.changedCallback = function(E, C, D) {
    this.okEnabled(this.slaForm.valid);
    this.resetSize({
        shrink: true
    })
};
SaveLogsAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.slaForm.valid) {
        var D = '"' + C.slaName.value + '"' + C.slaEmail.value;
        if (C.slaPhone.value) {
            D += '"' + C.slaPhone.value
        }
        if (C.slaComments.value) {
            D += '"' + C.slaComments.value
        }
        MC.collectDebugData(D, {
            processingMsg: strings.saveLogs.processing,
            failureMsg: strings.saveLogs.failed,
            callback: createObjectCallback(this, this._commandComplete),
            closeActionOn: "success"
        })
    }
};
SaveLogsAction.prototype._commandComplete = function(C) {
    if (C.success) {
        SaveLogsAction.inProcess = true;
        ShowActiveDialog({
            type: "processing",
            message: strings.saveLogs.processing
        })
    }
};
SaveLogsAction.save = function(C) {
    downloadData("store.zip", "downloadDebugData")
};

function SSDActivityDialog(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "SSDActivityDialog";
    E.title = strings.ssdIoWorkload.panelTitle;
    E.width = 780;
    E.height = 400;
    var D = 0;
    var C = createObjectCallback(this, this.settingsChanged);
    this.userRefreshedGraph = false;
    this.customPercentInput;
    this.graphUnit = (session.getSessionPreference("storage_size_base") == 2) ? "GiB" : "GB";
    E.widgets = [new TextWidget({
        row: D++,
        name: "ssdGraphDescription",
        text: strings.ssdIoWorkload.panelDescription,
        bottomMargin: true
    }), new TableWidget({
        name: "settingsAndGraphContainer",
        maxCols: 2,
        widgets: [new WidgetContainer({
            name: "settingsContainer",
            col: 0,
            widgets: [new LabeledWidgetContainer({
                row: 0,
                col: 0,
                name: "settings",
                fitContent: true,
                label: strings.ssdIoWorkload.settingsLabel,
                widgets: [new FormWidget({
                    name: "comboxBoxWidgets",
                    tableLayout: true,
                    widgets: [new ComboBoxWidget({
                        name: "poolSelection",
                        row: 1,
                        col: 1,
                        rightMargin: true,
                        leftMargin: true,
                        bottomMargin: true,
                        label: strings.ssdIoWorkload.poolsLabel,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        values: [{
                            value: "A",
                            text: "A"
                        }, {
                            value: "B",
                            text: "B"
                        }],
                        changeCallback: C
                    }), new ComboBoxWidget({
                        name: "valuesSelection",
                        row: 2,
                        col: 1,
                        rightMargin: true,
                        leftMargin: true,
                        bottomMargin: true,
                        label: strings.ssdIoWorkload.valuesLabel,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        values: [{
                            value: "peak",
                            text: strings.ssdIoWorkload.peak
                        }, {
                            value: "average",
                            text: strings.ssdIoWorkload.average
                        }],
                        changeCallback: C
                    }), new ComboBoxWidget({
                        name: "outputType",
                        row: 3,
                        col: 1,
                        rightMargin: true,
                        leftMargin: true,
                        bottomMargin: true,
                        label: strings.ssdIoWorkload.modesLabel,
                        labelOptions: {
                            col: 0,
                            rightMargin: true,
                            classes: "noWrap"
                        },
                        values: [{
                            value: "combined",
                            text: strings.ssdIoWorkload.totalIos
                        }, {
                            value: "reads",
                            text: strings.ssdIoWorkload.reads
                        }, {
                            value: "writes",
                            text: strings.ssdIoWorkload.writes
                        }],
                        changeCallback: C
                    })]
                }), new FormWidget({
                    name: "ssdWorkloadContainer",
                    row: 4,
                    col: 0,
                    bottomMargin: true,
                    widgets: [new TableWidget({
                        name: "workloadRows",
                        maxCols: 4,
                        widgets: [new LabelWidget({
                            row: 0,
                            col: 0,
                            cssClass: "textNoPadding",
                            value: strings.ssdIoWorkload.workloadLabel,
                            bottomSmallMargin: true,
                            rightMargin: true
                        }), new CheckboxInputWidget({
                            name: "io_80percent",
                            value: true,
                            setOrig: true,
                            row: 0,
                            col: 1,
                            label: strings.ssdIoWorkload.workload80,
                            labelOptions: {
                                col: 2,
                                rightMargin: true,
                                classes: "noWrap",
                                noTerminator: true
                            },
                            bottomSmallMargin: true,
                            changeCallback: C
                        }), new Widget({
                            name: "colorLegend",
                            row: 0,
                            col: 4,
                            htmlText: '<div class="checkboxLegend" style="background-color:#6EBE49"></div>'
                        }), new CheckboxInputWidget({
                            name: "io_100percent",
                            value: false,
                            setOrig: true,
                            row: 1,
                            col: 1,
                            label: strings.ssdIoWorkload.workload100,
                            labelOptions: {
                                col: 2,
                                rightMargin: true,
                                classes: "noWrap",
                                noTerminator: true
                            },
                            bottomSmallMargin: true,
                            changeCallback: C
                        }), new Widget({
                            name: "colorLegend",
                            row: 1,
                            col: 4,
                            htmlText: '<div class="checkboxLegend" style="background-color:#008F98"></div>'
                        }), new CheckboxInputWidget({
                            name: "textInput_percent",
                            row: 2,
                            col: 1,
                            label: '<input id="customInput" name="customInput" type="text" value="50%" size="5" tabindex="undefined" disabled="disabled" class="textInputWidget" style="margin-right: 8px">' + strings.ssdIoWorkload.workloadCustom,
                            labelOptions: {
                                col: 2,
                                noTerminator: true,
                                rightMargin: true
                            },
                            bottomSmallMargin: true,
                            rightMargin: true,
                            changeCallback: C
                        }), new Widget({
                            name: "colorLegend",
                            row: 2,
                            col: 4,
                            htmlText: '<div class="checkboxLegend" style="background-color:#F8BE15"></div>'
                        })]
                    })]
                }), new ButtonWidget({
                    id: "refreshButton",
                    row: D++,
                    col: 1,
                    name: "refreshButton",
                    classes: "signOutButton",
                    primary: true,
                    text: strings.ssdIoWorkload.refreshGraph,
                    callback: createObjectCallback(this, this.refreshGraph)
                })]
            })]
        }), this.graphContainer = new FormWidget({
            name: "graphContainer",
            leftMargin: true,
            widgets: [new TextWidget({
                name: "graphTitle",
                topSmallMargin: true,
                classes: "textCenter textBold",
                text: strings.ssdIoWorkload.ioWorkload
            }), new TextWidget({
                name: "ssdCapacityLabel",
                label: strings.ssdIoWorkload.ssdCapacityLabel,
                noTerminator: true,
                topSmallMargin: true,
                smallBottomMargin: true,
                classes: "textRight",
                text: '<div class="ssdCapacityLegend"></div>'
            }), new ProcessingWidget({
                name: "processingWidget",
                leftMargin: true,
                topMargin: true
            }), new TextWidget({
                name: "poolCapacity",
                topSmallMargin: true,
                bottomargin: true,
                classes: "textRight",
                label: strings.ssdIoWorkload.poolCapacityLabel
            }), this.graphWidget = new GraphWidget({
                name: "workloadGraph",
                width: 450,
                height: 200,
                visible: true,
                tooltips: true,
                graphOptions: {
                    points: {
                        show: true,
                        radius: 3,
                        fill: true
                    },
                    lines: {
                        show: true,
                        fill: false
                    },
                    grid: {
                        color: "#CCCCCC",
                        borderColor: "#6d6d6d"
                    },
                    legend: {
                        show: false,
                        position: "se"
                    },
                    xaxis: {
                        mode: "time",
                        timeformat: "%m/%d%",
                        axisLabel: strings.ssdIoWorkload.days,
                        axisLabelPadding: 10
                    },
                    yaxis: {
                        min: 0,
                        axisLabelPadding: 10,
                        axisLabel: strings.ssdIoWorkload.capacity,
                        tickFormatter: createObjectCallback(this, this.labelAxisTicks)
                    }
                }
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "SSDActivityDialog"
}
SSDActivityDialog.prototype = new ActionPanel();
SSDActivityDialog.prototype.constructor = SSDActivityDialog;
SSDActivityDialog.getMenuState = function() {
    if (!(DC.pools.A || DC.pools.B)) {
        return strings.menuTips.noPools
    }
};
SSDActivityDialog.prototype.showing = function() {
    var C = {
        pool: DC.pools.A ? "A" : "B",
        calcType: "peak",
        outputType: "combined"
    };
    MC.showWorkload(C, {
        dialog: false,
        noSuccessDialog: true,
        callback: createObjectCallback(this, this._handleIt)
    });
    this.customPercentInput = $("#customInput").val();
    $("#customInput").on("change keyup", createObjectCallback(this, this.updateCustomPercent))
};
SSDActivityDialog.prototype.updateCustomPercent = function() {
    this.customPercentInput = $("#customInput").val()
};
SSDActivityDialog.prototype.formatSSDSize = function(E, D) {
    var F = {
        blocks: E.get("current_ssd_space_numeric")
    };
    var C = new Size(F.blocks).getSize();
    if (C.spec == "KB" || C.spec == "MB" || C.spec == "KiB" || C.spec == "MiB") {
        C = new Size(F.blocks).getSize(D, 4)
    } else {
        C = new Size(F.blocks).getSize(D, 2)
    }
    F.formatted = C.size + " " + C.spec;
    return F
};
SSDActivityDialog.prototype.labelAxisTicks = function(C, D) {
    return C + " " + this.graphWidget.unit
};
SSDActivityDialog.prototype.getPoolCapacity = function(E) {
    var D = new Size(DC.pools[E].get("total_size")).getSize(this.graphUnit);
    var C = D.size + " " + D.spec;
    return C
};
SSDActivityDialog.prototype._handleIt = function(D) {
    if (D.success && D.json && D.json.objects.length > 0) {
        var I = D.json.objects[0];
        this.heatmapObjs = I.objects;
        if (this.userRefreshedGraph) {
            var G = {};
            this.retrieve(G);
            var F = this.formatSSDSize(I, this.graphUnit);
            var C = this.getPoolCapacity(G.poolSelection.value);
            var H = {
                props: [],
                colors: []
            };
            G.ssdCapacityLabel = {
                label: strings.ssdIoWorkload.ssdCapacityLabel + " (" + F.formatted + ")"
            };
            if (this.commandObj.textInput_percent) {
                H.props.push("capacity_a_numeric");
                H.colors.push("#F8BE15")
            }
            if (this.commandObj.io_80percent) {
                H.props.push("capacity_b_numeric");
                H.colors.push("#6EBE49")
            }
            if (this.commandObj.io_100percent) {
                H.props.push("capacity_c_numeric");
                H.colors.push("#008F98")
            }
            G.processingWidget = {
                visibility: "collapse"
            };
            G.poolCapacity = {
                text: C
            };
            G.workloadGraph.propertyGraphData = {
                ssdInfo: F,
                baseUnit: "binary",
                unit: this.graphUnit,
                data: this.heatmapObjs,
                props: H.props,
                colors: H.colors
            }
        } else {
            var F = this.formatSSDSize(I, this.graphUnit);
            var C = this.getPoolCapacity(DC.pools.A ? "A" : "B");
            var G = {
                processingWidget: {
                    visibility: "collapse"
                },
                poolSelection: {
                    disable: false,
                    value: DC.pools.A ? "A" : "B",
                    setOrig: true
                },
                valuesSelection: {
                    value: "peak",
                    setOrig: true
                },
                outputType: {
                    value: "combined",
                    setOrig: true
                },
                textInput_percent: {
                    setOrig: true,
                    value: false
                },
                graphContainer: {
                    visibility: "visible"
                },
                ssdCapacityLabel: {
                    label: strings.ssdIoWorkload.ssdCapacityLabel + " (" + F.formatted + ")"
                },
                poolCapacity: {
                    text: C
                },
                workloadGraph: {
                    propertyGraphData: {
                        ssdInfo: F,
                        baseUnit: "binary",
                        data: this.heatmapObjs,
                        unit: this.graphUnit,
                        props: ["capacity_b_numeric"],
                        colors: ["#6ebe49"]
                    }
                }
            }
        }
        this.update(G)
    } else {
        this.update({
            workloadGraph: {
                clearGraphData: true
            },
            processingWidget: {
                visibility: "collapse"
            }
        });
        if (D.success && D.json && D.json.objects.length == 0) {
            var E = "message";
            D.message = strings.ssdIoWorkload.noDataFound
        } else {
            var E = "error";
            D.message = strings.perfTopic.failureMsg + D.message
        }
        ShowActiveDialog({
            type: E,
            dialogOverride: "true",
            message: D.message
        })
    }
};
SSDActivityDialog.prototype.settingsChanged = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.io_100percent.value && !C.io_80percent.value && !C.textInput_percent.value) {
        this.update({
            refreshButton: {
                disable: true
            }
        });
        return
    } else {
        this.update({
            refreshButton: {
                disable: false
            }
        })
    }
    if (D.name == "textInput_percent") {
        if (F[D.name].value) {
            $("#customInput").prop("disabled", false)
        } else {
            $("#customInput").prop("disabled", true)
        }
    }
    if (F[D.name].valueChanged) {
        C[D.name] = F[D.name].value
    }
    this.update(C)
};
SSDActivityDialog.prototype.refreshGraph = function() {
    var D = {};
    this.retrieve(D);
    var C = this.getPoolCapacity(D.poolSelection.value);
    this.commandObj = {
        pool: D.poolSelection.value,
        poolCapacity: {
            text: C
        },
        calcType: D.valuesSelection.value,
        outputType: D.outputType.value,
        io_100percent: (D.io_100percent.value ? "100%" : 0),
        io_80percent: (D.io_80percent.value ? "80%" : 0),
        textInput_percent: (D.textInput_percent.value ? this.customPercentInput : 0)
    };
    this.update({
        processingWidget: {
            visibility: "visible"
        }
    });
    this.userRefreshedGraph = true;
    MC.showWorkload(this.commandObj, {
        dialog: false,
        noSuccessDialog: true,
        callback: createObjectCallback(this, this._handleIt)
    })
};

function CreateDiskGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "CreateDiskGroupAction";
    C.okCallback = createObjectCallback(this, this._create);
    C.okButtonText = strings.addDiskGroup.okButtonText;
    C.width = 800;
    C.widgets = [new WidgetContainer({
        name: "addDiskGroupForm",
        width: "800px",
        tableLayout: true,
        widgets: [this.addDiskGroup = new AddDiskGroupWidget({
            changeCallback: createObjectCallback(this, this._selectionChange)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "CreateDiskGroupAction"
}
CreateDiskGroupAction.prototype = new ActionPanel();
CreateDiskGroupAction.prototype.constructor = CreateDiskGroupAction;
CreateDiskGroupAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D = false;
    var F = 0;
    var C = false;
    for (var E in DC.disks) {
        if (DC.disks[E].getInt("usage_numeric") == DRIVE_USAGE.AVAILABLE) {
            D = true;
            break
        }
    }
    for (var E in DC.disks) {
        if (DC.disks[E].getInt("architecture_numeric") == DISK_ARCH.SSD) {
            F++;
            if (F == propertyCount(DC.disks)) {
                C = true
            } else {
                continue
            }
        }
    }
    if (C) {
        if (licenseInfo.isLicensed("performance_tier") || RI.hasFeature("allFlashArray")) {
            return []
        } else {
            return strings.menuTips.changeLicense
        }
    }
    if (D) {
        return []
    } else {
        return strings.menuTips.noAvailableDisks
    }
};
CreateDiskGroupAction.prototype._selectionChange = function(C) {
    if (C) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateDiskGroupAction.prototype.showing = function() {
    var C = this;
    this.okEnabled(false)
};
CreateDiskGroupAction.prototype._create = function() {
    this.addDiskGroup._create()
};

function AddDiskGroupWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "AddDiskGroupWidget";
    this.defaultLevel = "raid1";
    D.width = 747;
    if (D.storageType != undefined) {
        this.storageType = D.storageType
    }
    var C = [{
        value: "raid1",
        text: strings.raid1,
        tip: strings.raid1tip
    }, {
        value: "raid5",
        text: strings.raid5,
        tip: strings.raid5tip
    }, {
        value: "raid6",
        text: strings.raid6,
        tip: strings.raid6tip
    }, {
        value: "raid10",
        text: strings.raid10,
        tip: strings.raid10tip
    }];
    if (RI.hasFeature("adapt")) {
        C.push({
            value: "adapt",
            text: strings.adapt,
            tip: strings.adapttip
        })
    }
    D.widgets = [new FormWidget({
        name: "addDiskGroupForm",
        width: "800px",
        data: {
            name: {
                value: "default"
            },
            level: {
                value: "raid5"
            }
        },
        widgets: [new WidgetContainer({
            name: "inputTable",
            widgets: [new TextInputWidget({
                name: "name",
                label: strings.addDiskGroup.nameLabel,
                labelOptions: {
                    rightMargin: true
                },
                leftMargin: true,
                classes: "poolTableRow",
                rules: {
                    dhName: true,
                    utf8length: RI.getMaxNameLength(),
                    diskGroupExists: true
                },
                messages: {
                    required: strings.addDiskGroup.nameErr
                },
                changeCallback: createObjectCallback(this, this._nameChange)
            }), this.typeWidget = new OptionInputWidget({
                name: "type",
                label: strings.addDiskGroup.typeLabel,
                values: this.typeValues,
                value: "virtual",
                classes: "poolTableRow poolRowMargin",
                changeCallback: createObjectCallback(this, this._typeChange)
            }), new OptionInputWidget({
                name: "owner",
                label: strings.addDiskGroup.poolLabel,
                labelOptions: {
                    rightMargin: true
                },
                values: this.poolValues,
                value: "a",
                classes: "poolTableRow poolRowMargin",
                changeCallback: createObjectCallback(this, this._ownerChange)
            }), new OptionInputWidget({
                name: "level",
                label: strings.addDiskGroup.dataProtectionLabel,
                singleCell: true,
                values: C,
                value: "raid6",
                multiple: false,
                classes: "poolTableRow poolRowMargin",
                changeCallback: createObjectCallback(this, this.raidChange)
            }), new WidgetContainer({
                classes: "poollinearValues",
                widgets: [new OptionInputWidget({
                    name: "chunk",
                    label: strings.addDiskGroup.chunkLabel,
                    leftMargin: true,
                    classes: "poolTableRow ",
                    values: []
                }), new CheckboxInputWidget({
                    name: "mode",
                    label: strings.addDiskGroup.modeLabel,
                    rightMargin: true,
                    classes: "poolTableRow poolRowMargin",
                    value: true
                }), new OptionInputWidget({
                    name: "subArrays",
                    label: strings.addDiskGroup.subArraysLabel,
                    labelOptions: {
                        bottomMargin: true,
                        display: "none"
                    },
                    multiple: false,
                    classes: "poolTableRow",
                    leftMargin: true,
                    changeCallback: createObjectCallback(this, this.raidChange)
                })]
            })]
        }), this.driveSelectionWidget = new DriveSelectionWidget({
            name: "driveSelection",
            row: 1,
            col: 0,
            mode: "create",
            raidType: this.defaultLevel,
            changeCallback: createObjectCallback(this, this._selectionChange)
        })]
    })];
    WidgetContainer.call(this, D);
    this.class_name = "AddDiskGroupWidget"
}
AddDiskGroupWidget.prototype = new WidgetContainer();
AddDiskGroupWidget.prototype.constructor = AddDiskGroupWidget;
AddDiskGroupWidget.prototype.showing = function() {
    this.getWidgetInfo()
};
AddDiskGroupWidget.prototype.getWidgetInfo = function(H) {
    this.ctrlInfo = getControllerInfo();
    if (this.ctrlInfo.single) {
        this.poolValues = [{
            value: this.ctrlInfo.local.toLowerCase(),
            text: this.ctrlInfo.local
        }]
    } else {
        this.poolValues = [{
            value: "a",
            text: "A"
        }, {
            value: "b",
            text: "B"
        }]
    }
    this.ownerValues = [{
        value: "auto",
        text: strings.auto
    }];
    if (this.ctrlInfo.single) {
        this.ownerValues.push({
            value: this.ctrlInfo.local.toLowerCase(),
            text: strings.addDiskGroup.owner(this.ctrlInfo.local)
        })
    } else {
        this.ownerValues.push({
            value: "a",
            text: strings.addDiskGroup.owner("A")
        }, {
            value: "b",
            text: strings.addDiskGroup.owner("B")
        })
    }
    this.typeValues = [];
    var E = licenseInfo.isLicensed("virtualization");
    var J = RI.hasFeature("defaultLinearOnV3") || isQuantumSystem();
    var D = false;
    this.rcPoolValues = [];
    if (DC.pools.A && !DC.pools.A.hasReadCache()) {
        D = true;
        this.rcPoolValues.push({
            value: "a",
            text: "A"
        })
    }
    if (DC.pools.B && !DC.pools.B.hasReadCache()) {
        D = true;
        this.rcPoolValues.push({
            value: "b",
            text: "B"
        })
    }
    if (RI.supportsPaged() && E) {
        this.typeValues.push({
            value: "virtual",
            text: strings.addDiskGroup.virtual
        })
    }
    if (RI.supportsLinear()) {
        this.typeValues.push({
            value: "linear",
            text: strings.addDiskGroup.linear
        })
    }
    if (RI.supportsPaged() && RI.hasFeature("ssdSupport") && D) {
        this.typeValues.push({
            value: "read-cache",
            text: strings.addDiskGroup.readCache
        })
    }
    var C = "linear";
    if (E && !J) {
        C = "virtual"
    }
    if (H != undefined) {
        C = H
    }
    var I = this.formDiskGroupData(C);
    I.type = {
        value: C,
        values: this.typeValues
    };
    I.title = {
        text: strings.addDiskGroup.title
    };
    this.chunkValues = [];
    for (var F = 64; F <= system.maxChunkSize; F = F * 2) {
        this.chunkValues.push({
            value: F + "k",
            text: strings.addDiskGroup.chunkSize(F)
        })
    }
    this.noChunkValues = [{
        value: "",
        text: strings.na
    }];
    var G = false;
    if (this.driveSelectionWidget.disksData != undefined && this.driveSelectionWidget.disksData.numAvail >= 12) {
        G = true
    }
    if (RI.adapt != undefined && RI.featureMatches("adapt", "true") && G) {
        this.defaultLevel = "adapt"
    } else {
        this.defaultLevel = "raid6"
    }
    if (this.storageType != undefined) {
        I.type = this.storageType
    }
    I.driveSelection.raidType = this.defaultLevel;
    if (H != undefined) {
        I.driveSelection.raidChange = true
    }
    I.level.value = this.defaultLevel;
    this.update(I)
};
AddDiskGroupWidget.prototype.getVirtualPool = function() {
    if (DC.pools.A && DC.pools.B) {
        if (DC.pools.A.getInt("total_size_numeric") <= DC.pools.B.getInt("total_size_numeric")) {
            return "a"
        } else {
            return "b"
        }
    } else {
        if (this.ctrlInfo.single) {
            return this.ctrlInfo.local.toLowerCase()
        } else {
            if (DC.pools.A) {
                return "b"
            } else {
                return "a"
            }
        }
    }
};
AddDiskGroupWidget.prototype.countAvailableDrives = function() {
    var C = MC.disksSet.select({
        type: "prop",
        name: "usage_numeric",
        value: DRIVE_USAGE.AVAILABLE
    });
    return C.objects.length
};
AddDiskGroupWidget.prototype.generateSubs = function(F, C) {
    var D = [];
    for (var E = F; E <= C; E++) {
        D[D.length] = {
            value: "" + E,
            text: "" + E
        }
    }
    return D
};
AddDiskGroupWidget.prototype.formDiskGroupData = function(C) {
    var D = {
        owner: {
            label: strings.addDiskGroup.poolLabel,
            values: this.poolValues,
            value: "a"
        },
        level: {
            disable: false,
            visibility: "visible"
        },
        subArrays: {
            disable: true,
            visibility: "collapse"
        },
        chunk: {
            disable: true
        },
        mode: {
            disable: true
        },
        driveSelection: {
            raidType: this.defaultLevel
        }
    };
    switch (C) {
        case "virtual":
            D.owner.values = this.poolValues;
            D.owner.value = this.getVirtualPool();
            D.name = {
                value: DC.getUnusedKey("diskGroups", "dg" + D.owner.value.toUpperCase() + "00")
            };
            D.subArrays.visibility = "collapse";
            D.mode = {
                disable: true,
                visibility: "collapse"
            };
            D.chunk = {
                disable: true,
                visibility: "collapse"
            };
            D.level.values = [{
                value: "raid1",
                text: strings.raid1,
                tip: strings.raid1tip
            }, {
                value: "raid5",
                text: strings.raid5,
                tip: strings.raid5tip
            }, {
                value: "raid6",
                text: strings.raid6,
                tip: strings.raid6tip
            }, {
                value: "raid10",
                text: strings.raid10,
                tip: strings.raid10tip
            }];
            if (RI.hasFeature("adapt")) {
                D.level.values.push({
                    value: "adapt",
                    text: strings.adapt,
                    tip: strings.adapttip
                })
            }
            break;
        case "read-cache":
            D.owner.values = this.rcPoolValues;
            D.subArrays.visibility = "collapse";
            D.mode = {
                disable: true,
                visibility: "collapse"
            };
            D.chunk = {
                disable: true,
                visibility: "collapse"
            };
            if (DC.pools.A && !DC.pools.A.hasReadCache()) {
                D.owner.value = "a"
            } else {
                if (DC.pools.B && !DC.pools.B.hasReadCache()) {
                    D.owner.value = "b"
                }
            }
            D.name = {
                value: DC.getUnusedKey("diskGroups", "rc" + D.owner.value.toUpperCase() + "0")
            };
            D.level.disable = true;
            break;
        case "linear":
            D.name = {
                value: DC.getUnusedKey("diskGroups", "dg00")
            };
            D.owner.label = strings.addDiskGroup.ownerLabel;
            D.owner.values = this.ownerValues;
            D.owner.value = "auto";
            D.subArrays.visibility = "collapse";
            D.mode = {
                disable: false,
                visibility: "visible"
            };
            D.chunk = {
                disable: false,
                visibility: "visible"
            };
            D.level.values = [{
                value: "raid1",
                text: strings.raid1,
                tip: strings.raid1tip
            }, {
                value: "raid5",
                text: strings.raid5,
                tip: strings.raid5tip
            }, {
                value: "raid6",
                text: strings.raid6,
                tip: strings.raid6tip
            }, {
                value: "raid10",
                text: strings.raid10,
                tip: strings.raid10tip
            }, {
                value: "raid50",
                text: strings.raid50,
                tip: strings.raid50tip
            }];
            if (RI.hasFeature("adapt")) {
                D.level.values.push({
                    value: "adapt",
                    text: strings.adapt,
                    tip: strings.adapttip
                })
            }
            break;
        default:
            break
    }
    return D
};
AddDiskGroupWidget.prototype._create = function(E) {
    var G = {};
    this.retrieve(G);
    if (!G.addDiskGroupForm.valid) {
        return
    }
    var H = {
        type: G.type.value,
        name: G.name.value
    };
    switch (G.type.value) {
        case "virtual":
            H.pool = G.owner.value;
            H.level = G.level.value;
            break;
        case "read-cache":
            H.pool = G.owner.value;
            break;
        case "linear":
            H.assignedTo = G.owner.value;
            H.level = G.level.value;
            break;
        default:
            return;
            break
    }
    if (!G.chunk.disable) {
        H.chunkSize = G.chunk.value
    }
    if (!G.mode.disable) {
        H.mode = (G.mode.value ? "online" : "offline")
    }
    for (var D in G.driveSelection) {
        H[D] = G.driveSelection[D]
    }
    H.diskType = G.driveSelection.diskType;
    var I = "";
    var F = 0;
    if (findSectorFormat(G.driveSelection) == SECTOR_FORMAT.FMT_MIXED) {
        I += strings.addDiskGroup.sectorFormatWarning + "<br/><br/>";
        F++
    }
    if (hasDegradedDisk(G.disks.selected)) {
        I += strings.usingDegradedDisk + "<br/><br/>";
        F++
    }
    if (F > 0) {
        I += strings.continueMessage;
        if (F > 1) {
            I = strings.pleaseConfirmTheFollowing + I
        }
    }
    var C = [];
    C.push({
        name: "addDiskGroup",
        command: MC.addDiskGroup,
        data: H,
        options: {
            processingMsg: strings.addDiskGroup.processing(G.name.value),
            failureMsg: strings.addDiskGroup.failure(G.name.value),
            successMsg: strings.addDiskGroup.success(G.name.value)
        }
    });
    if (E != undefined) {
        this.diskGroupname = G.name.value;
        MC.addDiskGroup(H, {
            dialog: true,
            confirmMsg: (isQuantumSystem()) ? false : I,
            processingMsg: strings.addDiskGroup.processing(G.name.value),
            failureMsg: strings.addDiskGroup.failure(G.name.value),
            successMsg: strings.addDiskGroup.success(G.name.value),
            noSuccessDialog: E.noSuccessDialog,
            closeActionOn: E.closeAction,
            callback: createObjectCallback(E.caller, E.callBack)
        })
    } else {
        MC.addDiskGroup(H, {
            dialog: true,
            confirmMsg: (isQuantumSystem()) ? false : I,
            processingMsg: strings.addDiskGroup.processing(G.name.value),
            failureMsg: strings.addDiskGroup.failure(G.name.value),
            successMsg: strings.addDiskGroup.success(G.name.value),
            closeActionOn: "success"
        })
    }
};
AddDiskGroupWidget.prototype._typeChange = function(F, D, E) {
    var C = this.formDiskGroupData(F.type.value);
    this.update(C);
    this.raidChange({
        level: {
            value: this.defaultLevel
        }
    })
};
AddDiskGroupWidget.prototype._nameChange = function(F, D, E) {
    var C = {};
    C.name = {
        value: F.name.value,
        rules: {
            required: true,
            dhName: true,
            utf8length: RI.getMaxNameLength(),
            diskGroupExists: true
        }
    };
    this.update(C)
};
AddDiskGroupWidget.prototype._ownerChange = function(I, G, H) {
    var D = I.owner.value;
    var C = {};
    this.typeWidget.retrieve(C, true);
    var E = C.type.value;
    var F = {};
    switch (E) {
        case "virtual":
            F.name = {
                value: DC.getUnusedKey("diskGroups", "dg" + D.toUpperCase() + "00")
            };
            break;
        case "read-cache":
            F.name = {
                value: DC.getUnusedKey("diskGroups", "rc" + D.toUpperCase() + "0")
            };
            break;
        case "linear":
            break;
        default:
            break
    }
    if (F.name) {
        this.update(F)
    }
};
AddDiskGroupWidget.prototype.raidChange = function(I) {
    var H = {};
    var K = {};
    this.retrieve(K, true);
    var C = false;
    subArrays = (K.subArrays.value) ? K.subArrays.value : 0;
    var M = (K.level.value) ? K.level.value : "raid5";
    if (I.level != undefined) {
        var J = true;
        var D = false;
        C = true;
        switch (I.level.value) {
            case "raid10":
                var F = this.countAvailableDrives();
                var E = Math.floor(Math.min(F, 16) / 2);
                var N = this.generateSubs(2, E);
                var L = 2;
                J = false;
                break;
            case "raid50":
                var F = this.countAvailableDrives();
                var G = Math.floor(Math.min(F, 32) / 3);
                var N = this.generateSubs(2, G);
                var L = 2;
                J = false;
                break;
            case "raid1":
                var N = this.generateSubs(1, 0);
                var L = 0;
                J = true;
                D = true;
                break;
            case "adapt":
                D = true;
                J = true;
                break;
            default:
                var N = this.generateSubs(1, 0);
                var L = 0;
                break
        }
        subArrays = L;
        H.subArrays = {
            disable: J,
            values: N,
            value: L
        };
        if (K.type.value == "linear") {
            if (D) {
                H.chunk = {
                    values: this.noChunkValues,
                    value: "",
                    disable: true
                }
            } else {
                H.chunk = {
                    values: this.chunkValues,
                    value: "512k",
                    disable: false
                }
            }
            if (I.level.value == "raid10" || I.level.value == "raid50") {
                H.subArrays.visibility = "visible"
            } else {
                H.subArrays.visibility = "collapse"
            }
            H.chunk.visibility = "visible";
            H.mode = {
                visibility: "visible"
            }
        } else {
            if (K.type.value == "virtual" && I.level.value == "raid10") {
                H.subArrays.visibility = "visible";
                H.subArrays.classes = "ARLeftMargin"
            } else {
                H.subArrays.visibility = "collapse"
            }
        }
        M = I.level.value
    }
    if (I.subArrays != undefined) {
        C = true
    }
    H.driveSelection = {
        diskGroupType: K.type.value,
        mode: "create",
        subArrays: subArrays,
        raidType: M,
        raidChange: C,
        all: false,
        diskType: (K.type.value == "read-cache" ? "sSAS" : "none")
    };
    if (I.level != undefined && I.level.value == "adapt") {
        H.chunk = {
            values: this.noChunkValues,
            value: "",
            disable: true
        };
        H.subArrays.visibility = "collapse";
        H.chunk.visibility = "collapse";
        H.mode = {
            visibility: "collapse"
        }
    }
    H.level = {
        value: M
    };
    this.update(H)
};
AddDiskGroupWidget.prototype._selectionChange = function(D, C) {
    if ($.isFunction(this.options.changeCallback)) {
        this.options.changeCallback.call(this, C.getValid())
    }
};

function ExpandDiskGroupAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ExpandDiskGroupAction";
    D.okCallback = createObjectCallback(this, this._modify);
    D.okButtonText = strings.modifyDiskGroupAction.okButtonText;
    D.width = 747;
    this.ctrlInfo = getControllerInfo();
    var C = [];
    if (this.ctrlInfo.single) {
        C = [{
            value: this.ctrlInfo.local.toUpperCase(),
            text: (this.ctrlInfo.local.toUpperCase() == "A") ? strings.controllerA : strings.controllerB
        }]
    } else {
        C = [{
            value: "A",
            text: strings.controllerA
        }, {
            value: "B",
            text: strings.controllerB
        }]
    }
    D.widgets = [new FormWidget({
        name: "inputForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "dgName",
            row: 0,
            col: 1,
            label: strings.modifyDiskGroupAction.nameLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "dgType",
            row: 0,
            col: 3,
            label: strings.addDiskGroup.typeLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true,
            wrapText: true
        }), new TextWidget({
            name: "dgOwner",
            row: 1,
            col: 1,
            label: strings.modifyDiskGroupAction.ownerLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "dgDataProtection",
            row: 1,
            col: 3,
            label: strings.addDiskGroup.dataProtectionLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true,
            wrapText: true
        })]
    }), this.driveSelectionWidget = new DriveSelectionWidget({
        name: "drives",
        mode: "expand",
        bottomMargin: true,
        changeCallback: createObjectCallback(this, this._selectionChange)
    })];
    ActionPanel.call(this, D);
    this.class_name = "ExpandDiskGroupAction"
}
ExpandDiskGroupAction.prototype = new ActionPanel();
ExpandDiskGroupAction.prototype.constructor = "ExpandDiskGroupAction";
ExpandDiskGroupAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var G = TopicPanel.getSelected(["disk-groups"], 1);
    if (G) {
        var H = DC.diskGroupsSerial[G[0].key];
        if (!H) {
            return false
        }
        var E = H.get("serial_number");
        var D = H.get("raidtype");
        var F = parseInt(H.get("diskcount"));
        var C = false;
        if (D == "ADAPT") {
            C = true
        } else {
            if (H.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
                switch (D) {
                    case "RAID0":
                    case "RAID3":
                    case "RAID5":
                    case "RAID6":
                    case "RAID10":
                        if (F < 16) {
                            C = true
                        }
                        break;
                    case "RAID50":
                        if (F < 32) {
                            C = true
                        }
                        break;
                    case "NRAID":
                    case "RAID1":
                    default:
                        break
                }
            }
        }
        if (C) {
            return G
        } else {
            return strings.menuTips.dgExpansion
        }
    } else {
        return strings.menuTips.selectSingle(strings.diskgroup)
    }
};
ExpandDiskGroupAction.prototype.showing = function() {
    var D = [{
        value: "0",
        text: "0"
    }];
    var G = "0";
    var E = TopicPanel.getSelected(["disk-groups"], 1);
    var H = DC.diskGroupsSerial[E[0].key];
    var C = H.get("raidtype");
    switch (C) {
        case "RAID10":
            D = [{
                value: "0",
                text: "0"
            }, {
                value: "1",
                text: "1"
            }, {
                value: "2",
                text: "2"
            }];
            G = "1";
            break;
        case "RAID50":
            D = [{
                value: "0",
                text: "0"
            }, {
                value: "1",
                text: "1"
            }];
            G = "1";
            break;
        default:
            break
    }
    var F = {
        dgName: {
            text: H.get("name"),
            setOrig: true
        },
        dgType: {
            text: H.get("storage_type"),
            setOrig: true
        },
        dgDataProtection: {
            text: H.get("raidtype"),
            setOrig: true
        },
        dgOwner: {
            text: H.get("preferred_owner"),
            setOrig: true
        },
        drives: {
            mode: "expand",
            expand: true,
            spares: false,
            expandArrays: G,
            diskGroupSerial: H.get("serial_number"),
            visibility: "visible",
            disable: true
        }
    };
    this.update(F);
    this.okEnabled(false);
    $(".actionTray", this.elements).css("width", "99%")
};
ExpandDiskGroupAction.prototype._selectionChange = function(D, C) {
    if (C.getValid()) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
ExpandDiskGroupAction.prototype._modify = function() {
    var G = {};
    this.retrieve(G);
    var H = [];
    var I = 0;
    var J = "";
    var N;
    var L = strings.modifyDiskGroupAction.confirmExpandMsg;
    if (session.brand != undefined && session.brand.toLowerCase() == "hp") {
        L = strings.modifyDiskGroupAction.confirmExpandMsgHP
    }
    J += L + "<br/><br/>";
    I++;
    var E = this.previousSelection[0].getObject();
    if (E.selectedDrivesWillResultInMixedFormat(G.drives)) {
        J += strings.modifyDiskGroupAction.sectorFormatWarning + "<br/><br/>";
        I++
    }
    if (hasDegradedDisk(G.disks.selected)) {
        J += strings.usingDegradedDisk + "<br/><br/>";
        I++
    }
    var D = {
        vdisk: E.get("serial_number"),
        raidLevel: E.get("raidtype")
    };
    var K = [];
    for (var F = 0; F < G.disks.selected.length; F++) {
        var M = G.disks.selected[F].key;
        var C = M.substr(M.lastIndexOf("_") + 1);
        K[F] = C
    }
    D.disks = K;
    H.push({
        name: "expandDiskGroup",
        command: MC.expandDiskGroup,
        data: D,
        options: {
            processingMsg: strings.modifyDiskGroupAction.doingExpand,
            failureMsg: strings.modifyDiskGroupAction.failedExpand,
            callback: createObjectCallback(this, this._finishedCallback)
        }
    });
    if (I > 0) {
        J += strings.continueMessage;
        if (I > 1) {
            J = strings.pleaseConfirmTheFollowing + J
        }
    }
    if (G.drives.maxLimit) {
        N = J;
        J = strings.addDiskGroup.maxLimitWarning
    }
    if (H.length) {
        MC.execCommandList(H, {
            confirmMsg: (isQuantumSystem()) ? false : J,
            confirm2Msg: N,
            successMsg: strings.modifyDiskGroupAction.success,
            closeActionOn: "success"
        })
    }
};
ExpandDiskGroupAction.prototype._finishedCallback = function(C) {
    if (!C.success) {
        this.driveSelectionWidget.selectedDrives = 0;
        this.driveSelectionWidget.updateSets()
    }
};

function ModifyDiskGroupAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ModifyDiskGroupAction";
    D.okCallback = createObjectCallback(this, this._modify);
    D.okButtonText = strings.modifyDiskGroupAction.okButtonText;
    this.ctrlInfo = getControllerInfo();
    var C = [];
    if (this.ctrlInfo.single) {
        C = [{
            value: this.ctrlInfo.local.toUpperCase(),
            text: (this.ctrlInfo.local.toUpperCase() == "A") ? strings.controllerA : strings.controllerB
        }]
    } else {
        C = [{
            value: "A",
            text: strings.controllerA
        }, {
            value: "B",
            text: strings.controllerB
        }]
    }
    D.widgets = [new FormWidget({
        name: "inputForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "dgName",
            row: 0,
            col: 1,
            label: strings.modifyDiskGroupAction.nameLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true,
            wrapText: true
        }), new TextInputWidget({
            name: "dgNewName",
            row: 1,
            col: 1,
            label: strings.modifyDiskGroupAction.newNameLabel,
            rules: {
                dhName: true,
                utf8length: RI.getMaxNameLength(),
                diskGroupExists: true
            },
            bottomMargin: true,
            leftMargin: true,
            changeCallback: createObjectCallback(this, this._changeCallback)
        }), new OptionInputWidget({
            name: "dgOwner",
            row: 2,
            col: 1,
            label: strings.modifyDiskGroupAction.ownerLabel,
            bottomMargin: true,
            leftMargin: true,
            rightMargin: true,
            multiple: false,
            values: C,
            changeCallback: createObjectCallback(this, this._changeCallback)
        }), new CheckboxInputWidget({
            name: "dgSpinDownDelayEnabled",
            row: 3,
            col: 1,
            label: strings.modifyDiskGroupAction.enableSpinDown,
            leftMargin: true,
            bottomMargin: true,
            rules: {
                required: false
            },
            changeCallback: createObjectCallback(this, this.dsdChange)
        }), new TextInputWidget({
            name: "dgSpinDownDelay",
            row: 4,
            col: 1,
            label: strings.modifyDiskGroupAction.spinDownDelay,
            labelOptions: {
                bottomMargin: true
            },
            leftMargin: true,
            bottomMargin: true,
            rules: {
                range: [0, 360]
            },
            messages: {
                range: strings.modifyDiskGroupAction.dgDelayRangeError
            },
            changeCallback: createObjectCallback(this, this._changeCallback)
        }), new TextInputWidget({
            name: "dgScrubDuration",
            row: 5,
            col: 1,
            label: strings.modifyDiskGroupAction.scrubDuration,
            labelOptions: {
                bottomMargin: true
            },
            leftMargin: true,
            bottomMargin: true,
            rules: {
                range: [0, 1080]
            },
            messages: {
                range: strings.modifyDiskGroupAction.scrubRangeError
            },
            changeCallback: createObjectCallback(this, this._changeCallback)
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "ModifyDiskGroupAction"
}
ModifyDiskGroupAction.prototype = new ActionPanel();
ModifyDiskGroupAction.prototype.constructor = "ModifyDiskGroupAction";
ModifyDiskGroupAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = TopicPanel.getSelected(["disk-groups"], 1);
    if (C) {
        return C
    } else {
        return strings.menuTips.selectSingle(strings.diskgroup)
    }
};
ModifyDiskGroupAction.prototype.showing = function() {
    var H = [{
        value: "0",
        text: "0"
    }];
    var G = "0";
    var J = this.previousSelection[0].getObject();
    if (!J) {
        return
    }
    this.dgSerial = J.get("serial_number");
    this.dgRaidLevel = J.get("raidtype");
    var D = false;
    var E = false;
    var K = false;
    var L = 0;
    var F = 0;
    if (J.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
        D = true;
        var I = J.getInt("disk_dsd_enable_vdisk_numeric");
        if (I == 0) {
            K = false
        } else {
            K = true
        }
        if (J.get("disk_dsd_delay_vdisk")) {
            L = J.get("disk_dsd_delay_vdisk")
        }
        if (RI.hasFeature("scrubDuration")) {
            E = true;
            F = J.get("scrub_duration_goal")
        }
    }
    var C = {
        dgName: {
            text: J.get("name"),
            setOrig: true
        },
        dgNewName: {
            value: "",
            setOrig: true
        },
        dgOwner: {
            value: J.get("preferred_owner"),
            setOrig: true,
            visibility: (D ? "visible" : "collapse")
        },
        dgSpinDownDelayEnabled: {
            value: K,
            setOrig: true,
            visibility: (D ? "visible" : "collapse")
        },
        dgSpinDownDelay: {
            value: L,
            setOrig: true,
            disable: (K ? false : true),
            visibility: (D ? "visible" : "collapse")
        },
        dgScrubDuration: {
            value: F,
            setOrig: true,
            visibility: (E ? "visible" : "collapse")
        },
        subGroups: {
            disable: true,
            values: H,
            value: G,
            visibility: "collapse"
        }
    };
    this.update(C)
};
ModifyDiskGroupAction.prototype.dsdChange = function(D) {
    if (D) {
        if (D.dgSpinDownDelayEnabled.value) {
            var C = {
                dgSpinDownDelay: {
                    disable: false
                }
            };
            if (D.dgSpinDownDelayEnabled.valueChanged) {
                C.dgSpinDownDelay.value = 15
            }
        } else {
            var C = {
                dgSpinDownDelay: {
                    disable: true,
                    value: 0
                }
            }
        }
        this.update(C);
        this._changeCallback()
    }
};
ModifyDiskGroupAction.prototype._changeCallback = function(G, D, E) {
    var C = {};
    this.retrieve(C);
    var F = false;
    if (C.dgNewName.valueChanged || C.dgOwner.valueChanged || (C.dgSpinDownDelay.value && C.dgSpinDownDelay.valueChanged) || C.dgSpinDownDelayEnabled.valueChanged || C.dgScrubDuration.valueChanged) {
        F = true
    }
    this.okEnabled(F)
};
ModifyDiskGroupAction.prototype._modify = function() {
    var H = {};
    this.retrieve(H);
    var G = [];
    var F = 0;
    var I = "";
    var C = this.previousSelection[0].getObject().get("name");
    if (H.dgNewName.valueChanged || H.dgOwner.valueChanged || (H.dgSpinDownDelay.value && H.dgSpinDownDelay.valueChanged) || H.dgSpinDownDelayEnabled.valueChanged || H.dgScrubDuration.valueChanged) {
        var E = {
            dgSerial: this.dgSerial
        };
        var D = "";
        if (H.dgNewName.valueChanged) {
            E.dgName = H.dgNewName.value;
            D = strings.modifyDiskGroupAction.nameParam
        }
        if (H.dgOwner.valueChanged) {
            E.dgOwner = H.dgOwner.value;
            if (D != "") {
                D += " " + strings.and + " "
            }
            D += strings.modifyDiskGroupAction.ownerParam;
            I += strings.modifyDiskGroupAction.confirmChangeOwner + "<br/><br/>";
            F++
        }
        if (H.dgSpinDownDelayEnabled.valueChanged || H.dgSpinDownDelay.valueChanged) {
            E.dgSpinEnabled = H.dgSpinDownDelayEnabled.value;
            E.dgSpinDelay = H.dgSpinDownDelay.value
        }
        if (H.dgScrubDuration.valueChanged) {
            E.dgScrubDurationGoal = H.dgScrubDuration.value
        }
        G.push({
            name: "setDiskGroup",
            command: MC.setDiskGroup,
            data: E,
            options: {
                processingMsg: strings.modifyDiskGroupAction.doingDataChange(D),
                failureMsg: strings.modifyDiskGroupAction.failedDataChange
            }
        })
    }
    if (F > 0) {
        I += strings.continueMessage;
        if (F > 1) {
            I = strings.pleaseConfirmTheFollowing + I
        }
    }
    if (G.length) {
        MC.execCommandList(G, {
            confirmMsg: (isQuantumSystem()) ? false : I,
            successMsg: strings.modifyDiskGroupAction.success,
            closeActionOn: "success"
        })
    }
};

function RemoveDiskGroupsAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveDiskGroupsAction";
    C.okCallback = createObjectCallback(this, this._remove);
    C.width = 300;
    C.widgets = [new WidgetContainer({
        name: "removeWC",
        widgets: [new TextWidget({
            name: "diskGroupNamesText",
            label: strings.DiskGroups,
            classes: "scrollText100",
            bottomMargin: true
        }), new TextWidget({
            name: "warningText"
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveDiskGroupsAction"
}
RemoveDiskGroupsAction.prototype = new ActionPanel();
RemoveDiskGroupsAction.prototype.constructor = RemoveDiskGroupsAction;
RemoveDiskGroupsAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var I = TopicPanel.getSelected(["disk-groups"], 20);
    var D = 0;
    var E = false;
    var Q = false;
    var C = false;
    for (var R in DC.diskGroups) {
        if (DC.diskGroups[R].getInt("storage_type_numeric")) {
            D++
        }
    }
    if (DC.peerConnections) {
        var G = objectCount(DC.peerConnections, APIObject);
        if (G) {
            E = true
        }
    }
    if (I) {
        for (var P = 0; P < I.length; P++) {
            var S = I[P].getObject();
            var L = S.getInt("storage_type_numeric");
            var N = S.get("pool");
            var O = DC.pools[N];
            var H = S.getInt("status_numeric");
            if (typeof O == "undefined") {
                if (H == DISK_GROUP_STATE.QTOF) {
                    return strings.menuTips.quarantinedDiskGroup
                }
                if (H == DISK_GROUP_STATE.OFF) {
                    return I
                }
                return I
            }
            if (L == STORAGE_MODELS.LINEAR) {
                Q = true
            } else {
                if (L == STORAGE_MODELS.PAGED) {
                    C = true
                }
            }
            if (I.length == O.getNumDiskGroups() && C) {
                for (var M in O.volumes) {
                    var K = O.volumes[M];
                    if (MC.volumeCopySet != undefined) {
                        var F = MC.volumeCopySet.data.objects;
                        for (var J = 0; J < F.length; J++) {
                            if (F[J].get("source_pool_name") === O.get("name") && F[J].get("source_volume") === K.get("volume_name")) {
                                return strings.menuTips.volumeCopyInProgress
                            }
                        }
                    }
                    if (K.get("replication_set")) {
                        return strings.menuTips.replicationSetExists
                    }
                }
            }
        }
        if (Q && C) {
            return strings.menuTips.selectRangeOfType(1, 20, strings.DiskGroups, strings.classStr)
        } else {
            if (C && I.length == D && E) {
                return strings.menuTips.peerConnectionExists
            } else {
                return I
            }
        }
    } else {
        return strings.menuTips.selectRangeOfType(1, 20, strings.DiskGroups, strings.classStr)
    }
};
RemoveDiskGroupsAction.prototype.showing = function() {
    var F = this.previousSelection;
    this.diskGroupSerials = [];
    var G = [];
    var L = {};
    var H = {};
    var M = "";
    for (var O = 0; O < F.length; O++) {
        var E = F[O].getObject();
        var D = E.get("name");
        var C = E.get("serial_number");
        var K = E.get("pool");
        G.push(D);
        this.diskGroupSerials.push(C);
        if (E.getInt("storage_tier_numeric") != TIERS.READCACHE) {
            if (!H[K]) {
                H[K] = []
            }
            H[K].push(D)
        }
    }
    if (G && G.length == 1) {
        this.dgLabel = strings.DiskGroup
    } else {
        if (G && G.length > 1) {
            this.dgLabel = strings.DiskGroups;
            this.multiple = true
        }
    }
    L.diskGroupNamesText = {
        text: MC.getItemList(G, true),
        label: this.dgLabel
    };
    var J = strings.removeDiskGroups.standardWarning(this.dgLabel.toLowerCase());
    this.displayDeletePoolMsg = false;
    this.deletePoolMsg = strings.removeDiskGroups.deletePoolWarning;
    this.deleteVolsMsg = "";
    for (var I in H) {
        var P = 0;
        var N = DC.pools[I];
        if (typeof N == "undefined") {
            for (var O in DC.pools) {
                if (DC.pools[O].diskGroupsSerial[C]) {
                    N = DC.pools[O];
                    break
                }
            }
        }
        if (typeof N != "undefined") {
            if (N.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL) {
                if (H[I].length >= N.getNumDiskGroups()) {
                    P = propertyCount(N.volumes)
                }
            } else {
                P = propertyCount(N.volumes)
            }
        }
        if (P > 0) {
            this.displayDeletePoolMsg = true;
            this.deleteVolsMsg += strings.removeDiskGroups.poolWithVolumes(I, P, (P == 1 ? strings.volume : strings.volumes))
        }
    }
    L.warningText = {
        text: J
    };
    this.update(L);
    this.okEnabled(true, true)
};
RemoveDiskGroupsAction.prototype._remove = function() {
    var D;
    var C = {
        diskGroups: this.diskGroupSerials
    };
    if (this.displayDeletePoolMsg) {
        D = this.deletePoolMsg + strings.removeDiskGroups.deletePoolsSummary + this.deleteVolsMsg + strings.removeDiskGroups.standardWarning(strings.pools)
    }
    MC.removeDiskGroups(C, {
        dialog: true,
        includeInfo: true,
        confirmMsg: D,
        processingMsg: strings.removeDiskGroups.processing(this.dgLabel.toLowerCase()),
        failureMsg: strings.removeDiskGroups.failure(this.dgLabel.toLowerCase()),
        successMsg: strings.removeDiskGroups.success,
        okLabel: strings.Yes,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "any"
    })
};

function PoolSettingsAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "PoolSettingsAction";
    this.changeCallback = createObjectCallback(this, this._changeCallback);
    D.okCallback = createObjectCallback(this, this.okCallback);
    this.changed = {};
    var C = 0;
    D.widgets = new FormWidget({
        name: "psaForm",
        tableLayout: true,
        widgets: [new TableWidget({
            name: "threshTbl",
            widgets: [new TextWidget({
                name: "poolToChange",
                row: ++C,
                col: 0,
                text: "Placeholder Text Changed In Showing",
                bottomMargin: true
            }), new TextInputWidget({
                row: ++C,
                col: 1,
                name: "lowThreshold",
                size: 2,
                label: strings.poolSettings.poolLow,
                labelOptions: {
                    classes: "noWrap"
                },
                rules: {
                    required: true,
                    digits: true,
                    range: [0, 99]
                },
                changeCallback: this.changeCallback,
                bottomMargin: true,
                leftMargin: true
            }), new TextInputWidget({
                row: ++C,
                col: 1,
                name: "midThreshold",
                size: 2,
                label: strings.poolSettings.poolMid,
                labelOptions: {
                    classes: "noWrap"
                },
                rules: {
                    required: true,
                    digits: true,
                    range: [0, 99]
                },
                changeCallback: this.changeCallback,
                bottomMargin: true,
                leftMargin: true
            }), new TextWidget({
                row: ++C,
                col: 1,
                name: "highThreshold",
                classes: "textCenter",
                label: strings.poolSettings.poolHigh,
                labelOptions: {
                    classes: "noWrap"
                },
                bottomMargin: true,
                leftMargin: true
            }), new CheckboxInputWidget({
                row: ++C,
                col: 0,
                colSpan: 3,
                name: "overcommit",
                label: strings.poolSettings.overcommit,
                singleCell: true,
                changeCallback: this.changeCallback
            })]
        })]
    });
    ActionPanel.call(this, D);
    this.class_name = "PoolSettingsAction"
}
PoolSettingsAction.prototype = new ActionPanel();
PoolSettingsAction.prototype.constructor = PoolSettingsAction;
PoolSettingsAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = TopicPanel.getSelected(["pools"], 1);
    if (!C) {
        return strings.menuTips.selectSingle(strings.virtual_pool)
    } else {
        if (C.length > 1) {
            return strings.menuTips.selectSingle(strings.virtual_pool)
        }
        var D = C[0].getObject().get("storage_type_numeric");
        if (D != STORAGE_CLASS.VIRTUAL) {
            return strings.menuTips.selectSingle(strings.virtual_pool)
        }
        return C
    }
};
PoolSettingsAction.prototype.showing = function() {
    this.resetSize({
        extraHeight: true
    });
    var F = this.previousSelection;
    var G = F[0].getObject();
    var D = DC.poolsSerial[G.get("serial_number")];
    this.poolName = D.get("name");
    this.highThreshold = parseInt(D.get("high_threshold"), 10);
    var E = D.get("overcommit_numeric");
    var C = (D.getInt("over_committed_numeric")) ? true : false;
    this.update({
        lowThreshold: {
            value: parseInt(D.get("low_threshold"), 10),
            setOrig: true
        },
        midThreshold: {
            value: parseInt(D.get("middle_threshold"), 10),
            setOrig: true
        },
        highThreshold: {
            text: this.highThreshold,
            setOrig: true
        },
        poolToChange: {
            text: strings.poolSettings.poolToChange(this.poolName)
        },
        overcommit: {
            setOrig: true,
            value: (E == 0 ? false : true),
            disable: C
        }
    });
    this._setThresholdRules();
    this.options.widgets.resetValidation()
};
PoolSettingsAction.prototype._changeCallback = function(E, C, D) {
    if (C.valueChanged) {
        this.changed[C.name] = true
    } else {
        delete this.changed[C.name]
    }
    if (propertyCount(this.changed) > 0 && this.options.widgets.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    if (D) {
        this._setThresholdRules()
    }
};
PoolSettingsAction.prototype._setThresholdRules = function() {
    var D = {};
    this.retrieve(D, true);
    var F = parseInt(D.lowThreshold.value, 10);
    var G = parseInt(D.midThreshold.value, 10);
    var E = this.highThreshold;
    var C = {};
    if (D.midThreshold.valueChanged && D.lowThreshold.valueChanged) {
        C.midThreshold = {
            rules: {
                required: true,
                number: true,
                range: [F, E]
            }
        };
        C.lowThreshold = {
            rules: {
                required: true,
                number: true,
                range: [0, G]
            }
        }
    } else {
        if (D.midThreshold.valueChanged && ((F > G) || (G > E))) {
            C.midThreshold = {
                rules: {
                    required: true,
                    number: true,
                    range: [F, E]
                }
            }
        } else {
            if (D.lowThreshold.valueChanged && F > G) {
                C.lowThreshold = {
                    rules: {
                        required: true,
                        number: true,
                        range: [0, G]
                    }
                }
            }
        }
    }
    this.update(C)
};
PoolSettingsAction.prototype.okCallback = function() {
    var D = {};
    this.retrieve(D);
    if (!D.psaForm.valid) {
        return
    }
    var C = {
        pool: this.poolName
    };
    if (D.overcommit.valueChanged) {
        C.overcommit = D.overcommit.value
    }
    if (D.lowThreshold.valueChanged) {
        C.lowThreshold = D.lowThreshold.value
    }
    if (D.midThreshold.valueChanged) {
        C.midThreshold = D.midThreshold.value
    }
    MC.setPool(C, {
        dialog: true,
        processingMsg: strings.poolSettings.poolProcessing(this.poolName),
        failureMsg: strings.poolSettings.poolFailure(this.poolName),
        successMsg: strings.poolSettings.success,
        closeActionOn: "success"
    })
};

function diskGroupUtilities(F) {
    if (arguments.length == 0) {
        return
    }
    F.name = "diskGroupUtilities";
    F.title = strings.diskGroupUtilities.title;
    F.width = 240;
    var D = createObjectCallback(this, this.verifyCallback);
    var C = createObjectCallback(this, this.abortVerifyCallback);
    var E = createObjectCallback(this, this.scrubCallback);
    var G = createObjectCallback(this, this.abortScrubCallback);
    this.jobRunning = false;
    F.widgets = [new TextWidget({
        name: "name",
        row: 1,
        col: 1,
        label: strings.addDiskGroup.nameLabel,
        labelOptions: {
            row: 1,
            col: 0,
            bottomMargin: true
        },
        bottomMargin: true,
        rightMargin: true,
        rules: {
            required: true,
            dhName: true,
            utf8length: RI.getMaxNameLength(),
            diskGroupExists: true
        },
        messages: {
            required: strings.addDiskGroup.nameErr
        }
    }), new TextWidget({
        name: "jobRunning",
        visibility: "collapse",
        text: "",
        bottomMargin: true
    }), new TextWidget({
        name: "jobInformation",
        visibility: "collapse",
        text: "",
        bottomMargin: true
    }), new LabeledWidgetContainer({
        label: strings.diskGroupUtilities.verifyLabel,
        widgets: [new ButtonContainer({
            name: "verifybc",
            orientation: "horizontal",
            widgets: [new ButtonWidget({
                name: "verifyDiskGroup",
                text: strings.diskGroupUtilities.verify,
                primary: true,
                click: D
            }), new ButtonWidget({
                name: "abortVerifyDiskGroup",
                text: strings.diskGroupUtilities.abortVerify,
                primary: true,
                click: C
            })]
        })]
    }), new LabeledWidgetContainer({
        label: strings.diskGroupUtilities.scrubLabel,
        widgets: [new ButtonContainer({
            name: "scrubbc",
            orientation: "horizontal",
            widgets: [new ButtonWidget({
                name: "scrubDiskGroup",
                text: strings.diskGroupUtilities.scrub,
                primary: true,
                click: E
            }), new ButtonWidget({
                name: "abortScrubDiskGroup",
                text: strings.diskGroupUtilities.abortScrub,
                primary: true,
                click: G
            })]
        })]
    })];
    ActionPanel.call(this, F);
    this.class_name = "diskGroupUtilities"
}
diskGroupUtilities.prototype = new ActionPanel();
diskGroupUtilities.prototype.constructor = diskGroupUtilities;
diskGroupUtilities.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = TopicPanel.getSelected(["disk-groups"], 20);
    if (!C) {
        return strings.menuTips.selectSingle(strings.diskgroup)
    } else {
        if (C.length > 1) {
            return strings.menuTips.selectSingle(strings.diskgroup)
        }
        return C
    }
};
diskGroupUtilities.prototype.showing = function() {
    this.subscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.handlePoolsData)
    });
    var C = this.previousSelection[0].getObject();
    var D = {
        name: {
            text: C.get("name")
        },
        verifybc: {
            visibility: "none"
        }
    };
    if (C.getPropertyValue("raidtype_numeric") == DATAPROTECTIONLEVEL.ADAPT) {
        D.verifyDiskGroup = {
            disable: true
        }
    }
    this.update(D)
};
diskGroupUtilities.prototype.handlePoolsData = function(G) {
    var M = this.previousSelection[0].getObject();
    var N = "collapse";
    var L = "";
    var C = M.get("name");
    var I = jobNumericToString(M.getPropertyValue("current_job_numeric"));
    var E = jobToPercent(M.getPropertyValue("current_job_completion"));
    if (E == 100) {
        E = 0
    }
    var J = true;
    var O = true;
    var F = true;
    if (!I || I.length == 0) {
        if (this.jobRunning) {
            this.jobRunning = false;
            var K = 240;
            var D = 240
        }
        F = false;
        L = strings.diskGroupUtilities.noJobRunning
    } else {
        N = "visible";
        if (!this.jobRunning) {
            this.jobRunning = true;
            var K = 300;
            var D = 264
        }
        L = strings.diskGroupUtilities.needToAbort;
        if (I == strings.VRSC) {
            J = false
        } else {
            if (I == strings.VRFY) {
                O = false
            } else {
                L = strings.diskGroupUtilities.needToWait
            }
        }
    }
    var H = {
        verifyDiskGroup: {
            disable: F
        },
        abortVerifyDiskGroup: {
            disable: O
        },
        scrubDiskGroup: {
            disable: F
        },
        abortScrubDiskGroup: {
            disable: J
        },
        jobRunning: {
            visibility: N,
            text: htmlProgressBar({
                caption: strings.diskGroupUtilities.jobRunning(I, E),
                percent: E,
                width: 100
            })
        },
        jobInformation: {
            text: L
        }
    };
    this.update(H);
    if (typeof K != "undefined") {
        this.resetSize({
            shrink: true,
            width: K
        })
    }
};
diskGroupUtilities.prototype.verifyCallback = function() {
    var D = {
        vdiskSerial: this.previousSelection[0].getObject().get("serial_number")
    };
    var C = {
        dialog: true,
        processingMsg: strings.diskGroupUtilities.verifyProcessingMsg,
        failureMsg: strings.diskGroupUtilities.verifyFail,
        successMsg: strings.diskGroupUtilities.verifySuccess,
        closeActionOn: "none"
    };
    MC.verifyVdisk(D, C)
};
diskGroupUtilities.prototype.abortVerifyCallback = function() {
    var D = {
        vdiskSerial: this.previousSelection[0].getObject().get("serial_number")
    };
    var C = {
        dialog: true,
        processingMsg: strings.diskGroupUtilities.abortVerifyProcessing,
        failureMsg: strings.diskGroupUtilities.abortVerifyFail,
        successMsg: strings.diskGroupUtilities.abortVerifySuccess,
        closeActionOn: "none"
    };
    MC.abortVerifyVdisk(D, C)
};
diskGroupUtilities.prototype.scrubCallback = function() {
    var D = {
        vdiskSerial: this.previousSelection[0].getObject().get("serial_number")
    };
    var C = {
        dialog: true,
        processingMsg: strings.diskGroupUtilities.scrubProcessing,
        failureMsg: strings.diskGroupUtilities.scrubFail,
        successMsg: strings.diskGroupUtilities.scrubSuccess,
        closeActionOn: "none"
    };
    MC.mediaScrubVdisk(D, C)
};
diskGroupUtilities.prototype.abortScrubCallback = function() {
    var D = {
        vdiskSerial: this.previousSelection[0].getObject().get("serial_number")
    };
    var C = {
        dialog: true,
        processingMsg: strings.diskGroupUtilities.abortScrubProcessing,
        failureMsg: strings.diskGroupUtilities.abortScrubFail,
        successMsg: strings.diskGroupUtilities.abortScrubSuccess,
        closeActionOn: "none"
    };
    MC.abortMediaScrubVdisk(D, C)
};

function DequarantineDiskGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DequarantineDiskGroupAction";
    C.title = strings.actions.DequarantineDiskGroupAction;
    C.width = 300;
    C.height = 100;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "dgLabel",
        label: strings.dequarantine.dgLabel
    }), new TextWidget({
        name: "confirmMsg",
        text: strings.dequarantine.infoMsg
    })];
    ActionPanel.call(this, C);
    this.class_name = "DequarantineDiskGroupAction"
}
DequarantineDiskGroupAction.prototype = new ActionPanel();
DequarantineDiskGroupAction.prototype.constructor = DequarantineDiskGroupAction;
DequarantineDiskGroupAction.getMenuState = function() {
    if (RI.pagedOnly()) {
        return false
    }
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D = TopicPanel.getSelected(["disk-groups"], 20);
    if (!D) {
        return strings.menuTips.selectSingle(strings.dequarantine.quarantinedDiskGroup)
    } else {
        if (D.length > 1) {
            return strings.menuTips.selectSingle(strings.dequarantine.quarantinedDiskGroup)
        }
        var C = D[0].getObject().get("status");
        if (C != "QTOF" && C != "QTDN" && C != "QTCR") {
            return strings.menuTips.selectSingle(strings.dequarantine.quarantinedDiskGroup)
        }
        return D
    }
};
DequarantineDiskGroupAction.prototype.showing = function() {
    var C = this.previousSelection[0].getObject().get("name");
    var D = {
        dgLabel: {
            text: C
        }
    };
    this.update(D);
    this.okEnabled(true)
};
DequarantineDiskGroupAction.prototype.okCallback = function() {
    var C = {
        dialog: true,
        confirmMsg: strings.dequarantine.confirmMsg,
        processingMsg: strings.dequarantine.processingMsg,
        failureMsg: strings.dequarantine.error,
        successMsg: strings.dequarantine.success,
        closeActionOn: "success"
    };
    var D = {
        vdiskSerial: this.previousSelection[0].getObject().get("serial_number")
    };
    MC.dequarantineVdisk(D, C)
};

function ChangeSparesAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ChangeSparesAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.cancelCallback = createObjectCallback(this, this.cancelCallback);
    C.okButtonText = strings.changeSpares.buttonText;
    this.okEnabled(false);
    C.widgets = [new WidgetContainer({
        name: "addDiskGroupForm",
        width: "800px",
        tableLayout: true,
        widgets: [this.changeSpares = new ChangeSpareWidget({
            changeCallback: createObjectCallback(this, this._selectionChange)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ChangeSparesAction"
}
ChangeSparesAction.prototype = new ActionPanel();
ChangeSparesAction.prototype.constructor = ChangeSparesAction;
ChangeSparesAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!$.isEmptyObject(DC.diskGroups)) {
        var F = false;
        for (var E in DC.diskGroups) {
            var D = DC.diskGroups[E];
            var C = D.getPropertyValue("raidtype_numeric");
            if (C != DATAPROTECTIONLEVEL.ADAPT) {
                F = true;
                break
            }
        }
        if (!F) {
            return strings.changeSpares.notSupported
        } else {
            return []
        }
    }
};
ChangeSparesAction.prototype.cancelCallback = function() {
    return true
};
ChangeSparesAction.prototype.okCallback = function() {
    this.changeSpares.addSpare()
};
ChangeSparesAction.prototype._selectionChange = function(D, C) {
    this.okEnabled(C.isValid())
};

function ChangeSpareWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.dedicatedDiskGroups = [];
    this.addDrives = [];
    C.name = "ChangeSpareWidget";
    C.widgets = [new FormWidget({
        name: "wrapper",
        classes: "nowrap",
        widgets: [new WidgetContainer({
            name: "leftSection",
            classes: "leftSection",
            width: 600,
            widgets: [new WidgetContainer({
                name: "spareWidgets",
                widgets: [new TextWidget({
                    name: "existingTitle",
                    classes: "stepNumText",
                    text: strings.changeSpares.existingTitle,
                    topMargin: true
                }), this.existingSpareTable = new TableInator({
                    name: "existingSpareTable",
                    topMargin: true,
                    type: "rawData",
                    selectable: "multiple",
                    metadata: [{
                        sTitle: "key",
                        bVisible: false,
                        bIsKey: true
                    }, {
                        sTitle: strings.Type
                    }, {
                        sTitle: strings.addDiskGroup.location
                    }, {
                        sTitle: strings.addDiskGroup.size
                    }, {
                        sTitle: strings.changeSpares.spareType
                    }, {
                        sTitle: strings.DiskGroup
                    }, {
                        sTitle: strings.addDiskGroup.health
                    }],
                    noFeatures: true,
                    selectCallback: createObjectCallback(this, this.checkRemoveButton)
                }), new ButtonWidget({
                    name: "remove",
                    primary: true,
                    disable: true,
                    classes: "removeButton",
                    topMargin: true,
                    bottomMargin: true,
                    text: strings.removeButtonText,
                    callback: createObjectCallback(this, this.removeSpare)
                }), new TextWidget({
                    name: "addSpareTitle",
                    classes: "addspareTitle stepNumText",
                    text: strings.changeSpares.addSpareTitle
                }), new TextWidget({
                    name: "addSpareText",
                    text: strings.changeSpares.addSpareText,
                    topMargin: true,
                    bottomMargin: true
                }), new TextWidget({
                    name: "addDedSpareText",
                    text: strings.changeSpares.addDedSpareText,
                    topMargin: true,
                    bottomMargin: true
                }), new CheckboxInputWidget({
                    name: "dedicatedSpare",
                    classes: "dedicatedGroupList",
                    label: strings.changeSpares.dedicatedSpare,
                    changeCallback: createObjectCallback(this, this._dedicatedSpareChanged)
                }), new OptionInputWidget({
                    name: "diskGroupList",
                    classes: "dedicatedGroupList",
                    values: this.dedicatedDiskGroups,
                    disable: true,
                    changeCallback: createObjectCallback(this, this._selectDiskGroup)
                }), this.availableDrivesTable = new TableInator({
                    name: "availableDrivesTable",
                    topMargin: true,
                    type: "rawData",
                    selectable: "multiple",
                    metadata: [{
                        sTitle: "key",
                        bVisible: false,
                        bIsKey: true
                    }, {
                        sTitle: strings.Type,
                        bFilterMenu: true
                    }, {
                        sTitle: strings.addDiskGroup.location,
                        sType: "diskslot"
                    }, {
                        sTitle: strings.addDiskGroup.size
                    }, {
                        sTitle: strings.addDiskGroup.health
                    }],
                    dtOptions: {
                        aaSorting: [
                            [2, "asc"]
                        ]
                    },
                    selectCallback: createObjectCallback(this, this.addSparetoList)
                })]
            })]
        })]
    })];
    WidgetContainer.call(this, C);
    this.class_name = "ChangeSpareWidget"
}
ChangeSpareWidget.prototype = new WidgetContainer();
ChangeSpareWidget.prototype.constructor = ChangeSpareWidget;
ChangeSpareWidget.prototype.showing = function() {
    this.poolSubscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.updatePoolsData)
    });
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.updateSpare)
    });
    if (RI.feature("storageModel") == "PAGED") {
        var C = {};
        C.addSpareText = {
            visibility: "visible"
        };
        C.addDedSpareText = {
            visibility: "collapse"
        };
        C.dedicatedSpare = {
            visibility: "collapse"
        };
        C.diskGroupList = {
            visibility: "collapse"
        };
        this.update(C)
    }
    this.populateLinearDiskGroup()
};
ChangeSpareWidget.prototype.hiding = function() {
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.poolsSubscription);
        delete this.poolsSubscription
    }
    if (this.disksSubscription) {
        MC.disksSet.unregister(this.disksSubscription);
        delete this.disksSubscription
    }
};
ChangeSpareWidget.prototype.updatePoolsData = function() {
    this.linearDiskGroups = [];
    for (var C in DC.diskGroups) {
        var D = DC.diskGroups[C];
        if (D.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
            this.linearDiskGroups.push(D.getPropertyValue("name"))
        }
    }
};
ChangeSpareWidget.prototype.updateSpare = function() {
    var I = {};
    this.existingSpares = [];
    this.availableDrives = [];
    var D = strings.na;
    this.globalSpareCount = 0;
    for (var C in DC.disks) {
        var K = DC.disks[C];
        var G = K.getInt("usage_numeric");
        var M = K.getPropertyValue("durable_id");
        if (G == DRIVE_USAGE.GLOBAL_SPARE || G == DRIVE_USAGE.DEDICATED_SPARE) {
            if (G == DRIVE_USAGE.GLOBAL_SPARE) {
                this.globalSpareCount++
            }
            var H = K.getPropertyValue("type");
            var J = K.getPropertyValue("location");
            var L = K.getPropertyValue("size");
            var F = this.interceptHealthHandler(K);
            if (G == DRIVE_USAGE.GLOBAL_SPARE) {
                var E = strings.changeSpares.globalType;
                D = strings.na
            } else {
                var E = strings.changeSpares.dedicatedType;
                D = K.getPropertyValue("disk_group")
            }
            this.existingSpares.push([M, H, J, L, E, D, F])
        } else {
            if (G == DRIVE_USAGE.AVAILABLE) {
                var H = K.getPropertyValue("type");
                var J = K.getPropertyValue("location");
                var L = K.getPropertyValue("size");
                var F = this.interceptHealthHandler(K);
                this.availableDrives.push([M, H, J, L, F])
            }
        }
    }
    I.existingSpareTable = {
        data: this.existingSpares
    };
    I.availableDrivesTable = {
        data: this.availableDrives
    };
    this.update(I)
};
ChangeSpareWidget.prototype.interceptHealthHandler = function(E) {
    var F = E.getPropertyValue("health");
    var C = E.getPropertyValue("health_numeric");
    switch (parseInt(C)) {
        case 0:
            var D = "sortOrder1 healthOk";
            break;
        case 1:
            var D = "sortOrder3 healthDegraded";
            break;
        case 2:
            var D = "sortOrder4 healthBad";
            break;
        case 3:
        default:
            var D = "sortOrder2 healthUnknown";
            break
    }
    return '<div class="healthStyle ' + D + '"><span class="healthText">' + F + "</span></div>"
};
ChangeSpareWidget.prototype.populateLinearDiskGroup = function() {
    var E = {};
    for (var C in DC.diskGroups) {
        var F = DC.diskGroups[C];
        var D = F.getInt("raidtype_numeric");
        if (F.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
            if (D != DATAPROTECTIONLEVEL.RAID0 && D != DATAPROTECTIONLEVEL.NRAID && D != DATAPROTECTIONLEVEL.ADAPT) {
                this.dedicatedDiskGroups.push({
                    value: F.getPropertyValue("name"),
                    text: F.getPropertyValue("name")
                })
            }
        }
    }
    if (this.dedicatedDiskGroups.length > 0) {
        E.diskGroupList = {
            value: this.dedicatedDiskGroups[0].value,
            values: this.dedicatedDiskGroups,
            disable: true
        };
        this.update(E)
    } else {
        E.dedicatedSpare = {
            visibility: "collapse"
        };
        E.diskGroupList = {
            visibility: "collapse"
        };
        E.addDedSpareText = {
            visibility: "collapse"
        };
        this.update(E)
    }
};
ChangeSpareWidget.prototype.checkRemoveButton = function(D, C) {
    this.selectedDisks = [];
    if (D.length > 0) {
        this.update({
            remove: {
                disable: false
            }
        });
        this.selectedDisks = D
    } else {
        this.update({
            remove: {
                disable: true
            }
        })
    }
};
ChangeSpareWidget.prototype.removeSpare = function(D) {
    var E = [];
    if (this.selectedDisks != undefined && this.selectedDisks.length > 0) {
        for (var C = 0; C < this.selectedDisks.length; C++) {
            E[C] = DC.disks[this.selectedDisks[C].key]
        }
        var F = {};
        F.spares = new APIData(E);
        MC.removeDiskSpareSet(F, {
            dialog: true,
            processingMsg: strings.changeSpares.modifying,
            failureMsg: strings.changeSpares.error,
            successMsg: strings.changeSpares.success
        });
        this.update({
            remove: {
                disable: true
            }
        })
    }
};
ChangeSpareWidget.prototype._selectDiskGroup = function(E, C, D) {
    this.diskGroup = E.diskGroupList.value;
    this.updateAvailableDisks(this.diskGroup)
};
ChangeSpareWidget.prototype._dedicatedSpareChanged = function(F, D, E) {
    if (!F.dedicatedSpare.value) {
        var C = {};
        C.diskGroupList = {
            disable: true
        };
        C.availableDrivesTable = {
            data: this.availableDrives
        };
        this.update(C)
    } else {
        var C = {};
        this.retrieve(C);
        this.update({
            diskGroupList: {
                disable: false
            }
        });
        if (C.diskGroupList.value != null || C.diskGroupList.value != "") {
            this.updateAvailableDisks(C.diskGroupList.value)
        }
    }
};
ChangeSpareWidget.prototype.updateAvailableDisks = function(G) {
    var J = {};
    var D = [];
    var K = DC.diskGroups[G];
    var L = K.getInt("min_drive_size_numeric");
    var O = K.getInt("pool_sector_format");
    if (RI.hasFeature("e2ePi")) {
        for (var P in DC.diskGroups.disks) {
            var M = DC.diskGroups.disks[P].getPropertyValue("pi_formatted_numeric");
            break
        }
    }
    for (var I = 0; I < this.availableDrives.length; I++) {
        var E = DC.disks[this.availableDrives[I][0]];
        var H = E.getInt("size_numeric");
        var N = E.getInt("sector_format");
        if (RI.hasFeature("e2ePi")) {
            var C = false;
            var F = E.getInt("min_drive_size_numeric");
            if (F == M) {
                C = true
            } else {
                if ((F == PI_TYPES.T0 || F == PI_TYPES.NA) && (M == PI_TYPES.T0 || M == PI_TYPES.NA)) {
                    C = true
                } else {
                    C = false
                }
            }
            if (!C) {
                continue
            }
        }
        if (O != SECTOR_FORMAT.FMT_MIXED) {
            if (!isQuantumSystem) {
                if (O != N) {
                    this.mixedSector = true
                }
            }
        }
        if (L < H) {
            D.push(this.availableDrives[I])
        }
    }
    J.availableDrivesTable = {
        data: D
    };
    this.update(J)
};
ChangeSpareWidget.prototype.addSparetoList = function(D, C) {
    var E = {};
    this.retrieve(E);
    this.addDrives = D;
    if (D.length > 0 && this.globalSpareCount < 64) {
        if (E.dedicatedSpare.value && (this.globalSpareCount + D.length) > 64) {
            this.valid = false
        } else {
            this.valid = true
        }
    } else {
        this.valid = false
    }
    this.fireChange()
};
ChangeSpareWidget.prototype.isValid = function() {
    return this.valid
};
ChangeSpareWidget.prototype.fireChange = function() {
    if ($.isFunction(this.options.changeCallback)) {
        var C = {};
        if (this.name) {
            this.handleRetrieve(C)
        }
        this.options.changeCallback.call(this, C, this)
    }
};
ChangeSpareWidget.prototype.addSpare = function() {
    var G = {};
    this.retrieve(G);
    var E = "";
    var F = 0;
    var I = [];
    var J = {};
    if (hasDegradedDisk(G.availableDrivesTable.selected)) {
        E += strings.usingDegradedDisk + "<br/><br/>";
        F++
    }
    if (G.dedicatedSpare.value && (G.diskGroupList.value != null || G.diskGroupList.value != "")) {
        var H = G.diskGroupList.value;
        var C = DC.diskGroups[H].getPropertyValue("serial_number");
        if ((this.mixedSector != undefined) && this.mixedSector) {
            E += strings.changeSpares.sectorFormatWarning + "<br/><br/>";
            F++
        }
        if (F > 0) {
            E += strings.continueMessage;
            if (F > 1) {
                E = strings.pleaseConfirmTheFollowing + E
            }
        }
        if (this.addDrives.length > 0) {
            for (var D = 0; D < this.addDrives.length; D++) {
                I[D] = DC.disks[this.addDrives[D].key]
            }
            J.spares = new APIData(I);
            J.vdiskSerial = C;
            MC.modifyVdiskSpareSet(J, {
                dialog: true,
                confirmMsg: (isQuantumSystem()) ? false : E,
                processingMsg: strings.changeDiskGroupSpares.modifying,
                failureMsg: strings.changeDiskGroupSpares.error,
                successMsg: strings.changeDiskGroupSpares.success
            })
        }
    } else {
        if (F > 0) {
            E += strings.continueMessage;
            if (F > 1) {
                E = strings.pleaseConfirmTheFollowing + E
            }
        }
        if (this.addDrives.length > 0) {
            for (var D = 0; D < this.addDrives.length; D++) {
                I[D] = DC.disks[this.addDrives[D].key]
            }
            J.spares = new APIData(I);
            MC.modifyGlobalSpareSet(J, {
                dialog: true,
                confirmMsg: (isQuantumSystem()) ? false : E,
                processingMsg: strings.changeGlobalSparesAction.modifying,
                failureMsg: strings.changeGlobalSparesAction.error,
                successMsg: strings.changeGlobalSparesAction.success
            })
        }
    }
    this.valid = false;
    this.fireChange()
};
CreateVirtualVolumesAction.MAXROWS = 15;
var SNAP_POOL_DIVISOR = 5;

function CreateVirtualVolumesAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "CreateVirtualVolumesAction";
    D.width = 600;
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = createObjectCallback(this, this._changedCallback);
    this.dataOK = true;
    this.overcommitEnabled = {
        A: (DC.pools.A ? DC.pools.A.getInt("overcommit_numeric") != 0 : false),
        B: (DC.pools.B ? DC.pools.B.getInt("overcommit_numeric") != 0 : false)
    };
    this.defaultVolSize = (userBasePreferenceIsDecimal()) ? "100GB" : "100GiB";
    this.qualPerf = strings.createVirtualVolumes.qualPerf;
    this.qualNoAffinity = strings.createVirtualVolumes.qualNoAffinity;
    this.qualArchive = strings.createVirtualVolumes.qualArchive;
    this.nameExcludes = [];
    this.editRow = -1;
    this.numRows = 1;
    D.widgets = [this.header = new TableWidget({
        bottomMargin: true,
        classes: "width100pct",
        widgets: [new LabelWidget({
            row: 0,
            col: 0,
            cellClasses: "textCenter columnA",
            noTerminator: true,
            value: "A",
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 0,
            col: 1,
            cellClasses: "textCenter columnB",
            noTerminator: true,
            value: "B",
            bottomSmallMargin: true
        }), new SpaceMeter({
            name: "cvaCapA",
            cellClasses: "columnA",
            row: 1,
            col: 0,
            height: 22,
            width: 280,
            prec: 0,
            bottomSmallMargin: true,
            rightMargin: true
        }), new SpaceMeter({
            name: "cvaCapB",
            cellClasses: "columnB",
            row: 1,
            col: 1,
            cellClasses: "alignRight",
            height: 22,
            width: 280,
            prec: 0,
            bottomSmallMargin: true
        }), new TextWidget({
            name: "cvaUsageA",
            cellClasses: "columnA",
            row: 2,
            col: 0,
            text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
        }), new TextWidget({
            name: "cvaUsageB",
            cellClasses: "columnB",
            row: 2,
            col: 1,
            text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
        })]
    }), this.table = new TableInator({
        name: "cvaTable",
        noFeatures: true,
        width: 575,
        type: "rawData",
        editCallback: C,
        editingCallback: createObjectCallback(this, this._editingCell),
        bottomMargin: true,
        metadata: this._getTableMeta()
    }), new FormWidget({
        name: "cvaForm",
        widgets: [new TableWidget({
            bottomMargin: true,
            classes: "width100pct",
            widgets: [new WidgetContainer({
                row: 0,
                col: 0,
                cellClasses: "verticalTop",
                classes: "noWrap",
                widgets: []
            }), new WidgetContainer({
                row: 0,
                col: 1,
                cellClasses: "verticalTop",
                bottomMargin: true,
                widgets: [new ButtonContainer({
                    orientation: "horizontal",
                    alignment: "right",
                    widgets: [new ButtonWidget({
                        name: "cvaAddRowButton",
                        text: strings.createVirtualVolumes.addRowLabel,
                        callback: createObjectCallback(this, this._addRow)
                    }), new ButtonWidget({
                        name: "cvaRemoveRowButton",
                        id: "cvaRemoveRowButton",
                        text: strings.createVirtualVolumes.removeRowLabel,
                        disable: true,
                        callback: createObjectCallback(this, this._removeRow)
                    })]
                }), new WidgetContainer({
                    classes: "clearFloats"
                })]
            })]
        })]
    }), new TextWidget({
        name: "cvaSummary",
        text: "",
        topMargin: true
    })];
    ActionPanel.call(this, D);
    this.class_name = "CreateVirtualVolumesAction"
}
CreateVirtualVolumesAction.prototype = new ActionPanel();
CreateVirtualVolumesAction.prototype.constructor = CreateVirtualVolumesAction;
CreateVirtualVolumesAction.getMenuState = function(D) {
    if (!session.hasConfigurationCapability() || !RI.supportsPaged()) {
        return false
    }
    if (!DC.pools.A && !DC.pools.B) {
        return strings.menuTips.noPools
    }
    if (D.actionOptions && D.actionOptions.topic == "Volumes") {
        return []
    } else {
        var C = TopicPanel.getSelected("pools", 1);
        if (C && C[0].getObject().getInt("storage_type_numeric") == VOLUME_CLASS.VIRTUAL) {
            return C
        } else {
            return strings.menuTips.selectSingle(strings.VirtualPool)
        }
    }
};
CreateVirtualVolumesAction.prototype.showing = function() {
    var D = {
        cvaTable: {
            data: []
        }
    };
    if (DC.pools.A) {
        D.cvaUsageA = {
            text: strings.createVirtualVolumes.poolDetails(MC.volumeGroupsSet.numVolsVirtual.A, this.overcommitEnabled.A ? MC.poolsSet.virtUncommittedSize.A.format("scale") : MC.poolsSet.virtPoolAvailSize.A.format("scale"), MC.poolsSet.virtPoolAvailSize.A.format("scale"))
        }
    } else {
        this.header.elements$.find(".columnA").hide()
    }
    if (DC.pools.B) {
        D.cvaUsageB = {
            text: strings.createVirtualVolumes.poolDetails(MC.volumeGroupsSet.numVolsVirtual.B, this.overcommitEnabled.B ? MC.poolsSet.virtUncommittedSize.B.format("scale") : MC.poolsSet.virtPoolAvailSize.B.format("scale"), MC.poolsSet.virtPoolAvailSize.B.format("scale"))
        }
    } else {
        this.header.elements$.find(".columnB").hide()
    }
    this.update(D);
    var E = null;
    if (this.previousSelection.length) {
        var C = this.previousSelection[0].getObject();
        if (C) {
            E = C.get("name")
        }
    }
    this._addRow(true, E);
    this._recalc();
    var F = this.table.nextEditableCell();
    setTimeout(function() {
        $(F).click()
    }, 50)
};
CreateVirtualVolumesAction.prototype._getTableMeta = function() {
    var F = [];
    var E = 0;
    var D = userBasePreferenceIsDecimal();
    this.nameCol = E++;
    F[this.nameCol] = {
        sTitle: strings.createVirtualVolumes.volNameCol,
        editable: {
            rules: {
                required: true,
                dhName: true,
                utf8length: 32
            }
        }
    };
    this.sizeCol = E++;
    F[this.sizeCol] = {
        sTitle: strings.createVirtualVolumes.sizeCol,
        editable: {
            rules: {
                required: true,
                decimalBaseSizeString: D,
                binaryBaseSizeString: !D,
                sizeRange: ["1MB", "128TiB"]
            }
        }
    };
    this.copiesCol = E++;
    F[this.copiesCol] = {
        sTitle: strings.createVirtualVolumes.copiesCol,
        editable: {
            rules: {
                required: true,
                range: [1, (Math.floor(system.maxLuns / 2))]
            }
        }
    };
    if (RI.hasFeature("volTierPreference")) {
        this.qualCol = E++;
        F[this.qualCol] = {
            sTitle: strings.createVirtualVolumes.qualityCol,
            editable: [this.qualPerf, this.qualNoAffinity, this.qualArchive]
        }
    }
    if (RI.hasFeature("e2ePi")) {
        this.piCol = E++;
        F[this.piCol] = {
            sTitle: strings.createVirtualVolumes.piCol,
            editable: [strings.No, strings.Yes]
        }
    }
    this.poolCol = E++;
    F[this.poolCol] = {
        sTitle: strings.createVirtualVolumes.poolCol
    };
    var C = [];
    if (DC.pools.A && (this.overcommitEnabled.A || MC.poolsSet.virtUncommittedSize.A.getRawValue() > 1000000)) {
        C.push("A")
    }
    if (DC.pools.B && (this.overcommitEnabled.B || MC.poolsSet.virtUncommittedSize.B.getRawValue() > 1000000)) {
        C.push("B")
    }
    if (C.length > 1) {
        F[this.poolCol].editable = C
    }
    return F
};
CreateVirtualVolumesAction.prototype._changedCallback = function(E, C) {
    if (C == this.nameCol) {
        var D = this.table.getData(E, C).trim();
        if (DC.volumes[D]) {
            newName = DC.getUnusedKey("volumes", D, this.nameExcludes);
            this.table.cellAdjusted(E, C, strings.createVirtualVolumes.nameChanged);
            this.table.updateData(newName, E, C)
        } else {
            this.table.updateData(D, E, C);
            this.table.cellAdjusted(E, C, "")
        }
    }
    this._recalc()
};
CreateVirtualVolumesAction.prototype._addRow = function(F, D) {
    if (F === true) {
        this.nameExcludes.empty();
        if (D) {
            this.nextPool = D
        } else {
            if (!DC.pools.A) {
                this.nextPool = "B"
            } else {
                if (!DC.pools.B) {
                    this.nextPool = "A"
                } else {
                    if (MC.volumeGroupsSet.numVolsVirtual.B < MC.volumeGroupsSet.numVolsVirtual.A) {
                        this.nextPool = "B"
                    } else {
                        this.nextPool = "A"
                    }
                }
            }
        }
    }
    var C = DC.getUnusedKey("volumes", this.nameExcludes);
    var E = [];
    E[this.nameCol] = C;
    E[this.sizeCol] = this.defaultVolSize;
    E[this.copiesCol] = 1;
    if (this.qualCol) {
        E[this.qualCol] = strings.createVirtualVolumes.qualNoAffinity
    }
    if (this.piCol) {
        E[this.piCol] = strings.No
    }
    E[this.poolCol] = this.nextPool;
    this.table.addData(E);
    if (this.nextPool == "A" && DC.pools.B) {
        this.nextPool = "B"
    } else {
        if (this.nextPool == "B" && DC.pools.A) {
            this.nextPool = "A"
        }
    }
    this._recalc();
    this.numRows++;
    if (this.numRows > CreateVirtualVolumesAction.MAXROWS) {
        this.update({
            cvaAddRowButton: {
                disable: true
            }
        })
    }
};
CreateVirtualVolumesAction.prototype._editingCell = function(C, H, E) {
    if (this.editingTimeout) {
        clearTimeout(this.editingTimeout);
        delete this.editingTimeout
    }
    if (C) {
        this.editing = true;
        this.editRow = H
    } else {
        this.editing = false
    }
    var G = this.table.getData();
    var D = (!C) || (G.length == 1);
    if (D) {
        var F = this;
        this.editingTimeout = setTimeout(function() {
            F.update({
                cvaRemoveRowButton: {
                    disable: D
                }
            })
        }, 200)
    } else {
        this.update({
            cvaRemoveRowButton: {
                disable: D
            }
        })
    }
};
CreateVirtualVolumesAction.prototype._removeRow = function() {
    if (this.editRow != -1) {
        $("#cvaRemoveRowButton").focus()
    }
    this.table.removeRow(this.editRow);
    this._recalc();
    this.numRows--;
    this.update({
        cvaAddRowButton: {
            disable: false
        }
    })
};
CreateVirtualVolumesAction.prototype._recalc = function() {
    var M = new Size();
    var G = new Size();
    var K = 0;
    var T = 0;
    var E = 0;
    var I = 1;
    var D = this.table.getData();
    var O = "";
    this.dataOK = true;
    this.overcommitting = false;
    var C = {};
    this.retrieve(C);
    var J = false;
    var S = this.table.getErrorCount();
    if (S > 0) {
        if (S == 1) {
            O += '<span class="inputInvalid">' + strings.createVirtualVolumes.valError1 + "</span><br />"
        } else {
            O += '<span class="inputInvalid">' + strings.createVirtualVolumes.valErrors(S) + "</span><br />"
        }
        this.dataOK = false
    } else {
        for (var H = 0; H < D.length; H++) {
            var Q = new Size(D[H][this.sizeCol]);
            var L = parseInt(D[H][this.copiesCol], 10);
            if (L > I) {
                I = L
            }
            Q.set(Q.getPages(), "pages");
            Q.multiply(L);
            if (D[H][this.poolCol] == "A") {
                K += L;
                M.add(Q)
            } else {
                T += L;
                G.add(Q)
            }
            if (L > 1) {
                var F = D[H][this.nameCol];
                for (var N = 0; N < L; N++) {
                    var P = F + leadingZeros(N, 4);
                    if (DC.volumes[P]) {
                        O += '<span class="inputInvalid">' + strings.createVirtualVolumes.badGeneratedName(F, P) + "</span><br />";
                        this.dataOK = false;
                        break
                    }
                }
            }
            E += L
        }
        if (DC.pools.A) {
            if (Size.compare(M, MC.poolsSet.virtUncommittedSize.A) > 0) {
                if (!this.overcommitEnabled.A) {
                    J = "A"
                } else {
                    if ((MC.poolsSet.virtUncommittedSize.A.getRawValue() > 0) || (MC.poolsSet.virtUncommittedSize.A.getRawValue() == 0 && M.format() != 0)) {
                        this.overcommitting = true
                    }
                }
            }
        }
        if (DC.pools.B) {
            if (Size.compare(G, MC.poolsSet.virtUncommittedSize.B) > 0) {
                if (!this.overcommitEnabled.B) {
                    if (J) {
                        J += " " + strings.and + " B"
                    } else {
                        J = "B"
                    }
                } else {
                    if ((MC.poolsSet.virtUncommittedSize.B.getRawValue() > 0) || (MC.poolsSet.virtUncommittedSize.B.getRawValue() == 0 && G.format() != 0)) {
                        this.overcommitting = true
                    }
                }
            }
        }
        if (J) {
            O += '<span class="inputInvalid">' + strings.createVirtualVolumes.overcommitted(J) + "</span><br />";
            this.dataOK = false
        }
        if ((MC.volumeGroupsSet.totalVols + E) > system.maxLuns) {
            O += '<span class="inputInvalid">' + strings.createVirtualVolumes.exceededMaxVols(system.maxLuns) + "</span><br />";
            this.dataOK = false
        }
    }
    if (this.dataOK) {
        this.okEnabled(true);
        if (E > 1) {
            if (DC.pools.A && DC.pools.B) {
                O += strings.createVirtualVolumes.newVolsCount2pools(E, K, M.format(), T, G.format())
            } else {
                if (DC.pools.A) {
                    O += strings.createVirtualVolumes.newVolsCount1pool(E, "A", M.format())
                } else {
                    O += strings.createVirtualVolumes.newVolsCount1pool(E, "B", G.format())
                }
            }
        } else {
            if (K > 0) {
                O += strings.createVirtualVolumes.newVolsCount1("A", M.format())
            } else {
                O += strings.createVirtualVolumes.newVolsCount1("B", G.format())
            }
        }
        if (I > 1) {
            O += strings.createVirtualVolumes.copiesMsg
        }
    } else {
        this.okEnabled(false)
    }
    var R = {
        cvaCapA: {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.A,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.A,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.A,
                label: strings.Unallocated
            }, {
                cssClass: "spaceNewVols",
                size: M,
                label: strings.createVirtualVolumes.newVols
            }]
        },
        cvaCapB: {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.B,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.B,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.B,
                label: strings.Unallocated
            }, {
                cssClass: "spaceNewVols",
                size: G,
                label: strings.createVirtualVolumes.newVols
            }]
        },
        cvaSummary: {
            text: O
        }
    };
    this.update(R);
    this.resetSize({
        shrink: true
    })
};
CreateVirtualVolumesAction.prototype.okCallback = function() {
    if (this.editing) {
        this.table.quitEditing();
        if (!this.dataOK) {
            return
        }
    }
    var G = this.table.getData();
    var J = {};
    this.retrieve(J);
    if (!J.cvaForm.valid) {
        return
    }
    var F = [];
    var K = G.length;
    for (var N = 0; N < K; N++) {
        var H = G[N][this.nameCol];
        var D = G[N][this.sizeCol];
        var E = G[N][this.copiesCol];
        if (this.qualCol) {
            var I = G[N][this.qualCol];
            if (I == this.qualPerf) {
                var C = "performance"
            } else {
                if (I == this.qualArchive) {
                    var C = "archive"
                } else {
                    var C = "no-affinity"
                }
            }
        }
        if (this.piCol) {
            var M = (G[N][this.piCol] == strings.Yes ? true : false)
        }
        var L = G[N][this.poolCol];
        if (E == 1) {
            F.push({
                name: "createVol" + N,
                command: MC.createVolume,
                data: {
                    pool: L,
                    name: H,
                    size: this.useAvailableSpace(L, K, D) ? this.getAvailablePoolSize(L, "MB") : D,
                    piSetting: M,
                    preference: C
                },
                options: {
                    processingMsg: strings.createVirtualVolumes.creatingOneMsg(H),
                    failureMsg: strings.createVirtualVolumes.createFailedOneMsg(H),
                    closeActionOn: "success",
                    confirmMsg: this.useAvailableSpace(L, K, D) ? this.getFreeSpaceUsageMsg(L, D) : null
                }
            })
        } else {
            F.push({
                name: "createVolSet" + N,
                command: MC.createVolumeSet,
                data: {
                    pool: L,
                    baseName: H,
                    size: D,
                    piSetting: M,
                    preference: C,
                    count: E
                },
                options: {
                    processingMsg: strings.createVirtualVolumes.creatingMultMsg(H),
                    failureMsg: strings.createVirtualVolumes.createFailedMultMsg(H),
                    closeActionOn: "success"
                }
            })
        }
    }
    MC.execCommandList(F, {
        successMsg: strings.createVirtualVolumes.completedMsg,
        confirmMsg: (this.overcommitting ? strings.overcommitMsg : null),
        closeActionOn: "success"
    })
};
CreateVirtualVolumesAction.prototype.useAvailableSpace = function(C, E, D) {
    if (E != 1 || this.overcommitting) {
        return false
    }
    var F = MC.poolsSet.virtUncommittedSize[C].format("scale");
    if (new Size(F).value <= new Size(D).value) {
        return true
    }
    return false
};
CreateVirtualVolumesAction.prototype.getAvailablePoolSize = function(C, D) {
    return MC.poolsSet.virtUncommittedSize[C].format(D)
};
CreateVirtualVolumesAction.prototype.getFreeSpaceUsageMsg = function(C, D) {
    if (D.toLowerCase().indexOf("gb") != -1 || D.toLowerCase().indexOf("mb") != -1) {
        return strings.createVirtualVolumes.freeSpaceUsageMsg(D, "")
    } else {
        return strings.createVirtualVolumes.freeSpaceUsageMsg(D, "(" + this.getAvailablePoolSize(C, "GB") + ")")
    }
};

function CreateLinearVolumesAction(H) {
    if (arguments.length == 0) {
        return
    }
    H.name = "CreateLinearVolumesAction";
    var G = 0;
    H.okCallback = createObjectCallback(this, this._create);
    this.curData = {};
    this.maxVolumes = DC.systemParameters.get("max_volumes") - MC.volumeGroupsSet.totalVols;
    var D = 10000000;
    var F = 10000000000;
    var C = DC.cacheParameter.get("cache_block_size");
    if (system.minBackingStoreSize) {
        this.minSnapPoolSize = new Size(system.minBackingStoreSize, "blocks")
    } else {
        var E = Math.ceil(F / C);
        this.minSnapPoolSize = new Size(E, "blocks")
    }
    var E = Math.ceil(D / C);
    this.minVolSize = new Size(E, "blocks");
    H.widgets = this.form = new FormWidget({
        name: "linVolForm",
        widgets: [new TextWidget({
            name: "err",
            text: "",
            bottomMargin: true
        }), this.widgetTable = new TableWidget({
            name: "volumeTable",
            maxCols: 2,
            widgets: [new TextWidget({
                name: "poolName",
                row: (this.poolNameRow = G++),
                leftMargin: true,
                label: strings.createLinearVolumes.poolLabel
            }), new ComboBoxWidget({
                name: "poolCombo",
                row: (this.poolComboRow = G++),
                leftMargin: true,
                label: strings.createLinearVolumes.poolLabel,
                values: [],
                changeCallback: createObjectCallback(this, this._poolChange)
            }), this.volNumWidget = new TextInputWidget({
                name: "volNum",
                row: G++,
                leftMargin: true,
                topMargin: true,
                label: strings.createLinearVolumes.numVolumesLabel,
                size: 4,
                value: 1,
                rules: {
                    required: true
                },
                changeCallback: createObjectCallback(this, this._volNumChange)
            }), new TextInputWidget({
                name: "name",
                row: G++,
                leftMargin: true,
                topMargin: true,
                label: strings.createLinearVolumes.nameLabel,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: RI.getMaxNameLength(),
                    volumeExists: true
                },
                changeCallback: createObjectCallback(this, this._otherValueChange)
            }), new TextInputWidget({
                name: "volSize",
                row: G++,
                leftMargin: true,
                topMargin: true,
                label: strings.createLinearVolumes.sizeLabel,
                size: 8,
                value: userBasePreferenceIsDecimal() ? "100GB" : "100GiB",
                rules: {
                    required: true
                },
                changeCallback: createObjectCallback(this, this._volSizeChange),
                tip: strings.createLinearVolumes.sizeTip
            }), new CheckboxInputWidget({
                name: "piSetting",
                row: (this.piSettingRow = G++),
                leftMargin: true,
                topMargin: true,
                label: strings.createLinearVolumes.piSettingLabel,
                changeCallback: createObjectCallback(this, this._otherValueChange)
            }), new CheckboxContainer({
                name: "snapOption",
                row: (this.snapOptionRow = G++),
                col: 0,
                colSpan: 2,
                topMargin: true,
                rightMargin: true,
                leftMargin: true,
                label: strings.createLinearVolumes.snappableTitle,
                changeCallback: createObjectCallback(this, this._snapOptionChange),
                widgets: [this.snapWidgetTable = new TableWidget({
                    name: "snapOptionsTable",
                    widgets: [new RadioButtonsInputWidget({
                        name: "snapChoice",
                        row: 0,
                        col: 1,
                        colSpan: 3,
                        topMargin: true,
                        leftMargin: true,
                        label: strings.createLinearVolumes.snapPoolChoiceLabel,
                        labelOptions: {
                            row: 0,
                            col: 0,
                            topMargin: true
                        },
                        changeCallback: createObjectCallback(this, this._snapChoiceChange),
                        value: "standard",
                        values: [{
                            value: "standard",
                            text: strings.createLinearVolumes.standardLabel
                        }, {
                            value: "snapPool",
                            widget: new TextInputWidget({
                                name: "snapPool",
                                value: userBasePreferenceIsDecimal() ? "10GB" : "10GiB",
                                label: strings.createLinearVolumes.snapPoolLabel,
                                classes: "inline ARLeftSmallMargin",
                                disable: true,
                                changeCallback: createObjectCallback(this, this._snapPoolChange)
                            })
                        }, {
                            value: "attach",
                            widget: new OptionInputWidget({
                                name: "attachPool",
                                label: strings.createLinearVolumes.attachPoolLabel,
                                classes: "inline ARLeftSmallMargin",
                                values: [],
                                width: 150,
                                changeCallback: createObjectCallback(this, this._otherValueChange)
                            })
                        }]
                    }), new CheckboxInputWidget({
                        name: "repPrepare",
                        row: (this.repPrepareRow = 1),
                        col: 1,
                        bottomMediumMargin: true,
                        leftMargin: true,
                        label: strings.createLinearVolumes.prepareLabel,
                        changeCallback: createObjectCallback(this, this._otherValueChange)
                    })]
                })]
            })]
        })]
    });
    ActionPanel.call(this, H);
    this.class_name = "CreateLinearVolumesAction"
}
CreateLinearVolumesAction.prototype = new ActionPanel();
CreateLinearVolumesAction.prototype.constructor = CreateLinearVolumesAction;
CreateLinearVolumesAction.getMenuState = function(C) {
    if (!session.hasConfigurationCapability() || !RI.supportsLinear()) {
        return false
    }
    var F = false;
    var E = false;
    var G = new Size(19532, "blocks");
    for (var D in DC.pools) {
        if (DC.pools[D].getInt("storage_type_numeric") == VOLUME_CLASS.LINEAR) {
            if (DC.pools[D].getInt("total_avail_numeric") > G.getBlocks()) {
                F = true;
                break
            } else {
                E = true
            }
        }
    }
    if (F) {
        return []
    } else {
        if (E) {
            return strings.menuTips.poolTooSmall
        } else {
            return strings.menuTips.noLinearPools
        }
    }
};
CreateLinearVolumesAction.prototype.showing = function() {
    var D = {};
    if (this.previousSelection.length) {
        this.selectablePool = false;
        this.pool = this.previousSelection[0].getObject();
        this.widgetTable.hideRows(this.poolComboRow, this.poolComboRow);
        D.poolCombo = {
            disable: true
        };
        D.poolName = {
            text: this.pool.get("name")
        }
    } else {
        this.selectablePool = true;
        var C = this._getPools();
        this.pool = DC.poolsSerial[C[0].value];
        this.widgetTable.hideRows(this.poolNameRow, this.poolNameRow);
        D.poolName = {
            disable: true
        };
        D.poolCombo = {
            values: C,
            value: C[0].value
        }
    }
    if (!RI.hasFeature("e2ePi")) {
        this.widgetTable.hideRows(this.piSettingRow, this.piSettingRow);
        D.piSetting = {
            disable: true
        }
    }
    if (!RI.hasFeature("dms")) {
        this.widgetTable.hideRows(this.snapOptionRow);
        D.snapOption = {
            disable: true
        };
        D.snapChoice = {
            disable: true
        };
        D.snapPool = {
            disable: true
        };
        D.attachPool = {
            disable: true
        };
        D.repPrepare = {
            disable: true
        }
    } else {
        if (!RI.hasFeature("rsr")) {
            this.snapWidgetTable.hideRows(this.repPrepareRow, this.repPrepareRow);
            D.repPrepare = {
                disable: true
            }
        }
    }
    this.update(D);
    this._reset();
    this.initialized = true
};
CreateLinearVolumesAction.prototype._reset = function() {
    if (RI.hasFeature("dms")) {
        this.widgetTable.showRows(this.snapOptionRow)
    }
    var D = this.pool.getInt("total_avail_numeric");
    this.poolFreeSize = new Size(D, "blocks");
    var G = this.minVolSize.format("auto", 0);
    var J = this.poolFreeSize.format("scale");
    if (parseInt(this.pool.objects[0].getPropertyValue("raidtype_numeric")) == 2) {
        J = this.adaptLinearVolumeBoundary(this.poolFreeSize)
    }
    var K = Math.floor(D / this.minVolSize.getBlocks());
    if (K > this.maxVolumes) {
        K = this.maxVolumes
    }
    var C = this.minSnapPoolSize.format("auto");
    var M = new Size(this.poolFreeSize);
    M.subtract(this.minVolSize);
    var H = M.format("scale");
    var L = '<span class="inputInvalid">' + strings.createVirtualVolumes.exceededMaxVols(system.maxLuns) + "</span><br />";
    var I = this.getAttachPoolData();
    var E = userBasePreferenceIsDecimal();
    var F = {
        err: {
            text: (K > 0) ? "" : L
        },
        volNum: {
            value: 1,
            rules: {
                required: true,
                range: [1, K],
                digits: true
            },
            disable: (K > 0) ? false : true
        },
        name: {
            value: DC.getUnusedKey("volumes", this.pool.get("name") + "_v"),
            disable: (K > 0) ? false : true
        },
        volSize: {
            value: J,
            rules: {
                required: true,
                decimalBaseSizeString: E,
                binaryBaseSizeString: !E,
                sizeRange: [G, J]
            },
            disable: (K > 0) ? false : true
        },
        piSetting: {
            value: false
        },
        snapOption: {
            value: false,
            disable: (K > 0) ? false : true
        },
        snapChoice: {
            value: "standard",
            disable: true
        },
        snapPool: {
            value: this._getDefaultSnapPoolSize(this.poolFreeSize).format("scale"),
            rules: {
                required: true,
                decimalBaseSizeString: E,
                binaryBaseSizeString: !E,
                sizeRange: [C, H]
            },
            disable: true
        },
        attachPool: I
    };
    if (K > 0) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    F.attachPool.disable = true;
    this.singleVolume = true;
    F.linVolForm = {
        resetValidation: true
    };
    this.inReset = true;
    this.update(F);
    delete this.inReset;
    this.retrieve(this.curData, true);
    this.resetSize({
        shrink: true
    });
    this.sizeChanged = false
};
CreateLinearVolumesAction.prototype._getPools = function() {
    this.pools = [];
    for (var F in DC.pools) {
        var C = DC.pools[F];
        if (C.getInt("storage_type_numeric") == VOLUME_CLASS.LINEAR && C.getInt("total_avail_numeric") > this.minVolSize.getBlocks()) {
            var D = C.get("serial_number");
            var E = C.get("preferred_owner");
            this.pools.push({
                value: D,
                text: F,
                controller: E
            })
        }
    }
    return this.pools
};
CreateLinearVolumesAction.prototype.getAttachPoolData = function() {
    if (!this.snapPools) {
        this.snapPools = {
            A: [],
            B: []
        };
        for (var E in DC.volumes) {
            var D = DC.volumes[E];
            if (D.getInt("volume_type_numeric") == VOLUME_TYPES.BACKING_STORE) {
                this.snapPools[D.get("preferred_owner")].push({
                    value: D.get("serial_number"),
                    text: E
                })
            }
        }
    }
    var C = this.pool.get("preferred_owner");
    this.hasAttachPools = this.snapPools[C].length ? true : false;
    var F = {
        values: this.snapPools[C],
        value: (this.hasAttachPools ? this.snapPools[C][0].value : ""),
        disable: !this.hasAttachPools
    };
    return F
};
CreateLinearVolumesAction.prototype._poolChange = function(D, C, E) {
    if (!this.initialized || D.poolCombo.value == this.curData.poolCombo.value) {
        return
    }
    $.extend(this.curData, D);
    this.pool = DC.poolsSerial[D.poolCombo.value];
    this._reset()
};
CreateLinearVolumesAction.prototype._volNumChange = function(E, D, G) {
    if (!this.initialized || E.volNum.value == this.curData.volNum.value || this.inReset) {
        return
    }
    $.extend(this.curData, E);
    if (D.invalid) {
        this.okEnabled(false);
        return
    }
    var F = this.pool.get("name");
    var C = E.volNum.value;
    if (this.singleVolume && C > 1) {
        this.singleVolume = false;
        this.widgetTable.hideRows(this.snapOptionRow);
        this.curData.name.label = strings.createLinearVolumes.nameSetLabel;
        this.curData.name.value = F + "_v"
    } else {
        if (!this.singleVolume && C == 1) {
            this.singleVolume = true;
            if (RI.hasFeature("dms")) {
                this.widgetTable.showRows(this.snapOptionRow)
            }
            this.curData.name.label = strings.createLinearVolumes.nameLabel;
            this.curData.name.value = DC.getUnusedKey("volumes", F + "_v")
        }
    }
    this._setMaxVolSize();
    this.curData.linVolForm.validate = true;
    this.update(this.curData);
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
CreateLinearVolumesAction.prototype._volSizeChange = function(G, F, H) {
    if (!this.initialized || G.volSize.value == this.curData.volSize.value || this.inReset) {
        return
    }
    $.extend(this.curData, G);
    if (this.singleVolume) {
        var I = this._getDefaultSnapPoolSize();
        this.curData.snapPool.value = I.format("scale");
        this.curData.snapPool.value = Math.ceil(this.curData.snapPool.value / 8) * 8
    } else {
        var E = new Size(this.poolFreeSize);
        E.divide(new Size(G.volSize.value));
        var C = E.getRawValue();
        if (this.curData.volNum.value > C) {
            this.curData.volNum.value = C
        }
    }
    this.curData.linVolForm.validate = true;
    var D = $.extend({}, this.curData);
    delete D.volSize;
    this.update(D);
    this.sizeChanged = true;
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateLinearVolumesAction.prototype._snapOptionChange = function(D, C, E) {
    if (!this.initialized || D.snapOption.value == this.curData.snapOption.value || this.inReset) {
        return
    }
    $.extend(this.curData, D);
    if (D.snapOption.value) {
        this.curData.snapChoice.disable = false;
        if (this.curData.snapChoice.value != "snapPool") {
            this.curData.snapPool.disable = true
        }
        if (this.curData.snapChoice.value != "attach") {
            this.curData.attachPool.disable = true
        }
        if (!this.hasAttachPools) {
            this.curData.snapChoice.values = [{
                value: "attach",
                disable: true
            }]
        }
    } else {
        this.curData.snapChoice.disable = true;
        this.curData.repPrepare.value = false;
        this.curData.repPrepare.disable = true;
        this.curData.attachPool.disable = true
    }
    this._setMaxVolSize();
    this.curData.linVolForm.validate = true;
    this.update(this.curData);
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateLinearVolumesAction.prototype._snapChoiceChange = function(D, C, E) {
    if (!this.initialized || D.snapChoice.value == this.curData.snapChoice.value || this.inReset) {
        return
    }
    $.extend(this.curData, D);
    if (D.snapChoice.value == "snapPool") {
        this.curData.snapPool.disable = false
    } else {
        this.curData.snapPool.disable = true
    }
    if (D.snapChoice.value == "attach" && this.hasAttachPools) {
        this.curData.attachPool.disable = false
    } else {
        this.curData.attachPool.disable = true
    }
    if (!this.hasAttachPools) {
        this.curData.snapChoice.values = [{
            value: "attach",
            disable: true
        }]
    }
    this._setMaxVolSize();
    this.curData.linVolForm.validate = true;
    this.update(this.curData);
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateLinearVolumesAction.prototype._snapPoolChange = function(D, C, E) {
    if (!this.initialized || D.snapPool.value == this.curData.snapPool.value || this.inReset) {
        return
    }
    $.extend(this.curData, D);
    this._setMaxVolSize();
    this.curData.linVolForm.validate = true;
    this.update(this.curData);
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateLinearVolumesAction.prototype._otherValueChange = function(D, C, E) {
    if (!this.initialized || this.inReset) {
        return
    }
    $.extend(this.curData, D);
    if (this.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CreateLinearVolumesAction.prototype._getSnapPoolSize = function() {
    if (!this.curData.snapOption.value) {
        return new Size()
    }
    switch (this.curData.snapChoice.value) {
        case "standard":
            return this._getDefaultSnapPoolSize();
        case "snapPool":
            return new Size(this.curData.snapPool.value);
        case "attach":
        default:
            return new Size()
    }
};
CreateLinearVolumesAction.prototype._getDefaultSnapPoolSize = function(D) {
    if (D) {
        var F = new Size(D)
    } else {
        var F = new Size(this.curData.volSize.value)
    }
    var C = new Size(F);
    var E = new Size(this.poolFreeSize);
    C.divide(SNAP_POOL_DIVISOR);
    E.divide(SNAP_POOL_DIVISOR + 1);
    var G = new Size(C);
    G.add(F);
    if (Size.compare(G, this.poolFreeSize) > 0) {
        return E
    } else {
        return C
    }
};
CreateLinearVolumesAction.prototype.adaptLinearVolumeBoundary = function(E) {
    var C = new Size(parseInt(this.pool.objects[0].getPropertyValue("adapt_linear_volume_boundary")), "blocks");
    if ((E.getBlocks() - C.getBlocks()) < 0) {
        this.okEnabled(false);
        return E.format("scale")
    }
    var D = E.getBlocks() / C.getBlocks();
    if (parseFloat(D.toFixed(2)) > D) {
        D = parseFloat(D.toFixed(2)) - 0.01
    }
    var G = parseFloat(D.toFixed(2)) * C.getBlocks();
    var F = new Size(G, "blocks");
    return F.format("scale")
};
CreateLinearVolumesAction.prototype._setMaxVolSize = function() {
    var E = new Size(this.curData.volSize.value);
    if (this.form.widgetMap.volNum.invalid) {
        return
    }
    if (this.curData.volNum.value > 1 || !this.curData.snapOption.value || this.curData.snapChoice == "attach") {
        var H = new Size(this.poolFreeSize).divide(this.curData.volNum.value)
    } else {
        var G = this._getSnapPoolSize();
        var H = new Size(this.poolFreeSize);
        H.subtract(G)
    }
    var F = H.format("scale");
    if (parseInt(this.pool.objects[0].getPropertyValue("raidtype_numeric")) == 2) {
        F = this.adaptLinearVolumeBoundary(H)
    }
    if (!this.sizeChanged || Size.compare(E, H) > 0) {
        this.curData.volSize.value = F;
        this.sizeChanged = false
    }
    var C = this.minVolSize.format("auto", 0);
    var D = userBasePreferenceIsDecimal();
    this.curData.volSize.rules = {
        required: true,
        decimalBaseSizeString: D,
        binaryBaseSizeString: !D,
        sizeRange: [C, F]
    }
};
CreateLinearVolumesAction.prototype._create = function() {
    var G = {};
    this.retrieve(G);
    if (G.volNum.value != this.curData.volNum.value) {
        this.volNumWidget.fireChange();
        this.retrieve(G)
    }
    if (!G.linVolForm.valid) {
        return
    }
    var H = this.pool.get("name");
    var E = parseInt(G.volNum.value);
    var C = G.name.value;
    var D = Size.prototype.unTranslate(G.volSize.value);
    if (E > 1) {
        MC.createVolumeSet({
            pool: H,
            baseName: C,
            count: E,
            size: D,
            piSetting: (RI.hasFeature("e2ePi") ? G.piSetting.value : null)
        }, {
            dialog: true,
            processingMsg: strings.createLinearVolumes.setProcessing(E, C),
            failureMsg: strings.createLinearVolumes.setFailure(E, C),
            successMsg: strings.createLinearVolumes.setSuccess(E, C),
            closeActionOn: "success"
        })
    } else {
        var F = {
            pool: H,
            name: C,
            size: this.useAvailableSpace(D) ? this.getAvailablePoolSize("MB") : D,
            piSetting: (RI.hasFeature("e2ePi") ? G.piSetting.value : null),
            prepareReplication: (RI.hasFeature("rsr") ? G.repPrepare.value : null)
        };
        if (RI.hasFeature("dms") && G.snapOption.value) {
            F.snappable = G.snapOption.value;
            if (G.snapChoice.value == "snapPool") {
                F.reserve = Size.prototype.unTranslate(G.snapPool.value)
            } else {
                if (G.snapChoice.value == "attach") {
                    F.snapPool = G.attachPool.value
                }
            }
        }
        MC.createVolume(F, {
            dialog: true,
            processingMsg: strings.createLinearVolumes.processing(C),
            failureMsg: strings.createLinearVolumes.failure(C),
            successMsg: strings.createLinearVolumes.success(C),
            confirmMsg: this.useAvailableSpace(D) ? this.getFreeSpaceUsageMsg(D) : null,
            closeActionOn: "success"
        })
    }
};
CreateLinearVolumesAction.prototype.useAvailableSpace = function(C) {
    var D = this._getSnapPoolSize();
    var F = new Size(this.poolFreeSize);
    F.subtract(D);
    var E = F.format("scale");
    if (new Size(E).value <= new Size(C).value) {
        return true
    }
    return false
};
CreateLinearVolumesAction.prototype.getAvailablePoolSize = function(D) {
    var C = this._getSnapPoolSize();
    var E = new Size(this.poolFreeSize);
    E.subtract(C);
    return E.format(D)
};
CreateLinearVolumesAction.prototype.getFreeSpaceUsageMsg = function(C) {
    if (C.toLowerCase().indexOf("gb") != -1 || C.toLowerCase().indexOf("mb") != -1) {
        return strings.createLinearVolumes.freeSpaceUsageMsg(C, "")
    } else {
        return strings.createLinearVolumes.freeSpaceUsageMsg(C, "(" + this.getAvailablePoolSize("GB") + ")")
    }
};

function CopyVolumeAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "CopyVolumeAction";
    D.width = 390;
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = createObjectCallback(this, this.changedCallback);
    D.widgets = [new FormWidget({
        name: "copyVolumeForm",
        widgets: [this.copyVolTable = new TableWidget({
            name: "copyVolTable",
            classes: "equalColumnWidth",
            widgets: [new TextWidget({
                name: "srcVolName",
                row: 0,
                col: 1,
                colSpan: 2,
                bottomMargin: true,
                leftMargin: true,
                label: strings.copyVolumeAction.srcVolLabel
            }), new TextInputWidget({
                name: "newVolName",
                row: 1,
                col: 1,
                label: strings.copyVolumeAction.newVolLabel,
                bottomMargin: true,
                changeCallback: C
            }), new OptionInputWidget({
                name: "linearPool",
                row: 2,
                col: 1,
                label: strings.copyVolumeAction.onVdisk,
                bottomMargin: true
            }), new RadioButtonsInputWidget({
                name: "virtualPool",
                row: 3,
                col: 1,
                label: strings.copyVolumeAction.onVdisk,
                orientation: "horizontal",
                values: [{
                    value: "auto",
                    text: strings.auto
                }, {
                    value: "A",
                    text: "A"
                }, {
                    value: "B",
                    text: "B"
                }]
            }), new CheckboxInputWidget({
                name: "withModifiedData",
                row: 4,
                col: 0,
                colSpan: 2,
                label: strings.copyVolumeAction.withModified,
                singleCell: true,
                bottomMargin: true,
                changeCallback: C
            })]
        }), this.schedContainer = new CheckboxContainer({
            name: "schedContainer",
            value: false,
            label: strings.copyVolumeAction.scheduled,
            changeCallback: createObjectCallback(this, this.toggleSchedule),
            widgets: [new TextInputWidget({
                name: "volcopyPrefix",
                row: 0,
                col: 1,
                label: strings.copyVolumeAction.prefixLabel,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: (RI.getMaxNameLength() - 6)
                },
                messages: {
                    required: strings.copyVolumeAction.enterPrefix
                },
                bottomMargin: true
            }), this.scheduleInputWidget = new ScheduleInputWidget({
                name: "copyVolumeSchedule",
                row: 1,
                col: 0,
                changeCallback: createObjectCallback(this, this.scheduleChanged)
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "CopyVolumeAction"
}
CopyVolumeAction.prototype = new ActionPanel();
CopyVolumeAction.prototype.constructor = CopyVolumeAction;
CopyVolumeAction.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.supportsSnaps()) {
        return false
    }
    var C = TopicPanel.getSelected(["snapshots", "volumes"], 1);
    if (C) {
        var D = C[0].getObject();
        if (D instanceof APISnapshots) {
            D = DC.volumesSerial[D.get("serial_number")]
        }
        if (D.isCopyable()) {
            if (D.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL) {
                if (D.getMapsCount() > 0) {
                    return strings.copyVolumeAction.volWithMaps
                }
            } else {
                if (RI.pagedOnly()) {
                    return strings.menuTips.linearNotSupported
                }
            }
            return C
        } else {
            return strings.menuTips.selectSingle(strings.snapshotOrVolume)
        }
    } else {
        return strings.menuTips.selectSingle(strings.snapshotOrVolume)
    }
};
CopyVolumeAction.prototype.showing = function() {
    var O = DC.base.volumes[this.previousSelection[0].key];
    this.volumeName = O.get("volume_name");
    var J = O.getInt("volume_type_numeric");
    var L = (J == VOLUME_TYPES.SNAPSHOT || J == VOLUME_TYPES.PAGED_SNAPSHOT);
    var T = (L) ? strings.copyVolumeAction.srcSnapLabel : strings.copyVolumeAction.srcVolLabel;
    var R = O.get("virtual_disk_name");
    var H = this.isVirtual = (O.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL);
    var K = [];
    var D = "c00";
    var F = MC.schedulesSet.select({
        type: "prop",
        name: "task_type",
        value: "VolumeCopy"
    });
    var G = [];
    for (var P = 0; P < F.objects.length; P++) {
        var S = F.objects[P].get("task_destination_volume_prefix");
        if (G.find(S) == -1) {
            G.push(S)
        }
    }
    var I = DC.getUnusedKey("volumes", this.volumeName + D, G, 24);
    var E = DataSet.generateTaskPrefix(this.volumeName, "VolumeCopy");
    if (!H) {
        var M = DC.pools[R];
        var C = M.get("preferred_owner");
        for (var N in DC.pools) {
            var Q = DC.pools[N];
            if (Q.get("storage_type_numeric") == STORAGE_CLASS.LINEAR && Q.get("owner") == C) {
                K.push({
                    value: N,
                    text: N
                })
            }
        }
    }
    this.update({
        srcVolName: {
            label: T,
            text: this.volumeName
        },
        newVolName: {
            value: I,
            rules: {
                required: true,
                dhName: true,
                utf8length: 32,
                volumeExists: true
            }
        },
        linearPool: {
            values: K,
            visibility: (H) ? "collapse" : "visible"
        },
        virtualPool: {
            visibility: (H) ? "visible" : "collapse"
        },
        withModifiedData: {
            visibility: (L && !H) ? "visible" : "hidden"
        },
        schedContainer: {
            value: false,
            visibility: (H) ? "collapse" : "visible"
        },
        copyVolumeSchedule: {
            disable: true
        },
        volcopyPrefix: {
            value: E,
            disable: true
        }
    });
    if (H) {
        this.copyVolTable.hideRows(2, 3);
        this.copyVolTable.showRows(3)
    } else {
        this.copyVolTable.hideRows(3, 4);
        this.copyVolTable.showRows(4)
    }
    this.okEnabled(true);
    this.resetSize({
        shrink: true
    })
};
CopyVolumeAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.copyVolumeForm) {
        return
    }
    if (C.copyVolumeForm.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
CopyVolumeAction.prototype.toggleSchedule = function(E, C, D) {
    this.update({
        newVolName: {
            disable: E.schedContainer.value
        },
        volCopyPrefix: {
            disable: !E.schedContainer.value
        }
    });
    this.resetSize({
        shrink: true
    });
    this.changedCallback(E, C, D)
};
CopyVolumeAction.prototype.scheduleChanged = function(F, D, E) {
    var C = (F.copyVolumeSchedule_repeat.value ? 530 : 390);
    this.resetSize({
        shrink: true,
        width: C
    });
    this.changedCallback()
};
CopyVolumeAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.schedContainer.value) {
        this._initiateScheduleCopyVolume(C)
    } else {
        this._initiateCopyVolume(C)
    }
};
CopyVolumeAction.prototype._initiateCopyVolume = function(D) {
    var C = {
        useNewCommand: false,
        volumeName: this.volumeName,
        volcopyName: D.newVolName.value
    };
    if (this.isVirtual) {
        C.useNewCommand = true;
        if (D.virtualPool.value != "auto") {
            C.destPool = D.virtualPool.value
        }
    } else {
        if (D.linearCopyType.value == "ltv") {
            C.useNewCommand = true
        } else {
            C.vdiskName = D.linearPool.value;
            if (D.withModifiedData.value) {
                C.modifiedSnapshot = true
            }
        }
    }
    MC.copyVolume(C, {
        dialog: true,
        confirmMsg: strings.copyVolumeAction.unmountSourceConfirm,
        processingMsg: strings.copyVolumeAction.processing(this.volumeName),
        failureMsg: strings.copyVolumeAction.failure(this.volumeName),
        successMsg: strings.copyVolumeAction.success(this.volumeName),
        closeActionOn: "success"
    })
};
CopyVolumeAction.prototype._initiateScheduleCopyVolume = function(F) {
    this.taskName = DC.getUnusedKey("tasks", this.volumeName + "TC000", 32);
    this.schedName = DC.getUnusedKey("schedules", this.volumeName + "SC000", 32);
    var E = {
        name: this.taskName,
        type: "VolumeCopy",
        sourceVolume: this.volumeName,
        destPrefix: F.volcopyPrefix.value,
        modifiedSnapshot: (F.withModifiedData.value) ? "yes" : "no",
        destVdisk: F.linearPool.value
    };
    var D = [{
        name: "task",
        command: MC.createTask,
        data: E,
        options: {
            processingMsg: strings.copyVolumeAction.processing(this.volumeName),
            failureMsg: strings.copyVolumeAction.failure(this.volumeName)
        }
    }];
    var C = {
        name: this.schedName,
        scheduleSpecification: F.copyVolumeSchedule.value,
        taskName: this.taskName
    };
    D[D.length] = {
        name: "schedules",
        command: MC.createSchedule,
        data: C,
        options: {
            processingMsg: strings.copyVolumeAction.processing(this.volumeName),
            failureMsg: strings.copyVolumeAction.failure(this.volumeName)
        }
    };
    MC.execCommandList(D, {
        confirmMsg: strings.copyVolumeAction.unmountSourceConfirm,
        closeActionOn: "success",
        callback: createObjectCallback(this, this._scheduleTaskComplete),
        successMsg: strings.copyVolumeAction.scheduleSuccess(this.volumeName),
        failureMsg: strings.copyVolumeAction.scheduleFailure(this.volumeName)
    })
};
CopyVolumeAction.prototype._scheduleTaskComplete = function(C) {
    var D = C.results.schedules;
    if (D && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true
        })
    }
};

function AbortVolumeCopyAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AbortVolumeCopyAction";
    C.title = strings.menus.abortVolumeCopy;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.okButtonText = strings.Yes;
    C.cancelButtonText = strings.No;
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "abortWC",
        widgets: [new TextWidget({
            classes: "scrollText100",
            name: "volumeNameText",
            label: "Volume",
            width: 240
        }), new TextWidget({
            name: "warningText",
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "AbortVolumeCopyAction"
}
AbortVolumeCopyAction.prototype = new ActionPanel();
AbortVolumeCopyAction.prototype.constructor = AbortVolumeCopyAction;
AbortVolumeCopyAction.getMenuState = function() {
    var F;
    var D;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (MC.volumeCopySet == undefined) {
        return false
    } else {
        var C = MC.volumeCopySet.data.objects;
        var H = MC.volumeCopySet.data.objects.length > 0
    }
    var G = TopicPanel.getSelected(["snapshots", "volumes"], 1);
    if (G) {
        if (H) {
            for (var E = 0; E < C.length; E++) {
                if (C[E].get("source_volume_serial") == G[0].key || C[E].get("destination_volume_serial") == G[0].key) {
                    return G
                }
            }
        } else {
            return strings.abortVolumeCopy.noCopyInProgress
        }
    }
    if (H) {
        return strings.menuTips.selectMax(strings.volumesSlashsnapshots)
    } else {
        return strings.abortVolumeCopy.noCopyInProgress
    }
};
AbortVolumeCopyAction.prototype.showing = function() {
    var D = {};
    this.selected = this.previousSelection;
    this.sourceVol = this.selected[0].key;
    this.volName = "";
    for (var C in DC.volumes) {
        if (this.sourceVol == DC.volumes[C].get("serial_number")) {
            this.volName = DC.volumes[C].get("volume_name")
        }
    }
    this.update({
        volumeNameText: {
            text: this.volName,
            label: strings.volumeLabel
        },
        warningText: {
            text: strings.abortVolumeCopy.panelWarning
        }
    });
    this.resetSize();
    this.okEnabled(true, true)
};
AbortVolumeCopyAction.prototype._okCallback = function() {
    var C = {
        type: "virtual",
        volume: this.sourceVol
    };
    MC.abortCopyVolume(C, {
        dialog: true,
        processingMsg: strings.abortVolumeCopy.processing,
        failureMsg: strings.abortVolumeCopy.failure(this.volName),
        successMsg: strings.abortVolumeCopy.success(this.volName),
        closeActionOn: "success"
    })
};

function ModifyVolumeAction(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "ModifyVolumeAction";
    E.okCallback = createObjectCallback(this, this.okCallback);
    var C = createObjectCallback(this, this.changedCallback);
    this.changedWidgets = {};
    this.changed = false;
    var D = [{
        value: "standard",
        text: strings.volumeCache.standard
    }, {
        value: "no-mirror",
        text: strings.volumeCache.no_mirror
    }];
    if (RI.hasFeature("atomicWrites")) {
        D.push({
            value: "atomic-write",
            text: strings.volumeCache.atomic_write
        })
    }
    E.widgets = [this.modifyVolForm = new FormWidget({
        name: "modVolForm",
        widgets: [new WidgetContainer({
            name: "modVolWC",
            widgets: [new TableWidget({
                widgets: [new TextWidget({
                    name: "volToMod",
                    row: 0,
                    bottomMargin: true,
                    leftMargin: true,
                    label: strings.Volume
                }), new TextInputWidget({
                    name: "modVolName",
                    row: 1,
                    col: 1,
                    labelOptions: {
                        classes: "noWrap"
                    },
                    bottomMargin: true,
                    leftMargin: true,
                    label: strings.modifyVolumeAction.setVolName,
                    rules: {
                        dhName: true,
                        utf8length: RI.getMaxNameLength(),
                        volumeExists: true
                    },
                    changeCallback: C
                })]
            }), new LabeledWidgetContainer({
                name: "sizingWC",
                label: strings.Size,
                bottomMargin: true,
                widgets: [new TableWidget({
                    widgets: [new TextWidget({
                        name: "currentSizeText",
                        row: 0,
                        col: 1,
                        text: "",
                        label: strings.modifyVolumeAction.CurrentSize,
                        bottomMargin: true,
                        leftMargin: true,
                        labelOptions: {
                            classes: "noWrap"
                        }
                    }), new TextInputWidget({
                        name: "expandSize",
                        label: strings.modifyVolumeAction.Expand,
                        row: 1,
                        col: 1,
                        changeCallback: createObjectCallback(this, this._expandChanged),
                        size: 15,
                        bottomMargin: true,
                        leftMargin: true,
                        labelOptions: {
                            classes: "noWrap"
                        }
                    }), new TextWidget({
                        name: "newSize",
                        row: 2,
                        col: 1,
                        label: strings.modifyVolumeAction.NewSize,
                        leftMargin: true
                    })]
                })]
            }), new LabeledWidgetContainer({
                name: "cacheSettings",
                label: strings.modifyVolumeAction.cacheSettings,
                bottomMargin: true,
                widgets: [new TableWidget({
                    widgets: [new ComboBoxWidget({
                        name: "writePolicy",
                        row: 0,
                        col: 1,
                        bottomMargin: true,
                        leftMargin: true,
                        label: strings.modifyVolumeAction.writePolicy,
                        values: [{
                            value: "write-back",
                            text: strings.modifyVolumeAction.writeBack
                        }, {
                            value: "write-through",
                            text: strings.modifyVolumeAction.writeThrough
                        }],
                        changeCallback: C
                    }), new ComboBoxWidget({
                        name: "optimization",
                        row: 1,
                        col: 1,
                        bottomMargin: true,
                        leftMargin: true,
                        label: strings.modifyVolumeAction.writeOpt,
                        values: D,
                        changeCallback: C
                    }), new ComboBoxWidget({
                        name: "readAhead",
                        row: 2,
                        col: 1,
                        leftMargin: true,
                        label: strings.modifyVolumeAction.writeReadAhead,
                        values: [{
                            value: "adaptive",
                            text: strings.volumeCache.adaptive
                        }, {
                            value: "disabled",
                            text: strings.volumeCache.disabled
                        }, {
                            value: "stripe",
                            text: strings.volumeCache.stripe
                        }, {
                            value: "512KB",
                            text: strings.volumeCache.fivetwelve_kb
                        }, {
                            value: "1MB",
                            text: strings.volumeCache.one_mb
                        }, {
                            value: "2MB",
                            text: strings.volumeCache.two_mb
                        }, {
                            value: "4MB",
                            text: strings.volumeCache.four_mb
                        }, {
                            value: "8MB",
                            text: strings.volumeCache.eight_mb
                        }, {
                            value: "16MB",
                            text: strings.volumeCache.sixteen_mb
                        }, {
                            value: "32MB",
                            text: strings.volumeCache.thirtytwo_mb
                        }],
                        changeCallback: C
                    })]
                })]
            }), new ComboBoxWidget({
                name: "preference",
                label: strings.TierAffinity,
                labelOptions: {
                    classes: "noWrap"
                },
                values: [{
                    value: TIER_AFFINITY.NOAFFINITY,
                    text: strings.volPreference.NoAffinity
                }, {
                    value: TIER_AFFINITY.ARCHIVE,
                    text: strings.volPreference.Archive
                }, {
                    value: TIER_AFFINITY.PERFORMANCE,
                    text: strings.volPreference.Performance
                }],
                changeCallback: C
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "ModifyVolumeAction"
}
ModifyVolumeAction.prototype = new ActionPanel();
ModifyVolumeAction.prototype.constructor = ModifyVolumeAction;
ModifyVolumeAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = TopicPanel.getSelected("volumes", 1);
    if (C) {
        var D = C[0].getObject();
        if (D.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR && RI.pagedOnly()) {
            return strings.menuTips.linearNotSupported
        } else {
            return C
        }
    } else {
        return strings.menuTips.selectSingle(strings.volume)
    }
};
ModifyVolumeAction.prototype.showing = function() {
    this.selected = this.previousSelection[0];
    var G = this.selected.getObject();
    var C = new Size(G.get("size"));
    this.storageType = G.getInt("storage_type_numeric");
    this.myPool = G.get("storage_pool_name");
    this.overcommitEnabled = DC.pools[this.myPool] ? DC.pools[this.myPool].getInt("overcommit_numeric") : false;
    var F = G.getInt("volume_type_numeric");
    var D = userBasePreferenceIsDecimal();
    var E = {
        volToMod: {
            text: this.selected.getObject().get("volume_name")
        },
        modVolName: {
            value: "",
            setOrig: true
        },
        writePolicy: {
            value: this.selected.getObject().get("write_policy"),
            setOrig: true
        },
        optimization: {
            value: this.selected.getObject().get("cache_optimization"),
            setOrig: true
        },
        readAhead: {
            value: READ_AHEAD_SIZE[G.getInt("read_ahead_size_numeric")],
            setOrig: true
        },
        currentSizeText: {
            text: C.format("auto")
        },
        expandSize: {
            value: (D) ? "0GB" : "0GiB",
            setOrig: true,
            rules: {
                decimalBaseSizeString: D,
                binaryBaseSizeString: !D,
                sizeRange: this._getSizeRange()
            },
            messages: {
                sizeRange: this._getRangeMessage()
            }
        },
        newSize: {
            text: C.format("auto")
        }
    };
    if ((G.snapshots && this.storageType == 0) || F == VOLUME_TYPES.SNAPSHOT || F == VOLUME_TYPES.PAGED_SNAPSHOT) {
        E.sizingWC = {
            disable: true,
            visibility: "collapse"
        }
    }
    if (F == VOLUME_TYPES.BACKING_STORE) {
        E.cacheSettings = {
            disable: true,
            visibility: "collapse"
        }
    }
    if (RI.hasFeature("volTierPreference") && this.storageType == STORAGE_CLASS.VIRTUAL) {
        E.preference = {
            value: G.get("tier_affinity_numeric"),
            setOrig: true
        }
    } else {
        E.preference = {
            disable: true,
            visibility: "collapse"
        }
    }
    this.update(E);
    this.okEnabled(false)
};
ModifyVolumeAction.prototype._getRangeMessage = function() {
    var C;
    if (!this.overcommitEnabled) {
        C = strings.modifyVolumeAction.notInRange
    } else {
        C = strings.modifyVolumeAction.ocNotInRange
    }
    return C
};
ModifyVolumeAction.prototype._getSizeRange = function() {
    var D = new Size(this.selected.getObject().getInt("size_numeric"), "blocks");
    var C = new Size("128TiB");
    C.subtract(D);
    if (this.storageType == STORAGE_CLASS.VIRTUAL) {
        if (!this.overcommitEnabled) {
            C.set(C.getPages(), "pages");
            if (Size.compare(C, MC.poolsSet.virtUncommittedSize[this.myPool]) > 0) {
                C = MC.poolsSet.virtUncommittedSize[this.myPool]
            }
        }
    } else {
        var E = new Size(DC.pools[this.myPool].getInt("total_avail_numeric"), "blocks");
        if (E.getBlocks() < 8766) {
            this.update({
                expandSize: {
                    disable: true
                }
            })
        } else {
            C = E
        }
    }
    return [(userBasePreferenceIsDecimal()) ? "0GB" : "0GiB", C.format("scale", 5)]
};
ModifyVolumeAction.prototype._expandChanged = function(G, D, E) {
    var F = new Size(G[D.name].value);
    var C = F.add(this.selected.getObject().get("size"));
    this.update({
        newSize: {
            text: C.format("auto")
        }
    });
    this.changedCallback(G, D, E)
};
ModifyVolumeAction.prototype.changedCallback = function(H, E, F) {
    var C = {};
    this.retrieve(C);
    var G = false;
    for (var D in C) {
        if (C[D].valueChanged) {
            G = true;
            break
        }
    }
    G ? this.okEnabled(true) : this.okEnabled(false)
};
ModifyVolumeAction.prototype.okCallback = function() {
    var K = {};
    var I = {};
    var L = this.selected.getObject().get("volume_name");
    this.retrieve(K);
    var H = "";
    if (K.modVolForm.valid) {
        var D = [];
        if (K.expandSize.valueChanged) {
            var F = new Size(K.expandSize.value);
            var E = F.unTranslate(F.format("auto"));
            if (this.storageType == STORAGE_CLASS.VIRTUAL && this.overcommitEnabled) {
                var G = MC.poolsSet.virtUncommittedSize[this.myPool];
                if (G.getRawValue() > 0 && Size.compare(F, G) > 0) {
                    H = strings.overcommitMsg + "<br />"
                }
            }
            D[D.length] = {
                name: "expandVolume",
                command: MC.expandVolume,
                data: {
                    volumeSerial: this.selected.key,
                    volumeSize: E
                },
                options: {
                    processingMsg: strings.modifyVolumeAction.processing(strings.size),
                    failureMsg: strings.modifyVolumeAction.failure(strings.size)
                }
            }
        }
        if (K.modVolName.valueChanged) {
            D[D.length] = {
                name: "setVolName",
                command: MC.setVolumeName,
                data: {
                    volumeSerial: this.selected.key,
                    volumeName: K.modVolName.value.trim()
                },
                options: {
                    processingMsg: strings.modifyVolumeAction.processing(strings.name),
                    failureMsg: strings.modifyVolumeAction.failure(strings.name)
                }
            }
        }
        if (K.preference.valueChanged) {
            var J = "no-affinity";
            switch (K.preference.value) {
                case TIER_AFFINITY.ARCHIVE:
                    J = "archive";
                    break;
                case TIER_AFFINITY.PERFORMANCE:
                    J = "performance";
                    break;
                case TIER_AFFINITY.NOAFFINITY:
                default:
                    break
            }
            D.push({
                name: "setPreference",
                command: MC.setVolume,
                data: {
                    serial: this.selected.key,
                    preference: J
                },
                options: {
                    processingMsg: strings.modifyVolumeAction.processing(strings.preference),
                    failureMsg: strings.modifyVolumeAction.failure(strings.preference)
                }
            })
        }
        if (K.writePolicy.valueChanged || K.readAhead.valueChanged || K.optimization.valueChanged) {
            var C = {
                volumeSerial: this.selected.key
            };
            if (K.writePolicy.valueChanged) {
                C.writePolicy = K.writePolicy.value;
                if (K.writePolicy.value == "write-through") {
                    H = strings.modifyVolumeAction.writeThroughConfirmMsg + "<br />"
                }
            }
            if (K.optimization.valueChanged) {
                C.optimization = K.optimization.value;
                H = H + strings.modifyVolumeAction.optimizationConfirmMsg + "<br />";
                switch (K.optimization.value) {
                    case "no-mirror":
                        H = H + strings.modifyVolumeAction.no_mirrorOptConfirmMsg + "<br />";
                        break;
                    case "standard":
                    case "atomic-write":
                    default:
                        break
                }
            }
            if (K.readAhead.valueChanged) {
                C.readAhead = K.readAhead.value;
                H = H + strings.modifyVolumeAction.readAheadSizeConfirmMsg + "<br />"
            }
            H = H + strings.modifyVolumeAction.continueMsg;
            D[D.length] = {
                name: "setVolCacheParams",
                command: MC.modifyVolumeCache,
                data: C,
                options: {
                    processingMsg: strings.modifyVolumeAction.processing(strings.cache),
                    failureMsg: strings.modifyVolumeAction.failure(strings.cache)
                }
            }
        }
        MC.execCommandList(D, {
            closeActionOn: "success",
            confirmMsg: H,
            successMsg: strings.modifyVolumeAction.success(L)
        })
    }
};

function RollbackVolumeAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RollbackVolumeAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    this.volToRollback = "";
    C.widgets = [this.rollbackVolForm = new FormWidget({
        name: "rollbackVolForm",
        widgets: [new WidgetContainer({
            name: "rollbackVolContainer",
            widgets: [new TextWidget({
                name: "volToRollback",
                bottomMargin: true,
                label: strings.rollbackVolume.forVolLabel,
                labelOptions: {
                    bottomMargin: true
                }
            }), new TableInator({
                name: "snapsTable",
                selectable: "single",
                bottomMargin: true,
                noFeatures: true,
                selectCallback: createObjectCallback(this, this._snapSelected),
                type: "apiData",
                metadata: "snapshots",
                fields: ["name", "master_volume_name", "status", "snap_data", "uniquedata", "shareddata", "snapshot_type"]
            }), new CheckboxInputWidget({
                name: "modifiedSnap",
                label: strings.rollbackVolume.withModified,
                value: false
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RollbackVolumeAction"
}
RollbackVolumeAction.prototype = new ActionPanel();
RollbackVolumeAction.prototype.constructor = RollbackVolumeAction;
RollbackVolumeAction.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.supportsSnaps()) {
        return false
    }
    if (!licenseInfo.isLicensed("snapshot")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected("volumes", 1);
    if (D) {
        var C = MC.snapshotsSet.dataSelect({
            type: "prop",
            name: "master_volume_name",
            value: DC.base.volumes[D[0].key].get("volume_name")
        });
        if (DC.base.volumes[D[0].key].get("replication_set")) {
            var F = D[0].getObject();
            if (F.get("cs_replication_role") == "Secondary") {
                var E = DC.virtualReplicationSetsSerial[F.get("replication_set")];
                if (E.get("status_numeric") != REP_STATUS.FAILEDOVER) {
                    return strings.menuTips.noReplicationRollback
                }
            }
        }
        if (C.objects.length > 0) {
            var F = D[0].getObject();
            if (F.get("storage_type_numeric") == STORAGE_CLASS.LINEAR && RI.pagedOnly()) {
                return strings.menuTips.linearNotSupported
            } else {
                return D
            }
        } else {
            return strings.menuTips.selectSingleWith(strings.volume, strings.snapshot)
        }
    } else {
        return strings.menuTips.selectSingle(strings.volume)
    }
};
RollbackVolumeAction.prototype.showing = function() {
    var C = this.previousSelection[0].getObject();
    this.volToRollback = C.get("volume_name");
    this.isVirtual = (C.getInt("storage_type_numeric") == VOLUME_CLASS.VIRTUAL);
    this.update({
        volToRollback: {
            text: this.volToRollback
        },
        snapsTable: {
            data: MC.snapshotsSet.data.objects,
            criteria: createObjectCallback(this, this._getSnapsCriteria)
        },
        modifiedSnap: {
            visibility: (this.isVirtual ? "collapse" : "visible"),
            disable: this.isVirtual
        }
    })
};
RollbackVolumeAction.prototype._getSnapsCriteria = function(C) {
    if (this.volToRollback && C.prop.master_volume_name.text == this.volToRollback) {
        return true
    } else {
        return false
    }
};
RollbackVolumeAction.prototype.changedCallback = function(H, E, F) {
    var C = {};
    this.retrieve(C);
    var G = false;
    if (C.rollbackVolForm.valid) {
        for (var D in C) {
            if (this.snapSelected) {
                G = true;
                break
            }
            if (C[D].valueChanged) {
                G = true;
                break
            }
        }
        G ? this.okEnabled(true, true) : this.okEnabled(false)
    } else {
        this.okEnabled(false)
    }
};
RollbackVolumeAction.prototype._snapSelected = function(E, C, D) {
    this.snapSelected = true;
    this.changedCallback(E, C, D)
};
RollbackVolumeAction.prototype.okCallback = function() {
    var E = {};
    var D = {};
    this.retrieve(E);
    var G = DC.base.snapshots[E.snapsTable.selected[0].key].prop.name.text;
    if (this.isVirtual) {
        var F = strings.rollbackVolume.confirmVirtual;
        var C = strings.rollbackVolume.successVirtual
    } else {
        var F = strings.rollbackVolume.confirmLinear;
        var C = strings.rollbackVolume.successLinear
    }
    if (E.rollbackVolForm.valid) {
        D.volumeName = this.volToRollback;
        D.snapshotName = G;
        D.modifiedSnapshot = E.modifiedSnap.value;
        MC.rollbackVolume(D, {
            dialog: true,
            confirmMsg: F,
            processingMsg: strings.rollbackVolume.processing(this.volToRollback),
            failureMsg: strings.rollbackVolume.failure(this.volToRollback),
            successMsg: C(this.volToRollback),
            closeActionOn: "success"
        })
    }
};

function ResetSnapshotAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ResetSnapshotAction";
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.widgets = [new WidgetContainer({
        widgets: [new FormWidget({
            name: "resetSnapForm",
            widgets: [new TextWidget({
                name: "snapToReset",
                bottomMargin: true,
                label: strings.resetSnapshotAction.snapshotLabel
            }), this.schedContainer = new CheckboxContainer({
                name: "resetSnapSchedContainer",
                label: strings.resetSnapshotAction.scheduleLabel,
                changeCallback: createObjectCallback(this, this._toggleSchedule),
                widgets: [this.scheduleInputWidget = new ScheduleInputWidget({
                    name: "resetSnapSched",
                    changeCallback: createObjectCallback(this, this._scheduleChanged)
                })]
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ResetSnapshotAction"
}
ResetSnapshotAction.prototype = new ActionPanel();
ResetSnapshotAction.prototype.constructor = ResetSnapshotAction;
ResetSnapshotAction.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.supportsSnaps()) {
        return false
    }
    if (!licenseInfo.isLicensed("snapshot")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["snapshots", "volumes"], 1);
    if (C) {
        if (DC.base.snapshots[C[0].key] === undefined) {
            return strings.menuTips.selectSingle(strings.snapshot)
        } else {
            var D = C[0].getObject();
            if (D.get("storage_type_numeric") == STORAGE_CLASS.LINEAR && RI.pagedOnly()) {
                return strings.menuTips.linearNotSupported
            } else {
                return C
            }
        }
    } else {
        return strings.menuTips.selectSingle(strings.snapshot)
    }
};
ResetSnapshotAction.prototype.showing = function() {
    var C = this.previousSelection[0];
    this.snapName = DC.base.snapshots[C.key].get("name");
    var D = (DC.base.volumes[C.key].getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL);
    this.update({
        snapToReset: {
            text: this.snapName
        },
        resetSnapSchedContainer: {
            value: false,
            visibility: "visible"
        }
    });
    this.okEnabled(true);
    this.resetSize({
        shrink: true
    })
};
ResetSnapshotAction.prototype._toggleSchedule = function(E, C, D) {
    this.resetSize({
        shrink: true
    })
};
ResetSnapshotAction.prototype._scheduleChanged = function(E, C, D) {
    this.resetSize({
        shrink: true
    })
};
ResetSnapshotAction.prototype._okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.resetSnapSchedContainer.value) {
        this._initiateScheduleResetSnapshot(C)
    } else {
        this._initiateResetSnapshot(C)
    }
};
ResetSnapshotAction.prototype._initiateResetSnapshot = function(C) {
    MC.resetSnapshot({
        snapshotName: this.snapName
    }, {
        dialog: true,
        confirmMsg: strings.resetSnapshotAction.confirmMsg(this.snapName),
        processingMsg: strings.resetSnapshotAction.processing(this.snapName),
        failureMsg: strings.resetSnapshotAction.failure(this.snapName),
        successMsg: strings.resetSnapshotAction.success(this.snapName),
        closeActionOn: "success"
    })
};
ResetSnapshotAction.prototype._initiateScheduleResetSnapshot = function(D) {
    this.taskName = DC.getUnusedKey("tasks", this.snapName + "TR000", 32);
    this.schedName = DC.getUnusedKey("schedules", this.snapName + "SR000", 32);
    var C = [{
        name: "task",
        command: MC.createTask,
        data: {
            name: this.taskName,
            type: "ResetSnapshot",
            snapshotVolume: this.snapName
        },
        options: {
            processingMsg: strings.resetSnapshotAction.taskProcessing(this.snapName),
            failureMsg: strings.resetSnapshotAction.taskFailure(this.snapName)
        }
    }];
    C[C.length] = {
        name: "schedules",
        command: MC.createSchedule,
        data: {
            name: this.schedName,
            scheduleSpecification: D.resetSnapSched.value,
            taskName: this.taskName
        },
        options: {
            processingMsg: strings.resetSnapshotAction.scheduleProcessing(this.snapName),
            failureMsg: strings.resetSnapshotAction.scheduleFailure(this.snapName)
        }
    };
    MC.execCommandList(C, {
        closeActionOn: "success",
        callback: createObjectCallback(this, this._scheduleTaskComplete),
        successMsg: strings.resetSnapshotAction.scheduleSuccess(this.snapName)
    })
};
ResetSnapshotAction.prototype._scheduleTaskComplete = function(C) {
    var D = C.results.schedules;
    if (D && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: false
        })
    }
};

function DeleteVolumesAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DeleteVolumesAction";
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.okButtonText = strings.deleteVolumes.buttonText;
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "deleteWC",
        widgets: [new TextWidget({
            classes: "scrollText100",
            name: "volumeNamesText",
            label: strings.VolumesAndSnapshots,
            width: 240
        }), new TextWidget({
            name: "warningText",
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteVolumesAction"
}
DeleteVolumesAction.prototype = new ActionPanel();
DeleteVolumesAction.prototype.constructor = DeleteVolumesAction;
DeleteVolumesAction.getMenuState = function() {
    var E;
    var D;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var F = TopicPanel.getSelected(["snapshots", "volumes"], 100);
    if (F) {
        for (var C = 0; C < F.length; C++) {
            E = DC.base.volumes[F[C].key];
            volRepSetSerial = E.get("replication_set");
            D = E.get("volume_group");
            if (D != "UNGROUPEDVOLUMES") {
                return strings.menuTips.noneOfTheseBelongingToThis(strings.volumes, strings.volumeGroups)
            }
            if (propertyCount(E.snapshots) > 0) {
                return strings.menuTips.volumesWithoutSnapshots
            }
            if (DC.virtualReplicationSetsSerial[volRepSetSerial]) {
                return strings.menuTips.volAlreadyInRepSet
            }
        }
        return F
    } else {
        return strings.menuTips.selectMax(100, strings.volumesSlashsnapshots)
    }
};
DeleteVolumesAction.prototype.showing = function() {
    this.selected = this.previousSelection;
    this.volNames = [];
    this.volSerials = [];
    var G = 0;
    var E = 0;
    var I = 0;
    var D = "";
    var J = "";
    this.multiple = false;
    for (var H = 0; H < this.selected.length; H++) {
        var C = DC.base.volumes[this.selected[H].key];
        var F = C.getInt("volume_type_numeric");
        if (F == VOLUME_TYPES.MASTER_VOLUME || F == VOLUME_TYPES.VOLUME || F == VOLUME_TYPES.BASE || F == VOLUME_TYPES.VOLUME_COPY) {
            G++
        } else {
            if (F == VOLUME_TYPES.SNAPSHOT || F == VOLUME_TYPES.PAGED_SNAPSHOT) {
                E++
            } else {
                if (F == VOLUME_TYPES.BACKING_STORE) {
                    I++
                }
            }
        }
        D = C.get("volume_name");
        J = C.get("serial_number");
        this.volNames.push(D);
        this.volSerials.push(J)
    }
    this.multiple = ((G + E + I) > 1);
    this.update({
        volumeNamesText: {
            text: MC.getItemList(this.volNames, true),
            label: ((this.multiple) ? strings.volumeLabelPlural : strings.volumeLabel)
        },
        warningText: {
            text: strings.deleteVolumes.panelWarning(((this.multiple) ? strings.volumes : strings.volume))
        }
    });
    this.resetSize();
    this.okEnabled(true, true)
};
DeleteVolumesAction.prototype._okCallback = function() {
    var G = {
        dialog: true,
        processingMsg: strings.deleteVolumes.processing((this.multiple) ? strings.volumes : strings.volume),
        confirmMsg: strings.deleteVolumes.panelWarning((this.multiple) ? strings.volumes : strings.volume),
        failureMsg: strings.deleteVolumes.failure((this.multiple) ? strings.volumes : strings.volume),
        successMsg: ((this.multiple) ? strings.deleteVolumes.successPlural((this.multiple) ? strings.volumes : strings.volume) : strings.deleteVolumes.successSingular((this.multiple) ? strings.volumes : strings.volume)),
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    };
    var D = 30;
    if (this.volSerials.length > D) {
        var C = [];
        while (this.volSerials.length > 0) {
            var E = [];
            E = this.volSerials.splice(0, D);
            C.push({
                name: "deleteVols",
                command: MC.deleteVolumes,
                data: {
                    volumes: E
                },
                options: {
                    processingMsg: G.processingMsg,
                    failureMsg: G.failureMsg
                }
            })
        }
        MC.execCommandList(C, G)
    } else {
        var F = {
            volumes: this.volSerials
        };
        MC.deleteVolumes(F, G)
    }
};

function CreateSnapshotAction(G) {
    if (arguments.length == 0) {
        return
    }
    G.name = "CreateSnapshotAction";
    G.okCallback = createObjectCallback(this, this.okCallback);
    this.PANEL_STATES = {
        NOT_SCHEDULED: 0,
        SCHEDULED: 1,
        SCHEDULED_REPEAT: 2
    };
    this.PANEL_INPUTS = {
        SCHED_BOX_CHANGED: 0,
        REPEAT_CHANGED: 1
    };
    this.state = this.PANEL_STATES.NOT_SCHEDULED;
    this.volNames = [];
    this.stateTable = [{
        nextState: [this.PANEL_STATES.SCHEDULED, this.PANEL_STATES.NOT_SCHEDULED]
    }, {
        nextState: [this.PANEL_STATES.NOT_SCHEDULED, this.PANEL_STATES.SCHEDULED_REPEAT]
    }, {
        nextState: [this.PANEL_STATES.NOT_SCHEDULED, this.PANEL_STATES.SCHEDULED]
    }];
    var D = [];
    var H = DC.systemParameters.getInt("max_task_retention_count");
    for (var E = 1; E <= H; E++) {
        D[D.length] = {
            value: "" + E,
            text: "" + E
        }
    }
    var C = createObjectCallback(this, this.changedCallback);
    this.createSnapTable = new TableWidget({
        name: "createSnapshotTable",
        bottomMargin: true,
        classes: "width100pct",
        widgets: [new LabelWidget({
            value: strings.createSnapshot.srcVolLabel,
            row: 0,
            col: 0,
            classes: "formTableHeadingCenter",
            noTerminator: true
        }), new LabelWidget({
            value: strings.createSnapshot.creatingSnapshotLabel,
            row: 0,
            col: 1,
            classes: "formTableHeadingCenter",
            noTerminator: true
        })]
    });
    for (var F = 1; F <= CreateSnapshotAction.MAXSNAPSHOTSELECTIONS; F++) {
        this.createSnapTable.add(new TextWidget({
            name: "volumeSource" + F,
            row: F,
            col: 0,
            topSmallMargin: true
        }));
        this.createSnapTable.add(new TextInputWidget({
            name: "snapshotName" + F,
            rules: {
                dhName: true,
                utf8length: 32,
                volumeExists: true
            },
            changeCallback: C,
            row: F,
            col: 1,
            disable: true,
            topSmallMargin: true
        }))
    }
    G.widgets = [new TextWidget({
        name: "actionDescription",
        text: strings.createSnapshot.actionDescriptionSingle,
        topMargin: true,
        bottomMargin: true
    }), this.form = new FormWidget({
        name: "createSnapshotForm",
        widgets: [this.createSnapTable, this.schedContainer = new CheckboxContainer({
            name: "scheduleContainer",
            label: strings.createSnapshot.scheduledCheckBoxLabel,
            value: false,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.toggleSchedule),
            widgets: [new TextInputWidget({
                name: "snapshotPrefix",
                label: strings.createSnapshot.snapshotPrefixLabel,
                topMargin: true,
                rules: {
                    dhName: true,
                    utf8length: 26
                },
                changeCallback: C
            }), new OptionInputWidget({
                name: "retentionCount",
                label: strings.createSnapshot.retentionLabel,
                values: D,
                bottomMargin: true,
                topMargin: true
            }), this.scheduleInputWidget = new ScheduleInputWidget({
                name: "createSnapshotSchedule",
                changeCallback: createObjectCallback(this, this.scheduleChanged)
            })]
        })]
    })];
    ActionPanel.call(this, G);
    this.class_name = "CreateSnapshotAction"
}
CreateSnapshotAction.prototype = new ActionPanel();
CreateSnapshotAction.prototype.constructor = CreateSnapshotAction;
CreateSnapshotAction.MAXSNAPSHOTSELECTIONS = 16;
CreateSnapshotAction.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.supportsSnaps()) {
        return false
    }
    if (!licenseInfo.isLicensed("snapshot")) {
        return strings.menuTips.notLicensed
    }
    var H = 0;
    var C = 0;
    var E = TopicPanel.getSelected(["volumes"], CreateSnapshotAction.MAXSNAPSHOTSELECTIONS);
    if (E) {
        var F = E.length;
        if (licenseInfo.snapshotsAvail() < F) {
            return strings.menuTips.snapshotsExceeded
        }
        for (var G = 0; G < F; G++) {
            var D = E[G].getObject();
            if (!D.isSnappable()) {
                return strings.menuTips.selectRangeOfType("1", "16", strings.snappableVolumes, strings.classStr)
            }
            if (D.getInt("storage_type_numeric") == VOLUME_CLASS.LINEAR) {
                H++
            } else {
                C++
            }
        }
        if (H && RI.pagedOnly()) {
            return strings.menuTips.linearNotSupported
        }
        if (H && C) {
            return strings.menuTips.selectRangeOfType("1", "16", strings.snappableVolumes, strings.classStr)
        } else {
            return E
        }
    } else {
        return strings.menuTips.selectRangeOfType("1", "16", strings.snappableVolumes, strings.classStr)
    }
};
CreateSnapshotAction.prototype.showing = function() {
    var G;
    var D;
    this.selected = this.previousSelection;
    var K = {};
    this.virtSize = {
        A: new Size(),
        B: new Size()
    };
    var J = [];
    for (var C = 0; C < this.selected.length; C++) {
        G = this.selected[C].getObject();
        D = G.get("volume_name");
        K["volumeSource" + (C + 1)] = {
            text: D
        };
        var I = DC.getUnusedKey("snapshots", D + "_s", J);
        K["snapshotName" + (C + 1)] = {
            value: I,
            disable: false
        };
        this.volNames.push(D);
        if (G.get("storage_pool_name") && G.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL) {
            this.virtSize[G.get("storage_pool_name")].add(G.getPages(), "pages")
        }
    }
    if (this.selected.length == 1) {
        var L = MC.schedulesSet.select({
            type: "prop",
            name: "task_type",
            value: "TakeSnapshot"
        });
        var E = [];
        for (var H = 0; H < L.objects.length; H++) {
            var F = L.objects[H].get("task_snapshot_prefix");
            if (F && E.find(F) == -1) {
                E.push(F)
            }
        }
        this.update({
            createSnapshotTable: {
                hide: {
                    start: 2
                }
            },
            volumeSource1: {
                text: this.volNames[0]
            },
            snapshotName1: {
                value: I,
                disable: ((this.state != this.PANEL_STATES.NOT_SCHEDULED) ? true : false)
            },
            snapshotPrefix: {
                value: DC.getUnusedKey("snapshots", this.volNames[0] + "s00", E, 24),
                disable: ((this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true)
            },
            retentionCount: {
                value: 1,
                disable: ((this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true)
            },
            createSnapshotSchedule: {
                disable: ((this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true)
            }
        })
    } else {
        if (this.selected.length != 1) {
            K.actionDescription = {
                text: strings.createSnapshot.actionDescriptionMulti
            }
        } else {
            K.actionDescription = {
                text: strings.createSnapshot.actionDescriptionSingleNoSched
            }
        }
        K.createSnapshotTable = {
            hide: {
                start: this.selected.length + 1
            }
        };
        K.scheduleContainer = {
            visibility: "collapse",
            disable: true
        };
        this.update(K)
    }
    this._panelResize();
    this.okEnabled(true);
    if (this.form && (this.selected.length > 1)) {
        this.form.addCustomValidator(createObjectCallback(this, this.customValidator))
    }
};
CreateSnapshotAction.prototype.customValidator = function() {
    var D;
    var G;
    var F = {};
    var H = {};
    var C = {};
    this.retrieve(C, true);
    for (var E = 0; E < this.selected.length; E++) {
        G = "snapshotName" + (E + 1);
        D = C[G].value;
        if (F[D]) {
            H[G] = {
                message: strings.createSnapshot.snapshotNameNotUnique,
                relatedInputs: F[D]
            };
            return H
        } else {
            F[D] = true
        }
    }
    return null
};
CreateSnapshotAction.prototype._nextState = function(C) {
    this.state = this.stateTable[this.state].nextState[C]
};
CreateSnapshotAction.prototype._panelResize = function() {
    this.resetSize({
        shrink: true
    })
};
CreateSnapshotAction.prototype.changedCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.createSnapshotForm) {
        return
    }(C.createSnapshotForm.valid) ? this.okEnabled(true): this.okEnabled(false)
};
CreateSnapshotAction.prototype.toggleSchedule = function(F, D, E) {
    this._nextState(this.PANEL_INPUTS.SCHED_BOX_CHANGED);
    this.update({
        snapshotName1: {
            disable: (this.state != this.PANEL_STATES.NOT_SCHEDULED) ? true : false
        },
        snapshotPrefix: {
            disable: (this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true
        },
        retentionCount: {
            disable: (this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true
        },
        createSnapshotSchedule: {
            disable: (this.state != this.PANEL_STATES.NOT_SCHEDULED) ? false : true
        }
    });
    var C = {};
    this.retrieve(C);
    if (!C.createSnapshotForm) {
        return
    }(C.createSnapshotForm.valid) ? this.okEnabled(true): this.okEnabled(false);
    this._panelResize()
};
CreateSnapshotAction.prototype.scheduleChanged = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.createSnapshotForm) {
        return
    }(C.createSnapshotForm.valid) ? this.okEnabled(true): this.okEnabled(false);
    if ((this.state == this.PANEL_STATES.SCHEDULED_REPEAT) != F.createSnapshotSchedule_repeat.value) {
        this._nextState(this.PANEL_INPUTS.REPEAT_CHANGED)
    }
    this._panelResize()
};
CreateSnapshotAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (this.state != this.PANEL_STATES.NOT_SCHEDULED) {
        this._initiateScheduleCreateSnapshot(C)
    } else {
        this._initiateCreateSnapshot(C)
    }
};
CreateSnapshotAction.prototype._initiateCreateSnapshot = function(D) {
    var F = {};
    F.snapshotNames = [];
    F.volumeNames = this.volNames;
    var E = (this.selected.length > 1) ? "s" : "";
    var C = false;
    for (var H in DC.getVirtualPoolNames()) {
        if (DC.pools[H].getInt("overcommit_numeric") && MC.poolsSet.virtUncommittedSize[H].getRawValue() > 0 && Size.compare(this.virtSize[H], MC.poolsSet.virtUncommittedSize[H]) > 0) {
            C = true
        }
    }
    for (var G = 0; G < this.selected.length; G++) {
        F.snapshotNames[G] = D["snapshotName" + (G + 1)].value
    }
    MC.createSnapshots(F, {
        dialog: true,
        confirmMsg: (C ? strings.overcommitMsg : null),
        processingMsg: strings.createSnapshot.processing(E),
        failureMsg: strings.createSnapshot.failure(E),
        successMsg: strings.createSnapshot.success(E),
        closeActionOn: "success"
    })
};
CreateSnapshotAction.prototype._initiateScheduleCreateSnapshot = function(D) {
    this.taskName = DC.getUnusedKey("tasks", this.volNames[0] + "TS000", 32);
    this.schedName = DC.getUnusedKey("schedules", this.volNames[0] + "SS000", 32);
    var F = {
        name: this.taskName,
        type: "TakeSnapshot",
        sourceVolume: this.volNames[0],
        snapshotPrefix: D.snapshotPrefix.value,
        retentionCount: D.retentionCount.value
    };
    var E = [{
        name: "task",
        command: MC.createTask,
        data: F,
        options: {
            processingMsg: strings.createSnapshot.taskProcessing(D.snapshotName1.value),
            failureMsg: strings.createSnapshot.taskFailure(D.snapshotName1.value)
        }
    }];
    var C = {
        name: this.schedName,
        scheduleSpecification: D.createSnapshotSchedule.value,
        taskName: this.taskName
    };
    E.push({
        name: "schedules",
        command: MC.createSchedule,
        data: C,
        options: {
            processingMsg: strings.createSnapshot.scheduleProcessing(this.volNames[0]),
            failureMsg: strings.createSnapshot.scheduleFailure(this.volNames[0])
        }
    });
    MC.execCommandList(E, {
        closeActionOn: "success",
        callback: createObjectCallback(this, this._scheduleTaskComplete),
        successMsg: strings.createSnapshot.scheduleSuccess(this.volNames[0])
    })
};
CreateSnapshotAction.prototype._scheduleTaskComplete = function(C) {
    var D = C.results.schedules;
    if (D && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true
        })
    }
};

function AddToVolumeGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AddToVolumeGroupAction";
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    this.volsList = [];
    this.volsWithGroup = {};
    this.confirmMsg = "";
    this.groupToAdd = "";
    C.widgets = [new WidgetContainer({
        name: "avgaVolsWC",
        bottomMargin: true,
        widgets: [new TextWidget({
            name: "avgaVolumes",
            label: strings.Volumes,
            classes: "scrollText100",
            width: 300
        })]
    }), new WidgetContainer({
        name: "avgaGroupsContainer",
        classes: "aAvgaGroupsContainer",
        widgets: [this.avgaForm = new FormWidget({
            name: "avgaForm",
            widgets: [new TextWidget({
                name: "avgaComboInfo",
                text: strings.addToVolumeGroup.groupComboInfo,
                bottomSmallMargin: true
            }), new ComboBoxWidget({
                name: "avgaVolumeGroups",
                label: strings.VolumeGroups,
                allowInput: true,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: 32
                },
                changeCallback: createObjectCallback(this, this.groupsChanged)
            })]
        })]
    }), new WidgetContainer({
        name: "avgaConfirmWC",
        widgets: [new TextWidget({
            name: "avgaConfirm",
            classes: "scrollText100",
            width: 380
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "AddToVolumeGroupAction"
}
AddToVolumeGroupAction.prototype = new ActionPanel();
AddToVolumeGroupAction.prototype.constructor = AddToVolumeGroupAction;
AddToVolumeGroupAction.getMenuState = function() {
    if (!RI.hasFeature("volumeGroups") || !session.hasConfigurationCapability()) {
        return false
    }
    var G = TopicPanel.getSelected(["volumes"], 20);
    if (G) {
        var F = "";
        var C = -1;
        for (var E = 0; E < G.length; E++) {
            var H = G[E].getObject();
            var D = H.get("volume_group");
            if (!H.isGroupable()) {
                return strings.menuTips.onlyGroupableVolumes
            }
            if (C == -1) {
                C = H.getInt("storage_type_numeric")
            } else {
                if (C != H.getInt("storage_type_numeric")) {
                    return strings.menuTips.selectRangeOfType("1", "20", strings.volumes, strings.classStr)
                }
            }
            if (C == VOLUME_CLASS.VIRTUAL) {
                if (F == "") {
                    F = H.get("storage_pool_name")
                } else {
                    if (F != H.get("storage_pool_name")) {
                        return strings.menuTips.onlyInSamePool
                    }
                }
            }
            if (D != "UNGROUPEDVOLUMES") {
                return strings.menuTips.selectRange("1", "20", strings.ungroupedVolumes)
            }
        }
        return G
    } else {
        return strings.menuTips.selectRangeOfType("1", "20", strings.volumes, strings.classStr)
    }
};
AddToVolumeGroupAction.prototype.showing = function() {
    var D = this.previousSelection;
    var C = {};
    this._setVolList(D);
    C.avgaConfirm = {
        visibility: "hidden"
    };
    C.avgaVolumes = {
        text: MC.getItemList(this.volsList, true)
    };
    C.avgaVolumeGroups = {
        focus: true,
        values: this._getVolumeGroups()
    };
    C.avgaForm = {
        resetValidation: true
    };
    this.update(C)
};
AddToVolumeGroupAction.prototype._setVolList = function(F) {
    for (var D = 0; D < F.length; D++) {
        var E = DC.volumesSerial[F[D].key].get("volume_name");
        var C = DC.volumesSerial[F[D].key].get("volume_group");
        volGroupName = DC.volumeGroupsSerial[C].get("group_name");
        this.volsList.push(E);
        if (C != "UNGROUPEDVOLUMES") {
            if (!this.volsWithGroup[C]) {
                this.volsWithGroup[C] = [E]
            } else {
                this.volsWithGroup[C].push(E)
            }
        }
    }
};
AddToVolumeGroupAction.prototype._setConfirmMsg = function(D) {
    var C = "";
    if (this.groupToAdd) {
        C += strings.addToVolumeGroup.addVolumesAndCreateGroup(D)
    }
    var F = false;
    for (var E in this.volsWithGroup) {
        F = true;
        break
    }
    if (F) {
        C += strings.addToVolumeGroup.alreadyMember
    }
    if (D != "") {
        C += strings.addToVolumeGroup.confirmMsg
    }
    this.confirmMsg = C
};
AddToVolumeGroupAction.prototype.okCallback = function() {
    if (this.groupToAdd != undefined) {
        if (this.volsWithGroup) {
            var E = [];
            for (var C in this.volsWithGroup) {
                var H = DC.volumeGroupsSerial[C].get("group_name");
                var G = this.volsWithGroup[C];
                E.push({
                    name: "remove" + C,
                    command: MC.removeVolumeGroupMembers,
                    data: {
                        volNames: G,
                        groupName: H
                    },
                    options: {
                        processingMsg: strings.addToVolumeGroup.remove.processingMsg(MC.getItemList(G, true), H),
                        failureMsg: strings.addToVolumeGroup.remove.failureMsg(MC.getItemList(G, true), H)
                    }
                })
            }
            MC.execCommandList(E, {
                failureMsg: strings.addToVolumeGroup.remove.failureMsg,
                noSuccessDialog: true
            })
        }
        MC.createVolumeGroup({
            volNames: this.volsList,
            groupName: this.groupToAdd
        }, {
            dialog: true,
            processingMsg: strings.addToVolumeGroup.create.processingMsg(this.groupToAdd),
            failureMsg: strings.addToVolumeGroup.create.failureMsg(this.groupToAdd),
            successMsg: strings.addToVolumeGroup.create.successMsg(this.groupToAdd),
            closeActionOn: "success"
        })
    } else {
        var D = {};
        this.retrieve(D);
        var F = D.avgaVolumeGroups.value;
        var H = DC.volumeGroupsSerial[F].get("group_name");
        MC.addVolumeGroupMembers({
            volNames: this.volsList,
            groupName: H
        }, {
            dialog: true,
            processingMsg: strings.addToVolumeGroup.add.processingMsg(H),
            failureMsg: strings.addToVolumeGroup.add.failureMsg(H),
            successMsg: strings.addToVolumeGroup.add.successMsg(H),
            closeActionOn: "success"
        })
    }
};
AddToVolumeGroupAction.prototype.groupsChanged = function(G, E, F) {
    var C = {};
    var D = G[E.name].value;
    if (DC.volumeGroupsSerial[D]) {
        delete this.groupToAdd
    } else {
        this.groupToAdd = D
    }
    if (D != "" && !E.invalid) {
        this._setConfirmMsg(D);
        C.avgaConfirm = {
            text: this.confirmMsg,
            visibility: "visible"
        };
        this.okEnabled(true)
    } else {
        this._setConfirmMsg();
        C.avgaConfirm = {
            text: "",
            visibility: "hidden"
        };
        this.okEnabled(false)
    }
    this.update(C);
    this.resetSize()
};
AddToVolumeGroupAction.prototype._getVolumeGroups = function() {
    var C = DC.volumeGroups;
    var D = [];
    for (vg in C) {
        if (C[vg].getInt("type_numeric") != VOLUME_GROUP_TYPES.CONSISTENCY && C[vg].get("group_name") != strings.volumeNotGrouped) {
            D.push({
                value: C[vg].get("serial_number"),
                text: C[vg].get("group_name")
            })
        }
    }
    return D
};

function RemoveFromVolumeGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveFromVolumeGroupAction";
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    this.volGroups = {};
    C.widgets = [new WidgetContainer({
        name: "rvfgaVolsWC",
        bottomMargin: true,
        widgets: [new TextWidget({
            name: "rfvgaVolumes",
            label: strings.Volumes,
            classes: "scrollText100",
            width: 300
        }), new TextWidget({
            name: "rfvgaWarningText",
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveFromVolumeGroupAction"
}
RemoveFromVolumeGroupAction.prototype = new ActionPanel();
RemoveFromVolumeGroupAction.prototype.constructor = RemoveFromVolumeGroupAction;
RemoveFromVolumeGroupAction.getMenuState = function() {
    if (!RI.hasFeature("volumeGroups") || !session.hasConfigurationCapability()) {
        return false
    }
    var E = TopicPanel.getSelected(["volumes"]);
    if (E) {
        for (var D = 0; D < E.length; D++) {
            var C = DC.volumesSerial[E[D].key].get("volume_group");
            var F = DC.volumeGroupsSerial[C].getInt("type_numeric");
            if (C == "UNGROUPEDVOLUMES") {
                return strings.menuTips.oneOrMore(strings.groupedVolumes)
            }
            if (F == VOLUME_GROUP_TYPES.CONSISTENCY) {
                return strings.menuTips.noneOfTheseBelongingToThis(strings.volumes, strings.consistencyGroups)
            }
            if ((DC.volumeGroupsSerial[C].objects.length - E.length) < 1) {
                return strings.menuTips.mustContainMin(strings.VolumeGroups, 1, strings.volumes)
            }
            if (DC.volumeGroupsSerial[C].prop.replication_set_serial.text.length >= 1) {
                return strings.menuTips.partOfRepSet
            }
        }
        return E
    } else {
        return strings.menuTips.oneOrMore(strings.groupedVolumes)
    }
};
RemoveFromVolumeGroupAction.prototype.showing = function() {
    var G = this.previousSelection;
    this.multiple = (G.length > 1);
    var E = {};
    this._setGroupList(G);
    var D = "";
    var F;
    for (var C in this.volGroups) {
        var H = DC.volumeGroupsSerial[C].get("group_name");
        D += MC.getItemList(this.volGroups[C], true) + "<br/>";
        F = (typeof F != "undefined") ? (F + ", " + H) : H
    }
    E.rfvgaVolumes = {
        text: D
    };
    E.rfvgaWarningText = {
        text: strings.removeFromVolumeGroup.removeWarning(((this.multiple) ? strings.volumes : strings.volume), F)
    };
    this.update(E);
    this.okEnabled(true)
};
RemoveFromVolumeGroupAction.prototype._setGroupList = function(F) {
    for (var D = 0; D < F.length; D++) {
        var E = DC.volumesSerial[F[D].key].get("volume_name");
        var C = DC.volumesSerial[F[D].key].get("volume_group");
        if (!this.volGroups[C]) {
            this.volGroups[C] = []
        }
        this.volGroups[C].push(E)
    }
};
RemoveFromVolumeGroupAction.prototype.okCallback = function() {
    var E = [];
    for (var C in this.volGroups) {
        var F = DC.volumeGroupsSerial[C].get("group_name");
        var D = this.volGroups[C];
        E.push({
            name: "delete" + F + "Vols",
            command: MC.removeVolumeGroupMembers,
            data: {
                volNames: D,
                groupName: F
            },
            options: {
                dialog: true,
                processingMsg: strings.removeFromVolumeGroup.processingMsg(MC.getItemList(D, true), F),
                failureMsg: strings.removeFromVolumeGroup.failureMsg(MC.getItemList(D, true), F)
            }
        })
    }
    MC.execCommandList(E, {
        closeActionOn: "success",
        successMsg: strings.removeFromVolumeGroup.successMsg(MC.getItemList(D, true), F)
    })
};

function RenameVolumeGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RenameVolumeGroupAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [this.renVgaForm = new FormWidget({
        name: "renVgaForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "renVgaCurrentName",
            label: strings.Group,
            row: 0,
            col: 0,
            bottomMargin: true,
            singleCell: true
        }), new TextInputWidget({
            name: "renVgaNewGroupName",
            label: strings.renameVolumeGroup.NewGroupName,
            row: 1,
            col: 0,
            bottomMargin: true,
            singleCell: true,
            changeCallback: createObjectCallback(this, this.newNameChanged),
            rules: {
                dhName: true,
                required: true,
                utf8length: 32,
                volumeGroupExists: true
            }
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RenameVolumeGroupAction"
}
RenameVolumeGroupAction.prototype = new ActionPanel();
RenameVolumeGroupAction.prototype.constructor = RenameVolumeGroupAction;
RenameVolumeGroupAction.getMenuState = function() {
    if (!RI.hasFeature("volumeGroups") || !session.hasConfigurationCapability()) {
        return false
    }
    var E = APIVolumes.selectedGroups(TopicPanel.selection, true, 1);
    if (E) {
        var C = DC.volumeGroupsSerial[E[0].key];
        var F = C.getInt("type_numeric");
        var D = C.get("replication_set_serial");
        if (D != "") {
            return strings.menuTips.belongsToRepSet
        }
        if (F == VOLUME_GROUP_TYPES.CONSISTENCY) {
            return strings.menuTips.noneOfTheseBelongingToThis(strings.volumeGroups, strings.consistencyGroups)
        }
        return E
    } else {
        return strings.menuTips.selectNum(1, strings.volumeGroup)
    }
};
RenameVolumeGroupAction.prototype.showing = function() {
    var D = this.previousSelection[0];
    var C = {};
    var E = D.getObject();
    this.groupName = E.get("group_name");
    C.renVgaForm = {
        resetValidation: true
    };
    C.renVgaCurrentName = {
        text: this.groupName
    };
    C.renVgaNewGroupName = {
        focus: true
    };
    this.update(C)
};
RenameVolumeGroupAction.prototype.newNameChanged = function(F, D, E) {
    if (F[D.name].value) {
        var C = {};
        this.retrieve(C);
        this.newGroupName = F[D.name].value;
        if (C.renVgaForm.valid) {
            this.okEnabled(true)
        } else {
            this.resetSize();
            this.okEnabled(false)
        }
    } else {
        this.resetSize();
        this.okEnabled(false)
    }
};
RenameVolumeGroupAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.renVgaForm.valid) {
        MC.setVolumeGroup({
            currentName: this.groupName,
            newName: this.newGroupName
        }, {
            dialog: true,
            processingMsg: strings.renameVolumeGroup.processingMsg(this.groupName, this.newGroupName),
            successMsg: strings.renameVolumeGroup.successMsg(this.groupName, this.newGroupName),
            falureMsg: strings.renameVolumeGroup.failureMsg(this.groupName, this.newGroupName),
            closeActionOn: "success"
        })
    }
};

function RemoveVolumeGroupAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveVolumeGroupAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    this.volGroups = {};
    C.widgets = [new FormWidget({
        name: "remVgaWC",
        widgets: [new TextWidget({
            name: "remVgaGroups",
            label: strings.Groups,
            bottomMargin: true,
            classes: "scrollText100",
            width: 300
        }), new CheckboxInputWidget({
            name: "remVgaDeleteGroupsVols",
            label: strings.removeVolumeGroup.DeleteVolumes,
            singleCell: true,
            bottomMargin: true,
            changeCallback: createObjectCallback(this, this.deleteVols)
        }), new TextWidget({
            name: "remVgaWarningText"
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveVolumeGroupAction"
}
RemoveVolumeGroupAction.prototype = new ActionPanel();
RemoveVolumeGroupAction.prototype.constructor = RemoveVolumeGroupAction;
RemoveVolumeGroupAction.getMenuState = function() {
    if (!RI.hasFeature("volumeGroups") || !session.hasConfigurationCapability()) {
        return false
    }
    var E = APIVolumes.selectedGroups(TopicPanel.selection, true);
    if (E) {
        for (var C = 0; C < E.length; C++) {
            var D = DC.volumeGroupsSerial[E[C].key];
            if (D.get("replication_set_serial") != "") {
                return strings.menuTips.volGrpAlreadyInRepSet
            }
        }
        return E
    } else {
        return strings.menuTips.oneOrMore(strings.volumeGroups)
    }
};
RemoveVolumeGroupAction.prototype.showing = function() {
    var G = this.previousSelection;
    var F = {};
    var D = [];
    var H = [];
    for (var C = 0; C < G.length; C++) {
        var E = G[C].key;
        var I = DC.volumeGroupsSerial[E].get("group_name");
        if (I == "-ungrouped-") {
            continue
        }
        D.push(I);
        this.volGroups[I] = E
    }
    F.remVgaGroups = {
        text: MC.getItemList(D, true)
    };
    this.warningText = strings.removeVolumeGroup.removeGroupsWarning;
    F.remVgaWarningText = {
        text: this.warningText
    };
    this.update(F);
    this.okEnabled(true)
};
RemoveVolumeGroupAction.prototype.deleteVols = function(E, C, D) {
    warnText = this.warningText;
    if (E[C.name].value) {
        warnText += strings.removeVolumeGroup.removeVolsWarning
    } else {
        warnText = strings.removeVolumeGroup.removeGroupsWarning
    }
    this.update({
        remVgaWarningText: {
            text: warnText
        }
    });
    this.resetSize({
        shrink: true
    })
};
RemoveVolumeGroupAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var D = [];
    var H = [];
    for (var G in this.volGroups) {
        D.push(this.volGroups[G]);
        H.push(G)
    }
    var E = {
        groups: D,
        allVolumes: C.remVgaDeleteGroupsVols
    };
    var F = MC.getItemList(H, true);
    MC.deleteVolumeGroups(E, {
        dialog: true,
        processingMsg: strings.removeVolumeGroup.processingMsg(F),
        confirmMsg: (C.remVgaDeleteGroupsVols && C.remVgaDeleteGroupsVols.value) ? strings.removeVolumeGroup.confirmMsgGroupsAndVols(F) : strings.removeVolumeGroup.confirmMsgGroupsOnly(F),
        failureMsg: strings.removeVolumeGroup.failureMsg(F),
        successMsg: strings.removeVolumeGroup.successMsg(F),
        closeActionOn: "success"
    })
};

function createVolumesFactory(C) {
    if (arguments.length == 0) {
        return null
    }
    if (C.state) {
        if (C.state instanceof Array && C.state.length == 1) {
            var D = C.state[0].getObject();
            if (D) {
                if (D.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
                    return new CreateLinearVolumesAction({})
                } else {
                    return new CreateVirtualVolumesAction({})
                }
            }
        }
    }
    return null
}
createVolumesFactory.getMenuState = function(D) {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (D.actionOptions && D.actionOptions.topic == "Volumes") {
        return []
    } else {
        var C = TopicPanel.getSelected("pools", 1);
        if (!C) {
            return strings.menuTips.selectSingle(strings.pool)
        }
        if (C[0].getObject().getInt("storage_type_numeric") == VOLUME_CLASS.LINEAR) {
            var E = new Size(19532, "blocks");
            if (C[0].getObject().getInt("total_avail_numeric") > E.getBlocks()) {
                return C
            } else {
                return strings.menuTips.poolTooSmall
            }
        } else {
            return C
        }
    }
};

function CreateReplicationSetVol(F) {
    var E = 0;
    if (arguments.length == 0) {
        return
    }
    F.name = "CreateReplicationSetVol";
    F.autoHeight = true;
    F.okCallback = createObjectCallback(this, this.okCallback);
    this.volumeGroupSerial = "";
    this.volumeObj = "";
    this.volumeOption = CreateReplicationSetVol.source.SELECTVOLUME;
    this.repSetName = "";
    this.schedule = false;
    this.repSetSubscription = {};
    this.repStatus = false;
    this.MAXVOLUMESGROUP = 32;
    this.MAXRETENTIONCOUNT = 16;
    var C = [];
    for (var D = 1; D <= this.MAXRETENTIONCOUNT; D++) {
        C[C.length] = {
            value: "" + D,
            text: "" + D
        }
    }
    F.widgets = [this.createReplicationSetVolForm = new FormWidget({
        name: "createReplicationSetVolForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "volGroupInfo",
            row: E++,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            text: ""
        }), new TextWidget({
            name: "repVolume",
            row: E++,
            col: 1,
            bottomMargin: true,
            label: strings.createReplicationSetVol.volumeLabel,
            labelOptions: {
                rightMargin: true
            }
        }), new RadioButtonsInputWidget({
            name: "volumeOption",
            label: strings.createReplicationSetVol.sourceLabel,
            row: E++,
            col: 1,
            orientation: "horizontal",
            bottomSmallMargin: true,
            setOrig: true,
            values: [{
                value: CreateReplicationSetVol.source.SELECTVOLUME,
                text: strings.createReplicationSet.singleVolume
            }, {
                value: CreateReplicationSetVol.source.SELECTGROUP,
                text: strings.createReplicationSet.volumeGroup
            }],
            changeCallback: createObjectCallback(this, this._toggleVolumeOptionCallback)
        }), new TextInputWidget({
            name: "repSetName",
            row: E++,
            bottomMargin: true,
            rightMargin: true,
            label: strings.createReplicationSet.repSetNameLabel,
            rules: {
                required: true,
                dhRepName: true,
                utf8length: 32,
                replicationSetExists: true
            },
            changeCallback: createObjectCallback(this, this._changedCallback)
        }), new ComboBoxWidget({
            name: "peerCombo",
            row: E++,
            col: 1,
            bottomMargin: true,
            label: strings.createReplicationSetVol.selectPeer,
            values: [],
            changeCallback: createObjectCallback(this, this._changedCallback)
        }), new RadioButtonsInputWidget({
            name: "secondaryPool",
            row: E++,
            col: 1,
            colSpan: 2,
            bottomMargin: true,
            orientation: "horizontal",
            label: strings.createReplicationSetVol.secondaryPoolLabel,
            changeCallback: createObjectCallback(this, this._changedCallback),
            value: "A",
            values: [{
                value: "A",
                text: "A"
            }, {
                value: "B",
                text: "B"
            }]
        }), new LabelWidget({
            name: "secondaryLabel",
            value: strings.createReplicationSetVol.secondaryVolumeLabel,
            row: E,
            col: 0,
            bottomMargin: true
        }), new TextInputWidget({
            name: "secondaryVolumeName",
            row: E++,
            col: 1,
            size: 20,
            rules: {
                utf8length: 32,
                dhName: true
            },
            bottomMargin: true,
            changeCallback: createObjectCallback(this, this._changedCallback)
        }), new RadioButtonsInputWidget({
            name: "queuePolicy",
            label: strings.createReplicationSet.queuePolicylLabel,
            row: E++,
            col: 0,
            colSpan: 2,
            orientation: "horizontal",
            singleCell: true,
            bottomMargin: true,
            rightMargin: true,
            values: [{
                value: "discard",
                text: strings.createReplicationSet.discard
            }, {
                value: "queue-latest",
                text: strings.createReplicationSet.latest
            }],
            value: "queue-latest",
            changeCallback: createObjectCallback(this, this._changedCallback)
        }), new CheckboxContainer({
            name: "snapHistory",
            label: strings.createReplicationSet.snapHistLabel,
            row: E++,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            value: false,
            changeCallback: createObjectCallback(this, this.snapHistChanged),
            widgets: [new TableWidget({
                widgets: [new OptionInputWidget({
                    name: "retentionCount",
                    row: 0,
                    col: 1,
                    label: strings.createReplicationSet.retentionCountLabel,
                    values: C
                }), new TextInputWidget({
                    name: "snapshotBasename",
                    row: 1,
                    col: 1,
                    label: strings.createReplicationSet.snapshotBasenameLabel,
                    topMargin: true
                }), new CheckboxInputWidget({
                    name: "primaryVolSnap",
                    row: 2,
                    col: 1,
                    label: strings.createReplicationSet.primaryVolSnapLabel,
                    topMargin: true,
                    leftMargin: true
                }), new OptionInputWidget({
                    name: "retentionPriority",
                    row: 3,
                    col: 1,
                    label: strings.createReplicationSet.retentionPriorityLabel,
                    topMargin: true,
                    values: [{
                        value: "never-delete",
                        text: strings.createReplicationSet.neverDelete
                    }, {
                        value: "low",
                        text: strings.createReplicationSet.low
                    }, {
                        value: "medium",
                        text: strings.createReplicationSet.medium
                    }, {
                        value: "high",
                        text: strings.createReplicationSet.high
                    }]
                })]
            })]
        }), new CheckboxContainer({
            name: "scheduleReplication",
            row: E++,
            col: 0,
            colSpan: 2,
            bottomMediumMargin: true,
            value: false,
            label: strings.createReplicationSetVol.scheduled,
            widgets: [new TextWidget({
                text: strings.createLinearRepSet.schedInfo
            })]
        })]
    })];
    ActionPanel.call(this, F);
    this.class_name = "createReplicationSetVol"
}
CreateReplicationSetVol.source = {};
CreateReplicationSetVol.source.SELECTVOLUME = 0;
CreateReplicationSetVol.source.SELECTGROUP = 1;
CreateReplicationSetVol.prototype = new ActionPanel();
CreateReplicationSetVol.prototype.constructor = CreateReplicationSetVol;
CreateReplicationSetVol.getMenuState = function() {
    var J = {};
    var D = "";
    var I = {};
    var G;
    var C = 0;
    for (var M in DC.volumesSerial) {
        var E = DC.volumesSerial[M];
        if (E.get("replication_set")) {
            C += 1
        }
    }
    if (!(session.hasConfigurationCapability() && (RI.hasFeature("asyncRep") && !EXPR.isSasPortType))) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    if (C == 32) {
        return strings.createReplicationSet.maxRepSets
    }
    var F = TopicPanel.getSelected(["volumes"], 1);
    if (F) {
        J = DC.volumesSerial[F[0].key];
        G = J.getInt("storage_type_numeric");
        if (typeof G !== "undefined" && G != STORAGE_CLASS.VIRTUAL) {
            return strings.menuTips.replicationsReqVirtualVolumes
        } else {
            if (J && J.get("replication_set")) {
                return strings.menuTips.volAlreadyInRepSet
            } else {
                D = J.get("volume_group");
                if (D) {
                    I = DC.volumeGroupsSerial[D];
                    if (I && I.get("replication_set_serial")) {
                        return strings.menuTips.volGrpAlreadyInRepSet
                    }
                }
            }
        }
        if (propertyCount(DC.peerConnections) == 0) {
            return strings.menuTips.noPeers
        } else {
            for (var K in DC.peerConnectionsSerial) {
                var H = DC.peerConnectionsSerial[K];
                var L = H.getInt("health_numeric");
                if (L == 0) {
                    break
                }
            }
            if (L) {
                return strings.createReplicationSet.badConnection
            }
            return F
        }
    } else {
        return strings.menuTips.selectSingle(strings.volume)
    }
};
CreateReplicationSetVol.prototype.showing = function() {
    var G = {
        primaryVolSnap: {
            disable: true
        },
        retentionCount: {
            disable: true
        },
        retentionPriority: {
            disable: true
        },
        snapshotBasename: {
            disable: true,
            rules: {
                required: false
            }
        }
    };
    var I = [];
    var F = "";
    var K = DC.getUnusedKey("virtualReplicationSets", "repSet");
    this.repSetCreated = false;
    this.volumeObj = this.previousSelection[0].getObject();
    F = this.volumeObj.get("storage_pool_name");
    this.volumeGroupSerial = this.volumeObj.get("volume_group");
    this.volumeOption = CreateReplicationSetVol.source.SELECTVOLUME;
    var D = DC.volumeGroupsSerial[this.volumeGroupSerial].getInt("member_count");
    G.volGroupInfo = {
        visibility: "hidden"
    };
    G.volumeOption = {
        visibility: "hidden",
        value: this.volumeOption
    };
    G.repVolume = {
        text: this.volumeObj.get("volume_name")
    };
    G.repSetName = {
        value: K
    };
    if (this.volumeGroupSerial && (this.volumeGroupSerial != "UNGROUPEDVOLUMES") && (D <= this.MAXVOLUMESGROUP)) {
        var J = DC.volumeGroupsSerial[this.volumeGroupSerial];
        var H = false;
        if (J.get("replication_set_serial")) {
            H = true
        }
        for (var E = 0; E < J.objects; E++) {
            if (J.objects[E].get("replication_set")) {
                H = true;
                break
            }
        }
        if (!H) {
            var L = J.get("group_name");
            G.volGroupInfo = {
                visibility: "visible",
                text: strings.createReplicationSetVol.groupMessage(L)
            };
            G.volumeOption = {
                visibility: "visible",
                value: this.volumeOption
            }
        }
    }
    G.snapshotBasename.value = this.volumeObj.get("volume_name");
    for (var C in DC.peerConnectionsSerial) {
        I.push({
            value: C,
            text: DC.peerConnectionsSerial[C].get("peer_connection_name")
        })
    }
    G.peerCombo = {
        values: I,
        value: I[0].text
    };
    G.secondaryPool = {
        value: F
    };
    G.secondaryLabel = {
        value: strings.createReplicationSetVol.secondaryVolumeLabel
    };
    G.secondaryVolumeName = {
        value: this.volumeObj.get("volume_name")
    };
    this.update(G);
    this.okEnabled(true)
};
CreateReplicationSetVol.prototype._toggleVolumeOptionCallback = function(G, D, E) {
    var C = {};
    var F = DC.volumeGroupsSerial[this.volumeGroupSerial].get("group_name");
    this.volumeOption = parseInt(D.currentValue);
    if (!this.volumeGroupSerial || (this.volumeGroupSerial == "UNGROUPEDVOLUMES")) {
        return
    }
    if (this.volumeOption == CreateReplicationSetVol.source.SELECTGROUP) {
        C.volGroupInfo = {
            text: strings.createReplicationSetVol.volMessage(F)
        };
        C.repVolume = {
            label: strings.createReplicationSetVol.volumeGroupLabel,
            text: F
        };
        C.secondaryLabel = {
            visibility: "hidden"
        };
        C.secondaryVolumeName = {
            visibility: "hidden",
            disable: true
        };
        C.snapHistory = {
            value: false,
            visibility: "collapse",
            disable: true
        }
    } else {
        C.volGroupInfo = {
            text: strings.createReplicationSetVol.groupMessage(F)
        };
        C.repVolume = {
            label: strings.createReplicationSetVol.volumeLabel,
            text: this.volumeObj.get("volume_name")
        };
        C.secondaryLabel = {
            value: strings.createReplicationSetVol.secondaryVolumeLabel,
            visibility: "visible"
        };
        C.secondaryVolumeName = {
            value: this.volumeObj.get("volume_name"),
            visibility: "visible",
            disable: false
        };
        C.snapHistory = {
            visibility: "visible",
            disable: false
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    })
};
CreateReplicationSetVol.prototype._changedCallback = function(F, D, E) {
    var C = {};
    if ((D.name == "secondaryPool") && (D.currentValue == this.volumeObj.get("storage_pool_name"))) {
        return
    }
    this.retrieve(C);
    this.okEnabled(C.createReplicationSetVolForm.valid);
    this.resetSize({
        shrink: true
    })
};
CreateReplicationSetVol.prototype.snapHistChanged = function(F, D, E) {
    if (F[D.name].value) {
        var C = {
            primaryVolSnap: {
                disable: false
            },
            retentionCount: {
                disable: false
            },
            retentionPriority: {
                disable: false
            },
            snapshotBasename: {
                disable: false,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: 26
                }
            }
        }
    } else {
        var C = {
            primaryVolSnap: {
                disable: true
            },
            retentionCount: {
                disable: true
            },
            retentionPriority: {
                disable: true
            },
            snapshotBasename: {
                disable: true,
                rules: {
                    required: false
                }
            }
        }
    }
    this.update(C)
};
CreateReplicationSetVol.prototype.okCallback = function() {
    var D = {};
    this.retrieve(D);
    var C = {};
    var E = [];
    var F = {};
    this.schedule = D.scheduleReplication.value;
    var H = (this.volumeOption == CreateReplicationSetVol.source.SELECTVOLUME) ? this.volumeObj.get("volume_name") : DC.volumeGroupsSerial[this.volumeGroupSerial].get("group_name") + ".*";
    var G = (this.volumeOption == CreateReplicationSetVol.source.SELECTVOLUME) ? D.secondaryVolumeName.value : "";
    var I = D.secondaryPool.value;
    this.repSetName = D.repSetName.value;
    C = {
        repSetName: D.repSetName.value,
        primaryVol: H,
        secondaryVolName: (G != H) ? G : "",
        peerConnection: D.peerCombo.value,
        destinationPool: I,
        queuePolicy: D.queuePolicy.value
    };
    if (D.snapHistory.value) {
        $.extend(C, {
            snapHistory: (D.primaryVolSnap.value ? "both" : "secondary"),
            retentionCount: D.retentionCount.value,
            snapBasename: D.snapshotBasename.value,
            retentionPriority: D.retentionPriority.value
        })
    }
    E.push({
        name: "createReplicationSetVirtual",
        command: MC.createReplicationSet,
        data: C,
        options: {
            processingMsg: strings.createReplicationSetVol.processingRepSet,
            failureMsg: strings.createReplicationSetVol.failure,
            successMsg: (this.schedule) ? strings.createReplicationSetVol.scheduleSuccess : strings.createReplicationSetVol.initiateRepMsg
        }
    });
    this.repSetSubscription = MC.virtualReplicationSets.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.dataUpdated)
    });
    MC.execCommandList(E, {
        noSuccessDialog: true,
        closeActionOn: "success",
        callback: createObjectCallback(this, this.cmdComplete)
    })
};
CreateReplicationSetVol.prototype.showDialog = function() {
    if (this.repSetCreated) {
        if (this.schedule) {
            ShowActiveDialog({
                type: "success",
                dialogOverride: true,
                message: strings.createReplicationSetVol.schedulerMsg,
                ok: createObjectCallback(this, this.goSchedule)
            })
        } else {
            ShowActiveDialog({
                type: "success",
                message: strings.createReplicationSetVol.initiateRepMsg,
                dialogOverride: true,
                cancelState: "enabled",
                okLabel: strings.Yes,
                cancelLabel: strings.No,
                ok: createObjectCallback(this, this.initiateFirstRep),
                cancel: createObjectCallback(this, this.ok)
            })
        }
    } else {
        ShowActiveDialog({
            type: "success",
            message: this.resultMsg + "<br>" + strings.createReplicationSet.initOrScheduleLater,
            dialogOverride: true,
            ok: panels.actionDialog.close(true)
        })
    }
    MC.virtualReplicationSets.unregister(this.repSetSubscription);
    delete this.repSetSubscription;
    clearTimeout(this.repTimeout);
    delete this.repTimeout
};
CreateReplicationSetVol.prototype.cmdComplete = function(C) {
    if (C.success) {
        this.resultMsg = C.results.createReplicationSetVirtual.message;
        this.repTimeout = setTimeout(createObjectCallback(this, this.showDialog), 5 * 1000)
    }
};
CreateReplicationSetVol.prototype.goSchedule = function() {
    var C = this.checkForRepSet();
    NAV.navTo("HiddenActions", "scheduleReplications", null, C)
};
CreateReplicationSetVol.prototype.initiateFirstRep = function() {
    var D = DC.virtualReplicationSets[this.repSetName].get("serial_number");
    var C = {
        repSet: D
    };
    MC.replicateVolume(C, {
        dialog: true,
        processingMsg: strings.initiateReplication.processing,
        failureMsg: strings.initiateReplication.failure,
        successMsg: strings.initiateReplication.success,
        closeActionOn: "success"
    })
};
CreateReplicationSetVol.prototype.ok = function() {
    ShowActiveDialog({
        type: "success",
        message: strings.createReplicationSet.manualRepMsg,
        dialogOverride: true,
        ok: panels.actionDialog.close(true)
    })
};
CreateReplicationSetVol.prototype.checkForRepSet = function() {
    var H = "cs-replication-set";
    var E = [];
    for (var D in DC.virtualReplicationSetsSerial) {
        var G = DC.virtualReplicationSetsSerial[D];
        var C = G.get("name");
        if (C == this.repSetName) {
            var F = G.get("serial_number");
            break
        }
    }
    if (F) {
        E.push(new DCRef(H, F));
        return E
    } else {
        return null
    }
};
CreateReplicationSetVol.prototype.dataUpdated = function() {
    if (settings.memorex) {
        this.repSetCreated = true
    } else {
        for (var D in DC.virtualReplicationSets) {
            var E = DC.virtualReplicationSets[D];
            var C = E.get("name");
            if (C == this.repSetName) {
                if (this.scheduler) {
                    this.repSetCreated = true
                } else {
                    this.repSetCreated = (E.getInt("status_numeric") == REP_STATUS.UNSYNC)
                }
                break
            }
        }
    }
    if (this.repSetCreated) {
        if (this.repTimeout) {
            this.showDialog()
        }
    }
};

function ReplicateSnapshotVol(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ReplicateSnapshotVol";
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [this.form = new FormWidget({
        name: "repSnapForm",
        widgets: [new TextWidget({
            name: "snapLabel",
            label: strings.replicateSnapshot.snapLabel,
            bottomMargin: true
        }), new TextInputWidget({
            name: "repImageName",
            label: strings.replicateSnapshot.repImageName,
            bottomMargin: true,
            rules: {
                required: true,
                dhName: true,
                utf8length: RI.getMaxNameLength()
            },
            changeCallback: createObjectCallback(this, this.nameChange)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ReplicateSnapshotVol"
}
ReplicateSnapshotVol.prototype = new ActionPanel();
ReplicateSnapshotVol.prototype.constructor = ReplicateSnapshotVol;
ReplicateSnapshotVol.getMenuState = function() {
    var C = TopicPanel.getSelected(["snapshots", "volumes"], 1);
    if (C) {
        var G = C[0].getObject();
        if (G.get("storage_type_numeric") == STORAGE_CLASS.LINEAR) {
            if (G instanceof APIVolumes) {
                if (G.get("volume_type_numeric") == VOLUME_TYPES.SNAPSHOT && !G.get("replication_set")) {
                    var E = G.get("volume_parent");
                    var D = DC.volumesSerial[E];
                    if (D.isRSRSource()) {
                        return C
                    }
                }
            } else {
                if (G.get("snapshot_type_numeric") == "16384") {
                    var F = G.get("master_volume_name");
                    var D = DC.volumes[F];
                    if (D.isRSRSource()) {
                        return C
                    }
                }
            }
        }
    }
    return strings.replicateSnapshot.selectSnap
};
ReplicateSnapshotVol.prototype.showing = function() {
    var D = this.previousSelection[0].getObject();
    this.snapSerial = D.get("serial_number");
    if (D instanceof APIVolumes) {
        this.snapName = D.get("volume_name")
    } else {
        this.snapName = D.get("name")
    }
    var C = DC.getUnusedKey("snapshots", this.snapName + "_i");
    var E = {
        snapLabel: {
            text: this.snapName
        },
        repImageName: {
            value: C
        }
    };
    this.update(E);
    this.okEnabled(true)
};
ReplicateSnapshotVol.prototype.okCallback = function() {
    var E = {};
    this.retrieve(E);
    var D = {
        snapshot: this.snapSerial,
        name: E.repImageName.value
    };
    var C = {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.replicateSnapshot.processingMsg(this.snapName),
        failureMsg: strings.replicateSnapshot.failureMsg(this.snapName),
        successMsg: strings.replicateSnapshot.successMsg(this.snapName)
    };
    MC.replicateSnapshot(D, C)
};
ReplicateSnapshotVol.prototype.nameChange = function() {
    this.form.validate();
    this.okEnabled((this.form.valid ? true : false));
    this.resetSize({
        shrink: true
    })
};

function UpdatePerfAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "UpdatePerfAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = new MCDate();
    if (C.getMonth() < 6) {
        C.setFullYear(C.getFullYear() - 1)
    }
    C.setMonth((C.getMonth() + 6) % 12);
    D.widgets = [new FormWidget({
        name: "updatePerfForm",
        widgets: [new TextWidget({
            name: "descText",
            bottomMargin: true,
            text: strings.perfTopic.updateDesc
        }), new TableWidget({
            name: "updatecountTable",
            bottomMargin: true,
            widgets: [new TextInputWidget({
                name: "perfCount",
                row: 0,
                col: 1,
                width: 50,
                label: strings.perfTopic.count,
                labelOptions: {
                    row: 0,
                    col: 0,
                    rightMargin: true
                },
                rules: {
                    isNumber: true,
                    range: [5, 100]
                },
                value: 100
            })]
        }), new CheckboxContainer({
            name: "dateContainer",
            row: 1,
            col: 0,
            value: false,
            label: strings.perfTopic.timeRange,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.timeRangeSelected),
            widgets: [new DateTimeInputWidget({
                name: "dateTimeInput",
                row: 0,
                col: 0,
                startMinDate: C,
                endMinDate: C,
                startMaxDate: new MCDate(),
                endMaxDate: new MCDate(),
                endWidget: true
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "UpdatePerfAction"
}
UpdatePerfAction.prototype = new ActionPanel();
UpdatePerfAction.prototype.constructor = UpdatePerfAction;
UpdatePerfAction.getMenuState = function() {
    var C = TopicPanel.getSelected(["drives", "diskGroups", "tier-statistics", "pool-statistics"]);
    if (C) {
        return C
    } else {
        return strings.menuTips.noHistoricalUpdate
    }
};
UpdatePerfAction.prototype.showing = function() {
    this.okEnabled(true)
};
UpdatePerfAction.prototype.timeRangeSelected = function(C) {
    var E = {};
    if (C.dateContainer.value) {
        var D = new MCDate();
        E.dateTimeInput = {
            startValue: D,
            endValue: D
        };
        E.perfCount = {
            disable: true
        }
    } else {
        E.perfCount = {
            disable: false
        }
    }
    this.update(E)
};
UpdatePerfAction.prototype.okCallback = function() {
    var D = {};
    this.retrieve(D);
    var C = {};
    if (D.dateContainer.value) {
        C.timeRange = "Start " + D.dateTimeInput.startTextValue + " end " + D.dateTimeInput.endTextValue;
        C.dateRef = D.dateTimeInput.endValue.getTime() - (MCDate.arrayTimezoneOffset * 60000)
    } else {
        C.count = D.perfCount.value
    }
    panels.PerfTopic.updateHistData(C);
    panels.actionDialog.close()
};

function ExportPerfAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ExportPerfAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = new MCDate();
    if (C.getMonth() < 6) {
        C.setFullYear(C.getFullYear() - 1)
    }
    C.setMonth((C.getMonth() + 6) % 12);
    D.widgets = [new FormWidget({
        name: "exportPerfForm",
        widgets: [new TextWidget({
            name: "descText",
            bottomMargin: true,
            text: strings.perfTopic.exportPerf
        }), new CheckboxContainer({
            name: "dateContainer",
            value: false,
            label: strings.perfTopic.timeRange,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.timeRangeSelected),
            widgets: [new DateTimeInputWidget({
                name: "dateTimeInput",
                startMinDate: C,
                endMinDate: C,
                startMaxDate: new MCDate(),
                endMaxDate: new MCDate(),
                endWidget: true
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "ExportPerfAction"
}
ExportPerfAction.prototype = new ActionPanel();
ExportPerfAction.prototype.constructor = ExportPerfAction;
ExportPerfAction.getMenuState = function() {
    var C = TopicPanel.getSelected(["drives", "diskGroups", "tier-statistics", "pool-statistics"]);
    if (C) {
        return C
    } else {
        return strings.menuTips.noHistoricalUpdate
    }
};
ExportPerfAction.prototype.showing = function() {
    this.okEnabled(true)
};
ExportPerfAction.prototype.timeRangeSelected = function(C) {
    var E = {};
    if (C.dateContainer.value) {
        var D = new MCDate();
        E.dateTimeInput = {
            startValue: D,
            endValue: D
        }
    }
    this.update(E)
};
ExportPerfAction.prototype.okCallback = function() {
    var E = {
        historical: true,
        fileName: "Disk_Performance"
    };
    var F = {};
    this.retrieve(F);
    if (F.dateContainer.value) {
        E.timeRange = "start " + F.dateTimeInput.startTextValue + " end " + F.dateTimeInput.endTextValue
    }
    var D = "showDiskStatistics";
    var C = {};
    panels.PerfTopic.retrieve(C);
    if (C.componentsOption.value.indexOf("statistics") >= 0) {
        D = "showPoolStatistics"
    }
    MC[D](E, {
        dialog: true,
        processingMsg: strings.perfTopic.saveProcess,
        failureMsg: strings.perfTopic.saveFailure,
        successMsg: strings.perfTopic.saveSuccess,
        callback: createObjectCallback(this, this.downloadFile)
    })
};
ExportPerfAction.prototype.downloadFile = function(C) {
    if (C.success) {
        downloadData("Disk_Performance.csv", "downloadPerfData")
    }
};

function ResetPerfAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ResetPerfAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.width = 350;
    C.height = 180;
    C.widgets = [new FormWidget({
        name: "resetPerfWc",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "resetPerfText",
            row: 0,
            col: 0,
            colSpan: 2,
            text: strings.perfTopic.resetDesc,
            bottomMargin: true
        }), new RadioButtonsInputWidget({
            name: "statTypeChoice",
            row: 2,
            col: 0,
            leftMargin: true,
            label: strings.perfTopic.statTypeLable,
            labelOptions: {
                row: 1,
                col: 0,
                bottomMediumMargin: true
            },
            value: "current",
            values: [{
                value: "current",
                text: strings.perfTopic.current
            }, {
                value: "historical",
                text: strings.perfTopic.historical
            }]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ResetPerfAction"
}
ResetPerfAction.prototype = new ActionPanel();
ResetPerfAction.prototype.constructor = ResetPerfAction;
ResetPerfAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    return []
};
ResetPerfAction.prototype.showing = function() {
    this.okEnabled(true)
};
ResetPerfAction.prototype.okCallback = function() {
    var C = {};
    var D = {};
    this.retrieve(D);
    this.historical = false;
    if (D.statTypeChoice.value == "historical") {
        C = {
            historical: true
        };
        this.historical = true
    }
    MC.resetAllStatistics(C, {
        dialog: true,
        confirmMsg: strings.perfTopic.resetConfirm,
        processingMsg: strings.perfTopic.resetProcess,
        failureMsg: strings.perfTopic.resetFailure,
        successMsg: strings.perfTopic.resetSuccess,
        closeActionOn: "success",
        callback: createObjectCallback(this, this.resetCache)
    })
};
ResetPerfAction.prototype.resetCache = function(C) {
    if (C.success && this.historical) {
        panels.PerfTopic.resetHistStats()
    }
};

function getLinkTypes(H) {
    var I = false;
    var M = false;
    var K = [];
    var E = DC.ports;
    for (var D in E) {
        var L = E[D].prop.media.text;
        if (L == "iSCSI") {
            M = true
        } else {
            if (L.match(/^FC/)) {
                I = true
            }
        }
    }
    if (!(I || M)) {
        return K
    } else {
        if (H == undefined) {
            if (I) {
                K.push({
                    value: "FC",
                    text: strings.replicateVolume.linkTypeFC
                })
            }
            if (M) {
                K.push({
                    value: "iSCSI",
                    text: strings.replicateVolume.linkTypeISCSI
                })
            }
            return K
        }
    }
    var G = DC.remoteSystems;
    for (var C in G) {
        if (C == H) {
            var J = G[C];
            var F = J.prop.interfaces_numeric.text;
            if (F == REMOTE_INTERFACE_TYPES.Hybrid) {
                if (I) {
                    K.push({
                        value: "FC",
                        text: strings.replicateVolume.linkTypeFC
                    })
                }
                if (M) {
                    K.push({
                        value: "iSCSI",
                        text: strings.replicateVolume.linkTypeISCSI
                    })
                }
            } else {
                if (F == REMOTE_INTERFACE_TYPES.FC) {
                    if (I) {
                        K.push({
                            value: "FC",
                            text: strings.replicateVolume.linkTypeFC
                        })
                    }
                } else {
                    if (F == REMOTE_INTERFACE_TYPES.iSCSI) {
                        if (M) {
                            K.push({
                                value: "iSCSI",
                                text: strings.replicateVolume.linkTypeISCSI
                            })
                        }
                    }
                }
            }
            break
        }
    }
    return K
}

function rsrGetDestVolumes(D, I) {
    var H = parseInt(D.prop.blocks.text, 10);
    var J = [];
    if (I) {
        for (var F = 0; F < I.objects.length; F++) {
            var G = I.objects[F];
            var K = parseInt(G.prop.blocks.text, 10);
            if (G.isRSRPrepared() && (H == K)) {
                var E = G.prop.serial_number.text;
                var C = G.prop.volume_name.text;
                J.push({
                    value: E,
                    text: C
                })
            }
        }
    }
    return J
}

function CheckLinksAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "CheckLinksAction";
    D.width = 400;
    D.title = strings.actions.CheckLinks;
    var C = createObjectCallback(this, this.systemSelected);
    D.widgets = [new FormWidget({
        name: "form",
        data: {},
        widgets: [new TextWidget({
            name: "infoTxt",
            text: strings.localLinkTask.infoTxt,
            bottomMargin: true
        }), new OptionInputWidget({
            name: "system",
            classes: "inline ARLeftSmallMargin",
            label: "Select System",
            values: [],
            row: 0,
            col: 1,
            width: 200,
            leftSmallMargin: true,
            bottomMediumMargin: true,
            changeCallback: C
        }), new TableInator({
            name: "linkResultsTable",
            noFeatures: true,
            topMargin: true,
            type: "apiData",
            metadata: "remote-links-table",
            fields: ["type", "local_host_port", "remote_links"],
            columnOverrides: {
                type: {
                    sTitle: strings.localLinkTask.linkType
                },
                local_host_port: {
                    sTitle: strings.localLinkTask.sourcePort
                },
                remote_links: {
                    sTitle: strings.localLinkTask.destPort
                }
            }
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "CheckLinksAction"
}
CheckLinksAction.prototype = new ActionPanel();
CheckLinksAction.prototype.constructor = CheckLinksAction;
CheckLinksAction.getMenuState = function() {
    return []
};
CheckLinksAction.prototype.showing = function() {
    this.remoteSystemsSubscription = MC.remoteSystemsSet.requestData({
        update: false,
        durable: true,
        requester: this.class_name,
        handler: createObjectCallback(this, this.handleRemoteSystemsUpdate)
    });
    this.update({
        linkResultsTable: {
            visibility: "collapse"
        }
    })
};
CheckLinksAction.prototype.handleRemoteSystemsUpdate = function() {
    var C = [];
    this.localSystemName = DC.system.prop.system_name.text;
    C.push({
        text: strings.createLinearRepSet.selSystem
    });
    C.push({
        value: "local",
        text: this.localSystemName + strings.createLinearRepSet.local
    });
    var H = DC.remoteSystems;
    for (var E in H) {
        var D = H[E];
        var G = null;
        if (decodeBooleanFlag(D.getPropertyValue("isvalid_ip_a_numeric"))) {
            G = D.prop.ip_address_a.text
        } else {
            if (decodeBooleanFlag(D.getPropertyValue("isvalid_ip_b_numeric"))) {
                G = D.prop.ip_address_b.text
            }
        }
        if (D != null) {
            C.push({
                text: H[E].get("system_name"),
                value: G
            })
        }
    }
    this.systems = C;
    var F = {
        system: {
            values: C
        }
    };
    this.update(F)
};
CheckLinksAction.prototype.systemSelected = function(C, D) {
    this.selectedSystem = C.system.value;
    if (this.selectedSystem == "local") {
        MC.verifyLinks({}, {
            dialog: true,
            noSuccessDialog: true,
            processingMsg: strings.localLinkTask.processingMsg,
            failureMsg: strings.localLinkTask.failureMsg,
            callback: createObjectCallback(this, this.checkLinksCmdComplete)
        })
    } else {
        if (this.selectedSystem != "undefined") {
            var E = {
                rmtSys: this.selectedSystem
            };
            MC.verifyLinks(E, {
                dialog: true,
                processingMsg: strings.checkRemoteLink.processingMsg(C.system.textValue),
                failureMsg: strings.checkRemoteLink.failureMsg,
                noSuccessDialog: true,
                callback: createObjectCallback(this, this.checkLinksCmdComplete)
            })
        } else {
            this.update({
                linkResultsTable: {
                    visibility: "collapse"
                }
            });
            this.resetSize({
                shrink: true
            })
        }
    }
};
CheckLinksAction.prototype.checkLinksCmdComplete = function(C) {
    ActiveDialogOK();
    if (C.success && C.json) {
        var D = {
            linkResultsTable: {
                visibility: "visible",
                data: C.json.objects
            }
        };
        this.update(D)
    } else {
        ShowActiveDialog({
            type: "error",
            message: C.message
        })
    }
    this.resetSize({
        shrink: true
    })
};

function QueryPeerConnectionAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.title = strings.queryPeer.title;
    C.okCallback = createObjectCallback(this, this.okCallback);
    if (!C.name) {
        C.name = "QueryPeerConnectionAction"
    }
    C.widgets = [new FormWidget({
        name: "form",
        widgets: [new TextWidget({
            name: "infoTxt",
            text: strings.queryPeer.infoTxt,
            width: 400,
            bottomMargin: true
        }), new TextInputWidget({
            name: "destPeer",
            label: strings.queryPeer.remotePort,
            rules: {
                required: true,
                destPeerAddress: true
            },
            changeCallback: createObjectCallback(this, this.peerChanged)
        }), new WidgetContainer({
            name: "resultsContainer",
            widgets: [new TextWidget({
                label: "<b>" + strings.hovers.RemoteSystemHover + "</b>",
                topMargin: true
            }), new TextWidget({
                name: "sysName",
                leftMargin: true,
                label: strings.queryPeer.sysName
            }), new TextWidget({
                name: "sysContact",
                leftMargin: true,
                label: strings.queryPeer.sysContact
            }), new TextWidget({
                name: "sysLocation",
                leftMargin: true,
                label: strings.queryPeer.sysLocation
            }), new TextWidget({
                name: "sysInfo",
                leftMargin: true,
                label: strings.queryPeer.sysInfo
            }), new TextWidget({
                name: "controllerAInfoLabel",
                label: "<b>" + strings.queryPeer.controllerInfo("A") + "</b>",
                topMargin: true
            }), new TextWidget({
                name: "controllerAFW",
                leftMargin: true,
                label: strings.queryPeer.version
            }), new TextWidget({
                name: "controllerAIP",
                leftMargin: true,
                label: strings.queryPeer.IPAddress
            }), new TableInator({
                name: "controllerAPorts",
                type: "rawData",
                selectable: false,
                topMargin: true,
                metadata: [{
                    sTitle: strings.queryPeer.port
                }, {
                    sTitle: strings.queryPeer.type
                }, {
                    sTitle: strings.queryPeer.portHealth
                }, {
                    sTitle: strings.queryPeer.portAddr
                }, {
                    sTitle: strings.queryPeer.links
                }],
                noFeatures: true
            }), new TextWidget({
                name: "controllerBInfoLabel",
                label: "<b>" + strings.queryPeer.controllerInfo("B") + "</b>",
                topMargin: true
            }), new TextWidget({
                name: "controllerBFW",
                leftMargin: true,
                label: strings.queryPeer.version
            }), new TextWidget({
                name: "controllerBIP",
                leftMargin: true,
                label: strings.queryPeer.IPAddress
            }), new TableInator({
                name: "controllerBPorts",
                type: "rawData",
                selectable: false,
                topMargin: true,
                metadata: [{
                    sTitle: strings.queryPeer.port
                }, {
                    sTitle: strings.queryPeer.type
                }, {
                    sTitle: strings.queryPeer.portHealth
                }, {
                    sTitle: strings.queryPeer.portAddr
                }, {
                    sTitle: strings.queryPeer.links
                }],
                noFeatures: true
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "QueryPeerConnectionAction"
}
QueryPeerConnectionAction.prototype = new ActionPanel();
QueryPeerConnectionAction.prototype.constructor = QueryPeerConnectionAction;
QueryPeerConnectionAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    selected = TopicPanel.getSelected("peer-connections", 1);
    if (selected) {
        return selected
    } else {
        return []
    }
};
QueryPeerConnectionAction.prototype.showing = function() {
    var D = this.previousSelection;
    if (D.length) {
        this.portAddr = "";
        var E = D[0].getObject();
        for (var C = 0; C < E.objects.length; C++) {
            if (E.objects[C] instanceof APIRemotePorts) {
                this.portAddr = E.objects[C].get("port_address");
                break
            }
        }
        this.update({
            destPeer: {
                value: this.portAddr
            }
        });
        this.okEnabled(true)
    }
    this.update({
        resultsContainer: {
            visibility: "collapse"
        }
    })
};
QueryPeerConnectionAction.prototype.okCallback = function() {
    MC.queryPeerConnection({
        remotePort: this.portAddr
    }, {
        dialog: true,
        processingMsg: strings.queryPeer.processingMsg,
        failureMsg: strings.queryPeer.failureMsg,
        autoOK: true,
        callback: createObjectCallback(this, this.queryComplete)
    })
};
QueryPeerConnectionAction.prototype.peerChanged = function(C, E, D) {
    if (C[E.name].invalid) {
        this.okEnabled(false)
    } else {
        this.portAddr = C[E.name].value;
        this.okEnabled(true)
    }
    this.resetSize({
        shrink: true
    })
};
QueryPeerConnectionAction.prototype.queryComplete = function(I) {
    if (I.success) {
        var H = I.json.objects[0];
        var K = {
            resultsContainer: {
                visibility: "visible"
            },
            sysName: {
                text: H.get("system_name")
            },
            sysContact: {
                text: H.get("system_contact")
            },
            sysLocation: {
                text: H.get("system_location")
            },
            sysInfo: {
                text: H.get("system_information")
            }
        };
        for (var J = 0; J < H.objects.length; J++) {
            if (H.objects[J].get("controller") == "A") {
                var D = H.objects[J]
            } else {
                var C = H.objects[J]
            }
        }
        if (D) {
            var G = [];
            for (var J = 0; J < D.objects.length; J++) {
                var E = D.objects[J];
                G.push([E.get("local_host_port"), E.get("connection_type"), E.get("host_port_health"), E.get("port_address"), E.get("local_links")])
            }
            K.controllerAInfoLabel = {
                visibility: "visible"
            };
            K.controllerAFW = {
                text: D.get("mc_fw"),
                visibility: "visible"
            };
            K.controllerAIP = {
                text: D.get("ip_address"),
                visibility: "visible"
            };
            K.controllerAPorts = {
                data: G,
                visibility: "visible"
            }
        } else {
            K.controllerAInfoLabel = {
                visibility: "collapse"
            };
            K.controllerAFW = {
                visibility: "collapse"
            };
            K.controllerAIP = {
                visibility: "collapse"
            };
            K.controllerAPorts = {
                visibility: "collapse"
            }
        }
        if (C) {
            var F = [];
            for (var J = 0; J < C.objects.length; J++) {
                var E = C.objects[J];
                F.push([E.get("local_host_port"), E.get("connection_type"), E.get("host_port_health"), E.get("port_address"), E.get("local_links")])
            }
            K.controllerBInfoLabel = {
                visibility: "visible"
            };
            K.controllerBFW = {
                text: C.get("mc_fw"),
                visibility: "visible"
            };
            K.controllerBIP = {
                text: C.get("ip_address"),
                visibility: "visible"
            };
            K.controllerBPorts = {
                data: F,
                visibility: "visible"
            }
        } else {
            K.controllerBInfoLabel = {
                visibility: "collapse"
            };
            K.controllerBFW = {
                visibility: "collapse"
            };
            K.controllerBIP = {
                visibility: "collapse"
            };
            K.controllerBPorts = {
                visibility: "collapse"
            }
        }
        this.update(K)
    } else {
        this.update({
            resultsContainer: {
                visibility: "collapse"
            }
        })
    }
    this.resetSize({
        shrink: true
    })
};

function CreatePeerConnectionAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 400;
    D.okCallback = createObjectCallback(this, this.okCallback);
    if (!D.name) {
        D.name = "CreatePeerConnectionAction"
    }
    var C = 0;
    D.widgets = [this.createPeerForm = new FormWidget({
        name: "createPeerForm",
        tableLayout: true,
        maxCols: 2,
        widgets: [new TextWidget({
            name: "destInfo1",
            row: C++,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            text: strings.createPeer.infoText1
        }), new TextInputWidget({
            name: "peerName",
            row: C++,
            col: 1,
            label: strings.createPeer.peerNameLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            rules: {
                required: true,
                utf8length: 32,
                dhName: true,
                peerExists: true
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new TextInputWidget({
            name: "destAddress",
            row: C++,
            col: 1,
            label: strings.createPeer.destAddressLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            rules: {
                required: true,
                destPeerAddress: true
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new TextInputWidget({
            name: "remoteUsername",
            row: C++,
            col: 1,
            label: strings.createPeer.usernameLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            rules: {
                required: true,
                utf8length: 32
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new TextInputWidget({
            name: "remotePassword",
            row: C++,
            col: 1,
            label: strings.createPeer.passwordLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            password: true,
            rules: {
                required: true,
                utf8length: 32
            },
            changeCallback: createObjectCallback(this, this.changeCallback)
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "CreatePeerConnectionAction"
}
CreatePeerConnectionAction.prototype = new ActionPanel();
CreatePeerConnectionAction.prototype.constructor = CreatePeerConnectionAction;
CreatePeerConnectionAction.getMenuState = function() {
    var D = DC.systemParameters.getInt("max_peers_allowed");
    var C = DC.systemParameters.get("peers_in_use_count");
    if (!session.hasConfigurationCapability()) {
        return false
    } else {
        if (!(APIPort.hasPortType("iSCSI") || APIPort.hasPortType("FC"))) {
            return strings.menuTips.noValidPorts
        } else {
            if (!licenseInfo.isLicensed("remote_snapshot_replication") && (D == 0)) {
                return strings.menuTips.notLicensed
            } else {
                if (C >= D) {
                    return strings.menuTips.maxPeers(D)
                } else {
                    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
                        return strings.menuTips.notLicensed
                    } else {
                        if (!(DC.pools.A || DC.pools.B)) {
                            return strings.menuTips.noPools
                        } else {
                            return []
                        }
                    }
                }
            }
        }
    }
};
CreatePeerConnectionAction.prototype.showing = function() {
    var C = {
        createPeerForm: {
            resetValidation: true
        },
        peerName: "",
        destAddress: ""
    };
    this.update(C)
};
CreatePeerConnectionAction.prototype.changeCallback = function(H, F, G) {
    var E = {};
    this.retrieve(E, true);
    var C = {};
    var D = true;
    if (!H.destAddress && E.destAddress.value == "") {
        D = false;
        C.destAddress = {
            skipValidation: true
        }
    } else {
        C.destAddress = {
            skipValidation: false
        }
    }
    if (!H.peerName && E.peerName.value == "") {
        D = false;
        C.peerName = {
            skipValidation: true
        }
    } else {
        C.peerName = {
            skipValidation: false
        }
    }
    if (!H.remoteUsername && E.remoteUsername.value == "") {
        D = false;
        C.remoteUsername = {
            skipValidation: true
        }
    } else {
        C.remoteUsername = {
            skipValidation: false
        }
    }
    if (!H.remotePassword && E.remotePassword.value == "") {
        D = false;
        C.remotePassword = {
            skipValidation: true
        }
    } else {
        C.remotePassword = {
            skipValidation: false
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    this.okEnabled(this.createPeerForm.valid && D)
};
CreatePeerConnectionAction.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var D = C.peerName.value;
    var E = {
        name: D,
        remotePortAddr: C.destAddress.value,
        remoteUsername: C.remoteUsername.value,
        remotePassword: C.remotePassword.value
    };
    MC.createPeer(E, {
        dialog: true,
        processingMsg: strings.createPeer.processingMsg(D),
        successMsg: strings.createPeer.successMsg(D),
        failureMsg: strings.createPeer.failureMsg(D),
        closeActionOn: "success"
    })
};

function DeletePeerConnectionAction(C) {
    if (arguments.length == 0) {
        return
    }
    this.peerNames = [];
    this.multiple = null;
    this.selected = [];
    C.name = "DeletePeerConnectionAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "dpWC",
        widgets: [new TextWidget({
            name: "peerNames",
            classes: "scrollText100",
            label: strings.deletePeer.peerName,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "warningText",
            topMargin: true,
            text: strings.deletePeer.warning
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeletePeerConnectionAction"
}
DeletePeerConnectionAction.prototype = new ActionPanel();
DeletePeerConnectionAction.prototype.constructor = DeletePeerConnectionAction;
DeletePeerConnectionAction.getMenuState = function() {
    var F;
    var D;
    var G;
    var C;
    if (!session.hasConfigurationCapability()) {
        return false
    }
    F = TopicPanel.getSelected("peer-connections", 1);
    if (F) {
        D = DC.peerConnectionsSerial[F[0].key];
        if (D.getInt("connection_status_numeric") == PEERSTATUS.OFFLINE && D.getInt("health_numeric") == HEALTH.FAULT) {
            return strings.menuTips.offlinePeer
        }
        G = D.get("serial_number");
        for (var E in DC.virtualReplicationSetsSerial) {
            C = DC.virtualReplicationSetsSerial[E].get("peer_connection_serial");
            if (C == G) {
                return strings.menuTips.peerHasReplication
            }
        }
    } else {
        return strings.menuTips.selectSingle(strings.deletePeer.peerName)
    }
    return F
};
DeletePeerConnectionAction.prototype.showing = function() {
    var E;
    var D;
    var C;
    this.selected = this.previousSelection;
    this.multiple = (this.selected.length > 1);
    this.peerNames = [];
    for (E = 0; E < this.selected.length; E++) {
        D = DC.peerConnectionsSerial[this.selected[E].key];
        C = D.get("peer_connection_name");
        this.peerNames.push(C)
    }
    this.update({
        peerNames: {
            text: MC.getItemList(this.peerNames, true),
            label: (this.multiple) ? strings.deletePeer.peerNamePlural : strings.deletePeer.peerName
        },
        warningText: {
            text: (this.multiple) ? strings.deletePeer.warningPlural : strings.deletePeer.warning
        }
    });
    this.resetSize();
    this.okEnabled(true)
};
DeletePeerConnectionAction.prototype.okCallback = function() {
    var C = {
        list: this.peerNames
    };
    MC.deletePeer(C, {
        dialog: true,
        processingMsg: (this.multiple) ? strings.deletePeer.processingPlural : strings.deletePeer.processing,
        failureMsg: (this.multiple) ? strings.deletePeer.failurePlural : strings.deletePeer.failure,
        successMsg: ((this.multiple) ? strings.deletePeer.successPlural : strings.deletePeer.success),
        closeActionOn: "success"
    })
};

function ModifyPeerConnectionAction(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "ModifyPeerConnectionAction";
    D.okCallback = createObjectCallback(this, this.okCallback);
    var C = 0;
    D.widgets = [new TextWidget({
        name: "modifyDescription",
        row: C++,
        col: 0,
        text: strings.modifyPeerConnection.description,
        bottomMargin: true
    }), new TextWidget({
        name: "peerName",
        row: C++,
        label: strings.deletePeer.peerName,
        bottomMargin: true
    }), this.form = new FormWidget({
        name: "modifyPeerForm",
        tableLayout: true,
        widgets: [new TableWidget({
            name: "modifyTable",
            widgets: [new RadioButtonsInputWidget({
                name: "option",
                row: C++,
                col: 0,
                colSpan: 2,
                orientation: "horizontal",
                setOrig: true,
                singleCell: true,
                bottomMargin: true,
                leftMargin: true,
                values: [{
                    value: "newName",
                    text: strings.modifyPeerConnection.newNameLabel
                }, {
                    value: "newAddress",
                    text: strings.modifyPeerConnection.newAddressLabel
                }],
                changeCallback: createObjectCallback(this, this.changeTypeCallback)
            }), new TextInputWidget({
                name: "newInput",
                row: C++,
                col: 0,
                leftMargin: true,
                bottomMargin: true,
                changeCallback: createObjectCallback(this, this.changeCallback)
            }), new LabeledWidgetContainer({
                name: "credentials",
                label: strings.modifyPeerConnection.credentialLabel,
                row: C++,
                col: 0,
                colSpan: 2,
                widgets: [new TableWidget({
                    widgets: [new TextInputWidget({
                        name: "remoteUsername",
                        row: 0,
                        col: 1,
                        label: strings.createPeer.usernameLabel,
                        labelOptions: {
                            rightMargin: true
                        },
                        size: 20,
                        rules: {
                            required: true,
                            utf8length: 32
                        },
                        bottomMediumMargin: true,
                        changeCallback: createObjectCallback(this, this.changeCallback)
                    }), new TextInputWidget({
                        name: "remotePassword",
                        row: 1,
                        col: 1,
                        label: strings.createPeer.passwordLabel,
                        labelOptions: {
                            rightMargin: true
                        },
                        size: 20,
                        password: true,
                        rules: {
                            required: true,
                            utf8length: 32
                        },
                        changeCallback: createObjectCallback(this, this.changeCallback)
                    })]
                })]
            })]
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "ModifyPeerConnectionAction"
}
ModifyPeerConnectionAction.prototype = new ActionPanel();
ModifyPeerConnectionAction.prototype.constructor = ModifyPeerConnectionAction;
ModifyPeerConnectionAction.getMenuState = function() {
    var D = TopicPanel.getSelected(["peer-connections"], 1);
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    if (D) {
        var C = DC.peerConnectionsSerial[D[0].key];
        return D
    } else {
        return strings.menuTips.selectSingle(strings.peer)
    }
};
ModifyPeerConnectionAction.prototype.showing = function() {
    var D = TopicPanel.getSelected(["peer-connections"], 1);
    var C = DC.peerConnectionsSerial[D[0].key];
    this.peerInfo = {
        currentPeerName: C.get("peer_connection_name"),
        currentPeerSerial: C.get("serial_number")
    };
    this.update({
        modifyPeerForm: {
            resetValidation: true
        },
        peerName: {
            text: this.peerInfo.currentPeerName
        },
        option: {
            value: "newName",
            setOrig: true
        },
        newInput: {
            value: "",
            setOrig: true,
            rules: {
                dhName: true,
                peerExists: true,
                utf8length: 32
            }
        }
    })
};
ModifyPeerConnectionAction.prototype.changeCallback = function(G, F) {
    var E = {};
    this.retrieve(E, true);
    var C = {};
    var D = true;
    if (!G.newInput && E.newInput.value == "") {
        D = false;
        C.newInput = {
            skipValidation: true
        }
    } else {
        C.newInput = {
            skipValidation: false
        }
    }
    if (!G.remoteUsername && E.remoteUsername.value == "") {
        D = false;
        C.remoteUsername = {
            skipValidation: true
        }
    } else {
        C.remoteUsername = {
            skipValidation: false
        }
    }
    if (!G.remotePassword && E.remotePassword.value == "") {
        D = false;
        C.remotePassword = {
            skipValidation: true
        }
    } else {
        C.remotePassword = {
            skipValidation: false
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    this.okEnabled(this.form.valid && D)
};
ModifyPeerConnectionAction.prototype.changeTypeCallback = function(D, E) {
    if (D.option.valueChanged) {
        var C = {
            newInput: {
                rules: {
                    destPeerAddress: true
                }
            }
        }
    } else {
        var C = {
            newInput: {
                rules: {
                    dhName: true,
                    peerExists: true,
                    utf8length: 32
                }
            }
        }
    }
    this.update(C);
    this.changeCallback(D, E)
};
ModifyPeerConnectionAction.prototype.okCallback = function() {
    var D = {};
    this.retrieve(D);
    var C = {
        name: this.peerInfo.currentPeerSerial,
        remoteUsername: D.remoteUsername.value,
        remotePassword: D.remotePassword.value
    };
    if (D.option.value == "newName") {
        C.newPeerName = D.newInput.value
    } else {
        C.newRemoteAddress = D.newInput.value
    }
    MC.setPeer(C, {
        dialog: true,
        processingMsg: strings.modifyPeerConnection.processingMsg,
        successMsg: strings.modifyPeerConnection.successMsg,
        failureMsg: strings.modifyPeerConnection.failureMsg(this.peerInfo.currentPeerName),
        closeActionOn: "success"
    })
};

function CreateReplicationSet(F) {
    if (arguments.length == 0) {
        return
    }
    F.okCallback = createObjectCallback(this, this.okCallback);
    if (!F.name) {
        F.name = "CreateReplicationSet"
    }
    F.title = strings.actions.CreateReplicationSet;
    var E = 0;
    F.autoHeight = true;
    this.repSetSubscription = {};
    this.repStatus = false;
    this.MAXVOLUMESGROUP = 32;
    this.repSetData = {
        peerConnection: "",
        repSetName: "",
        secondaryVolName: "",
        pool: ""
    };
    this.MAXRETENTIONCOUNT = 16;
    var C = [];
    for (var D = 1; D <= this.MAXRETENTIONCOUNT; D++) {
        C[C.length] = {
            value: "" + D,
            text: "" + D
        }
    }
    F.widgets = this.createRepSet = new FormWidget({
        name: "createRepSetForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "peerConnection",
            row: 0,
            bottomMargin: true,
            rightMargin: true,
            label: strings.createReplicationSet.peerConnectionLabel
        }), new TextInputWidget({
            name: "repSetName",
            row: 1,
            bottomMargin: true,
            rightMargin: true,
            label: strings.createReplicationSet.repSetNameLabel,
            rules: {
                required: true,
                dhRepName: true,
                utf8length: 32,
                replicationSetExists: true
            },
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new RadioButtonsInputWidget({
            name: "volumeOption",
            label: strings.createReplicationSet.sourceLabel,
            row: 2,
            col: 0,
            colSpan: 2,
            orientation: "horizontal",
            singleCell: true,
            bottomSmallMargin: true,
            setOrig: true,
            values: [{
                value: 0,
                text: strings.createReplicationSet.singleVolume
            }, {
                value: 1,
                text: strings.createReplicationSet.volumeGroup
            }],
            changeCallback: createObjectCallback(this, this.volOptionChange)
        }), this.createRepTable = new TableWidget({
            name: "repSetTable",
            row: 3,
            col: 0,
            colSpan: 2,
            classes: "width100pct",
            widgets: [new TableInator({
                row: 0,
                col: 0,
                colSpan: 4,
                name: "singleVolTable",
                cellClasses: "verticalTop",
                selectable: "single",
                selectCallback: createObjectCallback(this, this.changeCallback),
                bottomMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: "basetype",
                    bVisible: false,
                    bIsBasetype: true
                }, {
                    sTitle: "key",
                    bVisible: false,
                    bIsKey: true
                }, {
                    sTitle: strings.createReplicationSet.volNameCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.createReplicationSet.volSizeCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.createReplicationSet.volTypeCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.createReplicationSet.volPoolCol,
                    bFilterMenu: true
                }],
                dtOptions: {
                    bFilter: "noInput",
                    bFilter: "noControls",
                    iDisplayLength: 8,
                    bLengthChange: false,
                    aaSorting: [
                        [2, "asc"],
                        [3, "asc"]
                    ]
                }
            }), new TableInator({
                row: 1,
                col: 0,
                colSpan: 4,
                name: "groupVolTable",
                cellClasses: "verticalTop",
                selectable: "single",
                selectCallback: createObjectCallback(this, this.changeCallback),
                bottomMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: "basetype",
                    bVisible: false,
                    bIsBasetype: true
                }, {
                    sTitle: "key",
                    bVisible: false,
                    bIsKey: true
                }, {
                    sTitle: strings.createReplicationSet.volGroupNameCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.createReplicationSet.volMembersCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.createReplicationSet.volPoolCol,
                    bFilterMenu: true
                }],
                dtOptions: {
                    bFilter: "noInput",
                    bFilter: "noControls",
                    iDisplayLength: 8,
                    bLengthChange: false,
                    aaSorting: [
                        [2, "asc"],
                        [3, "asc"]
                    ]
                }
            })]
        }), new TextInputWidget({
            name: "secondaryVolName",
            row: 4,
            col: 1,
            bottomMargin: true,
            rightMargin: true,
            label: strings.createReplicationSet.secondaryVolNameLabel,
            rules: {
                dhName: true
            },
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new RadioButtonsInputWidget({
            name: "destinationPool",
            label: strings.createReplicationSet.destinationPoolLabel,
            row: 5,
            col: 0,
            colSpan: 2,
            orientation: "horizontal",
            singleCell: true,
            bottomMargin: true,
            rightMargin: true,
            values: [{
                value: "A",
                text: "A"
            }, {
                value: "B",
                text: "B"
            }],
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new RadioButtonsInputWidget({
            name: "queuePolicy",
            label: strings.createReplicationSet.queuePolicyLabel,
            row: 6,
            col: 0,
            colSpan: 2,
            orientation: "horizontal",
            singleCell: true,
            bottomMargin: true,
            rightMargin: true,
            values: [{
                value: "discard",
                text: strings.createReplicationSet.discard
            }, {
                value: "queue-latest",
                text: strings.createReplicationSet.latest
            }],
            value: "queue-latest",
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new CheckboxContainer({
            name: "snapHistory",
            label: strings.createReplicationSet.snapHistLabel,
            row: 7,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            value: false,
            changeCallback: createObjectCallback(this, this.snapHistChanged),
            widgets: [new TableWidget({
                widgets: [new OptionInputWidget({
                    name: "retentionCount",
                    row: 0,
                    col: 1,
                    label: strings.createReplicationSet.retentionCountLabel,
                    values: C
                }), new TextInputWidget({
                    name: "snapshotBasename",
                    row: 1,
                    col: 1,
                    label: strings.createReplicationSet.snapshotBasenameLabel,
                    topMargin: true
                }), new CheckboxInputWidget({
                    name: "primaryVolSnap",
                    row: 2,
                    col: 1,
                    label: strings.createReplicationSet.primaryVolSnapLabel,
                    topMargin: true,
                    leftMargin: true
                }), new OptionInputWidget({
                    name: "retentionPriority",
                    row: 3,
                    col: 1,
                    label: strings.createReplicationSet.retentionPriorityLabel,
                    topMargin: true,
                    values: [{
                        value: "never-delete",
                        text: strings.createReplicationSet.neverDelete
                    }, {
                        value: "low",
                        text: strings.createReplicationSet.low
                    }, {
                        value: "medium",
                        text: strings.createReplicationSet.medium
                    }, {
                        value: "high",
                        text: strings.createReplicationSet.high
                    }]
                })]
            })]
        }), new CheckboxContainer({
            name: "repMode",
            label: strings.createReplicationSet.scheduleLabel,
            row: 8,
            col: 0,
            colSpan: 2,
            topMargin: true,
            value: false,
            widgets: [new TextWidget({
                text: strings.createLinearRepSet.schedInfo
            })]
        })]
    });
    ActionPanel.call(this, F);
    this.class_name = "CreateReplicationSet"
}
CreateReplicationSet.prototype = new ActionPanel();
CreateReplicationSet.prototype.constructor = CreateReplicationSet;
CreateReplicationSet.getMenuState = function(H) {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var G = TopicPanel.getSelected(["peer-connections"], 1);
    var I = false;
    var F = 0;
    for (var J in DC.volumesSerial) {
        var D = DC.volumesSerial[J];
        if (D.get("replication_set")) {
            F += 1
        }
    }
    for (var J in DC.volumesSerial) {
        var D = DC.volumesSerial[J];
        if (D.getInt("storage_type_numeric") && !D.get("replication_set")) {
            I = true;
            break
        }
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    } else {
        if (!I) {
            return strings.createReplicationSet.noVolumes
        } else {
            if (F == 32) {
                return strings.createReplicationSet.maxRepSets
            } else {
                if (G) {
                    var E = DC.peerConnectionsSerial[G[0].key];
                    var C = E.getInt("health_numeric");
                    if (!C && I) {
                        return G
                    } else {
                        return strings.createReplicationSet.badConnection
                    }
                } else {
                    return strings.menuTips.selectSingle(strings.peer)
                }
            }
        }
    }
};
CreateReplicationSet.prototype.showing = function() {
    this.selected = this.previousSelection[0];
    var G = this.selected.getObject();
    var C = G.get("peer_connection_name");
    this.repSetData.peerConnection = G.get("serial_number");
    var K = DC.getUnusedKey("virtualReplicationSets", "repSet");
    this.repSetCreated = false;
    var E = {
        createRepSetForm: {
            resetValidation: true
        },
        peerConnection: {
            text: C
        },
        repSetName: {
            value: K
        },
        singleVolTable: {
            data: this._getVolumeData(0)
        },
        groupVolTable: {
            data: this._getVolumeData(1),
            visibility: "hidden"
        },
        primaryVolSnap: {
            disable: true
        },
        retentionCount: {
            disable: true
        },
        retentionPriority: {
            disable: true
        },
        snapshotBasename: {
            disable: true,
            rules: {
                required: false
            }
        }
    };
    for (var J in DC.volumeGroups) {
        if (J != strings.volumeNotGrouped) {
            if (!DC.volumeGroups[J].get("replication_set_serial")) {
                var I = false;
                var D = DC.volumeGroups[J].objects.length;
                for (var F = 0; F < D; F++) {
                    if (DC.volumeGroups[J].objects[F].get("replication_set")) {
                        I = true
                    }
                }
                if (!I) {
                    var H = true;
                    break
                }
            }
        }
    }
    E.volumeOption = {
        values: [{
            value: 0,
            disable: !DC.volumes
        }, {
            value: 1,
            disable: !H
        }]
    };
    this.update(E);
    this.repSetData.repSetName = E.repSetName.value
};
CreateReplicationSet.prototype.dataUpdated = function() {
    if (settings.memorex) {
        this.repSetCreated = true
    } else {
        for (var D in DC.virtualReplicationSets) {
            var E = DC.virtualReplicationSets[D];
            var C = E.get("name");
            if (C == this.repSetData.repSetName) {
                if (this.scheduler) {
                    this.repSetCreated = true
                } else {
                    this.repSetCreated = (E.getInt("status_numeric") == REP_STATUS.UNSYNC)
                }
            }
        }
    }
    if (this.repSetCreated) {
        if (this.repTimeout) {
            this.showDialog()
        }
    }
};
CreateReplicationSet.prototype.volOptionChange = function(F, D) {
    var C = {};
    var E = (parseInt(D.currentValue)) ? 1 : 0;
    if (E) {
        this.createRepTable.widgets[0]._clearSelectAll();
        C.singleVolTable = {
            visibility: "hidden"
        };
        C.groupVolTable = {
            visibility: "visible"
        };
        C.secondaryVolName = {
            visibility: "hidden",
            disable: true,
            value: ""
        };
        C.snapHistory = {
            visibility: "collapse",
            disable: true
        }
    } else {
        this.createRepTable.widgets[1]._clearSelectAll();
        C.singleVolTable = {
            visibility: "visible"
        };
        C.groupVolTable = {
            visibility: "hidden"
        };
        C.secondaryVolName = {
            visibility: "visible",
            disable: false
        };
        C.snapHistory = {
            visibility: "visible",
            disable: false
        }
    }
    this.okEnabled(false);
    this.update(C);
    this.resetSize({
        shrink: true
    })
};
CreateReplicationSet.prototype._singleVolSelected = function(F) {
    this.createRepTable.widgets[1]._clearSelectAll();
    var E = F[0].getObject();
    var C = (F[0].basetype == "volume-groups") ? E.get("group_name") : E.get("volume_name");
    var D = E.get("storage_pool_name");
    this.repSetData.volume = {
        serialNum: E.get("serial_number"),
        name: C
    };
    this.update({
        secondaryVolName: {
            value: C
        },
        destinationPool: {
            value: D
        },
        snapshotBasename: {
            value: C
        },
        snapHistory: {
            disable: false
        }
    })
};
CreateReplicationSet.prototype._volGroupSelected = function(F) {
    this.createRepTable.widgets[0]._clearSelectAll();
    var E = F[0].getObject();
    var D = E.objects;
    var C = "A";
    if (D.length) {
        C = D[0].get("storage_pool_name")
    }
    this.repSetData.volume = {
        serialNum: E.get("serial_number")
    };
    this.update({
        destinationPool: {
            value: C
        }
    })
};
CreateReplicationSet.prototype.snapHistChanged = function(F, D, E) {
    if (F[D.name].value) {
        var C = {
            primaryVolSnap: {
                disable: false
            },
            retentionCount: {
                disable: false
            },
            retentionPriority: {
                disable: false
            },
            snapshotBasename: {
                disable: false,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: 26
                }
            }
        }
    } else {
        var C = {
            primaryVolSnap: {
                disable: true
            },
            retentionCount: {
                disable: true
            },
            retentionPriority: {
                disable: true
            },
            snapshotBasename: {
                disable: true,
                rules: {
                    required: false
                }
            }
        }
    }
    this.update(C)
};
CreateReplicationSet.prototype.changeCallback = function(G, D, E) {
    var C = {};
    this.retrieve(C);
    if (G.repSetName) {
        if (G.repSetName.value) {
            this.repSetData.repSetName = G.repSetName.value;
            this.repSetName = true
        }
    } else {
        if (G.secondaryVolName) {
            this.repSetData.secondaryVolName = G.secondaryVolName.value
        } else {
            if (G.destinationPool) {
                this.update({
                    destinationPool: G.destinationPool.value
                })
            } else {
                this.volSelected = true;
                var F = G[0].basetype;
                if (F == "volumes") {
                    this._singleVolSelected(G)
                } else {
                    this._volGroupSelected(G)
                }
            }
        }
    }
    this.okEnabled(this.volSelected && C.createRepSetForm.valid);
    this.resetSize({
        shrink: true
    })
};
CreateReplicationSet.prototype._getVolumeData = function(I) {
    var H = [];
    var E, D, M, R, S, Q, P, J, C, F;
    var L = {};
    this.retrieve(L);
    if (I) {
        for (var O in DC.volumeGroups) {
            P = DC.volumeGroups[O];
            if ((P.get("serial_number") !== "UNGROUPEDVOLUMES") && (P.objects !== undefined && P.objects.length !== 0)) {
                if (P.get("replication_set_serial")) {
                    continue
                }
                S = P.get("serial_number");
                Q = P.get("group_name");
                F = P.getInt("member_count");
                if (F > this.MAXVOLUMESGROUP) {
                    continue
                }
                var K = false;
                for (var G = 0; G < P.objects; G++) {
                    if (P.objects[G].get("replication_set")) {
                        K = true;
                        break
                    }
                }
                if (K) {
                    continue
                }
                for (var N in P.volumesSerial) {
                    J = P.volumesSerial[N].get("storage_pool_name");
                    break
                }
                H.push(["volume-groups", S, Q, F, J])
            }
        }
    } else {
        for (var R in DC.volumesSerial) {
            E = DC.volumesSerial[R];
            if (!E.getInt("storage_type_numeric") || E.get("replication_set")) {
                continue
            }
            D = E.get("volume_name");
            R = E.get("serial_number");
            C = E.get("size");
            M = E.get("storage_type");
            J = E.get("storage_pool_name");
            H.push(["volumes", R, D, C, M, J])
        }
    }
    return H
};
CreateReplicationSet.prototype.okCallback = function() {
    var C = {};
    this.retrieve(C);
    var D = [];
    this.scheduler = C.repMode.value;
    var E = {
        repSetName: C.repSetName.value,
        primaryVol: this.repSetData.volume.serialNum,
        secondaryVolName: C.secondaryVolName.value,
        peerConnection: this.repSetData.peerConnection,
        destinationPool: C.destinationPool.value,
        queuePolicy: C.queuePolicy.value
    };
    if (C.snapHistory.value) {
        $.extend(E, {
            snapHistory: (C.primaryVolSnap.value ? "both" : "secondary"),
            retentionCount: C.retentionCount.value,
            snapBasename: C.snapshotBasename.value,
            retentionPriority: C.retentionPriority.value
        })
    }
    if (this.scheduler) {
        D.push({
            name: "createReplicationSetVirtual",
            command: MC.createReplicationSet,
            data: E,
            options: {
                processingMsg: strings.createReplicationSet.processing,
                failureMsg: strings.createReplicationSet.failureMsg,
                successMsg: strings.createReplicationSet.schedulerSuccess
            }
        })
    } else {
        D.push({
            name: "createReplicationSetVirtual",
            command: MC.createReplicationSet,
            data: E,
            options: {
                processingMsg: strings.createReplicationSet.processing,
                failureMsg: strings.createReplicationSet.failureMsg,
                successMsg: strings.createReplicationSet.initiateRepMsg
            }
        })
    }
    this.repSetSubscription = MC.virtualReplicationSets.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.dataUpdated)
    });
    MC.execCommandList(D, {
        noSuccessDialog: true,
        closeActionOn: "success",
        callback: createObjectCallback(this, this.cmdComplete)
    });
    CreateReplicationSet.data = {
        createRepSetPanel: true,
        repSetName: E.repSetName,
        scheduler: this.scheduler
    }
};
CreateReplicationSet.prototype.cmdComplete = function(C) {
    if (C.success) {
        this.resultMsg = C.results.createReplicationSetVirtual.message;
        this.repTimeout = setTimeout(createObjectCallback(this, this.showDialog), 5 * 1000)
    }
};
CreateReplicationSet.prototype.showDialog = function() {
    if (this.repSetCreated) {
        if (this.scheduler) {
            ShowActiveDialog({
                type: "success",
                dialogOverride: true,
                message: strings.createReplicationSet.schedulerMsg,
                ok: createObjectCallback(this, CreateReplicationSet.open)
            })
        } else {
            ShowActiveDialog({
                type: "success",
                message: strings.createReplicationSet.initiateRepMsg,
                dialogOverride: true,
                cancelState: "enabled",
                okLabel: strings.Yes,
                cancelLabel: strings.No,
                ok: createObjectCallback(this, this.initiateFirstRep),
                cancel: createObjectCallback(this, this.ok)
            })
        }
    } else {
        ShowActiveDialog({
            type: "warning",
            message: this.resultMsg + "<br>" + strings.createReplicationSet.initOrScheduleLater,
            dialogOverride: true,
            ok: panels.actionDialog.close(true)
        })
    }
    MC.virtualReplicationSets.unregister(this.repSetSubscription);
    delete this.repSetSubscription;
    clearTimeout(this.repTimeout);
    delete this.repTimeout
};
CreateReplicationSet.open = function() {
    NAV.navTo("HiddenActions", "scheduleReplications")
};
CreateReplicationSet.prototype.initiateFirstRep = function() {
    var E = {};
    this.retrieve(E, true);
    var D = DC.virtualReplicationSets[E.repSetName.value].get("serial_number");
    var C = {
        repSet: D
    };
    MC.replicateVolume(C, {
        dialog: true,
        processingMsg: strings.initiateReplication.processing,
        failureMsg: strings.initiateReplication.failureMsg,
        successMsg: strings.initiateReplication.success,
        closeActionOn: "success"
    })
};
CreateReplicationSet.prototype.ok = function() {
    ShowActiveDialog({
        type: "success",
        message: strings.createReplicationSet.manualRepMsg,
        dialogOverride: true,
        ok: panels.actionDialog.close(true)
    })
};

function ScheduleReplications(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ScheduleReplications";
    C.title = strings.actions.ScheduleReplications;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.width = 500;
    this.repSetSchedInfo = {
        repSetName: "",
        repSetSerial: "",
        taskName: ""
    };
    C.widgets = [new FormWidget({
        name: "scheduleRepsForm",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            bottomMargin: true
        }), new TextInputWidget({
            name: "taskName",
            label: strings.replicate.taskName,
            width: 260,
            bottomMargin: true,
            changeCallback: createObjectCallback(this, this.taskNameChange)
        }), new CheckboxInputWidget({
            name: "lastSnapshot",
            row: 0,
            col: 0,
            label: strings.replicate.lastSnapshot,
            singleCell: true,
            bottomMargin: true,
            changeCallback: createObjectCallback(this, this.lastSnapshotChange)
        }), this.schedContainer = new CheckboxContainer({
            name: "replicationSchedContainer",
            label: strings.resetSnapshotAction.scheduleLabel,
            changeCallback: createObjectCallback(this, this._toggleSchedule),
            widgets: [this.scheduleInputWidget = new ScheduleInputWidget({
                name: "repSchedule",
                changeCallback: createObjectCallback(this, this.scheduleWidgetChange)
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ScheduleReplications"
}
ScheduleReplications.prototype = new ActionPanel();
ScheduleReplications.prototype.constructor = ScheduleReplications;
ScheduleReplications.getMenuState = function() {
    var C = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    if (C) {
        var D = DC.virtualReplicationSetsSerial[C[0].key];
        if (D.getInt("primary_location_numeric") != REPSET_DIRECTION.OUTBOUND) {
            return strings.scheduleReplication.cannotSchedule
        } else {
            return C
        }
    } else {
        return strings.menuTips.noRepSetSelected
    }
};
ScheduleReplications.prototype.showing = function() {
    var F = {
        repSet: {
            value: ""
        },
        taskName: {
            value: "",
            rules: {
                required: true
            }
        },
        replicationSchedContainer: {
            value: false,
            visibility: "visible"
        },
        scheduleRep: {
            disable: true
        },
        scheduleRepsForm: {
            resetValidation: true
        }
    };
    var G = false;
    var M = new CreateReplicationSet();
    if (M.constructor.data) {
        var C = M.constructor.data;
        G = C.scheduler
    }
    if (G) {
        for (var K in DC.virtualReplicationSetsSerial) {
            var J = DC.virtualReplicationSetsSerial[K];
            var L = J.get("name");
            if (L == C.repSetName) {
                var E = (J.getInt("group_numeric") == 1);
                var H = J.get("serial_number");
                break
            }
        }
        F.lastSnapshot = {
            visibility: (E ? "collapse" : "visible")
        };
        F.repSet = {
            text: C.repSetName
        };
        this.repSetSchedInfo.repSetName = C.repSetName;
        this.repSetSchedInfo.repSetSerial = H
    } else {
        this.selected = this.previousSelection;
        for (var I in this.selected) {
            var D = this.selected[I].basetype;
            var K = this.selected[I].key;
            if (D == "cs-replication-set") {
                var J = DC.virtualReplicationSetsSerial[K];
                var L = J.get("name");
                var H = J.get("serial_number");
                F.repSet = {
                    text: L
                };
                this.repSetSchedInfo.repSetName = L;
                this.repSetSchedInfo.repSetSerial = H;
                break
            }
        }
    }
    this.update(F)
};
ScheduleReplications.prototype.taskNameChange = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    this.repSetSchedInfo.taskName = F.taskName.value
};
ScheduleReplications.prototype.lastSnapshotChange = function(E, C, D) {
    this.repSetSchedInfo.lastSnapshot = E.lastSnapshot.value
};
ScheduleReplications.prototype._toggleSchedule = function(E, C, D) {
    this.resetSize({
        shrink: true
    });
    this.changeCallback(E, C, D)
};
ScheduleReplications.prototype.scheduleWidgetChange = function(E, C, D) {
    this.resetSize({
        shrink: true
    });
    this.changeCallback()
};
ScheduleReplications.prototype.changeCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.scheduleRepsForm) {
        return
    }
    if (C.scheduleRepsForm.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
ScheduleReplications.prototype.okCallback = function() {
    var E = [];
    var G = {};
    this.retrieve(G);
    var D = this.repSetSchedInfo.repSetName;
    this.schedName = DC.getUnusedKey("schedules", D + "SS000", 32);
    var F = {
        name: G.taskName.value,
        type: "Replicate",
        replicationSet: this.repSetSchedInfo.repSetSerial
    };
    if (G.lastSnapshot.value) {
        F.lastSnapshot = "last-snapshot"
    }
    E.push({
        name: "createRepSchedTask",
        command: MC.createTask,
        data: F,
        options: {
            processingMsg: strings.scheduleReplication.createTask.taskProcessing(F.name),
            failureMsg: strings.scheduleReplication.createTask.failureMsg(F.name)
        }
    });
    var C = {
        name: this.schedName,
        scheduleSpecification: G.repSchedule.value,
        taskName: G.taskName.value
    };
    E.push({
        name: "schedules",
        command: MC.createSchedule,
        data: C,
        options: {
            processingMsg: strings.scheduleReplication.createSched.scheduleProcessing(F.name),
            failureMsg: strings.scheduleReplication.createSched.scheduleFailure(F.name)
        }
    });
    MC.execCommandList(E, {
        closeActionOn: "success",
        callback: createObjectCallback(this, this._scheduleTaskComplete),
        successMsg: strings.scheduleReplication.scheduleSuccess(this.repSetSchedInfo.repSetName)
    })
};
ScheduleReplications.prototype._scheduleTaskComplete = function(C) {
    var D = C.results.schedules;
    if (D && !D.success) {
        MC.deleteTask({
            name: this.repSetSchedInfo.taskName
        }, {
            dialog: false,
            noSuccessDialog: true
        })
    }
};

function DeleteReplicationSet(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DeleteReplicationSet";
    C.title = strings.actions.DeleteReplicationSet;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "deleteWC",
        widgets: [new TextWidget({
            name: "repSets",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "warningText",
            topMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteReplicationSet"
}
DeleteReplicationSet.prototype = new ActionPanel();
DeleteReplicationSet.prototype.constructor = DeleteReplicationSet;
DeleteReplicationSet.getMenuState = function() {
    var H = TopicPanel.getSelected(["cs-replication-set"], 1);
    var F = objectCount(DC.peerConnections, APIObject);
    if (F && H) {
        var G = DC.virtualReplicationSetsSerial[H[0].key].get("peer_connection_name");
        var E = DC.peerConnections[G]
    }
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (H) {
        var I = DC.virtualReplicationSetsSerial[H[0].key];
        var D = I.getInt("status_numeric");
        var C = I.getInt("sync_job_active_numeric");
        if (E && E.getInt("health_numeric") == HEALTH.FAULT) {
            return strings.menuTips.faultyPeer
        } else {
            if (D == REP_STATUS.RUNNING) {
                return strings.deleteReplicationSets.repSetInProgress
            } else {
                if (C == REP_STATUS.SYNC_ACTIVE) {
                    return strings.deleteReplicationSets.activeSyncJob
                } else {
                    return H
                }
            }
        }
    } else {
        return strings.menuTips.noRepSetSelected
    }
};
DeleteReplicationSet.prototype.showing = function() {
    this.selected = this.previousSelection;
    var E = DC.virtualReplicationSetsSerial[this.selected[0].key];
    var C = E.get("name");
    this.repSetsSerial = E.get("serial_number");
    var D = {
        repSets: {
            text: C,
            label: strings.repSetLabel
        },
        warningText: {
            text: strings.deleteReplicationSets.panelWarning(strings.replicationSet)
        }
    };
    this.update(D);
    this.okEnabled(true)
};
DeleteReplicationSet.prototype._okCallback = function() {
    var C = {
        repSet: this.repSetsSerial
    };
    MC.deleteReplicationSet(C, {
        dialog: true,
        processingMsg: strings.deleteReplicationSets.processing(strings.replicationSet),
        failureMsg: strings.deleteReplicationSets.failure(strings.replicationSet),
        successMsg: strings.deleteReplicationSets.successSingular(strings.replicationSet),
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    })
};

function ModifyReplicationSet(C) {
    C.name = "ModifyReplicationSet";
    C.title = strings.actions.ModifyReplicationSet;
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "modifyRepSetForm",
        tableLayout: true,
        widgets: [new TextWidget({
            name: "repSetToMod",
            row: 0,
            bottomMargin: true,
            leftMargin: true,
            label: strings.repSetLabel
        }), new TextInputWidget({
            name: "modRepSetName",
            row: 1,
            col: 1,
            labelOptions: {
                classes: "noWrap"
            },
            bottomMargin: true,
            leftMargin: true,
            label: strings.modifyReplicationSet.setRepSetName,
            rules: {
                dhName: true,
                utf8length: RI.getMaxNameLength(),
                replicationSetExists: true
            },
            changeCallback: createObjectCallback(this, this.changedCallback)
        }), new RadioButtonsInputWidget({
            name: "queuePolicy",
            label: strings.createReplicationSet.queuePolicyLabel,
            row: 2,
            col: 0,
            colSpan: 2,
            orientation: "horizontal",
            singleCell: true,
            bottomMargin: true,
            rightMargin: true,
            values: [{
                value: "discard",
                text: strings.createReplicationSet.discard
            }, {
                value: "queue-latest",
                text: strings.createReplicationSet.latest
            }],
            changeCallback: createObjectCallback(this, this.changedCallback)
        }), new CheckboxContainer({
            name: "snapHistory",
            label: strings.createReplicationSet.snapHistLabel,
            row: 3,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            value: false,
            changeCallback: createObjectCallback(this, this.snapHistChanged),
            widgets: [new TableWidget({
                widgets: [new OptionInputWidget({
                    name: "retentionCount",
                    row: 0,
                    col: 1,
                    label: strings.createReplicationSet.retentionCountLabel,
                    changeCallback: createObjectCallback(this, this.changedCallback)
                }), new TextInputWidget({
                    name: "snapshotBasename",
                    row: 1,
                    col: 1,
                    label: strings.createReplicationSet.snapshotBasenameLabel,
                    topMargin: true,
                    changeCallback: createObjectCallback(this, this.changedCallback)
                }), new CheckboxInputWidget({
                    name: "primaryVolSnap",
                    row: 2,
                    col: 1,
                    label: strings.createReplicationSet.primaryVolSnapLabel,
                    topMargin: true,
                    leftMargin: true,
                    changeCallback: createObjectCallback(this, this.changedCallback)
                }), new OptionInputWidget({
                    name: "retentionPriority",
                    row: 3,
                    col: 1,
                    label: strings.createReplicationSet.retentionPriorityLabel,
                    topMargin: true,
                    values: [{
                        value: RETENTION_PRIORITY.NEVERDELETE,
                        text: strings.createReplicationSet.neverDelete
                    }, {
                        value: RETENTION_PRIORITY.LOW,
                        text: strings.createReplicationSet.low
                    }, {
                        value: RETENTION_PRIORITY.MEDIUM,
                        text: strings.createReplicationSet.medium
                    }, {
                        value: RETENTION_PRIORITY.HIGH,
                        text: strings.createReplicationSet.high
                    }],
                    changeCallback: createObjectCallback(this, this.changedCallback)
                })]
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ModifyReplicationSet"
}
ModifyReplicationSet.prototype = new ActionPanel();
ModifyReplicationSet.prototype.constructor = ModifyReplicationSet;
ModifyReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (C) {
        return C
    } else {
        return strings.menuTips.noRepSetSelected
    }
};
ModifyReplicationSet.prototype.showing = function() {
    var D = this.previousSelection;
    var L = DC.virtualReplicationSetsSerial[D[0].key];
    this.repSetName = L.get("name");
    var C = L.getInt("group_numeric");
    var K = (L.getInt("queue_policy_numeric") == 1 ? "discard" : "queue-latest");
    var J = {
        repSetToMod: {
            text: L.get("name")
        },
        modRepSetName: {
            value: "",
            setOrig: true
        },
        queuePolicy: {
            value: K,
            setOrig: true
        }
    };
    if (C < 1) {
        var N = (L.get("snapshot_count") == "0" ? "1" : L.get("snapshot_count"));
        var H = L.getInt("snapshot_history_numeric");
        var O = (H == REPSNAPHIST.SECONDARY || H == REPSNAPHIST.BOTH);
        var M = (H == REPSNAPHIST.BOTH);
        var G = L.get("snapshot_basename");
        if (G == "") {
            G = L.get("secondary_volume_name")
        }
        var F = 0;
        for (var E = 0; E < L.objects.length; E++) {
            if (L.objects[E] instanceof APICurrentReplicationSnapshots) {
                F += 1
            }
        }
        if (F == 0) {
            F = 1
        }
        var I = [];
        for (var E = F; E <= 16; E++) {
            I[I.length] = {
                value: "" + E,
                text: "" + E
            }
        }
        J.snapHistory = {
            value: O,
            setOrig: true
        };
        J.retentionCount = {
            values: I,
            value: N,
            disable: (O ? false : true),
            setOrig: true
        };
        J.retentionPriority = {
            value: L.getInt("retention_priority_numeric"),
            disable: (O ? false : true),
            setOrig: true
        };
        J.snapshotBasename = {
            value: G,
            disable: (O ? false : true),
            rules: {
                required: (O ? true : false),
                dhName: true,
                utf8length: 26
            },
            setOrig: true
        };
        J.primaryVolSnap = {
            value: M,
            disable: (O ? false : true),
            setOrig: true
        };
        if (F > 1) {
            J.retentionCount.tip = strings.modifyReplicationSet.retentionCountTip
        }
    } else {
        J.snapHistory = {
            visibility: "collapse"
        }
    }
    this.update(J);
    this.resetSize({
        shrink: true
    })
};
ModifyReplicationSet.prototype.snapHistChanged = function(G, E, F) {
    var D = {};
    this.retrieve(D);
    if (G[E.name].value) {
        var C = {
            primaryVolSnap: {
                disable: false
            },
            retentionCount: {
                disable: false
            },
            retentionPriority: {
                disable: false
            },
            snapshotBasename: {
                disable: false,
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: 26
                }
            }
        }
    } else {
        var C = {
            primaryVolSnap: {
                disable: true
            },
            retentionCount: {
                disable: true
            },
            retentionPriority: {
                disable: true
            },
            snapshotBasename: {
                disable: true,
                rules: {
                    required: false
                }
            }
        }
    }
    this.update(C);
    this.changedCallback()
};
ModifyReplicationSet.prototype.changedCallback = function(G, D, E) {
    var C = {};
    this.retrieve(C);
    var F = false;
    for (var D in C) {
        if (C[D].valueChanged) {
            F = true;
            break
        }
    }
    if (C.modifyRepSetForm.valid && F) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
ModifyReplicationSet.prototype.okCallback = function() {
    var E = {};
    this.retrieve(E);
    var D = {
        repSet: this.repSetName
    };
    var C = false;
    var F = function(H) {
        switch (H) {
            case "0":
                var G = "never-delete";
                break;
            case "1":
                var G = "high";
                break;
            case "2":
                var G = "medium";
                break;
            case "3":
                var G = "low";
                break;
            default:
                break
        }
        return G
    };
    if (E.modRepSetName.valueChanged) {
        D.name = E.modRepSetName.value
    }
    if (E.queuePolicy.valueChanged) {
        D.queuePolicy = E.queuePolicy.value
    }
    if (E.snapHistory.valueChanged) {
        if (E.snapHistory.value) {
            $.extend(D, {
                snapHistory: (E.primaryVolSnap.value ? "both" : "secondary"),
                retentionCount: E.retentionCount.value,
                snapBasename: E.snapshotBasename.value,
                retentionPriority: F(E.retentionPriority.value)
            })
        } else {
            D.snapHistory = "disabled"
        }
    } else {
        if (E.snapHistory.value) {
            if (E.retentionCount.valueChanged) {
                D.retentionCount = E.retentionCount.value
            }
            if (E.snapshotBasename.valueChanged) {
                D.snapBasename = E.snapshotBasename.value
            }
            if (E.retentionPriority.valueChanged) {
                D.retentionPriority = F(E.retentionPriority.value)
            }
            if (E.primaryVolSnap.valueChanged) {
                D.snapHistory = (E.primaryVolSnap.value ? "both" : "secondary")
            }
        }
    }
    MC.modifyReplicationSet(D, {
        dialog: true,
        processingMsg: strings.modifyReplicationSet.processing,
        failureMsg: strings.modifyReplicationSet.failure,
        successMsg: strings.modifyReplicationSet.success,
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    })
};

function ReplicateAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ReplicateAction";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "replicateForm",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.replicate.confirm
        }), new CheckboxContainer({
            name: "schedContainer",
            label: strings.replicate.scheduleLabel,
            value: false,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.toggleSchedule),
            widgets: [new TextInputWidget({
                name: "taskName",
                label: strings.replicate.taskName,
                rules: {
                    required: true
                },
                changeCallback: createObjectCallback(this, this.changeCallback),
                width: 260,
                bottomMargin: true
            }), new CheckboxInputWidget({
                name: "lastSnapshot",
                row: 0,
                col: 0,
                label: strings.replicate.lastSnapshot,
                singleCell: true,
                bottomMargin: true,
                changeCallback: createObjectCallback(this, this.changeCallback)
            }), new ScheduleInputWidget({
                name: "scheduleReplication",
                changeCallback: createObjectCallback(this, this.changeCallback)
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ReplicateAction"
}
ReplicateAction.prototype = new ActionPanel();
ReplicateAction.prototype.constructor = ReplicateAction;
ReplicateAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (D) {
        var F = DC.virtualReplicationSetsSerial[D[0].key];
        var E = F.get("status_numeric");
        if (F.getInt("primary_location_numeric") != REPSET_DIRECTION.OUTBOUND && F.getInt("failback_in_progress_numeric") == 0) {
            return strings.initiateReplication.cannotReplicate
        } else {
            if (E == REP_STATUS.UNSYNC || E == REP_STATUS.READY) {
                return D
            } else {
                var C = (F.getInt("queue_policy_numeric") == 1 ? "discard" : "queue-latest");
                if (C == "queue-latest" && E == REP_STATUS.RUNNING) {
                    return D
                } else {
                    if (E == REP_STATUS.FAILEDOVER) {
                        return strings.menuTips.failoverRepSet
                    } else {
                        return strings.initiateReplication.inProgress
                    }
                }
            }
        }
    } else {
        return strings.menuTips.noRepSetSelected
    }
};
ReplicateAction.prototype.showing = function() {
    this.schedule = false;
    var C = this.previousSelection[0].key;
    var E = DC.virtualReplicationSetsSerial[C];
    var D = E.getInt("group_numeric") == 1;
    this.repSetName = E.get("name");
    this.repSetSerial = C;
    this.update({
        repSet: {
            text: this.repSetName
        },
        lastSnapshot: {
            visibility: (D ? "collapse" : "visible")
        }
    });
    this.okEnabled(true)
};
ReplicateAction.prototype.okCallback = function() {
    if (this.schedule) {
        var F = [];
        var H = {};
        this.retrieve(H);
        this.schedName = DC.getUnusedKey("schedules", this.repSetName + "SS000", 32);
        this.taskName = H.taskName.value;
        var G = {
            name: this.taskName,
            type: "Replicate",
            replicationSet: this.repSetSerial
        };
        if (H.lastSnapshot.value) {
            G.lastSnapshot = "last-snapshot"
        }
        F.push({
            name: "createRepSchedTask",
            command: MC.createTask,
            data: G,
            options: {
                processingMsg: strings.scheduleReplication.createTask.taskProcessing(G.name),
                failureMsg: strings.scheduleReplication.createTask.failureMsg(G.name)
            }
        });
        var C = {
            name: this.schedName,
            scheduleSpecification: H.scheduleReplication.value,
            taskName: H.taskName.value
        };
        F.push({
            name: "schedules",
            command: MC.createSchedule,
            data: C,
            options: {
                processingMsg: strings.scheduleReplication.createSched.scheduleProcessing(G.name),
                failureMsg: strings.scheduleReplication.createSched.scheduleFailure(G.name)
            }
        });
        MC.execCommandList(F, {
            closeActionOn: "success",
            callback: createObjectCallback(this, this._scheduleTaskComplete),
            successMsg: strings.scheduleReplication.scheduleSuccess(this.repSetName)
        })
    } else {
        var H = {
            repSet: this.repSetSerial
        };
        var I = DC.virtualReplicationSetsSerial[this.repSetSerial];
        var E = (I.getInt("queue_policy_numeric") == 1 ? "discard" : "queue-latest");
        if (E == "queue-latest" && I.get("status_numeric") == REP_STATUS.RUNNING) {
            var D = strings.initiateReplication.queueSuccess
        } else {
            var D = strings.initiateReplication.success
        }
        MC.replicateVolume(H, {
            dialog: true,
            processingMsg: strings.initiateReplication.processing,
            failureMsg: strings.initiateReplication.failure,
            successMsg: D,
            okLabel: strings.deleteButtonText,
            cancelLabel: strings.cancelButtonText,
            closeActionOn: "success"
        })
    }
};
ReplicateAction.prototype.toggleSchedule = function(C) {
    if (C.schedContainer.value) {
        this.schedule = true;
        this.update({
            replicateForm: {
                resetValidation: true
            }
        })
    } else {
        this.schedule = false
    }
    this.resetSize({
        shrink: true
    })
};
ReplicateAction.prototype.changeCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.replicateForm) {
        return
    }
    if (C.replicateForm.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
ReplicateAction.prototype._scheduleTaskComplete = function(C) {
    var D = C.results.schedules;
    if (D && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true
        })
    }
};

function AbortReplication(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AbortReplicaion";
    C.title = strings.actions.AbortReplication;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "deleteWC",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.abortReplication.confirm
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "AbortReplication"
}
AbortReplication.prototype = new ActionPanel();
AbortReplication.prototype.constructor = AbortReplication;
AbortReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (D) {
        var F = DC.virtualReplicationSetsSerial[D[0].key];
        var E = F.get("status_numeric");
        var C = F.getInt("sync_job_active_numeric");
        if (F.getInt("primary_location_numeric") != REPSET_DIRECTION.OUTBOUND) {
            if (F.get("failback_in_progress_numeric") == 1) {
                if (E == REP_STATUS.RUNNING || E == REP_STATUS.SUSPENDED && C) {
                    return D
                } else {
                    return strings.abortReplication.inProgress
                }
            } else {
                return strings.abortReplication.cannotAbort
            }
        } else {
            if (E == REP_STATUS.RUNNING || (E == REP_STATUS.SUSPENDED && C)) {
                return D
            } else {
                if (E == REP_STATUS.FAILEDOVER) {
                    return strings.menuTips.failoverRepSet
                } else {
                    return strings.abortReplication.inProgress
                }
            }
        }
    } else {
        return strings.abortReplication.selectRepSet
    }
};
AbortReplication.prototype.showing = function() {
    this.selected = this.previousSelection;
    var C = DC.virtualReplicationSetsSerial[this.selected[0].key];
    this.update({
        repSet: {
            text: C.get("name")
        }
    });
    this.okEnabled(true)
};
AbortReplication.prototype._okCallback = function() {
    var C = {
        repSet: this.selected[0].key
    };
    MC.abortReplication(C, {
        dialog: true,
        processingMsg: strings.abortReplication.processing,
        failureMsg: strings.abortReplication.failure,
        successMsg: strings.abortReplication.success,
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    })
};

function ResumeReplicationSet(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ResumeReplicationSet";
    C.title = strings.actions.ResumeReplicationSet;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "resumeWC",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.resumeReplicationSet.confirm
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ResumeReplicationSet"
}
ResumeReplicationSet.prototype = new ActionPanel();
ResumeReplicationSet.prototype.constructor = ResumeReplicationSet;
ResumeReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (C) {
        var E = DC.virtualReplicationSetsSerial[C[0].key];
        var D = E.get("status_numeric");
        if (E.getInt("primary_location_numeric") != REPSET_DIRECTION.OUTBOUND) {
            if (E.get("failback_in_progress_numeric") == 1 && D == REP_STATUS.SUSPENDED) {
                return C
            } else {
                return strings.resumeReplicationSet.cannotResume
            }
        } else {
            if (D == REP_STATUS.SUSPENDED) {
                return C
            } else {
                return strings.resumeReplicationSet.suspendedRepSet
            }
        }
    } else {
        return strings.resumeReplicationSet.selectRepSet
    }
};
ResumeReplicationSet.prototype.showing = function() {
    this.selected = this.previousSelection;
    var C = DC.virtualReplicationSetsSerial[this.selected[0].key];
    this.update({
        repSet: {
            text: C.get("name")
        }
    });
    this.okEnabled(true)
};
ResumeReplicationSet.prototype._okCallback = function() {
    var C = {
        repSet: this.selected[0].key
    };
    MC.resumeReplication(C, {
        dialog: true,
        processingMsg: strings.resumeReplicationSet.processing,
        failureMsg: strings.resumeReplicationSet.failure,
        successMsg: strings.resumeReplicationSet.success,
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    })
};

function SuspendReplicationSet(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "SuspendReplicationSet";
    C.title = strings.actions.SuspendReplicationSet;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "deleteWC",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.suspendReplicationSet.confirm
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "SuspendReplicationSet"
}
SuspendReplicationSet.prototype = new ActionPanel();
SuspendReplicationSet.prototype.constructor = SuspendReplicationSet;
SuspendReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (C) {
        var E = DC.virtualReplicationSetsSerial[C[0].key];
        var D = E.get("status_numeric");
        if (E.getInt("primary_location_numeric") != REPSET_DIRECTION.OUTBOUND) {
            if (E.get("failback_in_progress_numeric") == 1 && (D == REP_STATUS.RUNNING || D == REP_STATUS.UNSYNC || D == REP_STATUS.READY)) {
                return C
            } else {
                return strings.suspendReplicationSet.cannotSuspend
            }
        } else {
            if (D == REP_STATUS.RUNNING || D == REP_STATUS.UNSYNC || D == REP_STATUS.READY) {
                return C
            } else {
                return strings.suspendReplicationSet.inProgress
            }
        }
    } else {
        return strings.suspendReplicationSet.selectRepSet
    }
};
SuspendReplicationSet.prototype.showing = function() {
    this.selected = this.previousSelection;
    var C = DC.virtualReplicationSetsSerial[this.selected[0].key];
    this.update({
        repSet: {
            text: C.get("name")
        }
    });
    this.okEnabled(true)
};
SuspendReplicationSet.prototype._okCallback = function() {
    var C = {
        repSet: this.selected[0].key
    };
    MC.suspendReplication(C, {
        dialog: true,
        processingMsg: strings.suspendReplicationSet.processing,
        failureMsg: strings.suspendReplicationSet.failure,
        successMsg: strings.suspendReplicationSet.success,
        okLabel: strings.deleteButtonText,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "success"
    })
};

function VerticalNavigationWidget(F) {
    F.htmlText = '<div style="padding-right: 15px;">';
    for (var E = 0; E < F.steps.length; E++) {
        var C = F.steps[E];
        F.htmlText += '<div id="' + C.name + '">    <div style="padding:5px;margin-top:5px;">        <div class="smallStepCircle"><span class="stepNumber">' + (E + 1) + '</span></div>        <div class="stepLabel">' + C.label + "</div>    </div>";
        if (C.substeps) {
            for (var D = 0; D < C.substeps.length; D++) {
                F.htmlText += '<div id="' + C.substeps[D].name + '" class="subStepLabel">' + C.substeps[D].label + "</div>"
            }
        }
        F.htmlText += "</div>"
    }
    F.htmlText += "</div>";
    WidgetContainer.call(this, F)
}
VerticalNavigationWidget.prototype = new WidgetContainer();
VerticalNavigationWidget.prototype.constructor = VerticalNavigationWidget;
VerticalNavigationWidget.prototype.setSubSteps = function(G, C) {
    var E = $("#" + G);
    $(".subStepLabel", E).remove();
    var F = "";
    for (var D = 0; D < C.length; D++) {
        F += '<div id="' + C[D].name + '" class="subStepLabel">' + C[D].label + "</div>"
    }
    $(F).appendTo(E)
};
VerticalNavigationWidget.prototype.setSubStepActive = function(C) {
    $(".subStepLabelActive").removeClass("subStepLabelActive");
    var D = $("#" + C);
    D.addClass("subStepLabelActive")
};
VerticalNavigationWidget.prototype.setPrimaryStepActive = function(E) {
    $(".smallStepCircleActive").removeClass("smallStepCircleActive");
    $(".stepNumberActive").removeClass("stepNumberActive");
    $(".stepLabel").addClass("stepLabelDisabled");
    $(".stepLabelActive").removeClass("stepLabelActive").addClass("stepLabelDisabled");
    var F = $(".smallStepCircle", "#" + E);
    var D = $(".stepNumber", "#" + E);
    var C = $(".stepLabel", "#" + E);
    F.removeClass("smallStepCircleComplete").addClass("smallStepCircleActive");
    D.removeClass("stepNumberComplete").addClass("stepNumberActive");
    C.removeClass("stepLabelDisabled stepLabelComplete").addClass("stepLabelActive");
    if (C.contents(".completed").length) {
        C.find(".completed").remove()
    }
    $(".subStepLabel").addClass("subStepLabelDisabled");
    var G = $(".subStepLabel", "#" + E);
    G.removeClass("subStepLabelDisabled")
};
VerticalNavigationWidget.prototype.markPrimaryStepComplete = function(E) {
    var F = $(".smallStepCircle", "#" + E);
    var D = $(".stepNumber", "#" + E);
    var C = $(".stepLabel", "#" + E);
    F.addClass("smallStepCircleComplete");
    D.addClass("stepNumberComplete");
    C.removeClass("stepLabelDisabled").addClass("stepLabelComplete");
    if (!C.contents(".completed").length) {
        $('<div class="completed"></div>').appendTo(C)
    }
};
VerticalNavigationWidget.prototype.markStepComplete = function(C) {
    var D = $("#" + C);
    $('<div class="completed"></div>').appendTo(D)
};
VerticalNavigationWidget.prototype.removeStepComplete = function(C) {
    var D = $("#" + C);
    D.find(".completed").remove()
};

function PeerStatusWidget(C) {
    if (C.includeImage) {
        C.htmlText = '<div style="padding: 10px">    <div id="peerStatusImage" style="display: inline-block; width: 200px; height: 100px;"></div>    <div class="widgetContainer" style="display: inline-block; padding-left: 10px; padding-top: 10px; vertical-align: top;"></div></div>'
    }
    C.widgets = [new TextWidget({
        name: "peerName",
        label: strings.recoveryManager.peerName,
        labelClass: "hoverSectionLabel"
    }), new TextWidget({
        name: "peerConnStatus",
        label: strings.recoveryManager.peerStatus,
        labelClass: "hoverSectionLabel"
    }), new TextWidget({
        name: "repSetName",
        label: strings.recoveryManager.repSetName,
        topMargin: true,
        labelClass: "hoverSectionLabel"
    }), new TextWidget({
        name: "repSetStatus",
        label: strings.recoveryManager.repSetStatus,
        bottomMargin: true,
        labelClass: "hoverSectionLabel"
    })];
    WidgetContainer.call(this, C);
    this.class_name = "PeerStatusWidget";
    if (C.includeImage) {
        this.peerStatusImage$ = $("#peerStatusImage", this.elements)
    }
}
PeerStatusWidget.prototype = new WidgetContainer();
PeerStatusWidget.prototype.constructor = PeerStatusWidget;
PeerStatusWidget.prototype.handleUpdate = function(C) {
    if (C.get("connection_status_numeric") == PEERSTATUS.ONLINE) {
        this.peerStatusImage$.css("background", "transparent url(../images/replications/peerOnline.png) no-repeat")
    } else {
        this.peerStatusImage$.css("background", "transparent url(../images/replications/peerDown.png) no-repeat")
    }
    this.peerStatusImage$.css("background-size", "contain")
};

function RecoveryManager(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "RecoveryManager";
    E.okCallback = createObjectCallback(this, this.okCallback);
    E.applyCallback = createObjectCallback(this, this.applyCallback);
    this.baseLun = getBaseLUN();
    var F = '<table><tr><td><div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/primaryVol.png) no-repeat; background-size: contain;"></div></td><td style="color: white;">' + strings.recoveryManager.primaryVol + '</td></tr><tr><td><div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/secondaryVol.png) no-repeat; background-size: contain;"></div></td><td style="color: white;">' + strings.recoveryManager.secondaryVol + "</td></tr></table>";
    E.widgets = [new WidgetContainer({
        name: "wrapper",
        classes: "nowrap",
        widgets: [new WidgetContainer({
            name: "leftSection",
            classes: "leftSection",
            widgets: [new WidgetContainer({
                name: "peerStatus",
                classes: "peerStatus",
                widgets: [new PeerStatusWidget({
                    includeImage: false
                })]
            }), this.navContainer = new WidgetContainer({
                name: "navigation",
                widgets: [this.navWidget = new VerticalNavigationWidget({
                    name: "nav",
                    steps: [{
                        name: "failover",
                        label: strings.recoveryManager.failoverToSecondary,
                        substeps: [{
                            name: "failoverIntro",
                            label: strings.recoveryManager.introLabel
                        }, {
                            name: "failoverSnap",
                            label: strings.recoveryManager.takeSnapLabel
                        }, {
                            name: "failoverAction",
                            label: strings.recoveryManager.failoverLabel
                        }, {
                            name: "failoverMap",
                            label: strings.recoveryManager.mapVolLabel
                        }, {
                            name: "failoverSummary",
                            label: strings.recoveryManager.summaryLabel
                        }]
                    }, {
                        name: "recovery",
                        label: strings.recoveryManager.recovery
                    }]
                })]
            })]
        }), new WidgetContainer({
            name: "widgetSection",
            classes: "recoveryManagerWidgetContainer",
            widgets: [this.form = new FormWidget({
                name: "recoveryForm",
                widgets: [new Widget({
                    name: "restoreAlert",
                    htmlText: '<div class="restoreAlertContainer">    <div style="display: table-cell;vertical-align: middle;"><div style="display: table;padding: 10px;">        <div class="restoreAlertIcon"></div><div class="restoreAlertLabel">' + strings.recoveryManager.alert + '</div>     </div></div>     <div class="restoreAlertText wordWrap">' + strings.recoveryManager.restoreAlertText + "</div></div>"
                }), new Widget({
                    name: "noRestoreAlert",
                    htmlText: '<div class="restoreAlertContainer">    <div style="display: table-cell;vertical-align: middle;"><div style="display: table;padding: 10px;">        <div class="restoreAlertIcon"></div><div class="restoreAlertLabel">' + strings.recoveryManager.alert + '</div>     </div></div>     <div class="restoreAlertText wordWrap">' + strings.recoveryManager.noRestoreAlertText + "</div></div>"
                }), new WidgetContainer({
                    name: "topWidgets",
                    classes: "topRecoverySection",
                    widgets: [new TextWidget({
                        name: "stepNumText",
                        classes: "stepNumText",
                        leftMargin: true,
                        topMargin: true
                    }), new WidgetContainer({
                        name: "legend",
                        htmlText: '<div style="float: right;"><div class="recoveryLegend"></div><div style="margin-top: -4px;">' + strings.recoveryManager.legend + "</div></div>",
                        tip: F,
                        noTipIcon: true
                    })]
                }), new WidgetContainer({
                    name: "failoverIntro",
                    widgets: [new TextWidget({
                        width: 400,
                        topMargin: true,
                        text: strings.recoveryManager.failoverIntroTxt
                    }), this.peerStatusWidget = new PeerStatusWidget({
                        includeImage: true
                    }), new TextWidget({
                        width: 400,
                        name: "peerStatusText"
                    }), new TextWidget({
                        width: 400,
                        name: "recoveryInfoTip",
                        text: strings.recoveryManager.whatIs,
                        topMargin: true,
                        tip: strings.recoveryManager.whatIsTip
                    }), new CheckboxInputWidget({
                        name: "testRun",
                        label: strings.recoveryManager.testRun,
                        topMargin: true,
                        changeCallback: createObjectCallback(this, function(G, H) {
                            if (G[H.name].value) {
                                this.okEnabled(true)
                            } else {
                                this.okEnabled(false)
                            }
                        }),
                        tip: strings.recoveryManager.testRunTip
                    })]
                }), new WidgetContainer({
                    name: "failoverSnap",
                    widgets: [new TextWidget({
                        name: "failoverSnapTxt",
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.failoverSnapTxt,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/secondaryVol.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        name: "repSetName",
                        label: strings.recoveryManager.repSetName,
                        topMargin: true
                    }), new TextWidget({
                        name: "secondaryVolName",
                        label: strings.recoveryManager.secondaryVolName,
                        bottomMargin: true
                    }), new TextInputWidget({
                        name: "snapshotName",
                        label: strings.recoveryManager.snapName,
                        rules: {
                            dhName: true,
                            utf8length: 32,
                            volumeExists: true
                        },
                        changeCallback: createObjectCallback(this, this.snapNameChanged),
                        topMargin: true,
                        bottomMargin: true
                    }), new TextWidget({
                        width: 400,
                        name: "snapGroup",
                        text: strings.recoveryManager.snapGroup,
                        topMargin: true
                    })]
                }), new WidgetContainer({
                    name: "failoverAction",
                    widgets: [new TextWidget({
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.failoverStepTxt,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/userAccessSecondary.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        width: 400,
                        text: strings.recoveryManager.failoverStepTxt2,
                        topMargin: true
                    }), new CheckboxInputWidget({
                        name: "failoverEnable",
                        width: 400,
                        topMargin: true,
                        changeCallback: createObjectCallback(this, function(G, H) {
                            if (G[H.name].value) {
                                this.okEnabled(true)
                            } else {
                                this.okEnabled(false)
                            }
                        }),
                        label: strings.recoveryManager.failoverStepTxt3
                    })]
                }), new WidgetContainer({
                    name: "map",
                    bottomMargin: true,
                    widgets: [new TextWidget({
                        name: "failoverMapInfo",
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.failoverMapTxt,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/secondaryVol.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        name: "restoreMapInfo",
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.recoveryMapTxt,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/primaryVol.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        name: "mapVolName",
                        label: strings.recoveryManager.secondaryVolName,
                        topMargin: true,
                        bottomMargin: true
                    }), new TextWidget({
                        text: strings.mapAction.hostsTopTitle,
                        classes: "actionSubtitle"
                    }), new TableInator({
                        name: "aMapHosts",
                        width: 490,
                        cellClasses: "verticalTop",
                        selectable: "multiple",
                        selectCallback: createObjectCallback(this, this._initSelected),
                        bottomMargin: true,
                        type: "rawData",
                        metadata: [{
                            sTitle: "basetype",
                            bVisible: false,
                            bIsBasetype: true
                        }, {
                            sTitle: "key",
                            bVisible: false,
                            bIsKey: true
                        }, {
                            sTitle: strings.mapAction.hostGroupCol,
                            bFilterMenu: true
                        }, {
                            sTitle: strings.mapAction.hostHostCol,
                            bFilterMenu: true
                        }, {
                            sTitle: strings.mapAction.hostNickCol,
                            bFilterMenu: true
                        }, {
                            sTitle: strings.mapAction.hostIdCol,
                            bFilterMenu: true
                        }],
                        dtOptions: {
                            bFilter: "noInput",
                            iDisplayLength: 8,
                            bLengthChange: false,
                            aaSorting: [
                                [2, "asc"],
                                [3, "asc"],
                                [4, "asc"]
                            ]
                        }
                    }), new ButtonWidget({
                        name: "mapButton",
                        classes: "aMapButton",
                        text: strings.mapAction.mapButtonLabel,
                        callback: createObjectCallback(this, this._map)
                    }), this.mapsTable = new TableInator({
                        name: "aMapMaps",
                        cellClasses: "verticalTop",
                        type: "rawData",
                        editCallback: createObjectCallback(this, this._mapEdited),
                        metadata: [{
                            sTitle: "id",
                            bVisible: false,
                            bIsKey: true
                        }, {
                            sTitle: "addID",
                            bVisible: false
                        }, {
                            sTitle: "mapID",
                            bVisible: false
                        }, {
                            sTitle: "state",
                            bVisible: false
                        }, {
                            sTitle: strings.mapAction.mapActionCol,
                            bVisible: false,
                            editable: createObjectCallback(this, this._actionOptions)
                        }, {
                            sTitle: strings.mapAction.mapHostCol
                        }, {
                            sTitle: strings.mapAction.mapVolCol,
                            bVisible: false
                        }, {
                            sTitle: strings.mapAction.mapModeCol,
                            editable: {},
                            bUseRendered: false,
                            fnRender: createObjectCallback(this, this._accessOptions)
                        }, {
                            sTitle: strings.mapAction.mapLunCol,
                            editable: {
                                rules: {
                                    required: true,
                                    range: [this.baseLun, system.maxLuns - 1]
                                }
                            }
                        }, {
                            sTitle: strings.mapAction.mapPortsCol,
                            bUseRendered: false,
                            fnRender: createObjectCallback(this, this._portRenderer)
                        }, {
                            sTitle: "mappedId",
                            bVisible: false
                        }, {
                            sTitle: "volCount",
                            bVisible: false
                        }],
                        dtOptions: {
                            bFilter: false,
                            iDisplayLength: 10,
                            bLengthChange: true,
                            fnRowCallback: createObjectCallback(this, this._rowDrawCallback),
                            aaSorting: []
                        }
                    })]
                }), new WidgetContainer({
                    name: "failoverSummary",
                    widgets: [new TextWidget({
                        text: '<span style="text-decoration: underline"><b>' + strings.recoveryManager.secondaryVolInfo + "</b></span>"
                    }), new TableWidget({
                        widgets: [new TextWidget({
                            name: "secVolName",
                            label: "<b>" + strings.recoveryManager.secondaryVolName + "</b>",
                            leftMargin: true,
                            topMargin: true,
                            row: 0,
                            col: 1
                        }), new TextWidget({
                            name: "snapsTaken",
                            label: "<b>" + strings.recoveryManager.snapTaken + "</b>",
                            leftMargin: true,
                            row: 1,
                            col: 1
                        }), new TextWidget({
                            name: "snapCreated",
                            label: "<b>" + strings.recoveryManager.snapCreated + "</b>",
                            leftMargin: true,
                            row: 2,
                            col: 1
                        }), new TextWidget({
                            name: "snapLocation",
                            label: "<b>" + strings.recoveryManager.snapLocation + "</b>",
                            leftMargin: true,
                            row: 3,
                            col: 1
                        }), new TextWidget({
                            name: "secVolMapped",
                            label: "<b>" + strings.recoveryManager.mapped + "</b>",
                            leftMargin: true,
                            row: 4,
                            col: 1
                        })]
                    }), new TextWidget({
                        text: strings.recoveryManager.failoverSummaryTxt2,
                        topMargin: true,
                        width: 300
                    }), new TextWidget({
                        text: strings.recoveryManager.failoverSummaryTxt,
                        topMargin: true,
                        width: 300
                    })]
                }), new WidgetContainer({
                    name: "recoveryIntro",
                    widgets: [new Widget({
                        htmlText: '<div style="background: transparent url(../images/replications/peerRepair.png) no-repeat; background-size: contain;margin: 0 auto; width: 200px; height: 130px;"></div>'
                    }), new TextWidget({
                        text: strings.recoveryManager.recoveryIntro,
                        width: 400,
                        topMargin: true
                    })]
                }), new WidgetContainer({
                    name: "recoverySnap",
                    widgets: [new TextWidget({
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.recoverySnapTxt,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/primaryVol.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        width: 350,
                        cssClass: "failoverSnap textWidget",
                        topMargin: true,
                        bottomMargin: true,
                        text: strings.recoveryManager.recoverySnapTxt2,
                        label: '<div style="display: inline-block; width: 60px; height: 67px; background: transparent url(../images/replications/secondaryVol.png) no-repeat; background-size: contain;"></div>',
                        noTerminator: true
                    }), new TextWidget({
                        name: "repSetName",
                        label: strings.recoveryManager.repSetName,
                        topMargin: true
                    }), new TextWidget({
                        name: "secondaryVolName",
                        label: strings.recoveryManager.secondaryVolName,
                        bottomMargin: true
                    }), new TextInputWidget({
                        name: "recoverySnapshotName",
                        label: strings.recoveryManager.snapName,
                        rules: {
                            dhName: true,
                            utf8length: 32,
                            volumeExists: true
                        },
                        changeCallback: createObjectCallback(this, this.snapNameChanged),
                        topMargin: true,
                        bottomMargin: true
                    }), new TextWidget({
                        width: 400,
                        name: "recoverySnapGroup",
                        text: strings.recoveryManager.snapGroup,
                        topMargin: true
                    })]
                }), this.recoveryOp = new WidgetContainer({
                    name: "recoveryOp"
                }), new WidgetContainer({
                    name: "recoveryConfirm",
                    widgets: [new Widget({
                        name: "reverseImage",
                        htmlText: '<div style="padding: 10px"><div style="display: inline-block; width: 200px; height: 100px; background: transparent url(../images/replications/reverse.png) no-repeat; background-size: contain;"></div><div class="textWidget" style="display: inline-block; padding-left: 10px; padding-top: 40px; vertical-align: top;font-weight: bold;">' + strings.recoveryManager.failbackRestore + "</div></div>"
                    }), new Widget({
                        name: "restoreImage",
                        htmlText: '<div style="padding: 10px"><div style="display: inline-block; width: 200px; height: 100px; background: transparent url(../images/replications/restore.png) no-repeat; background-size: contain;"></div><div class="textWidget" style="display: inline-block; padding-left: 10px; padding-top: 40px; vertical-align: top;font-weight: bold;">' + strings.recoveryManager.failbackNoRestore + "</div></div>"
                    }), new TextWidget({
                        name: "confirmInfo",
                        topMargin: true,
                        width: 400
                    }), this.recoveryConfirmTable = new TableWidget({
                        name: "recoveryConfirmTable",
                        topMargin: true,
                        width: 430
                    })]
                }), new WidgetContainer({
                    name: "recoverySummary",
                    widgets: [new Widget({
                        name: "reverseImage",
                        htmlText: '<div style="padding: 10px"><div style="display: inline-block; width: 200px; height: 100px; background: transparent url(../images/replications/reverse.png) no-repeat; background-size: contain;"></div><div class="textWidget" style="display: inline-block; padding-left: 10px; padding-top: 40px; vertical-align: top;font-weight: bold;">' + strings.recoveryManager.failbackRestore + "</div></div>"
                    }), new Widget({
                        name: "restoreImage",
                        htmlText: '<div style="padding: 10px"><div style="display: inline-block; width: 200px; height: 100px; background: transparent url(../images/replications/restore.png) no-repeat; background-size: contain;"></div><div class="textWidget" style="display: inline-block; padding-left: 10px; padding-top: 40px; vertical-align: top;font-weight: bold;">' + strings.recoveryManager.failbackNoRestore + "</div></div>"
                    }), new TextWidget({
                        text: '<span style="text-decoration: underline"><b>' + strings.recoveryManager.secondaryVolInfo + "</b></span>"
                    }), new TableWidget({
                        widgets: [new TextWidget({
                            name: "secVolName",
                            label: "<b>" + strings.recoveryManager.secondaryVolName + "</b>",
                            leftMargin: true,
                            topMargin: true,
                            row: 0,
                            col: 1
                        }), new TextWidget({
                            name: "snapsTaken",
                            label: "<b>" + strings.recoveryManager.snapTaken + "</b>",
                            leftMargin: true,
                            row: 1,
                            col: 1
                        }), new TextWidget({
                            name: "snapCreated",
                            label: "<b>" + strings.recoveryManager.snapCreated + "</b>",
                            leftMargin: true,
                            row: 2,
                            col: 1
                        }), new TextWidget({
                            name: "snapLocation",
                            label: "<b>" + strings.recoveryManager.snapLocation + "</b>",
                            leftMargin: true,
                            row: 3,
                            col: 1
                        })]
                    }), new TextWidget({
                        name: "recoverySummaryInfo",
                        topMargin: true,
                        width: 400
                    })]
                }), new WidgetContainer({
                    name: "restoreDirection",
                    widgets: [new TextWidget({
                        text: strings.recoveryManager.restoreTxt,
                        width: 400
                    })]
                }), new WidgetContainer({
                    name: "restoreSummary",
                    widgets: [new TextWidget({
                        text: strings.recoveryManager.restoreSummary,
                        width: 400
                    })]
                })]
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "RecoveryManager";
    this.snapCreated = false;
    this.backButton = false;
    this.added = [];
    this.rowID = 1;
    this.idCol = 0;
    this.addIdCol = 1;
    this.mapIdCol = 2;
    this.stateCol = 3;
    this.actionCol = 4;
    this.hostCol = 5;
    this.volCol = 6;
    this.modeCol = 7;
    this.lunCol = 8;
    this.portsCol = 9;
    this.mappedIdCol = 10;
    this.volCountCol = 11;
    this.states = {
        incomplete: "incomplete",
        unchanged: "unchanged",
        newMap: "newMap",
        modified: "modified",
        deleted: "deleted"
    };
    if (DC.controllers.A) {
        this.portsPerController = APIPort.getPortCount("A")
    } else {
        if (DC.controllers.B) {
            this.portsPerController = APIPort.getPortCount("B")
        } else {
            this.portsPerController = 4
        }
    }
    this.DEFAULTMODE = PORT_ACCESS.READ_WRITE;
    this.hybrid = false;
    var C = 0;
    for (var D in DC.ports) {
        if (C == 0) {
            C = DC.ports[D].get("port_type_numeric")
        } else {
            if (DC.ports[D].get("port_type_numeric") != C) {
                this.hybrid = true
            }
        }
    }
    $("tbody", this.mapsTable.elements).on("click", "input.mapPortInput", createObjectCallback(this, this._portChanged));
    $("tbody", this.mapsTable.elements).on("change", "select.selectable", createObjectCallback(this, this._accessChanged))
}
RecoveryManager.prototype = new ActionPanel();
RecoveryManager.prototype.constructor = RecoveryManager;
RecoveryManager.waitingForFailover = false;
RecoveryManager.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.hasFeature("recoveryManager")) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (RecoveryManager.waitingForFailover) {
        return strings.recoveryManager.waitForFailover
    }
    if (D) {
        var F = DC.virtualReplicationSetsSerial[D[0].key];
        if (F.getInt("primary_location_numeric") == REPSET_DIRECTION.OUTBOUND) {
            if (F.getInt("failback_in_progress_numeric") == 1) {
                return D
            } else {
                return strings.recoveryManager.mustSelectFromSecondary
            }
        } else {
            var C = this.peerName = F.get("peer_connection_name");
            var E = DC.peerConnections[C];
            if (F.get("status_numeric") == REP_STATUS.FAILEDOVER && E.getInt("connection_status_numeric") != PEERSTATUS.ONLINE) {
                return strings.recoveryManager.failoverSummaryTxt2
            } else {
                return D
            }
        }
    } else {
        return strings.recoveryManager.selectRepSet
    }
};
RecoveryManager.prototype.showing = function() {
    var W = this.previousSelection[0].getObject();
    var N = this.repSetName = W.get("name");
    var U = this.peerName = W.get("peer_connection_name");
    var O = DC.peerConnections[U];
    var M = O.get("connection_status_numeric");
    var F = O.get("connection_status");
    var R = W.get("status_numeric");
    var D = W.get("status");
    var C = W.get("secondary_volume_name");
    var T = W.get("primary_volume_name");
    var I = [{
        name: "recoveryIntro",
        label: strings.recoveryManager.introLabel
    }, {
        name: "recoverySnap",
        label: strings.recoveryManager.takeSnapLabel
    }, {
        name: "recoveryOp",
        label: strings.recoveryManager.recoveryOpLabel
    }, {
        name: "restoreDirection",
        label: strings.recoveryManager.completeFailback
    }, {
        name: "restoreMap",
        label: strings.recoveryManager.mapVolLabel
    }, {
        name: "restoreSummary",
        label: strings.recoveryManager.summaryLabel
    }];
    var L = [{
        name: "recoveryIntro",
        label: strings.recoveryManager.introLabel
    }, {
        name: "recoverySnap",
        label: strings.recoveryManager.takeSnapLabel
    }, {
        name: "recoveryOp",
        label: strings.recoveryManager.recoveryOpLabel
    }, {
        name: "recoverySummary",
        label: strings.recoveryManager.summaryLabel
    }];
    this.peerSubscription = MC.peerConnectionsSet.requestData({
        update: false,
        durable: true,
        requester: this.class_name,
        handler: createObjectCallback(this, this.updatePeerRepSetStatus)
    });
    this.repSetSubscription = MC.virtualReplicationSets.requestData({
        update: false,
        durable: true,
        requester: this.class_name,
        handler: createObjectCallback(this, this.updatePeerRepSetStatus)
    });
    if (W.getInt("primary_location_numeric") == REPSET_DIRECTION.OUTBOUND && W.getInt("failback_in_progress_numeric") == 1) {
        this.volumeName = T;
        this.navWidget.setSubSteps("recovery", I);
        this.setRestoreDirectionState()
    } else {
        if (M == PEERSTATUS.ONLINE && R == REP_STATUS.FAILEDOVER) {
            this.volumeName = C;
            var J = DC.volumes[this.volumeName];
            if (!J) {
                var H = this.volumeName.slice(0, -2);
                var G = DC.volumeGroups[H];
                var K = G.get("serial_number");
                var P = [];
                if (K && K != "UNGROUPEDVOLUMES") {
                    var V = DC.volGroupViewsSerial[K];
                    if (V) {
                        for (var S = 0; S < V.objects.length; S++) {
                            if (V.objects[S] instanceof APIVolumeGroupViewMappings) {
                                var Q = V.objects[S];
                                if (Q.get("mapped_id") != "AOI" || Q.getInt("access_numeric") != 0) {
                                    P.push(V.objects[S])
                                }
                            }
                        }
                    }
                }
            } else {
                var P = J.getMaps()
            }
            this.hasWriteAccess = false;
            if (P.length) {
                for (var S = 0; S < P.length; S++) {
                    var E = P[S].get("access_numeric");
                    if (E == PORT_ACCESS.READ_WRITE) {
                        this.hasWriteAccess = true;
                        break
                    }
                }
            }
            if (this.hasWriteAccess) {
                this.navWidget.setSubSteps("recovery", I)
            } else {
                this.navWidget.setSubSteps("recovery", L)
            }
            this.setRecoveryIntroState()
        } else {
            this.volumeName = C;
            this.navWidget.setSubSteps("recovery", L);
            this.setFailoverIntroState()
        }
    }
    this.update({
        peerName: {
            text: U
        },
        repSetName: {
            text: N
        },
        secondaryVolName: {
            text: C
        },
        restoreAlert: {
            visibility: "collapse"
        },
        noRestoreAlert: {
            visibility: "collapse"
        }
    });
    this.setBorder()
};
RecoveryManager.prototype.updatePeerRepSetStatus = function() {
    var D = DC.peerConnections[this.peerName];
    var F = DC.virtualReplicationSets[this.repSetName];
    if (D.get("connection_status_numeric") == PEERSTATUS.ONLINE) {
        var C = '<span style="color: green;">' + D.get("connection_status") + "</span>"
    } else {
        var C = '<span style="color: red;">' + D.get("connection_status") + "</span>"
    }
    var E = F.get("status");
    if (F.get("status_numeric") == REP_STATUS.FAILEDOVER) {
        E = '<span style="color: red;">' + E + "</span>"
    }
    this.update({
        peerConnStatus: {
            text: C
        },
        repSetStatus: {
            text: E
        }
    })
};
RecoveryManager.prototype.removeBackButton = function() {
    this.buttonContainer.remove(this.backButton);
    this.backButton = false
};
RecoveryManager.prototype.addBackButton = function() {
    this.buttonContainer.prepend(this.backButton = new ButtonWidget({
        name: "backButton",
        emphasized: false,
        text: strings.Back,
        callback: createObjectCallback(this, this.goBack)
    }))
};
RecoveryManager.prototype.goBack = function() {
    this.navigateBack = true;
    switch (this.currentState) {
        case "failoverSnap":
            this.setFailoverIntroState();
            break;
        case "failoverAction":
            this.setFailoverSnapState();
            break;
        case "recoverySnap":
            this.setRecoveryIntroState();
            break;
        case "recoveryOp":
            this.setRecoverySnapState();
            break;
        case "recoveryConfirm":
            this.setRecoveryOperationState();
            break;
        case "restoreSummary":
            this.setRestoreMapState();
            break;
        default:
            break
    }
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};
RecoveryManager.prototype.setFailoverIntroState = function() {
    var D = DC.peerConnections[this.peerName];
    this.peerStatusWidget.handleUpdate(D);
    this.navWidget.setPrimaryStepActive("failover");
    this.navWidget.setSubStepActive("failoverIntro");
    this.currentState = "failoverIntro";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    }
    var E = (D.get("connection_status_numeric") == PEERSTATUS.ONLINE);
    if (E) {
        this.okEnabled(false);
        var C = strings.recoveryManager.peerOnlineText
    } else {
        this.okEnabled(true);
        var C = strings.recoveryManager.peerOfflineText
    }
    if (this.backButton) {
        this.removeBackButton()
    }
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.continueLabel
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        testRun: {
            value: false,
            visibility: (E ? "visible" : "collapse")
        },
        peerStatusText: {
            text: C
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(1, 5) + "</span>" + strings.recoveryManager.introLabel
        },
        peerStatus: {
            visibility: "collapse"
        },
        failoverIntro: {
            visibility: "visible"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    })
};
RecoveryManager.prototype.setFailoverSnapState = function() {
    this.navWidget.setSubStepActive("failoverSnap");
    this.previousState = this.currentState;
    this.currentState = "failoverSnap";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    if (!this.backButton) {
        this.addBackButton()
    }
    var C = DC.volumes[this.volumeName];
    var D = false;
    if (!C) {
        D = true
    }
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.takeSnapButton
        },
        RecoveryManager_apply: {
            visibility: "visible",
            text: strings.recoveryManager.skip
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(2, 5) + "</span>" + strings.recoveryManager.takeSnapLabel
        },
        snapshotName: {
            disable: D
        },
        snapGroup: {
            visibility: D ? "visible" : "collapse"
        },
        peerStatus: {
            visibility: "visible"
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "visible"
        },
        failoverSnapTxt: {
            text: strings.recoveryManager.failoverSnapTxt(this.repSetName)
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.applyEnabled(true);
    this.okEnabled(false)
};
RecoveryManager.prototype.setfailoverActionState = function() {
    this.navWidget.setSubStepActive("failoverAction");
    this.previousState = this.currentState;
    this.currentState = "failoverAction";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    this.update({
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        RecoveryManager_ok: {
            text: strings.recoveryManager.failoverLabel
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(3, 5) + "</span>" + strings.recoveryManager.failoverLabel
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "visible"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        },
        failoverEnable: {
            value: false
        },
        snapshotName: {
            value: ""
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.setFailoverMapState = function() {
    this.navWidget.setSubStepActive("failoverMap");
    this.previousState = this.currentState;
    this.currentState = "failoverMap";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    var D = DC.volumes[this.volumeName];
    if (D) {
        var F = new DCRef("volumes", D.getKeyValue())
    } else {
        var E = this.volumeName.slice(0, -2);
        var C = DC.volumeGroups[E];
        var F = new DCRef("volume-groups", C.getKeyValue())
    }
    this.selectedVolumes = new Array(F);
    if (this.backButton) {
        this.removeBackButton()
    }
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.mapVolLabel
        },
        RecoveryManager_apply: {
            visibility: "visible",
            text: strings.recoveryManager.skip
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(4, 5) + "</span>" + strings.recoveryManager.mapVolLabel
        },
        aMapHosts: {
            data: this._getInitData()
        },
        aMapMaps: {
            data: []
        },
        mapButton: {
            disable: true
        },
        mapVolName: {
            text: this.volumeName
        },
        failoverMapInfo: {
            visibility: "visible"
        },
        restoreMapInfo: {
            visibility: "collapse"
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "visible"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.setFailoverSummaryState = function() {
    this.navWidget.setSubStepActive("failoverSummary");
    this.navWidget.markStepComplete(this.currentState);
    this.currentState = "failoverSummary";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    }
    var E = (this.snapshotName ? this.snapshotName : strings.na);
    var D = (this.snapshotName ? DC.snapshots[this.snapshotName].get("creation_date_time") : strings.na);
    var C = (this.snapshotName ? strings.recoveryManager.volTopic : strings.na);
    this.update({
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        RecoveryManager_ok: {
            visibility: "collapse"
        },
        failoverSumMap: {
            visibility: (this.didMap ? "visible" : "collapse")
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(5, 5) + "</span>" + strings.recoveryManager.summaryLabel
        },
        secVolName: {
            text: this.volumeName
        },
        snapsTaken: {
            text: E
        },
        snapCreated: {
            text: D
        },
        snapLocation: {
            text: C
        },
        secVolMapped: {
            text: (this.didMap ? strings.Yes : strings.No)
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "visible"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false);
    this.applyEnabled(false)
};
RecoveryManager.prototype.setRecoveryIntroState = function() {
    this.navWidget.setPrimaryStepActive("recovery");
    this.navWidget.setSubStepActive("recoveryIntro");
    this.currentState = "recoveryIntro";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    }
    if (this.backButton) {
        this.removeBackButton()
    }
    if (this.hasWriteAccess) {
        var C = strings.recoveryManager.stepLabel(1, 6)
    } else {
        var C = strings.recoveryManager.stepLabel(1, 4)
    }
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.continueLabel
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        stepNumText: {
            text: '<span class="activeText">' + C + "</span>" + strings.recoveryManager.introLabel
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "visible"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(true)
};
RecoveryManager.prototype.setRecoverySnapState = function() {
    this.navWidget.setSubStepActive("recoverySnap");
    this.previousState = this.currentState;
    this.currentState = "recoverySnap";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    if (!this.backButton) {
        this.addBackButton()
    }
    if (this.hasWriteAccess) {
        var D = strings.recoveryManager.stepLabel(2, 6)
    } else {
        var D = strings.recoveryManager.stepLabel(2, 4)
    }
    var C = DC.volumes[this.volumeName];
    var E = false;
    if (!C) {
        E = true
    }
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.takeSnapButton
        },
        RecoveryManager_apply: {
            text: strings.recoveryManager.skip,
            visibility: "visible"
        },
        stepNumText: {
            text: '<span class="activeText">' + D + "</span>" + strings.recoveryManager.takeSnapLabel
        },
        recoverySnapshotName: {
            disable: E
        },
        reocverySnapGroup: {
            visible: E ? "visible" : "collapse"
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "visible"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false);
    this.applyEnabled(true)
};
RecoveryManager.prototype.setRecoveryOperationState = function() {
    this.navWidget.setSubStepActive("recoveryOp");
    this.previousState = this.currentState;
    this.currentState = "recoveryOp";
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    var F = jQuery.format("<b>" + strings.recoveryManager.failbackRestore + " {0}</b>");
    var I = jQuery.format("<b>" + strings.recoveryManager.failbackNoRestore + " {0}</b>");
    var C = [];
    if (this.hasWriteAccess) {
        var H = strings.recoveryManager.isMapped;
        var F = F(strings.recoveryManager.recommended);
        var I = I("");
        var E = strings.recoveryManager.stepLabel(3, 6)
    } else {
        var H = strings.recoveryManager.isNotMapped;
        var F = F("");
        var I = I(strings.recoveryManager.recommended);
        var E = strings.recoveryManager.stepLabel(3, 4)
    }
    var G = new WidgetContainer({
        name: "restoreWidget",
        htmlText: '<div style="display: inline-block"></div>',
        widgets: [new WidgetContainer({
            htmlText: '<div style="padding: 0px 10px;display: inline-block;vertical-align: middle;"></div>',
            widgets: [new TextWidget({
                text: F,
                tip: strings.recoveryManager.recoveryTip
            }), new TextWidget({
                text: strings.recoveryManager.failbackRestoreTxt,
                width: 200
            })]
        }), new WidgetContainer({
            htmlText: '<div style="vertical-align: middle;display: inline-block;width: 200px; height: 100px;background: transparent url(../images/replications/reverse.png) no-repeat; background-size: contain;"></div>'
        })]
    });
    var D = new WidgetContainer({
        name: "noRestoreWidget",
        htmlText: '<div style="display: inline-block"></div>',
        widgets: [new WidgetContainer({
            htmlText: '<div style="padding: 0px 10px;display: inline-block;vertical-align: middle;"></div>',
            widgets: [new TextWidget({
                text: I
            }), new TextWidget({
                text: strings.recoveryManager.failbackNoRestoreTxt,
                width: 200
            })]
        }), new WidgetContainer({
            htmlText: '<div style="vertical-align: middle;display: inline-block;width: 200px; height: 100px;background: transparent url(../images/replications/restore.png) no-repeat; background-size: contain;"></div>'
        })]
    });
    if (this.hasWriteAccess) {
        C = [{
            value: "reverse",
            widget: G
        }, {
            value: "restore",
            widget: D
        }]
    } else {
        C = [{
            value: "restore",
            widget: D
        }, {
            value: "reverse",
            widget: G
        }]
    }
    this.recoveryOp._empty();
    this.recoveryOp.add(new TextWidget({
        name: "recoveryOpInfo",
        bottomMargin: true,
        width: 450
    }));
    this.recoveryOp.add(new RadioButtonsInputWidget({
        name: "recoveryOpType",
        orientation: "vertical",
        topMargin: true,
        bottomMargin: true,
        singleCell: true,
        value: "noValue",
        values: C,
        changeCallback: createObjectCallback(this, this.recoveryOpChanged)
    }));
    this.form.processWidgets();
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.continueLabel
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        restoreAlert: {
            visibility: "collapse"
        },
        noRestoreAlert: {
            visibility: "collapse"
        },
        stepNumText: {
            text: '<span class="activeText">' + E + "</span>" + strings.recoveryManager.recoveryOpLabel
        },
        recoveryOpInfo: {
            text: H
        },
        recoveryOpType: {
            values: C
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "visible"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        },
        recoveryOpType: {
            value: (this.hasWriteAccess ? "reverse" : "restore")
        },
        recoverySnapshotName: {
            value: ""
        }
    });
    this.okEnabled(true)
};
RecoveryManager.prototype.setRecoveryConfirmState = function() {
    this.previousState = this.currentState;
    this.currentState = "recoveryConfirm";
    var H = {};
    this.recoveryOp.retrieve(H);
    var E = (H.recoveryOpType.value == "reverse");
    if (E) {
        var G = strings.recoveryManager.restoreConfirm;
        var D = strings.recoveryManager.stepLabel(3, 6);
        var F = [{
            name: "c1",
            label: strings.recoveryManager.restoreConfirm1
        }, {
            name: "c2",
            label: strings.recoveryManager.restoreConfirm2
        }, {
            name: "c3",
            label: strings.recoveryManager.restoreConfirm3
        }, {
            name: "c4",
            label: strings.recoveryManager.restoreConfirm4
        }]
    } else {
        var G = strings.recoveryManager.noRestoreConfirm;
        var D = strings.recoveryManager.stepLabel(3, 4);
        var F = [{
            name: "c1",
            label: strings.recoveryManager.noRestoreConfirm1
        }, {
            name: "c2",
            label: strings.recoveryManager.noRestoreConfirm2
        }, {
            name: "c3",
            label: strings.recoveryManager.noRestoreConfirm3
        }]
    }
    this.recoveryConfirmTable._empty();
    for (var C = 0; C < F.length; C++) {
        this.recoveryConfirmTable.add(new CheckboxInputWidget({
            name: F[C].name,
            row: C,
            col: 0,
            label: F[C].label,
            leftMargin: true,
            bottomMediumMargin: true,
            singleCell: true,
            changeCallback: createObjectCallback(this, function() {
                var K = {};
                var J = {};
                this.recoveryOp.retrieve(K);
                this.retrieve(J);
                var I = (K.recoveryOpType.value == "reverse");
                if (I) {
                    if (J.c1.value && J.c2.value && J.c3.value && J.c4.value) {
                        this.okEnabled(true)
                    } else {
                        this.okEnabled(false)
                    }
                } else {
                    if (J.c1.value && J.c2.value && J.c3.value) {
                        this.okEnabled(true)
                    } else {
                        this.okEnabled(false)
                    }
                }
            })
        }))
    }
    this.form.processWidgets();
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.recoverLabel
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        restoreAlert: {
            visibility: (E ? "visible" : "collapse")
        },
        noRestoreAlert: {
            visibility: (E ? "collapse" : "visible")
        },
        confirmInfo: {
            text: G
        },
        reverseImage: {
            visibility: (E ? "visible" : "collapse")
        },
        restoreImage: {
            visibility: (E ? "collapse" : "visible")
        },
        stepNumText: {
            text: '<span class="activeText">' + D + "</span>" + strings.recoveryManager.recoveryOpLabel
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "visible"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.setRecoverySummaryState = function() {
    this.previousState = this.currentState;
    this.currentState = "recoverySummary";
    var G = {};
    this.retrieve(G);
    var J = (this.snapshotName ? this.snapshotName : strings.na);
    var I = (this.snapshotName ? DC.snapshots[this.snapshotName].get("creation_date_time") : strings.na);
    var H = (this.snapshotName ? strings.recoveryManager.volTopic : strings.na);
    var E = (G.recoveryOpType.value == "reverse");
    this.navWidget.markStepComplete("recoveryOp");
    if (E) {
        var F = strings.recoveryManager.recoverRestoreSummary;
        var D = strings.recoveryManager.stepLabel(4, 6);
        var C = strings.recoveryManager.completeFailback;
        this.navWidget.setSubStepActive("restoreDirection")
    } else {
        var F = strings.recoveryManager.recoverNoRestoreSummary;
        var D = strings.recoveryManager.stepLabel(4, 4);
        var C = strings.recoveryManager.summaryLabel;
        this.navWidget.setSubStepActive("recoverySummary")
    }
    if (this.backButton) {
        this.removeBackButton()
    }
    this.update({
        RecoveryManager_ok: {
            visibility: "collapse"
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        recoverySummaryInfo: {
            text: F
        },
        restoreAlert: {
            visibility: "collapse"
        },
        noRestoreAlert: {
            visibility: "collapse"
        },
        reverseImage: {
            visibility: (E ? "visible" : "collapse")
        },
        restoreImage: {
            visibility: (E ? "collapse" : "visible")
        },
        secVolName: {
            text: this.volumeName
        },
        snapsTaken: {
            text: J
        },
        snapCreated: {
            text: I
        },
        snapLocation: {
            text: H
        },
        stepNumText: {
            text: '<span class="activeText">' + D + "</span>" + C
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "visible"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false);
    this.applyEnabled(false)
};
RecoveryManager.prototype.setRestoreDirectionState = function() {
    this.navWidget.setPrimaryStepActive("recovery");
    this.navWidget.markStepComplete("recoveryIntro");
    this.navWidget.markStepComplete("recoverySnap");
    this.navWidget.markStepComplete("recoveryOp");
    this.navWidget.setSubStepActive("restoreDirection");
    this.currentState = "restoreDirection";
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.completeFailback
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(4, 6) + "</span>" + strings.recoveryManager.completeFailback
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "visible"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(true);
    this.applyEnabled(true)
};
RecoveryManager.prototype.setRestoreMapState = function() {
    this.previousState = this.currentState;
    this.currentState = "restoreMap";
    this.navWidget.setSubStepActive(this.currentState);
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    var D = DC.volumes[this.volumeName];
    if (D) {
        var F = new DCRef("volumes", D.getKeyValue())
    } else {
        var E = this.volumeName.slice(0, -2);
        var C = DC.volumeGroups[E];
        var F = new DCRef("volume-groups", C.getKeyValue())
    }
    this.selectedVolumes = new Array(F);
    this.update({
        RecoveryManager_ok: {
            text: strings.recoveryManager.mapVolLabel
        },
        RecoveryManager_apply: {
            text: strings.recoveryManager.skip,
            visibility: "visible"
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(5, 6) + "</span>" + strings.recoveryManager.mapVolLabel
        },
        aMapHosts: {
            data: this._getInitData()
        },
        aMapMaps: {
            data: []
        },
        mapButton: {
            disable: true
        },
        mapVolName: {
            label: strings.recoveryManager.primaryVolName,
            text: this.volumeName
        },
        failoverMapInfo: {
            visibility: "collapse"
        },
        restoreMapInfo: {
            visibility: "visible"
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "visible"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "collapse"
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.setRestoreSummaryState = function() {
    this.previousState = this.currentState;
    this.currentState = "restoreSummary";
    this.navWidget.setSubStepActive(this.currentState);
    if (this.navigateBack) {
        this.navWidget.removeStepComplete(this.currentState);
        this.navigateBack = false
    } else {
        this.navWidget.markStepComplete(this.previousState)
    }
    if (this.backButton) {
        this.removeBackButton()
    }
    this.update({
        RecoveryManager_ok: {
            visibility: "collapse"
        },
        RecoveryManager_apply: {
            visibility: "collapse"
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(6, 6) + "</span>" + strings.recoveryManager.summaryLabel
        },
        failoverIntro: {
            visibility: "collapse"
        },
        failoverSnap: {
            visibility: "collapse"
        },
        failoverAction: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        failoverSummary: {
            visibility: "collapse"
        },
        recoveryIntro: {
            visibility: "collapse"
        },
        recoverySnap: {
            visibility: "collapse"
        },
        recoveryOp: {
            visibility: "collapse"
        },
        recoveryConfirm: {
            visibility: "collapse"
        },
        recoverySummary: {
            visibility: "collapse"
        },
        restoreDirection: {
            visibility: "collapse"
        },
        restoreSummary: {
            visibility: "visible"
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.initiateFailover = function() {
    MC.recoverReplicationSet({
        repSet: this.repSetName,
        operation: "failover"
    }, {
        dialog: true,
        processingMsg: strings.recoveryManager.failoverProcessingMsg(this.repSetName),
        failureMsg: strings.recoveryManager.failoverFailureMsg(this.repSetName),
        successMsg: strings.recoveryManager.failoverSuccessMsg(this.repSetName),
        callback: createObjectCallback(this, function(C) {
            if (C.success) {
                RecoveryManager.waitingForFailover = this.repSetName;
                this.setFailoverMapState();
                this.resetSize({
                    shrink: true
                });
                this.setBorder()
            }
        })
    })
};
RecoveryManager.prototype.initiateRecovery = function() {
    var F = {};
    this.recoveryOp.retrieve(F);
    var E = F.recoveryOpType.value == "reverse";
    if (E) {
        var G = "failback-restore";
        var D = strings.recoveryManager.restoreConfirmMsg;
        if (isHPsystem()) {
            D += strings.recoveryManager.restoreConfirmAppr(strings.recoveryManager.accept) + '<br><br><input id="confirmRestoreText" type="text" tabindex="0" class="TextInputWidget">'
        } else {
            D += strings.recoveryManager.restoreConfirmCont
        }
    } else {
        var G = "failback-no-restore";
        var D = strings.recoveryManager.noRestoreConfirmMsg;
        if (isHPsystem()) {
            D += "<br><br>" + strings.recoveryManager.restoreConfirmAppr(strings.recoveryManager.accept) + '<br><br><input id="confirmRestoreText" type="text" tabindex="0" class="TextInputWidget">'
        }
    }
    MC.recoverReplicationSet({
        repSet: this.repSetName,
        operation: G
    }, {
        dialog: true,
        confirmMsg: D,
        processingMsg: strings.recoveryManager.recoverProcessingMsg(this.repSetName),
        failureMsg: strings.recoveryManager.recoverFailureMsg(this.repSetName),
        successMsg: strings.recoveryManager.recoverSuccessMsg(this.repSetName),
        callback: createObjectCallback(this, function(H) {
            if (H.success) {
                this.setRecoverySummaryState();
                this.resetSize({
                    shrink: true
                });
                this.setBorder()
            }
        })
    });
    if (isHPsystem()) {
        var C = (E ? strings.recoveryManager.beginFailbackRestore : strings.recoveryManager.beginFailbackNoRestore);
        ActiveDialogUpdate({
            okLabel: C,
            okState: "disabled",
            cancelLabel: strings.Cancel
        });
        $("#confirmRestoreText").keyup(function(J) {
            var H = $("#confirmRestoreText").val();
            var I = strings.recoveryManager.accept;
            if (H.toLowerCase() == I.toLowerCase()) {
                if (panels.activeDialogPanel.options.okState == "disabled") {
                    ActiveDialogUpdate({
                        okState: "enabled"
                    });
                    $("#confirmRestoreText").val(H);
                    $("#confirmRestoreText").keyup(arguments.callee)
                }
            } else {
                if (panels.activeDialogPanel.options.okState == "enabled") {
                    ActiveDialogUpdate({
                        okState: "disabled"
                    });
                    $("#confirmRestoreText").val(H);
                    $("#confirmRestoreText").keyup(arguments.callee)
                }
            }
        })
    }
};
RecoveryManager.prototype.initiateRestore = function() {
    MC.recoverReplicationSet({
        repSet: this.repSetName,
        operation: "failback-restore"
    }, {
        dialog: true,
        processingMsg: strings.recoveryManager.recoverProcessingMsg(this.repSetName),
        failureMsg: strings.recoveryManager.recoverFailureMsg(this.repSetName),
        successMsg: strings.recoveryManager.recoverSuccessMsg(this.repSetName),
        callback: createObjectCallback(this, function(C) {
            if (C.success) {
                this.setRestoreMapState();
                this.resetSize({
                    shrink: true
                });
                this.setBorder()
            }
        })
    })
};
RecoveryManager.prototype.createSnapshot = function() {
    var C = {};
    this.retrieve(C);
    if (this.currentState == "failoverSnap") {
        this.snapshotName = C.snapshotName.value;
        var F = createObjectCallback(this, this.failoverSnapCallback)
    } else {
        this.snapshotName = C.recoverySnapshotName.value;
        var F = createObjectCallback(this, this.recoverySnapCallback)
    }
    var E = {
        volumeNames: [this.volumeName],
        snapshotNames: [this.snapshotName]
    };
    var D = "<b>" + strings.createSnapshot.success("") + "</b><br><br>" + strings.recoveryManager.snapName + ": " + this.snapshotName;
    MC.createSnapshots(E, {
        dialog: true,
        processingMsg: strings.createSnapshot.processing(""),
        failureMsg: strings.createSnapshot.failure(""),
        successMsg: D,
        callback: F
    })
};
RecoveryManager.prototype.recoverySnapCallback = function(C) {
    if (C.success) {
        this.setRecoveryOperationState();
        this.resetSize({
            shrink: true
        });
        this.setBorder()
    }
};
RecoveryManager.prototype.failoverSnapCallback = function(C) {
    if (C.success) {
        this.setfailoverActionState();
        this.resetSize({
            shrink: true
        });
        this.setBorder()
    }
};
RecoveryManager.prototype._commandsComplete = function(D, C) {
    if (C.success) {
        this.didMap = true;
        if (this.currentState == "failoverMap") {
            this.setFailoverSummaryState()
        } else {
            this.setRestoreSummaryState()
        }
        this.resetSize({
            shrink: true
        });
        this.setBorder()
    }
};
RecoveryManager.prototype.resetAction = function() {
    this.rowID = 1;
    this.update({
        aMapHosts: {
            selectable: "multiple"
        },
        aMapMaps: {
            data: []
        },
        mapButton: {
            disable: true,
            text: strings.mapAction.mapButtonLabel,
            tooltip: strings.mapAction.mapButtonTip
        }
    });
    this.okEnabled(false)
};
RecoveryManager.prototype.okCallback = function() {
    switch (this.currentState) {
        case "failoverIntro":
            this.setFailoverSnapState();
            break;
        case "failoverSnap":
            this.createSnapshot();
            break;
        case "failoverAction":
            this.initiateFailover();
            break;
        case "failoverMap":
            this.mapVolume(false);
            break;
        case "recoveryIntro":
            this.setRecoverySnapState();
            break;
        case "recoverySnap":
            this.createSnapshot();
            break;
        case "recoveryOp":
            this.setRecoveryConfirmState();
            break;
        case "recoveryConfirm":
            this.initiateRecovery();
            break;
        case "restoreDirection":
            this.initiateRestore();
            break;
        case "restoreMap":
            this.mapVolume(false);
            break;
        default:
            break
    }
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};
RecoveryManager.prototype.applyCallback = function() {
    switch (this.currentState) {
        case "failoverSnap":
            this.setfailoverActionState();
            break;
        case "failoverMap":
            this.didMap = false;
            this.setFailoverSummaryState();
            break;
        case "failoverAction":
            this.setFailoverMapState();
            break;
        case "recoverySnap":
            this.setRecoveryOperationState();
            break;
        case "restoreMap":
            this.didMap = false;
            this.setRestoreSummaryState();
            break;
        default:
            break
    }
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};
RecoveryManager.prototype.setBorder = function() {
    var D = $(".recoveryManagerWidgetContainer");
    var C = $(".leftSection");
    if (C.height() > D.height()) {
        D.removeClass("recoveryBorderLeft");
        C.addClass("recoveryBorderRight")
    } else {
        D.addClass("recoveryBorderLeft");
        C.removeClass("recoveryBorderRight")
    }
};
RecoveryManager.prototype.snapNameChanged = function(C, E) {
    var D = C[E.name];
    if (this.currentState == "recoverySnap" || this.currentState == "failoverSnap") {
        if (D.invalid || D.value == "") {
            this.okEnabled(false)
        } else {
            this.okEnabled(true)
        }
    }
};
RecoveryManager.prototype.recoveryOpChanged = function(D, F) {
    var E = D[F.name];
    if (E.value == "reverse") {
        var C = strings.recoveryManager.stepLabel(3, 6);
        this.navWidget.setSubSteps("recovery", [{
            name: "recoveryIntro",
            label: strings.recoveryManager.introLabel
        }, {
            name: "recoverySnap",
            label: strings.recoveryManager.takeSnapLabel
        }, {
            name: "recoveryOp",
            label: strings.recoveryManager.recoveryOpLabel
        }, {
            name: "restoreDirection",
            label: strings.recoveryManager.completeFailback
        }, {
            name: "restoreMap",
            label: strings.recoveryManager.mapVolLabel
        }, {
            name: "restoreSummary",
            label: strings.recoveryManager.summaryLabel
        }])
    } else {
        var C = strings.recoveryManager.stepLabel(3, 4);
        this.navWidget.setSubSteps("recovery", [{
            name: "recoveryIntro",
            label: strings.recoveryManager.introLabel
        }, {
            name: "recoverySnap",
            label: strings.recoveryManager.takeSnapLabel
        }, {
            name: "recoveryOp",
            label: strings.recoveryManager.recoveryOpLabel
        }, {
            name: "recoverySummary",
            label: strings.recoveryManager.summaryLabel
        }])
    }
    this.navWidget.markStepComplete("recoveryIntro");
    this.navWidget.markStepComplete("recoverySnap");
    this.navWidget.setSubStepActive("recoveryOp");
    this.update({
        stepNumText: {
            text: '<span class="activeText">' + C + "</span>" + strings.recoveryManager.recoveryOpLabel
        }
    });
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};

function AddRemoteSystem(D) {
    if (arguments.length == 0) {
        return
    }
    if (!D.name) {
        D.name = "AddRemoteSystem"
    }
    var C = 0;
    D.okCallback = createObjectCallback(this, this.okCallback);
    D.widgets = [this.addRemoteSystemForm = new FormWidget({
        name: "addRemoteSystemForm",
        tableLayout: true,
        maxCols: 2,
        widgets: [new TextWidget({
            name: "destInfo1",
            row: C++,
            col: 0,
            colSpan: 2,
            bottomMargin: true,
            text: strings.addRemoteSystem.infoTxt
        }), new TextInputWidget({
            name: "ip",
            row: C++,
            col: 1,
            label: strings.addRemoteSystem.ipLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            rules: {
                required: true,
                ipv4Address: true,
                remoteSystemExists: true
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new TextInputWidget({
            name: "userName",
            row: C++,
            col: 1,
            label: strings.addRemoteSystem.usernameLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            rules: {
                required: true,
                dhName: true,
                utf8length: 19
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        }), new TextInputWidget({
            name: "password",
            row: C++,
            col: 1,
            label: strings.addRemoteSystem.passwordLabel,
            labelOptions: {
                rightMargin: true
            },
            size: 20,
            password: true,
            rules: {
                required: true,
                dhName: true,
                utf8length: 32
            },
            bottomMediumMargin: true,
            changeCallback: createObjectCallback(this, this.changeCallback)
        })]
    })];
    ActionPanel.call(this, D);
    this.class_name = "AddRemoteSystem"
}
AddRemoteSystem.prototype = new ActionPanel();
AddRemoteSystem.prototype.constructor = AddRemoteSystem;
AddRemoteSystem.getMenuState = function() {
    return []
};
AddRemoteSystem.prototype.changeCallback = function(F, H, G) {
    var E = {};
    this.retrieve(E, true);
    var C = {};
    var D = true;
    if (!F.userName && E.userName.value == "") {
        D = false;
        C.userName = {
            skipValidation: true
        }
    } else {
        C.userName = {
            skipValidation: false
        }
    }
    if (!F.password && E.password.value == "") {
        D = false;
        C.password = {
            skipValidation: true
        }
    } else {
        C.password = {
            skipValidation: false
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    this.okEnabled(this.addRemoteSystemForm.valid && D)
};
AddRemoteSystem.prototype.okCallback = function() {
    var D = {};
    this.retrieve(D);
    var C = {
        ip: D.ip.value,
        username: D.userName.value,
        password: D.password.value
    };
    MC.createRemoteSystem(C, {
        dialog: true,
        processingMsg: strings.addRemoteSystem.processing(D.ip.value),
        failureMsg: strings.addRemoteSystem.failure(D.ip.value),
        successMsg: strings.addRemoteSystem.success(D.ip.value),
        closeActionOn: "success"
    })
};

function DeleteRemoteSystem(C) {
    if (arguments.length == 0) {
        return
    }
    this.peerNames = [];
    this.multiple = null;
    this.selected = [];
    C.name = "DeleteRemoteSystem";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "deleteRemote",
        widgets: [new TextWidget({
            name: "remoteSystem",
            classes: "scrollText100",
            label: strings.deleteRemoteSystem.sysNameLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "warningText",
            topMargin: true,
            text: strings.deleteRemoteSystem.warningTxt
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteRemoteSystem"
}
DeleteRemoteSystem.prototype = new ActionPanel();
DeleteRemoteSystem.prototype.constructor = DeleteRemoteSystem;
DeleteRemoteSystem.getMenuState = function() {
    var C;
    var D;
    var F;
    var E = {};
    if (!session.hasConfigurationCapability()) {
        return false
    }
    C = TopicPanel.getSelected("remote-system", 1);
    if (C) {
        return C
    } else {
        return strings.menuTips.noRmtSysSelected
    }
};
DeleteRemoteSystem.prototype.showing = function() {
    var D = this.previousSelection[0].getObject();
    var C = D.get("system_name");
    this.update({
        remoteSystem: {
            text: C
        }
    });
    this.okEnabled(true)
};
DeleteRemoteSystem.prototype.okCallback = function() {
    var D = this.previousSelection[0].getObject();
    var E = D.get("system_name");
    var F = {
        systems: E
    };
    var C = {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        confirmMsg: strings.deleteRemoteSystem.confirmMsg(E),
        processingMsg: strings.deleteRemoteSystem.processingMsg(E),
        failureMsg: strings.deleteRemoteSystem.failureMsg(E),
        successMsg: strings.deleteRemoteSystem.successMsg(E)
    };
    MC.deleteRemoteSystem(F, C)
};

function CreateRsrReplicationSet(F) {
    if (arguments.length == 0) {
        return
    }
    F.name = "CreateRsrReplicationSet";
    F.width = 580;
    F.okCallback = createObjectCallback(this, this.okCallback);
    var G = createObjectCallback(this, this.destSystemSelected);
    var C = createObjectCallback(this, this.initCheckboxCallback);
    var D = [];
    for (var E = 3; E <= 32; E++) {
        D[D.length] = {
            value: "" + E,
            text: "" + E
        }
    }
    F.widgets = [new FormWidget({
        name: "form",
        data: {},
        widgets: [new TextWidget({
            name: "primaryVol",
            label: strings.setPrimaryVolume.primaryLabel,
            bottomMargin: true
        }), new TextWidget({
            name: "infoTxt",
            text: strings.createLinearRepSet.infoTxt
        }), new TableInator({
            name: "singleVolTable",
            cellClasses: "verticalTop",
            selectable: "single",
            selectCallback: createObjectCallback(this, this.volumeSelected),
            bottomMargin: true,
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "key",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.createReplicationSet.volNameCol,
                bFilterMenu: true
            }, {
                sTitle: strings.createReplicationSet.volSizeCol,
                bFilterMenu: true
            }, {
                sTitle: strings.createReplicationSet.volPoolCol,
                bFilterMenu: true
            }],
            dtOptions: {
                bFilter: "noInput",
                bFilter: "noControls",
                iDisplayLength: 8,
                bLengthChange: false,
                aaSorting: [
                    [2, "asc"],
                    [3, "asc"]
                ]
            }
        }), new TableWidget({
            widgets: [this.destSystem = new OptionInputWidget({
                name: "destSystem",
                classes: "inline ARLeftSmallMargin",
                label: strings.createLinearRepSet.secondarySystem,
                values: [],
                row: 0,
                col: 1,
                width: 200,
                leftSmallMargin: true,
                bottomMediumMargin: true,
                changeCallback: G
            }), this.destVolumeChoice = new RadioButtonsInputWidget({
                name: "destVolumeChoice",
                label: strings.createLinearRepSet.secondaryVolume,
                labelOptions: {
                    bottomMargin: true,
                    rightSmallMargin: true
                },
                changeCallback: createObjectCallback(this, this.somethingChanged),
                row: 1,
                col: 1,
                value: "create",
                values: [{
                    value: "create",
                    widget: new WidgetContainer({
                        name: "createGroup",
                        classes: "inline",
                        widgets: [new OptionInputWidget({
                            name: "destVdisk",
                            classes: "inline ARLeftSmallMargin",
                            label: strings.createLinearRepSet.createLabel,
                            values: [],
                            width: 200,
                            leftSmallMargin: true,
                            bottomMediumMargin: true
                        })]
                    })
                }, {
                    value: "existing",
                    widget: new WidgetContainer({
                        name: "existingGroup",
                        classes: "inline",
                        widgets: [new OptionInputWidget({
                            name: "destVolume",
                            classes: "inline ARLeftSmallMargin",
                            label: strings.createLinearRepSet.existingLabel,
                            values: [],
                            width: 200,
                            leftSmallMargin: true,
                            bottomMediumMargin: true
                        })]
                    })
                }]
            }), new OptionInputWidget({
                name: "linkType",
                row: 2,
                col: 1,
                topMargin: true,
                bottomMargin: true,
                label: strings.createLinearRepSet.linkType,
                labelOptions: {
                    topMargin: true,
                    bottomMargin: true
                },
                values: []
            }), this.initRep = new CheckboxContainer({
                name: "initReplication",
                row: 3,
                col: 0,
                colSpan: 2,
                label: strings.createLinearRepSet.schedLabel,
                value: false,
                widgets: [new TextWidget({
                    text: strings.createLinearRepSet.schedInfo
                })]
            })]
        })]
    })];
    ActionPanel.call(this, F);
    this.class_name = "CreateRsrReplicationSet"
}
CreateRsrReplicationSet.prototype = new ActionPanel();
CreateRsrReplicationSet.prototype.constructor = CreateRsrReplicationSet;
CreateRsrReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected("volumes", 1);
    if (D || currentTopic == "RsrTopic") {
        var E = function(H) {
            if (H.getInt("storage_type_numeric") == STORAGE_CLASS.LINEAR && !H.get("replication_set") && H.getInt("volume_type_numeric") != VOLUME_TYPES.BACKING_STORE && H.getInt("volume_type_numeric") != VOLUME_TYPES.SNAPSHOT) {
                return true
            } else {
                return false
            }
        };
        if (currentTopic == "RsrTopic") {
            for (var F in DC.volumes) {
                var C = DC.volumes[F];
                if (E(C)) {
                    return D
                }
            }
            return strings.menuTips.noVolumesAvailable
        } else {
            var G = D[0].getObject();
            if (E(G)) {
                return D
            }
        }
    }
    return strings.menuTips.selectSingle(strings.linearVolume)
};
CreateRsrReplicationSet.prototype.destSystemSelected = function(F, I) {
    this.selectedSystem = F.destSystem.value;
    var D = this;
    if (this.selectedSystem == "local") {
        this.local = true;
        this.populateSecondaryChoices(this.localVolumes, this.localVdisks);
        var C = getLinkTypes()
    } else {
        this.local = false;
        var H = "";
        if (this.systems) {
            for (var G = 0; G < this.systems.length; G++) {
                if (this.systems[G].value == this.selectedSystem) {
                    H = this.systems[G].text
                }
            }
        }
        this.volumeOptions = {
            processingMsg: strings.createLinearRepSet.volumesProcessing(H),
            failureMsg: strings.createLinearRepSet.volumesFailure(H),
            noSuccessDialog: true,
            dataType: "json"
        };
        this.vdiskOptions = {
            processingMsg: strings.createLinearRepSet.vdisksProcessing(H),
            failureMsg: strings.createLinearRepSet.vdisksFailure(H),
            noSuccessDialog: true,
            autoOK: true,
            dataType: "json"
        };
        var E = [{
            name: "volumes",
            command: MC.remote,
            data: {
                remoteSystem: this.selectedSystem,
                command: "show volumes"
            },
            options: this.volumeOptions
        }];
        E[E.length] = {
            name: "vdisks",
            command: MC.remote,
            data: {
                remoteSystem: this.selectedSystem,
                command: "show vdisks"
            },
            options: this.vdiskOptions
        };
        var C = getLinkTypes(H);
        MC.execCommandList(E, {
            callback: createObjectCallback(this, this.remoteDataComplete)
        })
    }
    var J = {
        linkType: {
            values: C.links
        }
    };
    D.update(J)
};
CreateRsrReplicationSet.prototype.remoteDataComplete = function(C) {
    this.remoteVolData = null;
    this.remoteVdiskData = null;
    if (C.success) {
        if (C.results.volumes.json) {
            this.remoteVolData = C.results.volumes.json.objects
        }
        if (C.results.vdisks.json) {
            this.remoteVdiskData = C.results.vdisks.json.objects
        }
    } else {
        MC.debugOutput("Error getting remote system volume/vdisk data: %s", C.message)
    }
    this.populateSecondaryChoices(this.remoteVolData, this.remoteVdiskData);
    this.somethingChanged()
};
CreateRsrReplicationSet.prototype.showing = function() {
    this.remoteSystemsSubscription = MC.remoteSystemsSet.requestData({
        update: false,
        durable: true,
        requester: this.class_name,
        handler: createObjectCallback(this, this.handleRemoteSystemsUpdate)
    });
    this.isRsrTopic = (currentTopic == "RsrTopic");
    this.local = true;
    var E = false;
    var C = false;
    var D = "";
    if (this.isRsrTopic) {
        E = true;
        C = true
    } else {
        D = this.previousSelection[0].getObject().get("volume_name")
    }
    var F = {
        infoTxt: {
            visibility: (E ? "visible" : "collapse")
        },
        primaryVol: {
            text: D,
            visibility: (E ? "collapse" : "visible")
        },
        singleVolTable: {
            data: this.getVolumeData(),
            visibility: (E ? "visible" : "collapse")
        },
        initiateContainer: {
            visibility: "collapse"
        },
        scheduledChoice: {
            visibility: "collapse"
        },
        destVolumeChoice: {
            disable: C
        },
        destSystem: {
            disable: C
        },
        linkType: {
            disable: C
        },
        initReplication: {
            disable: C
        }
    };
    if (this.isRsrTopic) {
        F.destVdisk = {
            values: [{
                value: "temp",
                text: strings.createLinearRepSet.noVolSelected
            }]
        };
        F.destVolume = {
            values: [{
                value: "temp",
                text: strings.createLinearRepSet.noVolSelected
            }]
        };
        F.imageName = {
            value: "tempVal"
        };
        F.imagePrefix = {
            value: "tempVal"
        }
    }
    this.update(F);
    if (!this.isRsrTopic) {
        this.volumeSelected(this.previousSelection)
    }
};
CreateRsrReplicationSet.prototype.handleRemoteSystemsUpdate = function(E) {
    var F = [];
    this.localSystemName = DC.system.prop.system_name.text;
    var K = DC.networkParameters.mgmtport_a.get("ip_address");
    var L = decodeBooleanFlag(DC.base["advanced-settings-table"].singleton.getInt("single_controller_numeric"));
    var I = (L ? null : DC.networkParameters.mgmtport_b.get("ip_address"));
    F.push({
        value: "local",
        text: this.localSystemName + strings.createLinearRepSet.local
    });
    var N = this.getLinkTypes();
    var J = DC.remoteSystems;
    for (var C in J) {
        var M = this.getLinkTypes(C);
        var D = J[C];
        var H = null;
        if (decodeBooleanFlag(D.getPropertyValue("isvalid_ip_a_numeric"))) {
            H = D.prop.ip_address_a.text
        } else {
            if (decodeBooleanFlag(D.getPropertyValue("isvalid_ip_b_numeric"))) {
                H = D.prop.ip_address_b.text
            }
        }
        if ((H != null) && ((H != K) && (H != I)) && (M.links.length)) {
            F.push({
                value: H,
                text: J[C].get("system_name")
            })
        }
    }
    this.systems = F;
    var G = {
        destSystem: {
            values: F
        },
        linkType: {
            values: N.links
        }
    };
    this.update(G)
};
CreateRsrReplicationSet.prototype.getVolumeData = function() {
    var C = [];
    for (var D in DC.volumesSerial) {
        vol = DC.volumesSerial[D];
        if (vol.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL || vol.get("replication_set") || vol.getInt("volume_type_numeric") == VOLUME_TYPES.BACKING_STORE || vol.getInt("volume_type_numeric") == VOLUME_TYPES.SNAPSHOT) {
            continue
        }
        volName = vol.get("volume_name");
        D = vol.get("serial_number");
        volSize = vol.get("size");
        volPool = vol.get("storage_pool_name");
        C.push(["volumes", D, volName, volSize, volPool])
    }
    return C
};
CreateRsrReplicationSet.prototype.okCallback = function() {
    var F = {};
    this.retrieve(F);
    var D = [];
    var E = this.selectedVol.get("volume_name");
    var G = {
        volume: this.selectedVol.get("serial_number"),
        linkType: F.linkType.value
    };
    this.scheduler = F.initReplication.value;
    if (F.destSystem.value != "local") {
        G.remoteSystem = F.destSystem.value
    }
    if (F.destVolumeChoice.value == "create") {
        if (!F.destVdisk.value) {
            MC.debugOutput("No vdisk");
            return
        }
        G.remoteVdisk = F.destVdisk.value
    } else {
        if (F.destVolumeChoice.value == "existing") {
            if (!F.destVolume.value) {
                MC.debugOutput("No volumes");
                return
            }
            G.remoteVolume = F.destVolume.value
        } else {
            MC.debugOutput("No vdisks or volumes");
            return
        }
    }
    var C = {
        dialog: true,
        usev2: true,
        noSuccessDialog: true,
        processingMsg: strings.createLinearRepSet.pairProcessing(E),
        failureMsg: strings.createLinearRepSet.pairFailure(E)
    };
    D[D.length] = {
        name: "creating",
        command: MC.createReplicationSet,
        data: G,
        options: C
    };
    MC.execCommandList(D, {
        callback: createObjectCallback(this, this.actionComplete)
    });
    CreateRsrReplicationSet.data = {
        createRepSetPanel: true,
        volName: E,
        serialNum: G.volume,
        scheduler: this.scheduler,
        initiate: E != undefined ? true : false
    }
};
CreateRsrReplicationSet.prototype.actionComplete = function(C) {
    var D = C.results.schedules;
    if (typeof D != "undefined" && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true,
            callback: function(E) {
                MC.debugOutput("returned:" + E.success + " msg:" + E.message + " code:" + E.code, "%s")
            }
        })
    } else {
        if (this.scheduler) {
            ShowActiveDialog({
                type: "success",
                dialogOverride: true,
                message: strings.createReplicationSet.schedulerMsg,
                ok: createObjectCallback(this, CreateRsrReplicationSet.open)
            })
        } else {
            ShowActiveDialog({
                type: "success",
                message: strings.createReplicationSet.initiateRepMsg,
                dialogOverride: true,
                cancelState: "enabled",
                okLabel: strings.Yes,
                cancelLabel: strings.No,
                ok: createObjectCallback(this, this.initiateFirstRsrRep),
                cancel: createObjectCallback(this, this.ok)
            })
        }
    }
};
CreateRsrReplicationSet.open = function() {
    NAV.navTo("HiddenActions", "scheduleRsrReplications")
};
CreateRsrReplicationSet.prototype.initiateFirstRsrRep = function() {
    NAV.navTo("HiddenActions", "initiateRsrReplication")
};
CreateRsrReplicationSet.prototype.ok = function() {
    ShowActiveDialog({
        type: "success",
        message: strings.createReplicationSet.manualRepMsg,
        dialogOverride: true,
        ok: panels.actionDialog.close(true)
    })
};
CreateRsrReplicationSet.prototype.volumeSelected = function(H) {
    this.selectedVol = H[0].getObject();
    var F = {
        destSystem: {
            disable: false
        },
        linkType: {
            disable: false
        },
        initReplication: {
            disable: false
        },
        imageName: {
            value: DC.getUnusedKey("snapshots", this.selectedVol.get("volume_name") + "_i")
        },
        imagePrefix: {
            value: DataSet.generateTaskPrefix(this.selectedVol.get("volume_name"), "ReplicateVolume")
        }
    };
    this.update(F);
    if (this.local) {
        if (typeof this.localVdisks == "undefined") {
            var J = [];
            var E = [];
            var I = DC.diskGroups;
            var D = DC.volumes;
            for (var G in I) {
                if (I[G].get("storage_type_numeric") == STORAGE_CLASS.LINEAR && I[G].get("owner") != this.selectedVol.get("owner")) {
                    J.push(I[G])
                }
            }
            for (var C in D) {
                if (D[C].get("storage_type_numeric") == STORAGE_CLASS.LINEAR && D[C].get("owner") != this.selectedVol.get("owner")) {
                    E.push(D[C])
                }
            }
            this.localVdisks = J;
            this.localVolumes = E
        }
        this.populateSecondaryChoices(this.localVolumes, this.localVdisks)
    } else {
        this.populateSecondaryChoices(this.remoteVolData, this.remoteVdiskData)
    }
    this.somethingChanged()
};
CreateRsrReplicationSet.prototype.somethingChanged = function() {
    var D = {};
    this.retrieve(D);
    var C = false;
    if (D.form.valid && typeof this.selectedVol != "undefined") {
        if ((D.destVolumeChoice.value == "create" && D.destVdisk.value != "temp") || (D.destVolumeChoice.value == "existing" && D.destVolume.value != "temp")) {
            C = true
        }
    }
    this.okEnabled(C);
    this.resetSize({
        shrink: true
    })
};
CreateRsrReplicationSet.prototype.populateSecondaryChoices = function(H, C) {
    var E = this.getDestDiskGroups(C);
    var K = this.getDestVolumes(H);
    var D = false;
    var I = false;
    var F = "create";
    if (E.length) {
        D = true
    } else {
        if (this.local) {
            var J = strings.createLinearRepSet.localLabel
        } else {
            var J = strings.createLinearRepSet.remoteLabel
        }
        E = [{
            value: "temp",
            text: strings.createLinearRepSet.noDgAvailable(J)
        }]
    }
    if (K.length) {
        I = true;
        if (!D) {
            F = "existing"
        }
    } else {
        if (this.local) {
            var J = strings.createLinearRepSet.localLabel
        } else {
            var J = strings.createLinearRepSet.remoteLabel
        }
        K = [{
            value: "temp",
            text: strings.createLinearRepSet.noVolAvailable(J)
        }]
    }
    var G = {
        destVolume: {
            values: K,
            disable: (!I)
        },
        destVdisk: {
            values: E,
            disable: (!D)
        },
        destVolumeChoice: {
            value: F,
            disable: (!(D || I))
        }
    };
    this.update(G)
};
CreateRsrReplicationSet.prototype.getDestVolumes = function(I) {
    var J = this.selectedVol.getInt("blocks");
    var H = [];
    if (I) {
        for (var F = 0; F < I.length; F++) {
            var G = I[F];
            var D = G.getInt("blocks");
            if (G.isRSRPrepared() && (J == D)) {
                var C = G.get("serial_number");
                var E = G.get(volume_name);
                H.push({
                    value: C,
                    text: E
                })
            }
        }
    }
    return H
};
CreateRsrReplicationSet.prototype.getDestDiskGroups = function(R) {
    var I = this.selectedVol.getInt("blocks");
    var H = 0;
    var D = 1048576000;
    var G = 0;
    var T = I / 5;
    var L = 10485760;
    var J = 0;
    if (this.selectedVol.getInt("volume_type_numeric") == VOLUME_TYPES.VOLUME) {
        if (T < L) {
            J = L
        } else {
            J = T
        }
    } else {
        var E = this.selectedVol.get("snap_pool");
        J = DC.snapPoolsSerial[E].getInt("size_numeric")
    }
    var F = I + J;
    if (T < D) {
        if (I < D) {
            H = I
        } else {
            H = D
        }
    } else {
        H = T
    }
    var O = I + H;
    if (O > F) {
        G = O
    } else {
        G = F
    }
    var M = [];
    var C = ("r" + this.selectedVol.get("volume_name"));
    while (utf8bytes(C) > 19) {
        C = C.slice(0, -1)
    }
    var K = ("spr" + this.selectedVol.get("volume_name"));
    while (utf8bytes(K) > 19) {
        K = K.slice(0, -1)
    }
    if (R) {
        for (var N = 0; N < R.length; N++) {
            var P = R[N];
            if (P.get("storage_type_numeric") == STORAGE_CLASS.LINEAR && P.getInt("freespace_numeric") > G && (P.volumes == undefined || (P.volumes[C] == undefined && P.volumes[K] == undefined))) {
                var Q = P.get("serial_number");
                var S = P.get("name");
                M.push({
                    value: Q,
                    text: S
                })
            }
        }
    }
    return M
};
CreateRsrReplicationSet.prototype.getLinkTypes = function(H) {
    var L = {
        iscsi: false,
        fc: false
    };
    var E = {
        iscsi: false,
        fc: false
    };
    var N = {
        iSCSI: false,
        fc: false,
        links: []
    };
    var J = DC.ports;
    for (var F in J) {
        var M = J[F];
        var K = M.prop.media.text;
        if (K == "iSCSI") {
            L.iscsi = true
        }
        if (K.match(/^FC/)) {
            L.fc = true
        }
    }
    if (H == undefined) {
        if (L.iscsi) {
            N.links.push({
                value: "iSCSI",
                text: "iSCSI"
            });
            N.iSCSI = true
        }
        if (L.fc) {
            N.links.push({
                value: "FC",
                text: "FC"
            });
            N.fc = true
        }
    } else {
        var G = DC.remoteSystems;
        for (var D in G) {
            if (D == H) {
                var I = G[D];
                var C = I.prop.interfaces_numeric.text;
                if (C == REMOTE_INTERFACE_TYPES.Hybrid) {
                    E.iscsi = true;
                    E.fc = true;
                    N.iSCSI = true;
                    N.fc = true
                } else {
                    if (C == REMOTE_INTERFACE_TYPES.FC) {
                        E.fc = true;
                        N.fc = true
                    } else {
                        if (C == REMOTE_INTERFACE_TYPES.iSCSI) {
                            E.iscsi = true;
                            N.iSCSI = true
                        }
                    }
                }
            }
        }
        if ((L.iscsi) && (E.iscsi)) {
            N.links.push({
                value: "iSCSI",
                text: "iSCSI"
            })
        }
        if ((L.fc) && (E.fc)) {
            N.links.push({
                value: "FC",
                text: "FC"
            })
        }
    }
    return N
};
CreateRsrReplicationSet.prototype.initCheckboxCallback = function() {
    if (this.initRep.currentValue) {
        var C = {
            initiateContainer: {
                visibility: "visible"
            }
        }
    } else {
        var C = {
            initiateContainer: {
                visibility: "collapse"
            }
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    })
};
CreateRsrReplicationSet.prototype.scheduleChanged = function() {
    this.resetSize({
        shrink: true
    })
};

function DeleteRsrReplicationSet(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DeleteRsrReplicationSet";
    C.width = 325;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "repSetName",
        bottomMargin: true,
        label: strings.deleteLinearRepSet.repSetName
    }), new TextWidget({
        name: "remRepText",
        bottomMediumMargin: true,
        text: strings.deleteLinearRepSet.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteRsrReplicationSet"
}
DeleteRsrReplicationSet.prototype = new ActionPanel();
DeleteRsrReplicationSet.prototype.constructor = DeleteRsrReplicationSet;
DeleteRsrReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D = TopicPanel.getSelected(["replication-set"], 1);
    if (!D) {
        return strings.menuTips.noRepSetSelected
    } else {
        var C = getRepSetInfo(D[0].getObject());
        if (C.rsrSource) {
            return D
        } else {
            return strings.deleteLinearRepSet.removeFromPrimary
        }
    }
};
DeleteRsrReplicationSet.prototype.showing = function() {
    this.update({
        repSetName: {
            text: this.previousSelection[0].getObject().get("name")
        }
    });
    this.okEnabled(true)
};
DeleteRsrReplicationSet.prototype.okCallback = function() {
    var G = this.previousSelection[0].getObject();
    var F = getRepSetInfo(G);
    var D = F.vol.get("serial_number");
    var E = F.vol.get("volume_name");
    var H = {
        volume: D
    };
    var C = {
        usev2: true,
        dialog: true,
        closeActionOn: "success",
        confirmMsg: strings.deleteLinearRepSet.confirmMsg(E),
        processingMsg: strings.deleteLinearRepSet.processingMsg(E),
        failureMsg: strings.deleteLinearRepSet.failureMsg(E),
        successMsg: strings.deleteLinearRepSet.successMsg(E)
    };
    MC.deleteReplicationSet(H, C)
};

function RsrReplicateAction(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "RsrReplicateAction";
    E.width = 500;
    E.okCallback = createObjectCallback(this, this.okCallback);
    var C = [];
    for (var D = 3; D <= 32; D++) {
        C[C.length] = {
            value: "" + D,
            text: "" + D
        }
    }
    E.widgets = [new FormWidget({
        name: "replicateForm",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260
        }), new TextInputWidget({
            name: "imageName",
            label: strings.createLinearRepSet.imageName,
            rules: {
                required: true,
                dhName: true,
                utf8length: RI.getMaxNameLength()
            },
            changeCallback: createObjectCallback(this, this.changeCallback),
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.replicate.confirm
        }), new CheckboxContainer({
            name: "schedContainer",
            label: strings.replicate.scheduleLabel,
            value: false,
            topMargin: true,
            changeCallback: createObjectCallback(this, this.toggleSchedule),
            widgets: [new TableWidget({
                name: "schedWidgets",
                widgets: [new TextInputWidget({
                    name: "imagePrefix",
                    label: strings.createLinearRepSet.imagePrefix,
                    labelOptions: {
                        rightMargin: true
                    },
                    rules: {
                        required: true,
                        dhName: true,
                        utf8length: (RI.getMaxNameLength() - 6)
                    },
                    row: 1,
                    col: 1,
                    messages: {
                        required: strings.replicateVolume.enterName
                    },
                    changeCallback: createObjectCallback(this, this.changeCallback),
                    bottomMediumMargin: true,
                    topMargin: true
                }), new RadioButtonsInputWidget({
                    name: "replicationMode",
                    bottomMargin: true,
                    label: strings.createLinearRepSet.repMode,
                    row: 2,
                    col: 1,
                    labelOptions: {
                        bottomMargin: true,
                        rightSmallMargin: true
                    },
                    value: "new-snapshot",
                    values: [{
                        value: "new-snapshot",
                        text: strings.createLinearRepSet.newSnap
                    }, {
                        value: "last-snapshot",
                        text: strings.createLinearRepSet.lastSnap
                    }]
                }), new OptionInputWidget({
                    name: "retentionCount",
                    bottomMargin: true,
                    label: strings.createLinearRepSet.retCount,
                    row: 3,
                    col: 1,
                    labelOptions: {
                        bottomMargin: true,
                        rightSmallMargin: true
                    },
                    values: C,
                    width: 40
                }), new ScheduleInputWidget({
                    name: "replicationSchedule",
                    row: 4,
                    col: 0,
                    colSpan: 2,
                    disable: true,
                    changeCallback: createObjectCallback(this, this.scheduleChanged)
                })]
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "RsrReplicateAction"
}
RsrReplicateAction.prototype = new ActionPanel();
RsrReplicateAction.prototype.constructor = RsrReplicateAction;
RsrReplicateAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var H = F[0].getObject();
        var C = H.objects[0].get("primary_volume_name");
        for (var G in DC.volumes) {
            var E = DC.volumes[G];
            var D = E.get("volume_name");
            if (C == D) {
                return F
            }
        }
        return strings.initiateReplication.cannotInitiate
    }
};
RsrReplicateAction.prototype.showing = function() {
    var G = this.previousSelection[0].getObject();
    var C = G.objects[0].get("primary_volume_name");
    var D = DC.getUnusedKey("snapshots", C + "_i");
    var F = DataSet.generateTaskPrefix(C, "ReplicateVolume");
    var E = {
        repSet: {
            text: C
        },
        imageName: {
            value: D
        },
        imagePrefix: {
            value: F
        },
        schedWidgets: {
            disable: true
        }
    };
    this.update(E);
    this.okEnabled(true);
    this.schedule = false
};
RsrReplicateAction.prototype.okCallback = function() {
    var J = this.previousSelection[0].getObject();
    var I = J.objects[0].get("primary_volume_name");
    var H = J.objects[0].get("primary_volume_serial");
    var E = {};
    this.retrieve(E);
    if (this.schedule) {
        this.taskName = DC.getUnusedKey("tasks", I + "_task");
        var K = DC.getUnusedKey("schedules", I + "_sched");
        var C = [];
        var G = {
            name: this.taskName,
            type: "ReplicateVolume",
            sourceVolume: H,
            snapshotPrefix: E.imagePrefix.value,
            replicationMode: E.replicationMode.value,
            retentionCount: E.retentionCount.value
        };
        C[C.length] = {
            name: "task",
            command: MC.createTask,
            data: G,
            options: {
                usev2: true,
                processingMsg: strings.createLinearRepSet.taskProcessing(I),
                failureMsg: strings.createLinearRepSet.taskFailure(I),
                successMsg: strings.createLinearRepSet.taskSuccess(I)
            }
        };
        var D = {
            name: K,
            scheduleSpecification: E.replicationSchedule.value,
            taskName: this.taskName
        };
        C[C.length] = {
            name: "schedules",
            command: MC.createSchedule,
            data: D,
            options: {
                usev2: true,
                closeActionOn: "success",
                processingMsg: strings.createLinearRepSet.scheduleProcessing(I),
                failureMsg: strings.createLinearRepSet.scheduleFailure(I),
                successMsg: strings.createLinearRepSet.scheduleSuccess(I)
            }
        };
        MC.execCommandList(C, {
            callback: createObjectCallback(this, this.actionComplete)
        })
    } else {
        var E = {
            volume: H,
            snapshot: E.imageName.value
        };
        var F = {
            dialog: true,
            usev2: true,
            closeActionOn: "success",
            processingMsg: strings.initiateReplication.rsrProcessing(I),
            failureMsg: strings.initiateReplication.rsrFailure(I),
            successMsg: strings.initiateReplication.rsrSuccess(I)
        };
        MC.replicateVolume(E, F)
    }
};
RsrReplicateAction.prototype.toggleSchedule = function(D) {
    if (D.schedContainer.value) {
        this.schedule = true;
        var C = {
            schedWidgets: {
                disable: false
            },
            imageName: {
                disable: true
            }
        }
    } else {
        this.schedule = false;
        var C = {
            schedWidgets: {
                disable: true
            },
            imageName: {
                disable: false
            }
        }
    }
    this.update(C)
};
RsrReplicateAction.prototype.scheduleChanged = function(E, C, D) {
    this.resetSize({
        shrink: true
    });
    this.changeCallback()
};
RsrReplicateAction.prototype.changeCallback = function(F, D, E) {
    var C = {};
    this.retrieve(C);
    if (!C.replicateForm) {
        return
    }
    if (C.replicateForm.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
RsrReplicateAction.prototype.actionComplete = function(C) {
    var D = C.results.schedules;
    if (typeof D != "undefined" && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true,
            callback: function(E) {
                MC.debugOutput("returned:" + E.success + " msg:" + E.message + " code:" + E.code, "%s")
            }
        })
    }
};

function InitiateRsrReplication(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "InitiateRsrReplication";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "form",
        data: {},
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repsTopic.primaryVol,
            topMargin: true
        }), new TextInputWidget({
            name: "imageName",
            label: strings.createLinearRepSet.imageName,
            rules: {
                required: true,
                dhName: true,
                utf8length: RI.getMaxNameLength()
            },
            changeCallback: createObjectCallback(this, this.changeCallback),
            topMargin: true
        }), new TextWidget({
            name: "confirmText",
            topMargin: true,
            text: strings.initiateReplication.confirm
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "InitiateRsrReplication"
}
InitiateRsrReplication.prototype = new ActionPanel();
InitiateRsrReplication.prototype.constructor = InitiateRsrReplication;
InitiateRsrReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var H = F[0].getObject();
        var C = H.objects[0].get("primary_volume_name");
        for (var G in DC.volumes) {
            var E = DC.volumes[G];
            var D = E.get("volume_name");
            if (C == D) {
                return F
            }
        }
        return strings.initiateReplication.cannotInitiate
    }
};
InitiateRsrReplication.prototype.showing = function() {
    var E = false;
    var D = new CreateRsrReplicationSet();
    if (D.constructor.data) {
        this.repSetData = D.constructor.data;
        E = this.repSetData.initiate
    }
    if (E) {
        var C = this.repSetData.volName
    } else {
        var H = this.previousSelection[0].getObject();
        var C = H.objects[0].get("primary_volume_name")
    }
    var F = DC.getUnusedKey("snapshots", C + "_i");
    var G = {
        repSet: {
            text: C
        },
        imageName: {
            value: F
        }
    };
    this.update(G);
    this.okEnabled(true)
};
InitiateRsrReplication.prototype.okCallback = function() {
    var H = this.previousSelection[0].getObject();
    if (H instanceof APIReplicationSet) {
        var D = H.objects[0].get("primary_volume_name");
        var G = H.objects[0].get("primary_volume_serial")
    } else {
        var D = this.repSetData.volName;
        var G = this.repSetData.serialNum
    }
    var F = {};
    this.retrieve(F);
    var E = {
        volume: G,
        snapshot: F.imageName.value
    };
    var C = {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.initiateReplication.rsrProcessing(D),
        failureMsg: strings.initiateReplication.rsrFailure(D),
        successMsg: strings.initiateReplication.rsrSuccess(D)
    };
    MC.replicateVolume(E, C)
};
InitiateRsrReplication.prototype.changeCallback = function() {
    var C = {};
    this.retrieve(C);
    if (C.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false);
        this.resetSize({
            shrink: true
        })
    }
};

function ScheduleRsrReplication(E) {
    if (arguments.length == 0) {
        return
    }
    E.name = "ScheduleRsrReplication";
    E.width = 460;
    E.okCallback = createObjectCallback(this, this.okCallback);
    var C = [];
    for (var D = 3; D <= 32; D++) {
        C[C.length] = {
            value: "" + D,
            text: "" + D
        }
    }
    E.widgets = [new FormWidget({
        name: "form",
        data: {},
        tableLayout: true,
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            row: 0,
            col: 1,
            label: strings.repsTopic.primaryVol,
            topMargin: true
        }), new TextInputWidget({
            name: "imagePrefix",
            label: strings.createLinearRepSet.imagePrefix,
            labelOptions: {
                rightMargin: true
            },
            rules: {
                required: true,
                dhName: true,
                utf8length: (RI.getMaxNameLength() - 6)
            },
            row: 1,
            col: 1,
            messages: {
                required: strings.replicateVolume.enterName
            },
            changeCallback: createObjectCallback(this, this.somethingChanged),
            bottomMediumMargin: true,
            topMargin: true
        }), new RadioButtonsInputWidget({
            name: "replicationMode",
            bottomMargin: true,
            label: strings.createLinearRepSet.repMode,
            row: 2,
            col: 1,
            labelOptions: {
                bottomMargin: true,
                rightSmallMargin: true
            },
            value: "new-snapshot",
            values: [{
                value: "new-snapshot",
                text: strings.createLinearRepSet.newSnap
            }, {
                value: "last-snapshot",
                text: strings.createLinearRepSet.lastSnap
            }]
        }), new OptionInputWidget({
            name: "retentionCount",
            bottomMargin: true,
            label: strings.createLinearRepSet.retCount,
            row: 3,
            col: 1,
            labelOptions: {
                bottomMargin: true,
                rightSmallMargin: true
            },
            values: C,
            width: 40
        }), new ScheduleInputWidget({
            name: "replicationSchedule",
            row: 4,
            col: 0,
            colSpan: 2,
            disable: true,
            changeCallback: createObjectCallback(this, this.somethingChanged)
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "ScheduleRsrReplication"
}
ScheduleRsrReplication.prototype = new ActionPanel();
ScheduleRsrReplication.prototype.constructor = ScheduleRsrReplication;
ScheduleRsrReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var H = F[0].getObject();
        var C = H.objects[0].get("primary_volume_name");
        for (var G in DC.volumes) {
            var E = DC.volumes[G];
            var D = E.get("volume_name");
            if (C == D) {
                return F
            }
        }
        return strings.initiateReplication.cannotSchedule
    }
};
ScheduleRsrReplication.prototype.showing = function() {
    var H = this.previousSelection[0].getObject();
    if (H instanceof APIReplicationSet) {
        var D = H.objects[0].get("primary_volume_name")
    } else {
        var E = false;
        var C = new CreateRsrReplicationSet();
        if (C.constructor.data) {
            this.repSetData = C.constructor.data;
            E = this.repSetData.scheduler
        }
        if (E) {
            var D = this.repSetData.volName
        }
    }
    var G = DataSet.generateTaskPrefix(D, "ReplicateVolume");
    var F = {
        repSet: {
            text: D
        },
        imagePrefix: {
            value: G
        },
        replicationSchedule: {
            disable: false
        }
    };
    this.update(F);
    this.okEnabled(true)
};
ScheduleRsrReplication.prototype.okCallback = function() {
    var J = this.previousSelection[0].getObject();
    if (J instanceof APIReplicationSet) {
        var H = J.objects[0].get("primary_volume_name");
        var I = J.objects[0].get("primary_volume_serial")
    } else {
        var H = this.repSetData.volName;
        var I = this.repSetData.serialNum
    }
    this.taskName = DC.getUnusedKey("tasks", H + "_task");
    var G = DC.getUnusedKey("schedules", H + "_sched");
    var D = [];
    var F = {};
    this.retrieve(F);
    var E = {
        name: this.taskName,
        type: "ReplicateVolume",
        sourceVolume: I,
        snapshotPrefix: F.imagePrefix.value,
        replicationMode: F.replicationMode.value,
        retentionCount: F.retentionCount.value
    };
    D[D.length] = {
        name: "task",
        command: MC.createTask,
        data: E,
        options: {
            usev2: true,
            processingMsg: strings.createLinearRepSet.taskProcessing(H),
            failureMsg: strings.createLinearRepSet.taskFailure(H),
            successMsg: strings.createLinearRepSet.taskSuccess(H)
        }
    };
    var C = {
        name: G,
        scheduleSpecification: F.replicationSchedule.value,
        taskName: this.taskName
    };
    D[D.length] = {
        name: "schedules",
        command: MC.createSchedule,
        data: C,
        options: {
            usev2: true,
            closeActionOn: "success",
            processingMsg: strings.createLinearRepSet.scheduleProcessing(H),
            failureMsg: strings.createLinearRepSet.scheduleFailure(H),
            successMsg: strings.createLinearRepSet.scheduleSuccess(H)
        }
    };
    MC.execCommandList(D, {
        callback: createObjectCallback(this, this.actionComplete)
    })
};
ScheduleRsrReplication.prototype.actionComplete = function(C) {
    var D = C.results.schedules;
    if (typeof D != "undefined" && !D.success) {
        MC.deleteTask({
            name: this.taskName
        }, {
            dialog: false,
            noSuccessDialog: true,
            callback: function(E) {
                MC.debugOutput("returned:" + E.success + " msg:" + E.message + " code:" + E.code, "%s")
            }
        })
    }
};
ScheduleRsrReplication.prototype.somethingChanged = function() {
    var C = {};
    this.retrieve(C);
    if (C.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};

function SetPrimaryVolume(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "SetPrimaryVolume";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "form",
        data: {},
        widgets: [new OptionInputWidget({
            name: "systems",
            classes: "inline ARLeftSmallMargin",
            label: strings.setPrimaryVolume.primaryLabel,
            labelOptions: {
                bottomMediumMargin: true
            },
            changeCallback: createObjectCallback(this, this.primaryVolumeChanged),
            leftSmallMargin: true,
            bottomMediumMargin: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "SetPrimaryVolume"
}
SetPrimaryVolume.prototype = new ActionPanel();
SetPrimaryVolume.prototype.constructor = SetPrimaryVolume;
SetPrimaryVolume.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["replication-set"], 1);
    if (!C) {
        return strings.menuTips.noRepSetSelected
    } else {
        return C
    }
};
SetPrimaryVolume.prototype.showing = function() {
    var G = [];
    var H = this.previousSelection[0].getObject();
    for (var D in H.repVolumesSerial) {
        var E = H.repVolumesSerial[D];
        var C = E.get("primary_volume_serial");
        G.push({
            value: D,
            text: E.get("name")
        })
    }
    var F = {
        systems: {
            values: G
        }
    };
    this.update(F);
    this.okEnabled(true)
};
SetPrimaryVolume.prototype.okCallback = function() {
    var K = {};
    this.retrieve(K);
    var J = this.previousSelection[0].getObject();
    var G = J.get("serial_number");
    for (var H in DC.volumes) {
        var D = DC.volumes[H];
        if (D.get("replication_set") && D.get("replication_set") == G) {
            var L = D.get("serial_number");
            break
        }
    }
    var C = K.systems.value;
    var I = K.systems.textValue;
    var E = {
        volume: L,
        extView: C
    };
    var F = {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        confirmMsg: strings.setPrimaryVolume.confirmMsg,
        processingMsg: strings.setPrimaryVolume.processingMsg(I),
        failureMsg: strings.setPrimaryVolume.failureMsg(I),
        successMsg: strings.setPrimaryVolume.successMsg(I)
    };
    MC.setReplicationPrimaryVolume(E, F)
};

function AbortRsrReplication(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "AbortRsrReplication";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "volName",
        label: strings.abortRsrReplication.volName,
        bottomMargin: true
    }), new TextWidget({
        name: "infoTxt",
        text: strings.abortRsrReplication.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "AbortRsrReplication"
}
AbortRsrReplication.prototype = new ActionPanel();
AbortRsrReplication.prototype.constructor = AbortRsrReplication;
AbortRsrReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var G = F[0].getObject();
        var E = getRepSetInfo(G);
        if (E.rsrDest) {
            for (var C in G.repVolumesSerial) {
                if (C == E.vol.get("serial_number")) {
                    var D = G.repVolumesSerial[C];
                    if (D.getInt("status_numeric") == 3) {
                        return F
                    }
                }
            }
            return strings.abortReplication.inProgress
        } else {
            return strings.menuTips.localRsrDest
        }
    }
};
AbortRsrReplication.prototype.showing = function() {
    var C = getRepSetInfo(this.previousSelection[0].getObject());
    this.update({
        volName: {
            text: C.vol.get("volume_name")
        }
    });
    this.okEnabled(true)
};
AbortRsrReplication.prototype.okCallback = function() {
    var F = this.previousSelection[0].getObject();
    var D = getRepSetInfo(F);
    var C = D.vol.get("volume_name");
    var E = D.vol.get("serial_number");
    MC.abortReplication({
        volume: E
    }, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.abortRsrReplication.processing(C),
        failureMsg: strings.abortRsrReplication.failure(C),
        successMsg: strings.abortRsrReplication.success(C)
    })
};

function SuspendRsrReplication(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "SuspendRsrReplication";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "volName",
        label: strings.abortRsrReplication.volName,
        bottomMargin: true
    }), new TextWidget({
        name: "infoTxt",
        text: strings.suspendRsrReplication.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "SuspendRsrReplication"
}
SuspendRsrReplication.prototype = new ActionPanel();
SuspendRsrReplication.prototype.constructor = SuspendRsrReplication;
SuspendRsrReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var G = F[0].getObject();
        var E = getRepSetInfo(G);
        if (E.rsrDest) {
            for (var C in G.repVolumesSerial) {
                if (C == E.vol.get("serial_number")) {
                    var D = G.repVolumesSerial[C];
                    if (D.getInt("status_numeric") == 3) {
                        return F
                    }
                }
            }
            return strings.suspendReplicationSet.inProgress
        } else {
            return strings.menuTips.localRsrDest
        }
    }
};
SuspendRsrReplication.prototype.showing = function() {
    var C = getRepSetInfo(this.previousSelection[0].getObject());
    this.update({
        volName: {
            text: C.vol.get("volume_name")
        }
    });
    this.okEnabled(true)
};
SuspendRsrReplication.prototype.okCallback = function() {
    var F = this.previousSelection[0].getObject();
    var D = getRepSetInfo(F);
    var C = D.vol.get("volume_name");
    var E = D.vol.get("serial_number");
    MC.suspendReplication({
        volume: E
    }, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.suspendRsrReplication.processing(C),
        failureMsg: strings.suspendRsrReplication.failure(C),
        successMsg: strings.suspendRsrReplication.success(C)
    })
};

function ResumeRsrReplication(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ResumeRsrReplication";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "volName",
        label: strings.abortRsrReplication.volName,
        bottomMargin: true
    }), new TextWidget({
        name: "infoTxt",
        text: strings.resumeRsrReplication.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "ResumeRsrReplication"
}
ResumeRsrReplication.prototype = new ActionPanel();
ResumeRsrReplication.prototype.constructor = ResumeRsrReplication;
ResumeRsrReplication.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var F = TopicPanel.getSelected(["replication-set"], 1);
    if (!F) {
        return strings.menuTips.noRepSetSelected
    } else {
        var G = F[0].getObject();
        var E = getRepSetInfo(G);
        if (E.rsrDest) {
            for (var C in G.repVolumesSerial) {
                if (C == E.vol.get("serial_number")) {
                    var D = G.repVolumesSerial[C];
                    if (D.getInt("status_numeric") == 5) {
                        return F
                    }
                }
            }
            return strings.resumeReplicationSet.suspendedRepSet
        } else {
            return strings.menuTips.localRsrDest
        }
    }
};
ResumeRsrReplication.prototype.showing = function() {
    var C = getRepSetInfo(this.previousSelection[0].getObject());
    this.update({
        volName: {
            text: C.vol.get("volume_name")
        }
    });
    this.okEnabled(true)
};
ResumeRsrReplication.prototype.okCallback = function() {
    var F = this.previousSelection[0].getObject();
    var D = getRepSetInfo(F);
    var C = D.vol.get("volume_name");
    var E = D.vol.get("serial_number");
    MC.resumeReplication({
        volume: E
    }, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.resumeRsrReplication.processing(C),
        failureMsg: strings.resumeRsrReplication.failure(C),
        successMsg: strings.resumeRsrReplication.success(C)
    })
};

function ReverseReplicationSet(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ReverseReplicationSet";
    C.title = strings.actions.ReverseReplication;
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.width = 400;
    C.widgets = [new WidgetContainer({
        name: "reverseWC",
        widgets: [new TextWidget({
            name: "repSet",
            classes: "scrollText100",
            label: strings.repSetLabel,
            width: 260,
            topMargin: true
        }), new TextWidget({
            name: "infoText",
            topMargin: true,
            text: strings.reverseReplication.infoText
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ReverseReplicationSet"
}
ReverseReplicationSet.prototype = new ActionPanel();
ReverseReplicationSet.prototype.constructor = ReverseReplicationSet;
ReverseReplicationSet.getMenuState = function() {
    if (!session.hasConfigurationCapability() || !RI.hasFeature("recoveryManager")) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var C = TopicPanel.getSelected(["cs-replication-set"], 1);
    if (C) {
        var E = DC.virtualReplicationSetsSerial[C[0].key];
        var D = DC.peerConnections[E.get("peer_connection_name")];
        if (E.getInt("primary_location_numeric") == REPSET_DIRECTION.OUTBOUND) {
            return strings.reverseReplication.mustBeSecondary
        } else {
            if (D.get("connection_status_numeric") != PEERSTATUS.ONLINE) {
                return strings.reverseReplication.peerOnline
            } else {
                return C
            }
        }
    } else {
        return strings.reverseReplication.singleRepSet
    }
};
ReverseReplicationSet.prototype.showing = function() {
    var C = {};
    this.selected = this.previousSelection;
    var E = DC.virtualReplicationSetsSerial[this.selected[0].key];
    var D = E.getInt("status_numeric");
    if (D == REP_STATUS.FAILEDOVER) {
        this.inFailover = true
    } else {
        this.inFailover = false
    }
    this.update({
        repSet: {
            text: E.get("name")
        }
    });
    this.okEnabled(true)
};
ReverseReplicationSet.prototype._okCallback = function() {
    var C = strings.reverseReplication.deleteMappingsConfirm;
    if (isHPsystem()) {
        C += "<br><br>" + strings.recoveryManager.restoreConfirmAppr(strings.recoveryManager.accept) + '<br><br><input id="confirmRestoreText" type="text" tabindex="0" class="TextInputWidget">'
    }
    ShowActiveDialog({
        title: strings.actions.ReverseReplication,
        type: "confirm",
        message: C,
        ok: createObjectCallback(this, this.apply, true)
    });
    if (isHPsystem()) {
        ActiveDialogUpdate({
            okState: "disabled",
            okLabel: strings.menus.reverseReplication,
            cancelLabel: strings.Cancel
        });
        $("#confirmRestoreText").keyup(function(F) {
            var D = $("#confirmRestoreText").val();
            var E = strings.recoveryManager.accept;
            if (D.toLowerCase() == E.toLowerCase()) {
                if (panels.activeDialogPanel.options.okState == "disabled") {
                    ActiveDialogUpdate({
                        okState: "enabled"
                    });
                    $("#confirmRestoreText").val(D);
                    $("#confirmRestoreText").keyup(arguments.callee)
                }
            } else {
                if (panels.activeDialogPanel.options.okState == "enabled") {
                    ActiveDialogUpdate({
                        okState: "disabled"
                    });
                    $("#confirmRestoreText").val(D);
                    $("#confirmRestoreText").keyup(arguments.callee)
                }
            }
        })
    }
};
ReverseReplicationSet.prototype.apply = function() {
    var D = this.selected[0].key;
    var C = [];
    if (!this.inFailover) {
        C.push({
            name: "repSetFailover",
            command: MC.recoverReplicationSet,
            data: {
                repSet: D,
                operation: "failover"
            },
            options: {
                processingMsg: strings.reverseReplication.processingFailover,
                failureMsg: strings.reverseReplication.failedFailover
            }
        })
    }
    C.push({
        name: "repSetReverse",
        command: MC.recoverReplicationSet,
        data: {
            repSet: D,
            operation: "reverse"
        },
        options: {
            processingMsg: strings.reverseReplication.processingReverse,
            failureMsg: strings.reverseReplication.failedReverse
        }
    });
    MC.execCommandList(C, {
        closeActionOn: "success",
        successMsg: strings.reverseReplication.reverseSuccessful
    })
};

function DetachReplicationVolume(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DetachReplicationVolume";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "volumeInfo",
        label: strings.detachReplicationVolume.secondaryVolLabel
    }), new TextWidget({
        name: "infoTxt",
        text: strings.detachReplicationVolume.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "DetachReplicationVolume"
}
DetachReplicationVolume.prototype = new ActionPanel();
DetachReplicationVolume.prototype.constructor = DetachReplicationVolume;
DetachReplicationVolume.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["replication-set"], 1);
    if (!D) {
        return strings.menuTips.noRepSetSelected
    } else {
        var E = D[0].getObject();
        var C = getRepSetInfo(E);
        if (!C.rsrDest) {
            return strings.detachReplicationVolume.cannotDetach
        }
        if (E.isDestDetached()) {
            return strings.detachReplicationVolume.alreadyDetached
        } else {
            return D
        }
    }
};
DetachReplicationVolume.prototype.showing = function() {
    this.repSetInfo = getRepSetInfo(this.previousSelection[0].getObject());
    var C = this.repSetInfo.vol.get("volume_name");
    this.update({
        volumeInfo: {
            text: C
        }
    });
    this.okEnabled(true)
};
DetachReplicationVolume.prototype.okCallback = function() {
    var D = this.repSetInfo.vol.get("volume_name");
    var E = this.repSetInfo.vol.get("serial_number");
    var C = {
        volume: E
    };
    MC.detachReplicationVolume(C, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        confirmMsg: strings.detachReplicationVolume.confirmText(D),
        processingMsg: strings.detachReplicationVolume.detachProcessing(D),
        failureMsg: strings.detachReplicationVolume.detachFailure(D),
        successMsg: strings.detachReplicationVolume.detachSuccess(D)
    })
};

function ReattachReplicationVolume(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ReattachReplicationVolume";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "volumeInfo",
        label: strings.reattachReplicationVolume.secondaryVolLabel
    }), new TextWidget({
        name: "infoTxt",
        text: strings.reattachReplicationVolume.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "ReattachReplicationVolume"
}
ReattachReplicationVolume.prototype = new ActionPanel();
ReattachReplicationVolume.prototype.constructor = ReattachReplicationVolume;
ReattachReplicationVolume.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["replication-set"], 1);
    if (!D) {
        return strings.menuTips.noRepSetSelected
    } else {
        var E = D[0].getObject();
        var C = getRepSetInfo(E);
        if (!C.rsrDest) {
            return strings.reattachReplicationVolume.cannotReattach
        }
        if (E.isDestDetached()) {
            return D
        } else {
            return strings.reattachReplicationVolume.alreadyAttached
        }
    }
};
ReattachReplicationVolume.prototype.showing = function() {
    this.repSetInfo = getRepSetInfo(this.previousSelection[0].getObject());
    var C = this.repSetInfo.vol.get("volume_name");
    this.update({
        volumeInfo: {
            text: C
        }
    });
    this.okEnabled(true)
};
ReattachReplicationVolume.prototype.okCallback = function() {
    var D = this.repSetInfo.vol.get("volume_name");
    var E = this.repSetInfo.vol.get("serial_number");
    var C = {
        volume: E
    };
    MC.reattachReplicationVolume(C, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        confirmMsg: strings.reattachReplicationVolume.confirmTxt(D),
        processingMsg: strings.reattachReplicationVolume.processing(D),
        failureMsg: strings.reattachReplicationVolume.failure(D),
        successMsg: strings.reattachReplicationVolume.success(D)
    })
};

function ExportSnapshot(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ExportSnapshot";
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new FormWidget({
        name: "form",
        data: {},
        widgets: [new TextWidget({
            name: "infoTxt",
            text: strings.exportSnapshot.infoTxt,
            bottomMargin: true
        }), new TextInputWidget({
            name: "snapName",
            label: strings.exportSnapshot.snapNameLabel,
            changeCallback: createObjectCallback(this, this.somethingChanged),
            rules: {
                required: true,
                dhName: true,
                utf8length: RI.getMaxNameLength()
            },
            messages: {
                required: strings.exportSnapshot.enterName
            },
            topMargin: true,
            disable: true
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ExportSnapshot"
}
ExportSnapshot.prototype = new ActionPanel();
ExportSnapshot.prototype.constructor = ExportSnapshot;
ExportSnapshot.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["replication-image"], 1);
    if (!D) {
        return strings.exportSnapshot.mustSelectRepImage
    } else {
        var E = D[0].getObject();
        var C = E.get("snapshot_serial");
        if (C in DC.snapshotsSerial) {
            return D
        } else {
            return strings.exportSnapshot.imageWithSnap
        }
    }
};
ExportSnapshot.prototype.showing = function() {
    var D = this.previousSelection[0].getObject();
    var E = D.get("snapshot_name");
    var C = DC.getUnusedKey("snapshots", E);
    this.update({
        snapName: {
            value: C
        }
    });
    this.okEnabled(true)
};
ExportSnapshot.prototype.somethingChanged = function() {
    var C = {};
    this.retrieve(C);
    if (C.form.valid) {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
    this.resetSize({
        shrink: true
    })
};
ExportSnapshot.prototype.okCallback = function() {
    var E = {};
    this.retrieve(E);
    var C = this.previousSelection[0].getObject();
    var D = C.get("snapshot_serial");
    MC.exportSnapshot({
        snapshot: D,
        name: E.snapName.value
    }, {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.exportSnapshot.processingMsg,
        failureMsg: strings.exportSnapshot.failureMsg,
        successMsg: strings.exportSnapshot.successMsg
    })
};

function DeleteRsrSnapshot(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "DeleteRsrSnapshot";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "snapshotName",
        label: strings.deleteRsrSnapshot.snapLabel,
        bottomMargin: true
    }), new TextWidget({
        text: strings.deleteRsrSnapshot.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "DeleteRsrSnapshot"
}
DeleteRsrSnapshot.prototype = new ActionPanel();
DeleteRsrSnapshot.prototype.constructor = DeleteRsrSnapshot;
DeleteRsrSnapshot.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var D = TopicPanel.getSelected(["replication-image"], 1);
    if (!D) {
        return strings.exportSnapshot.mustSelectRepImage
    } else {
        var E = D[0].getObject();
        var C = E.get("snapshot_serial");
        if (C in DC.snapshotsSerial) {
            return D
        } else {
            return strings.deleteRsrSnapshot.snapAlreadyDeleted
        }
    }
};
DeleteRsrSnapshot.prototype.showing = function() {
    var C = this.previousSelection[0].getObject();
    var D = C.get("snapshot_name");
    this.update({
        snapshotName: {
            text: D
        }
    });
    this.okEnabled(true)
};
DeleteRsrSnapshot.prototype.okCallback = function() {
    var D = this.previousSelection[0].getObject();
    var E = [D.get("snapshot_serial")];
    var G = {
        volumes: E
    };
    var F = DC.snapshotsSerial[E].get("snapshot_type");
    var C = {
        dialog: true,
        closeActionOn: "success",
        confirmMsg: strings.deleteRsrSnapshot.confirmMsg(F),
        processingMsg: strings.deleteRsrSnapshot.processingMsg,
        failureMsg: strings.deleteRsrSnapshot.failureMsg,
        successMsg: strings.deleteRsrSnapshot.successMsg
    };
    MC.deleteSnapshot(G, C)
};

function ReplicateSnapshot(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "ReplicateSnapshot";
    C.width = 400;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [this.form = new FormWidget({
        name: "form",
        widgets: [new TextWidget({
            name: "infoTxt",
            text: strings.replicateSnapshot.infoTxt
        }), new TableInator({
            name: "snapTable",
            cellClasses: "verticalTop",
            selectable: "single",
            selectCallback: createObjectCallback(this, this.snapSelected),
            bottomMargin: true,
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "key",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.replicateSnapshot.snapName,
                bFilterMenu: true
            }, {
                sTitle: strings.replicateSnapshot.snapSize,
                bFilterMenu: true
            }, {
                sTitle: strings.replicateSnapshot.snapPool,
                bFilterMenu: true
            }],
            dtOptions: {
                bFilter: "noInput",
                bFilter: "noControls",
                iDisplayLength: 8,
                bLengthChange: false,
                aaSorting: [
                    [2, "asc"],
                    [3, "asc"]
                ]
            }
        }), new TextInputWidget({
            name: "repImageName",
            label: strings.replicateSnapshot.repImageName,
            rules: {
                required: true,
                dhName: true,
                utf8length: RI.getMaxNameLength()
            },
            changeCallback: createObjectCallback(this, this.nameChange)
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "ReplicateSnapshot"
}
ReplicateSnapshot.prototype = new ActionPanel();
ReplicateSnapshot.prototype.constructor = ReplicateSnapshot;
ReplicateSnapshot.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (!licenseInfo.isLicensed("remote_snapshot_replication")) {
        return strings.menuTips.notLicensed
    }
    var D = TopicPanel.getSelected(["replication-set"], 1);
    if (!D) {
        return strings.menuTips.noRepSetSelected
    } else {
        var C = getRepSetInfo(D[0].getObject());
        if (C.rsrSource) {
            if (typeof C.vol.snapshots != "undefined") {
                for (snapName in C.vol.snapshots) {
                    var E = C.vol.snapshots[snapName];
                    if (!E.get("replication_set")) {
                        return D
                    }
                }
                return strings.replicateSnapshot.repWithSnaps
            } else {
                return strings.replicateSnapshot.repWithSnaps
            }
        } else {
            return strings.replicateSnapshot.repFromPrimary
        }
    }
};
ReplicateSnapshot.prototype.showing = function() {
    var E = getRepSetInfo(this.previousSelection[0].getObject());
    var D = E.vol.snapshots;
    var C = [];
    for (snapName in D) {
        var F = D[snapName];
        if (!F.get("replication_set")) {
            C.push([F.basetype, F.getKeyValue(), F.get("volume_name"), F.get("total_size"), F.get("storage_pool_name")])
        }
    }
    var G = {
        snapTable: {
            data: C
        },
        repImageName: {
            disable: true
        }
    };
    this.update(G)
};
ReplicateSnapshot.prototype.snapSelected = function(D) {
    var E = D[0].getObject();
    this.snapName = E.get("volume_name");
    this.snapSerial = E.get("serial_number");
    var C = DC.getUnusedKey("snapshots", this.snapName + "_i");
    this.update({
        repImageName: {
            disable: false,
            value: C
        }
    });
    this.okEnabled(true)
};
ReplicateSnapshot.prototype.nameChange = function() {
    this.form.validate();
    this.okEnabled((this.form.valid ? true : false));
    this.resetSize({
        shrink: true
    })
};
ReplicateSnapshot.prototype.okCallback = function() {
    var E = {};
    this.retrieve(E);
    var D = {
        snapshot: this.snapSerial,
        name: E.repImageName.value
    };
    var C = {
        dialog: true,
        usev2: true,
        closeActionOn: "success",
        processingMsg: strings.replicateSnapshot.processingMsg(this.snapName),
        failureMsg: strings.replicateSnapshot.failureMsg(this.snapName),
        successMsg: strings.replicateSnapshot.successMsg(this.snapName)
    };
    MC.replicateSnapshot(D, C)
};

function isLocalReplicationSet(C) {
    var F = C.repVolumesSerial;
    var E = 0;
    for (var D in F) {
        E += F[D].getInt("location_numeric")
    }
    if (E == 0) {
        return true
    } else {
        return false
    }
}

function getRepSetInfo(C) {
    var F = isLocalReplicationSet(C);
    var H = C.get("serial_number");
    var G;
    for (var E in DC.volumes) {
        var D = DC.volumes[E];
        if (D.get("replication_set") && !decodeBooleanFlag(D.get("snapshot")) && D.get("replication_set") == H) {
            if (F) {
                G = {
                    rsrSource: true,
                    rsrDest: true,
                    vol: D
                }
            } else {
                G = {
                    rsrSource: D.isRSRSource(),
                    rsrDest: D.isRSRDestination(),
                    vol: D
                }
            }
            break
        }
    }
    return G
}

function MapAction(H) {
    if (arguments.length == 0) {
        return
    }
    H.name = "MapAction";
    H.width = 970;
    H.height = 600;
    H.okCallback = createObjectCallback(this, this.okCallback);
    H.cancelCallback = createObjectCallback(this, this.cancelCallback);
    H.applyCallback = createObjectCallback(this, this.applyCallback);
    this.selectedInits = [];
    this.selectedVolumes = [];
    this.added = {};
    this.rowID = 1;
    this.pendingChanges = false;
    this.baseLun = getBaseLUN();
    if (DC.controllers.A) {
        this.portsPerController = APIPort.getPortCount("A")
    } else {
        if (DC.controllers.B) {
            this.portsPerController = APIPort.getPortCount("B")
        } else {
            this.portsPerController = 4
        }
    }
    this.states = {
        incomplete: "incomplete",
        unchanged: "unchanged",
        newMap: "newMap",
        modified: "modified",
        deleted: "deleted"
    };
    this.idCol = 0;
    this.addIdCol = 1;
    this.mapIdCol = 2;
    this.stateCol = 3;
    this.actionCol = 4;
    this.hostCol = 5;
    this.volCol = 6;
    this.modeCol = 7;
    this.lunCol = 8;
    this.portsCol = 9;
    this.mappedIdCol = 10;
    this.volCountCol = 11;
    this.DEFAULTMODE = PORT_ACCESS.READ_WRITE;
    this.hybrid = false;
    var C = 0;
    for (var E in DC.ports) {
        if (C == 0) {
            C = DC.ports[E].get("port_type_numeric")
        } else {
            if (DC.ports[E].get("port_type_numeric") != C) {
                this.hybrid = true
            }
        }
    }
    this.portChanged = createObjectCallback(this, this._portChanged);
    this.accessChanged = createObjectCallback(this, this._accessChanged);
    var F = detectBrowser();
    var D = "center10";
    if (F.mozilla || F.safari) {
        D += " padRight15"
    }
    var G = 0;
    H.widgets = [new TextWidget({
        text: strings.mapAction.instructionMsg
    }), new TableWidget({
        classes: D,
        widgets: [new TextWidget({
            row: G,
            col: 0,
            text: strings.mapAction.hostsTopTitle,
            classes: "actionSubtitle"
        }), new TableInator({
            row: ++G,
            col: 0,
            name: "aMapHosts",
            width: 490,
            cellClasses: "verticalTop",
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this._initSelected),
            bottomMargin: true,
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "key",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.mapAction.hostGroupCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapAction.hostHostCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapAction.hostNickCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapAction.hostIdCol,
                bFilterMenu: true
            }],
            dtOptions: {
                bFilter: "noInput",
                iDisplayLength: 8,
                bLengthChange: false,
                aaSorting: [
                    [2, "asc"],
                    [3, "asc"],
                    [4, "asc"]
                ]
            }
        }), new TextWidget({
            row: 0,
            col: 1,
            text: strings.mapAction.volumesTopTitle,
            classes: "actionSubtitle",
            leftMargin: true
        }), new TableInator({
            row: G,
            col: 1,
            name: "aMapVolumes",
            width: 435,
            cellClasses: "verticalTop",
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this._volumeSelected),
            leftMargin: true,
            bottomMargin: true,
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "key",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.mapAction.volGroupCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapAction.volNameCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapAction.volTypeCol,
                bFilterMenu: true
            }],
            dtOptions: {
                bFilter: "noInput",
                iDisplayLength: 8,
                bLengthChange: false,
                aaSorting: [
                    [2, "asc"],
                    [3, "asc"]
                ]
            }
        }), new ButtonWidget({
            name: "mapButton",
            row: ++G,
            col: 0,
            colSpan: 2,
            classes: "aMapButton",
            text: strings.mapAction.mapButtonLabel,
            callback: createObjectCallback(this, this._map)
        }), this.mapsTable = new TableInator({
            row: ++G,
            col: 0,
            colSpan: 2,
            name: "aMapMaps",
            cellClasses: "verticalTop",
            type: "rawData",
            editCallback: createObjectCallback(this, this._mapEdited),
            metadata: [{
                sTitle: "id",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: "addID",
                bVisible: false
            }, {
                sTitle: "mapID",
                bVisible: false
            }, {
                sTitle: "state",
                bVisible: false
            }, {
                sTitle: strings.mapAction.mapActionCol,
                editable: createObjectCallback(this, this._actionOptions)
            }, {
                sTitle: strings.mapAction.mapHostCol
            }, {
                sTitle: strings.mapAction.mapVolCol
            }, {
                sTitle: strings.mapAction.mapModeCol,
                editable: {},
                bUseRendered: false,
                fnRender: createObjectCallback(this, this._accessOptions)
            }, {
                sTitle: strings.mapAction.mapLunCol,
                editable: {
                    rules: {
                        required: true,
                        range: [this.baseLun, system.maxLuns - 1]
                    }
                }
            }, {
                sTitle: strings.mapAction.mapPortsCol,
                bUseRendered: false,
                fnRender: createObjectCallback(this, this._portRenderer)
            }, {
                sTitle: "mappedId",
                bVisible: false
            }, {
                sTitle: "volCount",
                bVisible: false
            }],
            dtOptions: {
                bFilter: false,
                iDisplayLength: 10,
                bLengthChange: true,
                fnRowCallback: createObjectCallback(this, this._rowDrawCallback),
                aaSorting: []
            }
        })]
    })];
    ActionPanel.call(this, H);
    this.class_name = "MapAction";
    $("tbody", this.mapsTable.elements).on("click", "input.mapPortInput", this.portChanged);
    $("tbody", this.mapsTable.elements).on("change", "select.selectable", this.accessChanged)
}
MapAction.prototype = new ActionPanel();
MapAction.prototype.constructor = MapAction;
MapAction.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (propertyCount(DC.volumes) < 1) {
        return strings.menuTips.noItemsConfigured(strings.volumes)
    }
    if (currentTopic == "VolumesTopic") {
        E = TopicPanel.getSelected(["volumes"]);
        if (E) {
            for (var D = 0, C = E.length; D < C; D++) {
                var F = E[D].getObject();
                if (!F.isMappable()) {
                    return strings.menuTips.oneOrMore(strings.mappableVolumes)
                }
                if (F.get("storage_type_numeric") == STORAGE_CLASS.LINEAR && RI.pagedOnly()) {
                    return strings.menuTips.linearNotSupported
                }
                if ((F.getInt("cs_secondary_numeric") == 1) && (DC.virtualReplicationSetsSerial[F.get("replication_set")].getInt("status_numeric") != REP_STATUS.FAILEDOVER)) {
                    return strings.menuTips.cannotMapSecondaryVolume
                }
            }
            return E
        } else {
            return strings.menuTips.oneOrMore(strings.mappableVolumes)
        }
    } else {
        if (currentTopic == "HostsTopic") {
            E = TopicPanel.getSelected(["initiator"]);
            if (E) {
                return E
            } else {
                return strings.menuTips.oneOrMore(strings.initiators)
            }
        } else {
            if (currentTopic == "MappingTopic") {
                var E = TopicPanel.getSelected(["volume-view-mappings", "volume-group-view-mappings"]);
                if (E) {
                    return E
                } else {
                    return []
                }
            }
        }
    }
};
MapAction.prototype.showing = function() {
    this.selectedInits = [];
    this.selectedVolumes = [];
    this.defalutPorts = [];
    this.added = {};
    this.rowID = 1;
    this.pendingChanges = false;
    var D;
    this.okEnabled(false);
    this.applyEnabled(false);
    var C = "none";
    if (this.previousSelection.length > 0) {
        var E = this.previousSelection[0].basetype;
        if (E == "volumes" || E == "volume-groups") {
            C = "volumes"
        } else {
            if (E == "host-group" || E == "host" || E == "initiator") {
                C = "hosts"
            } else {
                if (E == "volume-view-mappings" || E == "volume-group-view-mappings") {
                    C = "maps"
                }
            }
        }
    }
    if (C == "volumes") {
        this.update({
            aMapHosts: {
                data: this._getInitData(),
                selectable: "multiple"
            },
            aMapVolumes: {
                data: this._getVolumeData(this.previousSelection),
                selectable: "multiple",
                select: this.previousSelection,
                selectable: true
            },
            aMapMaps: {
                data: []
            },
            mapButton: {
                disable: true,
                text: strings.mapAction.mapButtonLabel,
                tooltip: strings.mapAction.mapButtonTip
            }
        })
    } else {
        if (C == "hosts") {
            this.update({
                aMapHosts: {
                    data: this._getInitData(this.previousSelection),
                    selectable: "multiple",
                    select: this.previousSelection,
                    selectable: true
                },
                aMapVolumes: {
                    data: this._getVolumeData(),
                    selectable: "multiple"
                },
                aMapMaps: {
                    data: []
                },
                mapButton: {
                    disable: true,
                    text: strings.mapAction.mapButtonLabel,
                    tooltip: strings.mapAction.mapButtonTip
                }
            })
        } else {
            if (C == "maps") {
                this.update({
                    aMapHosts: {
                        data: this._getInitData(),
                        selectable: false
                    },
                    aMapVolumes: {
                        data: this._getVolumeData(),
                        selectable: false
                    },
                    aMapMaps: {
                        data: []
                    },
                    mapButton: {
                        disable: false,
                        text: strings.mapAction.resetButtonLabel,
                        tooltip: strings.mapAction.resetButtonTip
                    }
                });
                this._fillMapData(this.previousSelection)
            } else {
                this.update({
                    aMapHosts: {
                        data: this._getInitData(),
                        selectable: "multiple"
                    },
                    aMapVolumes: {
                        data: this._getVolumeData(),
                        selectable: "multiple"
                    },
                    aMapMaps: {
                        data: []
                    },
                    mapButton: {
                        disable: true,
                        text: strings.mapAction.mapButtonLabel,
                        tooltip: strings.mapAction.mapButtonTip
                    }
                })
            }
        }
    }
    this.previousSelection = []
};
MapAction.prototype.hiding = function() {};
MapAction.prototype._getInitData = RecoveryManager.prototype._getInitData = function(K) {
    var H = [];
    var N, O, L, I, F, C, M;
    var J = {};
    var E = {};
    H.push(["AOI", "AOI", "-", "-", "", strings.allOtherInits]);
    for (var D in DC.initiatorsId) {
        N = DC.initiatorsId[D];
        if (K) {
            var P = false;
            for (var G = 0; G < K.length; G++) {
                if (K[G].basetype == "initiator" && K[G].key == D) {
                    P = true;
                    break
                }
            }
            if (!P) {
                continue
            }
        }
        O = DC.hostsSerial[N.get("host_id")];
        I = O.get("durable_id");
        C = O.get("name");
        L = DC.hostGroupsSerial[O.get("host_group")];
        F = L.get("durable_id");
        M = L.get("name");
        if (F != "HGU" && !E[M]) {
            H.push(["host-group", F, M, "*", "*", "*"]);
            E[M] = true
        }
        if (I != "HU" && !J[C]) {
            H.push(["host", I, "-", C, "*", "*"]);
            J[C] = true
        }
        H.push(["initiator", N.get("durable_id"), (F == "HGU" ? "-" : M), (I == "HU" ? "-" : C), N.get("nickname"), N.get("id")])
    }
    return H
};
MapAction.prototype._getVolumeData = function(G) {
    var F = [];
    var D, I, L, M, J;
    var C = {};
    for (var L in DC.volumesSerial) {
        D = DC.volumesSerial[L];
        if (!D.isMappable()) {
            continue
        }
        if (D.get("cs_replication_role") == "Secondary") {
            var H = DC.virtualReplicationSetsSerial[D.get("replication_set")];
            if (H != undefined && H.get("status_numeric") != REP_STATUS.FAILEDOVER) {
                continue
            }
        }
        if (G) {
            var K = false;
            for (var E = 0; E < G.length; E++) {
                if (G[E].basetype == "volumes" && G[E].key == L) {
                    K = true;
                    break
                }
            }
            if (!K) {
                continue
            }
        }
        L = D.get("serial_number");
        I = DC.volumeGroupsSerial[D.get("volume_group")];
        M = I.get("serial_number");
        J = I.get("group_name");
        if (M != "UNGROUPEDVOLUMES" && !C[J]) {
            F.push(["volume-groups", M, J, "*", strings.mapAction.volumeGroup]);
            C[J] = true
        }
        F.push(["volumes", L, (M == "UNGROUPEDVOLUMES" ? "-" : J), D.get("volume_name"), D.get("volume_type")])
    }
    return F
};
MapAction.prototype._fillMapData = function(D) {
    var E = [];
    for (var F = 0; F < D.length; F++) {
        var C = D[F].getObject();
        if (!C) {
            continue
        }
        var J = C.get("mapped_id");
        if (J.indexOf("HG") == 0) {
            var G = new DCRef("host-group", J)
        } else {
            if (J.indexOf("H") == 0) {
                var G = new DCRef("host", J)
            } else {
                var G = new DCRef("initiator", J)
            }
        }
        var H = C.get("parent_id");
        var K = null;
        if (H.indexOf("VG") == 0) {
            K = DC.volumeGroupsId[H]
        } else {
            if (H.indexOf("V") == 0) {
                K = DC.volumesId[H]
            }
        }
        var I = new DCRef(K.basetype, K.getKeyValue());
        this._addMapRow(G, I, C)
    }
};
MapAction.prototype.cancelCallback = function() {
    this.close()
};
MapAction.prototype.applyCallback = function() {
    ShowActiveDialog({
        title: strings.mapAction.mapConfirmTitle,
        type: "confirm",
        message: this._getConfirmMsg(),
        ok: createObjectCallback(this, this.applyActions, false)
    })
};
MapAction.prototype.okCallback = function() {
    ShowActiveDialog({
        title: strings.mapAction.mapConfirmTitle,
        type: "confirm",
        message: this._getConfirmMsg(),
        ok: createObjectCallback(this, this.applyActions, true)
    })
};
MapAction.prototype._initSelected = RecoveryManager.prototype._initSelected = function(C) {
    this.selectedInits = C;
    if (this.selectedInits.length > 0 && this.selectedVolumes.length > 0) {
        this.update({
            mapButton: {
                disable: false
            }
        })
    } else {
        this.update({
            mapButton: {
                disable: true
            }
        })
    }
};
MapAction.prototype._volumeSelected = function(C) {
    this.selectedVolumes = C;
    if (this.selectedInits.length > 0 && this.selectedVolumes.length > 0) {
        this.update({
            mapButton: {
                disable: false
            }
        })
    } else {
        this.update({
            mapButton: {
                disable: true
            }
        })
    }
};
MapAction.prototype._map = RecoveryManager.prototype._map = function() {
    if (this.rowID > 1) {
        this.resetAction()
    } else {
        this._getMaps(true);
        this._setActionState();
        this.update({
            aMapHosts: {
                select: [],
                selectable: false
            },
            aMapVolumes: {
                select: [],
                selectable: false
            },
            mapButton: {
                disable: false,
                text: strings.mapAction.resetButtonLabel,
                tooltip: strings.mapAction.resetButtonTip
            }
        })
    }
    if (this instanceof RecoveryManager) {
        this.resetSize()
    }
};
MapAction.prototype._actionOptions = function(I, D, H) {
    var G = this.mapsTable.getData(I);
    var F = G[this.stateCol];
    var E = G[this.volCol];
    var C = [];
    switch (F) {
        case this.states.incomplete:
            break;
        case this.states.deleted:
            C = [strings.mapAction.actions.none, strings.mapAction.actions.del];
            break;
        case this.states.unchanged:
            C = [strings.mapAction.actions.none, strings.mapAction.actions.del];
            break;
        case this.states.modified:
            C = [strings.mapAction.actions.save, strings.mapAction.actions.revert];
            break;
        case this.states.newMap:
            C = [strings.mapAction.actions.save, strings.mapAction.actions.remove];
            break;
        default:
            break
    }
    return C
};
MapAction.prototype._accessOptions = RecoveryManager.prototype._accessOptions = function(G) {
    if (G.aData[this.stateCol] == this.states.incomplete) {
        return ""
    }
    var E = "";
    var C = "";
    var F = "";
    var D = "";
    if (G.aData[this.modeCol] == PORT_ACCESS.READ_WRITE) {
        var E = "selected"
    } else {
        if (G.aData[this.modeCol] == PORT_ACCESS.READ_ONLY) {
            var C = "selected"
        } else {
            var F = "selected"
        }
    }
    D += "<select class='selectable' name='modeCol'>";
    D += "<option value=" + PORT_ACCESS.READ_WRITE + " " + E + ">" + strings.read_write + "</option>";
    D += "<option value=" + PORT_ACCESS.READ_ONLY + " " + C + ">" + strings.read_only + "</option>";
    D += "<option value=" + PORT_ACCESS.NO_ACCESS + " " + F + ">" + strings.no_access + "</option>";
    D += "</select>";
    return D
};
MapAction.prototype._portRenderer = RecoveryManager.prototype._portRenderer = function(F) {
    if (F.aData[this.stateCol] == this.states.incomplete) {
        return ""
    }
    var J = "portR" + F.iDataRow + "P";
    var I = "";
    var D = system.physicalPositionOffset;
    var G = D + this.portsPerController;
    if (F.aData[this.modeCol] == PORT_ACCESS.NO_ACCESS) {
        var K = ' disabled="disabled"'
    } else {
        var K = ""
    }
    for (var H = 0, E = D; H < this.portsPerController; H++, E++) {
        var L = (F.aData[this.portsCol][H] ? "CHECKED" : "");
        var C = J + E;
        I += '<span class="mapPortLabel">' + E + "</span>";
        I += '<input class="mapPortInput" name="' + C + '" type="checkbox" value="' + H + '" ' + L + K + " />"
    }
    return I
};
MapAction.prototype._rowDrawCallback = RecoveryManager.prototype._rowDrawCallback = function(F, E, D, C) {
    if (E[this.stateCol] == this.states.incomplete) {
        $("td:eq(0)", F).removeClass("selectable");
        $("td:eq(3)", F).removeClass("selectable");
        $("td:eq(4)", F).removeClass("editable")
    } else {
        if (!$("td:eq(0)", F).hasClass("selectable")) {
            $("td:eq(0)", F).addClass("selectable");
            $("td:eq(3)", F).addClass("selectable");
            if (E[this.modeCol] == PORT_ACCESS.NO_ACCESS) {
                $("td:eq(4)", F).removeClass("editable")
            } else {
                $("td:eq(4)", F).addClass("editable")
            }
        }
    }
    return F
};
MapAction.prototype._portChanged = RecoveryManager.prototype._portChanged = function(F) {
    var D = F.currentTarget.value;
    mcDebug("map", "Port %s changed", D);
    var C = $(F.currentTarget).closest("tr");
    var G = this.mapsTable.dataTable.fnGetPosition(C.get(0));
    var E = this.mapsTable.getData(G);
    if ($(F.currentTarget).prop("checked")) {
        E[this.portsCol][D] = true;
        if (this.hybrid) {
            if (D >= 2) {
                E[this.portsCol][0] = false;
                E[this.portsCol][1] = false
            } else {
                E[this.portsCol][2] = false;
                E[this.portsCol][3] = false
            }
            this.mapsTable.updateData(E[this.portsCol], G, this.portsCol, "keepPage")
        }
    } else {
        E[this.portsCol][F.currentTarget.value] = false
    }
    this._mapEdited(G, this.portsCol)
};
MapAction.prototype._accessChanged = RecoveryManager.prototype._accessChanged = function(F) {
    var D = F.currentTarget.value;
    var C = $(F.currentTarget).closest("tr");
    var G = this.mapsTable.dataTable.fnGetPosition(C.get(0));
    var E = this.mapsTable.getData(G);
    E[this.modeCol] = D;
    this.mapsTable.updateData(E[this.modeCol], G, this.modeCol, "keepPage");
    this._mapEdited(G, this.modeCol)
};
MapAction.prototype._getMaps = RecoveryManager.prototype._getMaps = function(P) {
    var J = [];
    var C = this.selectedVolumes.length;
    var L = this._getPreSelectPorts(this.selectedInits, this.selectedVolumes);
    for (var K = 0; K < C; K++) {
        var H = this.selectedVolumes[K].getObject();
        if (!H) {
            continue
        }
        var D = [];
        if (H.mapView) {
            D = H.mapView.objects
        }
        var N = {};
        for (var I = 0; I < D.length; I++) {
            var E = D[I];
            if (E.get("mapped_id") == "AOI" && E.getInt("access_numeric") == 0) {
                continue
            }
            N[D[I].get("mapped_id")] = E;
            if (E.get("mapped_id") == "AOI") {
                var O = E.getInt("lun")
            }
        }
        for (var G = 0; G < this.selectedInits.length; G++) {
            var M;
            for (var F = 0; F < L.length; F++) {
                if (L[F].selVolume == this.selectedVolumes[K].key && L[F].key == this.selectedInits[G].key) {
                    M = L[F].ports;
                    break
                }
            }
            if (N[this.selectedInits[G].key]) {
                this._addMapRow(this.selectedVolumes[K], this.selectedInits[G], N[this.selectedInits[G].key], M)
            } else {
                if (P) {
                    this._addMapRow(this.selectedVolumes[K], this.selectedInits[G], null, O, M)
                }
            }
        }
    }
    return J
};
MapAction.prototype._getPreSelectPorts = RecoveryManager.prototype._getPreSelectPorts = function(I, C) {
    var L = [];
    if (I) {
        for (var F = 0; F < C.length; F++) {
            for (var K = 0; K < I.length; K++) {
                var E = I[K].key;
                var M = [];
                if (E == "AOI") {
                    for (var J = 0; J < this.portsPerController; J++) {
                        M.push(true)
                    }
                    L.push({
                        key: E,
                        selVolume: C[F].key,
                        ports: M
                    });
                    break
                } else {
                    if (E.indexOf("I") != -1) {
                        for (var D in DC.initiatorsId) {
                            var Q = DC.initiatorsId[D];
                            if (typeof Q != "undefined" && Q.get("durable_id") == E) {
                                if (this.hybrid) {
                                    if (Q.getInt("host_bus_type_numeric") == PORT_TYPES.FC) {
                                        for (var J = 0; J < 2; J++) {
                                            M.push(true)
                                        }
                                        for (var H = 2; H < this.portsPerController; H++) {
                                            M.push(false)
                                        }
                                    } else {
                                        for (var J = 0; J < 2; J++) {
                                            M.push(false)
                                        }
                                        for (var H = 2; H < this.portsPerController; H++) {
                                            M.push(true)
                                        }
                                    }
                                } else {
                                    for (var J = 0; J < this.portsPerController; J++) {
                                        M.push(true)
                                    }
                                }
                                L.push({
                                    key: E,
                                    selVolume: C[F].key,
                                    ports: M
                                });
                                break
                            }
                        }
                    } else {
                        if (E.indexOf("HG") != -1) {
                            var N = I[K].getObject().objects;
                            var P = [];
                            for (var K = 0; K < N.length; K++) {
                                P = P.concat(N[K].objects)
                            }
                        } else {
                            var P = I[K].getObject().objects
                        }
                        var G = false;
                        var O = P[0].getInt("host_bus_type_numeric");
                        for (var K = 1; K < P.length; K++) {
                            var Q = P[K];
                            if (Q.getInt("host_bus_type_numeric") != O) {
                                G = true
                            }
                        }
                        if (this.hybrid) {
                            if (G) {
                                for (var J = 0; J < this.portsPerController; J++) {
                                    M.push(true)
                                }
                            } else {
                                if (O == PORT_TYPES.FC) {
                                    for (var J = 0; J < 2; J++) {
                                        M.push(true)
                                    }
                                    for (var H = 2; H < this.portsPerController; H++) {
                                        M.push(false)
                                    }
                                } else {
                                    for (var J = 0; J < 2; J++) {
                                        M.push(false)
                                    }
                                    for (var H = 2; H < this.portsPerController; H++) {
                                        M.push(true)
                                    }
                                }
                            }
                        } else {
                            for (var J = 0; J < this.portsPerController; J++) {
                                M.push(true)
                            }
                        }
                        L.push({
                            key: E,
                            selVolume: C[F].key,
                            ports: M
                        })
                    }
                }
                if (L.length == 0) {
                    for (var J = 0; J < this.portsPerController; J++) {
                        M.push(true)
                    }
                    L.push({
                        key: E,
                        selVolume: C[F].key,
                        ports: M
                    });
                    break
                }
            }
        }
    }
    return L
};
MapAction.prototype._addMapRow = RecoveryManager.prototype._addMapRow = function(G, S, N, I, M) {
    var O = G.makeID();
    var L = this.rowID++;
    var P = [L, O, "", "", "", "", "", "", "", ""];
    if (G.basetype == "volume-groups" || G.basetype == "volumes") {
        var K = "VOLUME"
    } else {
        var K = "HOST"
    }
    var J = G.getObject();
    this._fillMapSpec(P, J);
    if (!S) {
        P[this.stateCol] = this.states.incomplete;
        P[this.actionCol] = strings.mapAction.actions.notMapped;
        this.added[O] = L
    } else {
        var F = S.makeID();
        if (!this.added[O]) {
            this.added[O] = {}
        }
        var H = S.getObject();
        this._fillMapSpec(P, H);
        P[this.mapIdCol] = F;
        if (K == "HOST") {
            var D = G.key;
            var E = 1;
            if (H instanceof APIVolumeGroups) {
                var E = H.objects.length
            }
        } else {
            var D = S.key;
            var E = 1;
            if (J instanceof APIVolumeGroups) {
                var E = J.objects.length
            }
        }
        if (N) {
            P[this.stateCol] = this.states.unchanged;
            P[this.actionCol] = strings.mapAction.actions.none;
            var M = getPortUsage(N.get("ports"));
            if (N.prop.lun != undefined) {
                var R = N.get("lun")
            } else {
                if (N.objects && N.objects[0]) {
                    var R = N.objects[0].get("lun")
                } else {
                    var R = "*"
                }
            }
            var C = {
                mode: N.getInt("access_numeric"),
                lun: R,
                ports: M,
                mapObject: N
            };
            P[this.modeCol] = C.mode;
            P[this.lunCol] = C.lun;
            P[this.portsCol] = C.ports.slice(0);
            P[this.mappedIdCol] = D;
            P[this.volCountCol] = E;
            this.added[O][F] = C
        } else {
            P[this.stateCol] = this.states.newMap;
            P[this.actionCol] = strings.mapAction.actions.save;
            P[this.modeCol] = this.DEFAULTMODE;
            P[this.lunCol] = this._findAvailLun(L, D, P[this.volCol], M, E, I);
            P[this.portsCol] = M.slice(0);
            P[this.mappedIdCol] = D;
            P[this.volCountCol] = E;
            this.added[O][F] = "new"
        }
    }
    var Q = this.mapsTable.addData(P);
    if (P[this.modeCol] == PORT_ACCESS.NO_ACCESS) {
        this.mapsTable.removeCellClass(Q[0], this.lunCol, "editable")
    }
};
MapAction.prototype._fillMapSpec = RecoveryManager.prototype._fillMapSpec = function(D, E) {
    if (!E) {
        D[this.hostCol] = strings.allOtherInits;
        return
    }
    switch (E.basetype) {
        case "host-group":
            D[this.hostCol] = E.get("name") + ".*.*";
            break;
        case "host":
            D[this.hostCol] = E.get("name") + ".*";
            break;
        case "initiator":
            var C = E.get("nickname");
            if (C) {
                D[this.hostCol] = C
            } else {
                D[this.hostCol] = E.get("id")
            }
            break;
        case "volume-groups":
            D[this.volCol] = E.get("group_name") + ".*";
            break;
        case "volumes":
            D[this.volCol] = E.get("volume_name");
            break;
        default:
            return;
            break
    }
};
MapAction.prototype._mapChanged = function(G) {
    var E = this.mapsTable.getData(G);
    var F = null;
    var C = E[this.addIdCol];
    if (E[this.mapIdCol]) {
        F = this.added[C][E[this.mapIdCol]]
    }
    if (!F) {
        return false
    }
    if (E[this.modeCol] != F.mode) {
        return true
    }
    if (E[this.lunCol] != F.lun) {
        return true
    }
    var H = E[this.portsCol];
    for (var D = 0; D < this.portsPerController; D++) {
        if ((H[D] && !F.ports[D]) || (!H[D] && F.ports[D])) {
            return true
        }
    }
    return false
};
MapAction.prototype._mapEdited = RecoveryManager.prototype._mapEdited = function(P, E) {
    var G = this.mapsTable.getData(P);
    var C = G[this.stateCol];
    var I = C;
    var M = G[this.addIdCol];
    var F = G[this.mapIdCol];
    if (E == this.actionCol) {
        var H = G[this.actionCol];
        switch (C) {
            case this.states.unchanged:
                if (H == strings.mapAction.actions.del) {
                    I = this.states.deleted
                }
                break;
            case this.states.newMap:
                if (H == strings.mapAction.actions.remove) {
                    this.mapsTable.dataTable.fnDeleteRow(P);
                    if (F) {
                        delete this.added[M][F]
                    } else {
                        delete this.added[M]
                    }
                    return true
                }
                break;
            case this.states.modified:
                if (H == strings.mapAction.actions.revert) {
                    var M = G[this.addIdCol];
                    var F = G[this.mapIdCol];
                    var K = this.added[M][F];
                    G[this.modeCol] = K.mode;
                    G[this.lunCol] = K.lun;
                    for (var J = 0; J < this.portsPerController; J++) {
                        G[this.portsCol][J] = K.ports[J]
                    }
                    I = this.states.unchanged;
                    G[this.actionCol] = strings.mapAction.actions.none;
                    if (G[this.modeCol] == PORT_ACCESS.NO_ACCESS) {
                        this.mapsTable.removeCellClass(P, this.lunCol, "editable")
                    } else {
                        this.mapsTable.addCellClass(P, this.lunCol, "editable")
                    }
                }
                break;
            case this.states.deleted:
                if (H == strings.mapAction.actions.none) {
                    I = this.states.unchanged
                }
                break;
            default:
                break
        }
    } else {
        var N = false;
        if (E == this.lunCol || E == this.portsCol) {
            N = true;
            var D = G[this.lunCol];
            if (D == "*") {
                D = undefined
            }
        } else {
            if (E == this.modeCol) {
                if (G[this.modeCol] == PORT_ACCESS.NO_ACCESS) {
                    G[this.lunCol] = "";
                    this.mapsTable.updateData(G[this.lunCol], P, this.lunCol, "keepPage");
                    this.mapsTable.removeCellClass(P, this.lunCol, "editable");
                    G[this.portsCol] = [false, false, false, false]
                } else {
                    if (G[this.lunCol] == "") {
                        if (this.added[M][F] != "new" && this.added[M][F].mode != PORT_ACCESS.NO_ACCESS) {
                            var D = this.added[M][F].lun;
                            G[this.portsCol] = this.added[M][F].ports.slice(0)
                        } else {
                            G[this.portsCol] = this._getSelectedPortsForInit(G[this.mappedIdCol])
                        }
                        N = true;
                        this.mapsTable.addCellClass(P, this.lunCol, "editable")
                    }
                }
            }
        }
        if (N) {
            var O = this._findAvailLun(G[this.idCol], G[this.mappedIdCol], G[this.volCol], G[this.portsCol], G[this.volCountCol], D);
            if (O != G[this.lunCol] && O != "-") {
                G[this.lunCol] = O;
                this.mapsTable.updateData(O, P, this.lunCol, "keepPage");
                if (E != this.modeCol) {
                    this.mapsTable.cellAdjusted(P, this.lunCol, strings.mapAction.lunChanged)
                }
            } else {
                this.mapsTable.cellAdjusted(P, this.lunCol, "")
            }
        }
        if (E == this.modeCol) {
            this.mapsTable.updateData(G[this.portsCol], P, this.portsCol, "keepPage")
        }
        if (C != this.states.newMap) {
            if (this._mapChanged(P)) {
                I = this.states.modified
            } else {
                I = this.states.unchanged
            }
        }
    }
    var L = this.mapsTable.dataTable.fnGetNodes(P);
    $(L).removeClass("edited");
    if (I != C) {
        G[this.stateCol] = I;
        if (I == this.states.modified) {
            G[this.actionCol] = strings.mapAction.actions.save
        } else {
            if (I == this.states.unchanged) {
                G[this.actionCol] = strings.mapAction.actions.none
            }
        }
        this.mapsTable.updateData(G, P, -1, "keepPage")
    }
    this._setActionState();
    return false
};
MapAction.prototype._getSelectedPortsForInit = function(G) {
    var F = [];
    if (this.hybrid) {
        var E = false;
        for (var I in DC.initiatorsId) {
            var H = DC.initiatorsId[I];
            if (typeof H != "undefined" && H.get("durable_id") == G) {
                E = true;
                if (H.getInt("host_bus_type_numeric") == PORT_TYPES.ISCSI) {
                    for (var D = 0; D < 2; D++) {
                        F.push(false)
                    }
                    for (var C = 2; C < this.portsPerController; C++) {
                        F.push(true)
                    }
                } else {
                    if (H.getInt("host_bus_type_numeric") == PORT_TYPES.FC) {
                        for (var D = 0; D < 2; D++) {
                            F.push(true)
                        }
                        for (var C = 2; C < this.portsPerController; C++) {
                            F.push(false)
                        }
                    }
                }
                break
            }
        }
        if (!E) {
            for (var D = 0; D < 2; D++) {
                F.push(true)
            }
            for (var C = 2; C < this.portsPerController; C++) {
                F.push(false)
            }
        }
    } else {
        for (var D = 0; D < this.portsPerController; D++) {
            F.push(true)
        }
    }
    return F
};
MapAction.prototype._getConfirmMsg = function() {
    var M = this.mapsTable.getData();
    var H = 0;
    var I = 0;
    var E = 0;
    var O = false;
    for (var G = 0; G < M.length; G++) {
        var F = M[G][this.actionCol];
        switch (F) {
            case strings.mapAction.actions.del:
                H++;
                break;
            case strings.mapAction.actions.save:
                var C = M[G][this.stateCol];
                var L = M[G][this.hostCol];
                if (C == this.states.newMap) {
                    I++;
                    if (L == strings.allOtherInits) {
                        O = true
                    }
                } else {
                    E++
                }
                break;
            default:
                break
        }
    }
    var J = false;
    var D = strings.mapAction.confirmPrefix;
    var K = strings.mapAction.confirmMsgDelete;
    var N = strings.mapAction.confirmMultHosts;
    D += "<br />";
    if (I > 0) {
        if ((I > 1) || O) {
            D = N + D + strings.mapAction.confirmAdds(I) + "<br />"
        } else {
            D += strings.mapAction.confirmAddOne(I)
        }
        J = true
    }
    if (H > 0) {
        if (J) {
            D += ", "
        }
        if (H > 1) {
            D += strings.mapAction.confirmDeletes(H)
        } else {
            D += strings.mapAction.confirmDeleteOne(H)
        }
        D = K + D;
        J = true
    }
    if (E > 0) {
        if (J) {
            D += ", "
        }
        if (E > 1) {
            D += strings.mapAction.confirmModifies(E)
        } else {
            D += strings.mapAction.confirmModifyOne(E)
        }
    }
    return D
};
MapAction.prototype.applyActions = RecoveryManager.prototype.mapVolume = function(L) {
    var K = this.mapsTable.getData();
    var E = [];
    var G = 1;
    var N;
    var M = this.isLunOverLapWithDefault();
    for (var H = 0; H < K.length; H++) {
        var I = K[H];
        var F = I[this.actionCol];
        var J = I[this.hostCol];
        var C = I[this.volCol];
        var D = getPorts(I[this.portsCol]);
        if (I[this.lunCol] != "") {
            N = I[this.lunCol]
        } else {
            N = undefined
        }
        switch (F) {
            case strings.mapAction.actions.del:
                mcDebug("map", "Deleting map for volume %s, host %s.", I[this.volCol], I[this.hostCol]);
                E.push({
                    name: "mapCmd" + G + "Delete",
                    command: MC.unmapVolume,
                    data: {
                        volumeName: C,
                        host: (J == strings.allOtherInits ? null : J)
                    },
                    options: {
                        processingMsg: strings.mapAction.deleteProcessingMsg(J, C),
                        failureMsg: strings.mapAction.deleteFailMsg(J, C)
                    }
                });
                break;
            case strings.mapAction.actions.save:
                mcDebug("map", "Saving map for volume %s, host %s.", I[this.volCol], I[this.hostCol]);
                E.push({
                    name: "mapCmd" + G + "Save",
                    command: MC.mapVolume,
                    data: {
                        volumeName: C,
                        host: (J == strings.allOtherInits ? null : J),
                        lun: N,
                        access: PORT_ACCESS.CLI[I[this.modeCol]],
                        ports: D
                    },
                    options: {
                        processingMsg: strings.mapAction.mapProcessingMsg(J, C),
                        failureMsg: strings.mapAction.mapFailMsg(J, C)
                    }
                });
                break;
            default:
                mcDebug("map", "Ignoring map for volume %s, host %s.", I[this.volCol], I[this.hostCol]);
                break
        }
        G++
    }
    if (E.length > 0) {
        MC.execCommandList(E, {
            callback: createObjectCallback(this, this._commandsComplete, L),
            successMsg: strings.mapAction.mappingSucceeded,
            confirmMsg: M == true ? strings.mapAction.lunUsedConfirmMsg : ""
        })
    }
};
MapAction.prototype._commandsComplete = function(D, C) {
    if (C.success) {
        if (D) {
            this.close()
        } else {
            this.resetAction()
        }
    }
};
MapAction.prototype._setActionState = RecoveryManager.prototype._setActionState = function() {
    this.pendingChanges = false;
    var E = this.mapsTable.getData();
    var F = this.mapsTable.getErrorCount();
    for (var C = 0; C < E.length; C++) {
        var D = E[C][this.actionCol];
        if (D == strings.mapAction.actions.save || D == strings.mapAction.actions.del) {
            this.pendingChanges = true;
            break
        }
    }
    if (this.pendingChanges && F == 0) {
        this.okEnabled(true);
        this.applyEnabled(true)
    } else {
        this.okEnabled(false);
        if (this instanceof MapAction) {
            this.applyEnabled(false)
        }
    }
};
MapAction.prototype.resetAction = function() {
    this.showing()
};
MapAction.prototype._findAvailLun = RecoveryManager.prototype._findAvailLun = function(R, H, D, M, L, N) {
    var a = new Array();
    var P = system.maxLuns || 1024;
    if (N != undefined && (N < 0 || N >= P)) {
        return "-"
    }
    for (var Z = 0; Z < P; Z++) {
        a[Z] = false
    }
    if (H == "AOI") {
        for (var C in DC.volGroupMapsId) {
            var c = DC.volGroupMapsId[C];
            if (c.get("mapped_id") != "AOI") {
                continue
            }
            var F = getPortUsage(c.get("ports"));
            if (c.parentObject.get("group_name") != D && this.comparePortUsage(M, F)) {
                for (var W = 0; W < c.objects.length; W++) {
                    a[c.objects[W].get("lun")] = true
                }
            }
        }
        for (var C in DC.volMapsId) {
            var c = DC.volMapsId[C];
            if (c.get("mapped_id") != "AOI") {
                continue
            }
            var F = getPortUsage(c.get("ports"));
            if (c.parentObject.get("volume_name") != D && this.comparePortUsage(M, F)) {
                a[c.get("lun")] = true
            }
        }
        var U = this.mapsTable.getData();
        for (var Z = 0; Z < U.length; Z++) {
            var Q = U[Z];
            var X = Q[this.lunCol];
            if (X == "") {
                continue
            }
            if (Q[this.idCol] != R && Q[this.mappedIdCol] == "AOI" && Q[this.volCol] != D) {
                var b = Q[this.portsCol];
                if (this.comparePortUsage(M, b)) {
                    var S = Q[this.volCountCol];
                    for (W = 0; W < S; W++) {
                        a[X++] = true
                    }
                }
            }
        }
    } else {
        var J = [];
        if (H.indexOf("HG") == 0) {
            var O = DC.hostGroupsId[H];
            if (!O) {
                return "-"
            }
            J.push(O);
            for (var H in O.hostsId) {
                var T = DC.hostsId[H];
                if (!T) {
                    return "-"
                }
                J.push(T);
                for (var I in T.initiatorsId) {
                    J.push(DC.initiatorsId[I])
                }
            }
        } else {
            if (H.indexOf("H") == 0) {
                var T = DC.hostsId[H];
                if (!T) {
                    return "-"
                }
                J.push(T);
                if (T.parentObject.get("durable_id") != "HGU") {
                    J.push(T.parentObject)
                }
                for (var I in T.initiatorsId) {
                    J.push(DC.initiatorsId[I])
                }
            } else {
                var Y = DC.initiatorsId[H];
                if (!Y) {
                    return "-"
                }
                J.push(Y);
                if (Y.parentObject.get("durable_id") != "HU") {
                    var T = Y.parentObject;
                    J.push(T);
                    if (T.parentObject.get("durable_id") != "HGU") {
                        J.push(T.parentObject)
                    }
                }
            }
        }
        for (var Z = 0; Z < J.length; Z++) {
            this.markLunsUsed(J[Z], D, M, a)
        }
        var U = this.mapsTable.getData();
        for (var Z = 0; Z < U.length; Z++) {
            var Q = U[Z];
            var X = Q[this.lunCol];
            if (X == "") {
                continue
            }
            if (Q[this.idCol] != R && Q[this.mappedIdCol] != "AOI" && Q[this.volCol] != D) {
                var b = Q[this.portsCol];
                if (this.comparePortUsage(M, b)) {
                    var S = Q[this.volCountCol];
                    for (W = 0; W < S; W++) {
                        a[X++] = true
                    }
                }
            }
        }
    }
    if (N == undefined) {
        var G = this.baseLun
    } else {
        var G = N
    }
    var Z = parseInt(G, 10);
    var E = P;
    while (Z < E) {
        if (a[Z] === false) {
            var V = Z + L;
            if (V > P) {
                return "-"
            }
            var K = true;
            for (var W = Z + 1; W < V; W++) {
                if (a[W] !== false) {
                    K = false;
                    break
                }
            }
            if (K) {
                return Z.toString()
            }
        }
        Z++;
        if (Z == P && G != this.baseLun) {
            Z = this.baseLun;
            E = G
        }
    }
    return "-"
};
MapAction.prototype.markLunsUsed = RecoveryManager.prototype.markLunsUsed = function(I, C, F, G) {
    if (!I || !G || !(G instanceof Array)) {
        return
    }
    if (I.groupMaps) {
        for (var E in I.groupMaps) {
            var H = I.groupMaps[E];
            var J = getPortUsage(H.get("ports"));
            if (H.parentObject.get("group_name") != C && this.comparePortUsage(F, J)) {
                for (var D = 0; D < H.objects.length; D++) {
                    G[H.objects[D].get("lun")] = true
                }
            }
        }
    }
    if (I.maps) {
        for (var E in I.maps) {
            var H = I.maps[E];
            var J = getPortUsage(H.get("ports"));
            if (H.parentObject.get("volume_name") != C && this.comparePortUsage(F, J)) {
                G[H.get("lun")] = true
            }
        }
    }
};
MapAction.prototype.comparePortUsage = RecoveryManager.prototype.comparePortUsage = function(E, D) {
    if (!E || !D) {
        return false
    }
    if (D.length < E.length) {
        var F = D.length
    } else {
        var F = E.length
    }
    for (var C = 0; C < F; C++) {
        if (E[C] && D[C]) {
            return true
        }
    }
    return false
};
MapAction.prototype.isLunOverLapWithDefault = function() {
    var L = this.mapsTable.getData();
    var I = [];
    var H = [];
    var C = false;
    for (var F = 0; F < L.length; F++) {
        if (L[F][this.actionCol] == strings.mapAction.actions.del && L[F][this.mappedIdCol] == "AOI") {
            if (L[F][this.modeCol] == PORT_ACCESS.NO_ACCESS || L[F][this.lunCol] == "") {
                I.push(getBaseLUN())
            } else {
                if (DC.volumes[L[F][this.volCol]] !== undefined) {
                    I.push(L[F][this.lunCol] == "" ? getBaseLUN() : parseInt(L[F][this.lunCol]))
                } else {
                    var K = L[F][this.volCol].replace(".*", "");
                    var N = DC.volumeGroups[K].getPropertyValue("durable_id");
                    for (var E = 0; E < DC.volGroupViewsId[N].objects.length; E++) {
                        for (var D = 0; D < DC.volGroupViewsId[N].objects[E].objects.length; D++) {
                            I.push(parseInt(DC.volGroupViewsId[N].objects[E].objects[D].prop.lun.text))
                        }
                    }
                }
            }
        } else {
            if (L[F][this.actionCol] == strings.mapAction.actions.save && L[F][this.mappedIdCol] !== "AOI") {
                var J = getInitiatorIds(L[F][this.hostCol]);
                for (var E = 0; E < J.length; E++) {
                    if (DC.volumes[L[F][this.volCol]] !== undefined) {
                        H.push({
                            volume_serial: DC.volumes[L[F][this.volCol]].prop.serial_number.text,
                            host: J[E],
                            lun: L[F][this.lunCol] == "" ? getBaseLUN() : L[F][this.lunCol],
                            volumeGroup_Serial: DC.volumes[L[F][this.volCol]].prop.volume_group.text != "UNGROUPEDVOLUMES" ? DC.volumes[L[F][this.volCol]].prop.volume_group.text : null,
                            access_numeric: L[F][this.modeCol],
                            ports: L[F][this.modeCol] == PORT_ACCESS.NO_ACCESS ? [] : getPorts(L[F][this.portsCol])
                        })
                    } else {
                        if (DC.volumes[L[F][this.volCol]] === undefined) {
                            var K = L[F][this.volCol].replace(".*", "");
                            var M = L[F][this.lunCol];
                            for (var G = 0; G < DC.volumeGroups[K].objects.length; G++) {
                                H.push({
                                    volume_serial: DC.volumeGroups[K].objects[G].prop.serial_number.text,
                                    host: J[E],
                                    lun: L[F][this.lunCol] == "" ? getBaseLUN() : M,
                                    volumeGroup_Serial: DC.volumeGroups[K].prop.serial_number.text,
                                    access_numeric: L[F][this.modeCol],
                                    ports: L[F][this.modeCol] == PORT_ACCESS.NO_ACCESS ? null : getPorts(L[F][this.portsCol])
                                });
                                if (L[F][this.modeCol] != PORT_ACCESS.NO_ACCESS) {
                                    M++
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    if (H.length == 0) {
        return C
    }
    C = IsLunUsed(H, I);
    return C
};

function MapDetailAction(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "MapDetailAction";
    C.okCallback = createObjectCallback(this, this._okCallback);
    C.widgets = [new WidgetContainer({
        widgets: [new TableInator({
            name: "aMapDetail",
            minWidth: 650,
            cellClasses: "verticalTop",
            displayLength: 20,
            type: "rawData",
            metadata: [{
                sTitle: strings.mapDetailAction.hostGroupCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.hostCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.nickCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.idCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.volGroupCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.volumeCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.accessCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.lunCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mapDetailAction.portsCol,
                bFilterMenu: true
            }],
            dtOptions: {
                bLengthChange: false,
                aaSorting: [
                    [7, "asc"]
                ]
            }
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "MapDetailAction"
}
MapDetailAction.prototype = new ActionPanel();
MapDetailAction.prototype.constructor = MapDetailAction;
MapDetailAction.getMenuState = function() {
    var C = TopicPanel.getSelected(["volume-group-view-mappings", "volume-view-mappings"]);
    if (C) {
        return C
    } else {
        return strings.menuTips.oneOrMore(strings.maps)
    }
};
MapDetailAction.prototype.showing = function() {
    var M = [];
    var I, U, S, E, D, H, F;
    var C = [];
    var T = this.previousSelection.length;
    for (var R = 0; R < T; R++) {
        I = this.previousSelection[R];
        mcDebug("map", "Doing map %s", I.key);
        U = I.getObject();
        if (!U) {
            continue
        }
        C.empty();
        S = U.get("mapped_id");
        if (S == "AOI") {
            C.push(["-", "-", "-", strings.allOtherInits])
        } else {
            if (S.indexOf("HG") == 0) {
                E = DC.hostGroupsId[S];
                var J = E.get("name");
                for (var K in E.hosts) {
                    D = E.hosts[K];
                    var G = D.get("name");
                    for (var Q in D.initiators) {
                        H = D.initiators[Q];
                        C.push([J, G, H.get("nickname"), H.get("id")])
                    }
                }
            } else {
                if (S.indexOf("H") == 0) {
                    D = DC.hostsId[S];
                    var G = D.get("name");
                    for (var Q in D.initiators) {
                        H = D.initiators[Q];
                        C.push(["-", G, H.get("nickname"), H.get("id")])
                    }
                } else {
                    H = DC.initiatorsId[S];
                    if (!H) {
                        continue
                    }
                    C.push(["-", "-", H.get("nickname"), H.get("id")])
                }
            }
        }
        if (U instanceof APIVolumeViewMappings) {
            for (var O = 0; O < C.length; O++) {
                C[O].push("-");
                C[O].push(U.parentObject.get("volume_name"));
                C[O].push(U.get("access"));
                C[O].push(U.get("lun"));
                C[O].push(U.get("ports"));
                M.push(C[O])
            }
            continue
        } else {
            for (var O = 0; O < C.length; O++) {
                C[O].push(U.parentObject.get("group_name"));
                C[O].push("*");
                C[O].push(U.get("access"));
                C[O].push("*");
                C[O].push(U.get("ports"));
                for (var N = 0; N < U.objects.length; N++) {
                    var P = C[O].slice(0);
                    var L = U.objects[N];
                    P[5] = L.get("volume_name");
                    P[7] = L.get("lun");
                    M.push(P)
                }
            }
        }
    }
    this.update({
        aMapDetail: {
            data: M
        }
    });
    this.okEnabled(true)
};
MapDetailAction.prototype._okCallback = function() {
    this.close()
};

function RemoveMappings(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveMappings";
    C.width = 500;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "infoTxt",
        text: strings.mapAction.removeInfo,
        bottomMargin: true
    }), this.table = new TableWidget({
        width: 480,
        maxCols: 2,
        widgets: [new TextWidget({
            name: "hostLabel",
            text: strings.mappingTopic.hostCol,
            cssClass: "hoverSectionLabel"
        }), new TextWidget({
            name: "volumeLabel",
            text: strings.mappingTopic.volumeCol,
            cssClass: "hoverSectionLabel"
        }), new ContentHorizontalRule({
            colSpan: 2
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveMappings"
}
RemoveMappings.prototype = new ActionPanel();
RemoveMappings.prototype.constructor = RemoveMappings;
RemoveMappings.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    var C = TopicPanel.getSelected(["volume-group-view-mappings", "volume-view-mappings"]);
    if (C) {
        return C
    } else {
        return strings.menuTips.oneOrMore(strings.maps)
    }
};
RemoveMappings.prototype.showing = function() {
    var H = this.previousSelection;
    var E = this.previousSelection.length;
    for (var G = 0; G < E; G++) {
        var C = H[G].getObject();
        if (C instanceof APIVolumeGroupViewMappings) {
            var D = new TextWidget({
                text: C.parentObject.get("group_name"),
                bottomSmallMargin: true
            })
        } else {
            var D = new TextWidget({
                text: C.parentObject.get("volume_name"),
                bottomSmallMargin: true
            })
        }
        var F = new TextWidget({
            text: C.getHostName(),
            bottomSmallMargin: true
        });
        this.table.add(F);
        this.table.add(D)
    }
    this.okEnabled(true)
};
RemoveMappings.prototype.okCallback = function() {
    var H = {};
    var C = [];
    var G = 1;
    var J = this.previousSelection;
    var D = this.previousSelection.length;
    for (var I = 0; I < D; I++) {
        var E = J[I].getObject();
        var K = E.getHostName();
        if (E instanceof APIVolumeGroupViewMappings) {
            var F = E.parentObject.get("group_name")
        } else {
            var F = E.parentObject.get("volume_name")
        }
        C.push({
            name: "mapDelete" + G,
            command: MC.unmapVolume,
            data: {
                volumeName: F,
                host: (K == strings.allOtherInits ? null : K)
            },
            options: {
                processingMsg: strings.mapAction.deleteProcessingMsg(K, F),
                failureMsg: strings.mapAction.deleteFailMsg(K, F)
            }
        });
        G++
    }
    MC.execCommandList(C, {
        callback: this.close(),
        confirmMsg: strings.mapAction.confirmDeleteMessage,
        successMsg: strings.mapAction.successDelete
    })
};

function RemoveAllMappings(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RemoveAllMappings";
    C.width = 300;
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.widgets = [new TextWidget({
        name: "infoTxt",
        text: strings.mapAction.infoTxt
    })];
    ActionPanel.call(this, C);
    this.class_name = "RemoveAllMappings"
}
RemoveAllMappings.prototype = new ActionPanel();
RemoveAllMappings.prototype.constructor = RemoveAllMappings;
RemoveAllMappings.getMenuState = function() {
    if (!session.hasConfigurationCapability()) {
        return false
    }
    if (MC.mapsSet.data.objects.length) {
        var D = MC.mapsSet.data.objects;
        for (var F = 0; F < D.length; F++) {
            var G = D[F].objects;
            for (var E = 0; E < G.length; E++) {
                var C = G[E];
                if (C.getInt("access_numeric") != 0) {
                    return []
                }
            }
        }
    }
    return strings.mapAction.noMaps
};
RemoveAllMappings.prototype.showing = function() {
    this.okEnabled(true)
};
RemoveAllMappings.prototype.okCallback = function() {
    var F = MC.mapsSet.data.objects;
    var E = "";
    for (var C = 0; C < F.length; C++) {
        var D = F[C];
        if (D instanceof APIVolumeGroupView) {
            var G = D.get("group_name")
        } else {
            var G = D.get("volume_name")
        }
        E += G + ","
    }
    E = E.slice(0, -1);
    MC.unmapVolumes({
        volumeList: E
    }, {
        dialog: true,
        closeActionOn: "success",
        confirmMsg: strings.mapAction.confirmDeleteMessage,
        processingMsg: strings.mapAction.removeAllProcessing,
        failureMsg: strings.mapAction.removeAllFailure,
        successMsg: strings.mapAction.removeAllSuccess
    })
};

function HostSetup(H) {
    if (arguments.length == 0) {
        return
    }
    H.name = "HostSetup";
    H.okCallback = createObjectCallback(this, this.okCallback);
    var G = [{
        bVisible: false,
        bIsKey: true
    }];
    if (!false) {
        G.push({
            sTitle: '<input id="selectAll" type="checkbox">'
        })
    }
    G.push({
        sTitle: strings.storageSetup.nickname,
        editable: {
            rules: {
                utf8length: 32,
                dhHostName: true
            }
        }
    });
    G.push({
        sTitle: strings.storageSetup.hostId
    });
    var E = userBasePreferenceIsDecimal();
    var C = [];
    var D = getBaseLUN();
    this.overcommitEnabled = {
        A: (DC.pools.A ? DC.pools.A.getInt("overcommit_numeric") != 0 : false),
        B: (DC.pools.B ? DC.pools.B.getInt("overcommit_numeric") != 0 : false)
    };
    this.isLinear = (typeof DC.pools.A == "undefined" && typeof DC.pools.B == "undefined" && !$.isEmptyObject(DC.pools));
    if (this.isLinear) {
        for (var F in DC.pools) {
            C.push(F)
        }
    } else {
        if (DC.pools.A && (this.overcommitEnabled.A || MC.poolsSet.virtUncommittedSize.A.getRawValue() > 1000000)) {
            C.push("A")
        }
        if (DC.pools.B && (this.overcommitEnabled.B || MC.poolsSet.virtUncommittedSize.B.getRawValue() > 1000000)) {
            C.push("B")
        }
    }
    H.widgets = [new WidgetContainer({
        name: "wrapper",
        classes: "nowrap",
        widgets: [new WidgetContainer({
            name: "leftSection",
            classes: "leftSection",
            widgets: [this.navWidget = new VerticalNavigationWidget({
                name: "nav",
                steps: [{
                    name: "intro",
                    label: strings.hostSetup.intro
                }, {
                    name: "selectHost",
                    label: strings.hostSetup.selectHost
                }, {
                    name: "groupHost",
                    label: strings.hostSetup.groupHost
                }, {
                    name: "volumes",
                    label: strings.hostSetup.volumes
                }, {
                    name: "summary",
                    label: strings.hostSetup.summary
                }]
            })]
        }), new WidgetContainer({
            name: "widgetSection",
            classes: "recoveryManagerWidgetContainer",
            widgets: [new WidgetContainer({
                name: "intro",
                width: 400,
                widgets: [new TextWidget({
                    name: "introText1",
                    text: strings.hostSetup.introText
                }), new TextWidget({
                    name: "fibreChannelIntro",
                    topMargin: true,
                    text: "<h3>Fibre Channel</h3><ul><li>" + strings.hostSetup.mpio + "</li><li>" + strings.hostSetup.installHBAs + "</li><li>" + strings.hostSetup.installDrivers + "</li><li>" + strings.hostSetup.fcZoning + "</li></ul>"
                }), new TextWidget({
                    name: "iscsiIntro",
                    topMargin: true,
                    text: "<h3>iSCSI</h3><ul><li>" + strings.hostSetup.mpio + "</li><li>" + strings.hostSetup.iSCSI1 + "</li><li>" + strings.hostSetup.iSCSI2 + "</li><li>" + strings.hostSetup.iSCSI3 + "</li><li>" + strings.hostSetup.iSCSI4 + "</li></ul>"
                }), new TextWidget({
                    name: "sasIntro",
                    topMargin: true,
                    text: "<h3>SAS</h3><ul><li>" + strings.hostSetup.mpio + "</li><li>" + strings.hostSetup.SAS1 + "</li><li>" + strings.hostSetup.SAS2 + "</li><li>" + strings.hostSetup.SAS3 + "</li></ul>"
                })]
            }), new WidgetContainer({
                name: "selectHost",
                width: 400,
                widgets: [new FormWidget({
                    name: "hostForm",
                    widgets: [new TextWidget({
                        name: "selectHostText",
                        text: strings.hostSetup.selectHostText
                    }), new OptionInputWidget({
                        name: "hostSelectDropDown",
                        label: strings.hostSetup.hostDropdown,
                        topMargin: true,
                        changeCallback: createObjectCallback(this, this.selectedHostChanged)
                    }), new TextInputWidget({
                        name: "hostName",
                        label: strings.hostSetup.hostName,
                        rules: {
                            required: true,
                            utf8length: 32,
                            dhHostName: true,
                            hostExists: true
                        },
                        topMargin: true,
                        changeCallback: createObjectCallback(this, this.hostNameChanged)
                    }), new WidgetContainer({
                        name: "hostTableWidget",
                        classes: "width100pct tableDisplay",
                        widgets: [this.hostTable = new TableInator({
                            name: "hostTable",
                            topMargin: true,
                            type: "rawData",
                            rawBasetype: "initiator",
                            metadata: G,
                            editCallback: createObjectCallback(this, this._hostCellEdited),
                            noFeatures: true
                        })]
                    })]
                })]
            }), new WidgetContainer({
                name: "groupHost",
                width: 400,
                widgets: [new TextWidget({
                    name: "groupHostText",
                    topMargin: true,
                    bottomMargin: true
                }), new FormWidget({
                    name: "groupForm",
                    widgets: [new RadioButtonsInputWidget({
                        name: "groupOption",
                        value: null,
                        changeCallback: createObjectCallback(this, this.groupOptionChanged),
                        values: [{
                            value: "addToExisting",
                            widget: new WidgetContainer({
                                classes: "inlineBlock",
                                leftMargin: true,
                                bottomMargin: true,
                                widgets: [new TextWidget({
                                    text: strings.hostSetup.addToExisting,
                                    classes: "inlineBlock"
                                }), new OptionInputWidget({
                                    name: "addToExisting",
                                    classes: "inlineBlock",
                                    changeCallback: createObjectCallback(this, this.groupChanged),
                                    leftMargin: true
                                })]
                            })
                        }, {
                            value: "createNew",
                            widget: new WidgetContainer({
                                classes: "inlineBlock",
                                leftMargin: true,
                                bottomMargin: true,
                                widgets: [new TextWidget({
                                    text: strings.hostSetup.createNew,
                                    classes: "inlineBlock"
                                }), new TextInputWidget({
                                    name: "createNew",
                                    rules: {
                                        utf8length: 32,
                                        dhHostName: true
                                    },
                                    changeCallback: createObjectCallback(this, this.groupNameChanged),
                                    classes: "inlineBlock",
                                    leftMargin: true
                                })]
                            })
                        }, {
                            value: "dontGroup",
                            widget: new WidgetContainer({
                                classes: "inlineBlock",
                                leftMargin: true,
                                widgets: [new TextWidget({
                                    classes: "inlineBlock",
                                    text: strings.hostSetup.dontGroup
                                })]
                            })
                        }]
                    })]
                })]
            }), new WidgetContainer({
                name: "volumes",
                widgets: [new WidgetContainer({
                    name: "createNewVolumes",
                    width: 570,
                    widgets: [new TextWidget({
                        name: "volumeText",
                        text: strings.storageSetup.volumeText,
                        topMargin: true
                    }), this.header = new TableWidget({
                        bottomMargin: true,
                        classes: "width100pct",
                        widgets: [new LabelWidget({
                            row: 0,
                            col: 0,
                            cellClasses: "textCenter columnA",
                            noTerminator: true,
                            value: "A",
                            bottomSmallMargin: true
                        }), new LabelWidget({
                            row: 0,
                            col: 1,
                            cellClasses: "textCenter columnB",
                            noTerminator: true,
                            value: "B",
                            bottomSmallMargin: true
                        }), new SpaceMeter({
                            name: "cvaCapA",
                            cellClasses: "columnA",
                            row: 1,
                            col: 0,
                            height: 22,
                            width: 280,
                            prec: 0,
                            bottomSmallMargin: true,
                            rightMargin: true
                        }), new SpaceMeter({
                            name: "cvaCapB",
                            cellClasses: "columnB",
                            row: 1,
                            col: 1,
                            cellClasses: "alignRight",
                            height: 22,
                            width: 280,
                            prec: 0,
                            bottomSmallMargin: true
                        }), new TextWidget({
                            name: "cvaUsageA",
                            cellClasses: "columnA",
                            row: 2,
                            col: 0,
                            text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
                        }), new TextWidget({
                            name: "cvaUsageB",
                            cellClasses: "columnB",
                            row: 2,
                            col: 1,
                            text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
                        })]
                    }), this.volumeTable = new TableInator({
                        name: "volumeTable",
                        selectable: false,
                        topMargin: true,
                        type: "rawData",
                        metadata: [{
                            sTitle: strings.storageSetup.volNameLabel,
                            editable: {
                                rules: {
                                    required: true,
                                    dhName: true,
                                    utf8length: 32
                                }
                            }
                        }, {
                            sTitle: strings.storageSetup.volSizeLabel,
                            editable: {
                                rules: {
                                    required: true,
                                    decimalBaseSizeString: E,
                                    binaryBaseSizeString: !E,
                                    sizeRange: ["1MB", "128TiB"]
                                }
                            }
                        }, {
                            sTitle: strings.storageSetup.poolLabel,
                            editable: C
                        }, {
                            bVisible: false
                        }, {
                            sTitle: "",
                            editable: {}
                        }],
                        editCallback: createObjectCallback(this, this._volumeCellEdited),
                        noFeatures: true
                    }), new TableWidget({
                        name: "addRowButton",
                        classes: "width100pct",
                        widgets: [new ButtonContainer({
                            orientation: "horizontal",
                            alignment: "right",
                            widgets: [new ButtonWidget({
                                name: "cvaAddRowButton",
                                text: strings.createVirtualVolumes.addRowLabel,
                                callback: createObjectCallback(this, this.addRow),
                                topMargin: true
                            })]
                        })]
                    }), new TextWidget({
                        name: "cvaSummary"
                    })]
                }), new WidgetContainer({
                    name: "existingVolumes",
                    width: 400,
                    widgets: [new TextWidget({
                        name: "existingVolumesText"
                    }), new TableInator({
                        name: "existingVolumeTable",
                        selectable: false,
                        topMargin: true,
                        type: "rawData",
                        metadata: [{
                            sTitle: strings.storageSetup.volNameLabel
                        }, {
                            sTitle: strings.storageSetup.volSizeLabel
                        }],
                        noFeatures: true
                    })]
                })]
            }), new WidgetContainer({
                name: "summary",
                width: 400,
                widgets: [new TextWidget({
                    text: strings.hostSetup.summaryText,
                    bottomMargin: true
                }), new TextWidget({
                    name: "hostNameSummary",
                    label: strings.hostSetup.hostName,
                    topMargin: true,
                    leftMargin: true,
                    bottomSmallMargin: true,
                    wrapText: true
                }), new TextWidget({
                    name: "belongsToHostGroup",
                    label: strings.hostSetup.belongsToHostGroup,
                    leftMargin: true,
                    bottomMargin: true,
                    wrapText: true
                }), new TextWidget({
                    label: strings.hostSetup.hostInits,
                    topMargin: true,
                    bottomSmallMargin: true
                }), new TableInator({
                    name: "initSummary",
                    selectable: false,
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.storageSetup.nickname
                    }, {
                        sTitle: strings.storageSetup.hostID
                    }],
                    noFeatures: true
                }), new TextWidget({
                    label: strings.hostSetup.attachedVolumes,
                    bottomSmallMargin: true,
                    topMargin: true
                }), new TableInator({
                    name: "attachedVolumes",
                    selectable: false,
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.storageSetup.volNameLabel
                    }, {
                        sTitle: strings.storageSetup.volSizeLabel
                    }, {
                        sTitle: "LUN"
                    }],
                    noFeatures: true
                })]
            })]
        })]
    })];
    ActionPanel.call(this, H);
    this.class_name = "HostSetup";
    this.currentLuns = [];
    this.nameExcludes = [];
    this.initiatorExcludes = [];
    this.baseLUN = getBaseLUN();
    $("#selectAll", this.elements).click(createObjectCallback(this, function(P) {
        var O = this.hostTable.getNumVisibleRows();
        if (P.currentTarget.checked) {
            var K = {};
            this.retrieve(K);
            var M = this.hostTable.getData();
            var Q = 0;
            var I = this.hostTable.dataTable[0].rows.length - 1;
            var R = 0;
            while (Q < O) {
                for (var L = R; L < I; L++) {
                    var S = this.hostTable._selectRow(L);
                    var J = M[L][2];
                    if (J == "") {
                        var N = this.getDefaultNickname();
                        this.hostTable.updateData(N, S, 2, true)
                    }
                    Q++
                }
                this.hostTable.dataTable.fnPageChange("next", true);
                R = I;
                I = I + this.hostTable.dataTable[0].rows.length - 1
            }
            this.hostTable.dataTable.fnPageChange("first", true);
            $(".rowSelectbox").prop("checked", true);
            if (!K.hostName.invalid) {
                this.okEnabled(true)
            }
        } else {
            this.hostTable._clearSelectAll();
            $(".rowSelectbox").prop("checked", false);
            this.okEnabled(false)
        }
    }))
}
HostSetup.prototype = new ActionPanel();
HostSetup.prototype.constructor = HostSetup;
HostSetup.getMenuState = function() {
    if (session.hasConfigurationCapability() && RI.hasFeature("completesetup")) {
        if ($.isEmptyObject(DC.pools)) {
            return strings.hostSetup.mustHaveStorage
        } else {
            return []
        }
    } else {
        return false
    }
};
HostSetup.prototype.showing = function() {
    this.setState("intro");
    this.setBorder()
};
HostSetup.prototype.okCallback = function() {
    switch (this.currentState) {
        case "intro":
            this.setState("selectHost");
            break;
        case "selectHost":
            this.setState("groupHost");
            break;
        case "groupHost":
            this.setState("volumes");
            break;
        case "volumes":
            this.setState("summary");
            break;
        case "summary":
            this.configureHost();
            break;
        default:
            break
    }
};
HostSetup.prototype.addBackButton = function() {
    this.buttonContainer.prepend(this.backButton = new ButtonWidget({
        name: "backButton",
        emphasized: true,
        text: strings.wiz.prevButtonText,
        callback: createObjectCallback(this, this.backClicked)
    }))
};
HostSetup.prototype.backClicked = function() {
    switch (this.currentState) {
        case "selectHost":
            this.setState("intro");
            break;
        case "groupHost":
            this.setState("selectHost");
            break;
        case "volumes":
            this.setState("groupHost");
            break;
        case "summary":
            this.setState("volumes");
            break;
        default:
            break
    }
};
HostSetup.prototype.setState = function(F) {
    this.currentState = F;
    this.navWidget.setPrimaryStepActive(this.currentState);
    var D = {
        intro: {
            visibility: "collapse"
        },
        selectHost: {
            visibility: "collapse"
        },
        groupHost: {
            visibility: "collapse"
        },
        volumes: {
            visibility: "collapse"
        },
        summary: {
            visibility: "collapse"
        }
    };
    switch (F) {
        case "intro":
            D.intro.visibility = "visible";
            D.HostSetup_ok = {
                text: strings.wiz.nextButtonText
            };
            if (APIPort.hasPortType("iSCSI")) {
                D.iscsiIntro = {
                    visibility: "visible"
                }
            } else {
                D.iscsiIntro = {
                    visibility: "collapse"
                }
            }
            if (APIPort.hasPortType("FC")) {
                D.fibreChannelIntro = {
                    visibility: "visible"
                }
            } else {
                D.fibreChannelIntro = {
                    visibility: "collapse"
                }
            }
            if (APIPort.hasPortType("SAS")) {
                D.sasIntro = {
                    visibility: "visible"
                }
            } else {
                D.sasIntro = {
                    visibility: "collapse"
                }
            }
            this.okEnabled(true);
            this.update(D);
            break;
        case "selectHost":
            D.selectHost.visibility = "visible";
            this.navWidget.markPrimaryStepComplete("intro");
            this.okEnabled(false);
            if (typeof this.backButton == "undefined") {
                this.addBackButton()
            }
            if (false) {
                D.hostSelectDropDown = {
                    visibility: "visible"
                }
            } else {
                D.hostSelectDropDown = {
                    visibility: "collapse"
                }
            }
            if (this.hostTable.selected.length) {
                this.okEnabled(true)
            } else {
                var V = [];
                for (var X in DC.initiators) {
                    if (DC.initiators[X].get("nickname") != "") {
                        this.initiatorExcludes.push(DC.initiators[X].get("nickname"))
                    }
                    var T = [];
                    if (!decodeBooleanFlag(DC.initiators[X].get("mapped")) && DC.initiators[X].get("host_id") == "NOHOST") {
                        T = [DC.initiators[X].get("durable_id")];
                        if (!false) {
                            T.push('<input class="rowSelectbox" type="checkbox">')
                        }
                        T.push(DC.initiators[X].get("nickname"));
                        T.push(X);
                        V.push(T)
                    }
                }
                if (V.length) {
                    D.hostTableWidget = {
                        visibility: "visible"
                    };
                    D.hostTable = {
                        data: V
                    }
                } else {
                    D.hostTableWidget = {
                        visibility: "collapse"
                    };
                    D.hostName = {
                        visibility: "collapse",
                        skipValidation: true
                    };
                    if ($.isEmptyObject(DC.initiators)) {
                        D.selectHostText = {
                            text: strings.hostSetup.noInits
                        }
                    } else {
                        D.selectHostText = {
                            text: strings.hostSetup.initsGrouped
                        }
                    }
                }
            }
            this.update(D);
            $(".rowSelectbox").click(createObjectCallback(this, function(k) {
                var m = $(k.currentTarget.parentElement.parentElement).index();
                var g = {};
                this.retrieve(g);
                var d = this.hostTable.getData();
                var j = d[m][2];
                if (k.currentTarget.checked) {
                    this.hostTable._selectRow(m);
                    if (typeof g.hostName != "undefined" && !g.hostName.invalid) {
                        this.okEnabled(true)
                    }
                    if (j == "") {
                        var o = this.getDefaultNickname();
                        this.hostTable.updateData(o, m, 2, true)
                    }
                } else {
                    if ($("#selectAll").prop("checked") == true) {
                        $("#selectAll").prop("checked", false)
                    }
                    if (!DC.findInitiatorByNickname(j)) {
                        this.hostTable.updateData("", m, 2, true);
                        for (var f = 0; f < this.initiatorExcludes.length; f++) {
                            if (this.initiatorExcludes[f] == j) {
                                this.initiatorExcludes.splice(f, 1);
                                break
                            }
                        }
                    }
                    this.hostTable._unselectRow(m);
                    if (this.hostTable.selected.length === 0) {
                        this.okEnabled(false)
                    }
                }
            }));
            break;
        case "groupHost":
            var b = {};
            this.retrieve(b);
            this.navWidget.markPrimaryStepComplete("intro");
            this.navWidget.markPrimaryStepComplete("selectHost");
            D.groupHost.visibility = "visible";
            D.groupHostText = {
                text: strings.hostSetup.groupHostText(b.hostName.value)
            };
            var R = [{
                value: "choose",
                text: strings.hostSetup.chooseHost
            }];
            var W = false;
            for (var E in DC.hostGroups) {
                if (E != "-ungrouped-") {
                    W = true;
                    R.push({
                        value: DC.hostGroups[E].get("durable_id"),
                        text: DC.hostGroups[E].get("name")
                    })
                }
            }
            D.addToExisting = {
                values: R
            };
            if (!W) {
                D.groupOption = {
                    values: [{
                        value: "addToExisting",
                        disable: true
                    }]
                }
            }
            if (!b.groupOption.value) {
                D.addToExisting.disable = true;
                D.createNew = {
                    disable: true
                };
                this.okEnabled(false)
            } else {
                this.groupOptionChanged()
            }
            this.update(D);
            break;
        case "volumes":
            var b = {};
            this.retrieve(b);
            this.navWidget.markPrimaryStepComplete("intro");
            this.navWidget.markPrimaryStepComplete("selectHost");
            this.navWidget.markPrimaryStepComplete("groupHost");
            D.volumes.visibility = "visible";
            D.HostSetup_ok = {
                text: strings.wiz.nextButtonText
            };
            if (b.groupOption.value == "dontGroup" || b.groupOption.value == "createNew") {
                D.createNewVolumes = {
                    visibility: "visible"
                };
                D.existingVolumes = {
                    visibility: "collapse"
                };
                if (!this.volumeTable.getData().length) {
                    var J = [];
                    var Q = (userBasePreferenceIsDecimal() ? "100GB" : "100GiB");
                    this.lunCount = 0;
                    if (this.isLinear) {
                        this.header.elements$.find(".columnA").closest("tr").hide();
                        this.header.elements$.find(".columnB").closest("tr").hide();
                        for (var N in DC.pools) {
                            this.nextPool = N;
                            var a = Q;
                            var c = DC.getUnusedKey("volumes", this.nameExcludes);
                            J.push([c, a, N, this.generateLUNs(1)[0], '<div class="buttonLarge button deleteRow">' + strings.removeButtonText + "</div>"])
                        }
                    } else {
                        if (typeof DC.pools.A != "undefined") {
                            this.nextPool = "A";
                            var a = Q;
                            if (MC.poolsSet.virtUncommittedSize.A.value < 100000000000 && !this.overcommitEnabled.A) {
                                a = MC.poolsSet.virtUncommittedSize.A.format("scale")
                            }
                            var P = DC.getUnusedKey("volumes", this.nameExcludes);
                            J.push([P, a, "A", this.generateLUNs(1)[0], '<div class="buttonLarge button deleteRow">' + strings.removeButtonText + "</div>"])
                        } else {
                            this.header.elements$.find(".columnA").closest("tr").hide()
                        }
                        if (typeof DC.pools.B != "undefined") {
                            var a = Q;
                            if (MC.poolsSet.virtUncommittedSize.B.value < 100000000000 && !this.overcommitEnabled.B) {
                                a = MC.poolsSet.virtUncommittedSize.B.format("scale")
                            }
                            var O = DC.getUnusedKey("volumes", this.nameExcludes);
                            J.push([O, a, "B", this.generateLUNs(1)[0], '<div class="buttonLarge button deleteRow"">' + strings.removeButtonText + "</div>"]);
                            if (typeof DC.pools.A != "undefined") {
                                this.nextPool = "B"
                            }
                        } else {
                            this.header.elements$.find(".columnB").closest("tr").hide()
                        }
                    }
                    D.volumeTable = {
                        data: J
                    }
                }
                this.update(D);
                this.bindRemoveButton();
                this._recalc()
            } else {
                D.createNewVolumes = {
                    visibility: "collapse"
                };
                D.existingVolumes = {
                    visibility: "visible"
                };
                D.existingVolumesText = {
                    text: strings.hostSetup.existingVolumes(b.hostName.value, b.addToExisting.textValue)
                };
                var M = b.addToExisting.textValue;
                var S = DC.hostGroups[M].maps;
                var I = [];
                for (var C in S) {
                    var H = S[C];
                    var K = H.parentObject.get("volume_name");
                    var a = DC.volumes[K].get("size");
                    I.push([K, a])
                }
                D.existingVolumeTable = {
                    data: I
                };
                this.update(D)
            }
            break;
        case "summary":
            var b = {};
            this.retrieve(b);
            this.navWidget.markPrimaryStepComplete("intro");
            this.navWidget.markPrimaryStepComplete("selectHost");
            this.navWidget.markPrimaryStepComplete("groupHost");
            this.navWidget.markPrimaryStepComplete("volumes");
            D.summary.visibility = "visible";
            D.HostSetup_ok = {
                text: strings.hostSetup.configureHost
            };
            var Z = "";
            if (b.groupOption.value == "dontGroup") {
                Z = strings.na
            } else {
                if (b.groupOption.value == "addToExisting") {
                    Z = b.addToExisting.textValue
                } else {
                    if (b.groupOption.value == "createNew") {
                        Z = b.createNew.value
                    }
                }
            }
            var G = [];
            if (false) {} else {
                var T = this.hostTable.getData();
                for (var U = 0; U < T.length; U++) {
                    if (typeof T[U].DT_isSelected != "undefined" && T[U].DT_isSelected) {
                        G.push([(T[U][2] == "" ? strings.na : T[U][2]), T[U][3]])
                    }
                }
            }
            if (b.groupOption.value == "dontGroup" || b.groupOption.value == "createNew") {
                var I = this.volumeTable.getData();
                var Y = [];
                for (var U = 0; U < I.length; U++) {
                    Y.push([I[U][0], I[U][1], I[U][3]])
                }
            } else {
                var M = b.addToExisting.textValue;
                var S = DC.hostGroups[M].maps;
                var Y = [];
                for (var C in S) {
                    var H = S[C];
                    var K = H.parentObject.get("volume_name");
                    var a = DC.volumes[K].get("size");
                    var L = H.get("lun");
                    Y.push([K, a, L])
                }
            }
            D.hostNameSummary = {
                text: b.hostName.value
            };
            D.belongsToHostGroup = {
                text: Z
            };
            D.initSummary = {
                data: G
            };
            D.attachedVolumes = {
                data: Y
            };
            this.update(D);
            break;
        default:
            break
    }
    this.resetSize();
    this.setBorder()
};
HostSetup.prototype.selectedHostChanged = function() {};
HostSetup.prototype.hostNameChanged = function(C, E, D) {
    if (C.hostName.invalid) {
        this.okEnabled(false);
        return
    }
    if (false || this.hostTable.selected.length) {
        this.okEnabled(true)
    }
};
HostSetup.prototype.groupOptionChanged = function() {
    var D = {};
    this.retrieve(D);
    var E = true;
    var C = true;
    if (D.groupOption.value == "dontGroup") {
        this.okEnabled(true)
    } else {
        if (D.groupOption.value == "createNew") {
            E = false;
            if (D.createNew.value != "" && !D.createNew.invalid) {
                this.okEnabled(true)
            } else {
                this.okEnabled(false)
            }
        } else {
            if (D.groupOption.value == "addToExisting") {
                C = false;
                if (D.addToExisting.value == "choose") {
                    this.okEnabled(false)
                } else {
                    this.okEnabled(true)
                }
            }
        }
    }
    this.update({
        createNew: {
            disable: E
        }
    });
    this.update({
        addToExisting: {
            disable: C
        }
    })
};
HostSetup.prototype.groupNameChanged = function(C, E, D) {
    if (C.createNew.invalid || C.createNew.value == "") {
        this.okEnabled(false)
    } else {
        this.okEnabled(true)
    }
};
HostSetup.prototype.groupChanged = function(C, E, D) {
    if (C.addToExisting.value != "choose") {
        this.okEnabled(true)
    } else {
        this.okEnabled(false)
    }
};
HostSetup.prototype.configureHost = function() {
    var T = {};
    this.retrieve(T);
    this.hostName = T.hostName.value;
    var H = this.volumeTable.getData();
    var R = this.hostTable.getData();
    var C = this.hostTable.selected;
    var N = [];
    for (var O = 0; O < R.length; O++) {
        var U = R[O][0];
        var E = R[O][2];
        for (var P in DC.initiators) {
            if (U == DC.initiators[P].getKeyValue() && E != DC.initiators[P].get("nickname")) {
                N.push({
                    name: "init" + U,
                    command: MC.setInitiator,
                    data: {
                        id: DC.initiators[P].get("id"),
                        nickname: E
                    },
                    options: {
                        processingMsg: strings.modifyInit.processingMsg(DC.initiators[P].get("nickname")),
                        failureMsg: strings.modifyInit.failureMsg(DC.initiators[P].get("nickname"))
                    }
                })
            }
        }
    }
    if (false) {} else {
        var F = [];
        for (var O = 0; O < this.hostTable.selected.length; O++) {
            var M = this.hostTable.selected[O].getObject();
            F.push(M.get("id"))
        }
        var L = {
            initiators: F,
            hostName: this.hostName
        };
        if (T.groupOption.value == "addToExisting") {
            L.hostGroup = T.addToExisting.textValue
        }
        N.push({
            name: "createHost",
            command: MC.createHost,
            data: L,
            options: {
                processingMsg: strings.addToHost.processing,
                failureMsg: strings.addToHost.failure
            }
        });
        if (T.groupOption.value == "createNew") {
            N.push({
                name: "createHostGroup",
                command: MC.createHostGroup,
                data: {
                    hosts: [this.hostName],
                    hostGroupName: T.createNew.value
                },
                options: {
                    processingMsg: strings.addToHostGroup.processing,
                    failureMsg: strings.addToHostGroup.failure
                }
            })
        }
    }
    if (T.groupOption.value != "addToExisting") {
        var D = H.length;
        this.volumesCreated = [];
        for (var G = 0; G < D; G++) {
            var J = H[G][0];
            var S = H[G][1];
            var Q = H[G][2];
            N.push({
                name: "createVol" + G,
                command: MC.createVolume,
                data: {
                    pool: Q,
                    name: J,
                    size: S
                },
                options: {
                    processingMsg: strings.createVirtualVolumes.creatingOneMsg(J),
                    failureMsg: strings.createVirtualVolumes.createFailedOneMsg(J)
                }
            })
        }
        var H = this.volumeTable.getData();
        var D = H.length;
        if (T.groupOption.value == "createNew") {
            var K = T.createNew.value + ".*.*"
        } else {
            var K = this.hostName + ".*"
        }
        var I = this.getPorts();
        for (var G = 0; G < D; G++) {
            N.push({
                name: "mapVolume" + G,
                command: MC.mapVolume,
                data: {
                    volumeName: H[G][0],
                    host: K,
                    lun: H[G][3],
                    access: "read-write",
                    ports: I
                },
                options: {
                    processingMsg: strings.mapAction.mapProcessingMsg(K, H[G][0]),
                    failureMsg: strings.mapAction.mapFailMsg(K, H[G][0])
                }
            })
        }
    }
    MC.execCommandList(N, {
        noSuccessDialog: true,
        closeActionOn: "none",
        callback: createObjectCallback(this, this.showFinish)
    })
};
HostSetup.prototype.showFinish = function() {
    ShowActiveDialog({
        type: "success",
        message: strings.hostSetup.configureAnother,
        dialogOverride: true,
        cancelState: "enabled",
        okLabel: strings.Yes,
        cancelLabel: strings.No,
        ok: function() {
            panels.actionDialog.close(true);
            NAV.navTo("HomeTopic", "hostSetup", null)
        },
        cancel: function() {
            panels.actionDialog.close(true)
        }
    })
};
HostSetup.prototype.getPorts = function() {
    var I = false;
    var C = 0;
    if (DC.controllers.A) {
        var F = APIPort.getPortCount("A")
    } else {
        if (DC.controllers.B) {
            var F = APIPort.getPortCount("B")
        } else {
            var F = 4
        }
    }
    for (var E in DC.ports) {
        if (C == 0) {
            C = DC.ports[E].get("port_type_numeric")
        } else {
            if (DC.ports[E].get("port_type_numeric") != C) {
                I = true;
                break
            }
        }
    }
    var H = this.hostTable.selected[0].getObject();
    var G = [];
    if (I) {
        if (H.getInt("host_bus_type_numeric") == PORT_TYPES.FC) {
            for (var D = 0; D < 2; D++) {
                G.push("A" + (D + system.physicalPositionOffset));
                G.push("B" + (D + system.physicalPositionOffset))
            }
        } else {
            for (var D = 2; D < F; D++) {
                G.push("A" + (D + system.physicalPositionOffset));
                G.push("B" + (D + system.physicalPositionOffset))
            }
        }
    } else {
        for (var D = 0; D < F; D++) {
            G.push("A" + (D + system.physicalPositionOffset));
            G.push("B" + (D + system.physicalPositionOffset))
        }
    }
    return G
};
HostSetup.prototype._volumeCellEdited = function(E, C) {
    if (C == 0) {
        var D = this.volumeTable.getData(E, C).trim();
        if (DC.volumes[D]) {
            newName = DC.getUnusedKey("volumes", D, this.nameExcludes);
            this.volumeTable.cellAdjusted(E, C, strings.createVirtualVolumes.nameChanged);
            this.volumeTable.updateData(newName, E, C)
        } else {
            this.volumeTable.updateData(D, E, C);
            this.volumeTable.cellAdjusted(E, C, "")
        }
    }
    this._recalc()
};
HostSetup.prototype._hostCellEdited = function(F, C) {
    var E = this.hostTable.getData();
    var D = E[F];
    if (D.DT_isSelected && D[2] == "") {
        this.hostTable.cellAdjusted(F, C, strings.hostSetup.noBlankInit);
        this.hostTable.updateData(this.getDefaultNickname(), F, C)
    }
};
HostSetup.prototype.getDefaultNickname = function() {
    return DC.getUnusedKey("initiators", strings.initiator, this.initiatorExcludes)
};

function StorageSetup(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "StorageSetup";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.cancelCallback = createObjectCallback(this, this.cancelCallback);
    if (!$.isEmptyObject(DC.pools)) {
        this.provideSkip = true;
        C.applyCallback = createObjectCallback(this, this.skipCallback);
        C.applyButtonText = strings.skip
    } else {
        this.provideSkip = false
    }
    C.widgets = [new WidgetContainer({
        name: "wrapper",
        classes: "nowrap",
        width: 650,
        widgets: [new WidgetContainer({
            name: "leftSection",
            classes: "leftSection",
            widgets: [this.navWidget = new VerticalNavigationWidget({
                name: "nav",
                steps: [{
                    name: "pools",
                    label: strings.storageSetup.poolsLabel
                }, {
                    name: "volumes",
                    label: strings.storageSetup.volumeLabel
                }, {
                    name: "mapAction",
                    label: strings.storageSetup.mapLabel
                }, {
                    name: "summary",
                    label: strings.storageSetup.summaryLabel
                }]
            })]
        }), new WidgetContainer({
            name: "widgetSection",
            classes: "recoveryManagerWidgetContainer",
            widgets: [new TextWidget({
                name: "stepNumText",
                classes: "stepNumText",
                leftMargin: true,
                topMargin: true
            }), this.poolWidget = new EZPoolWidget({
                name: "EZpoolWidget"
            }), new WidgetContainer({
                name: "volumes",
                widgets: [new TextWidget({
                    name: "volumeText",
                    text: strings.storageSetup.volumeText,
                    width: 570,
                    topMargin: true
                }), this.header = new TableWidget({
                    bottomMargin: true,
                    classes: "width100pct",
                    widgets: [new LabelWidget({
                        row: 0,
                        col: 0,
                        cellClasses: "textCenter columnA",
                        noTerminator: true,
                        value: "A",
                        bottomSmallMargin: true
                    }), new LabelWidget({
                        row: 0,
                        col: 1,
                        cellClasses: "textCenter columnB",
                        noTerminator: true,
                        value: "B",
                        bottomSmallMargin: true
                    }), new SpaceMeter({
                        name: "cvaCapA",
                        cellClasses: "columnA",
                        row: 1,
                        col: 0,
                        height: 22,
                        width: 280,
                        prec: 0,
                        bottomSmallMargin: true,
                        rightMargin: true
                    }), new SpaceMeter({
                        name: "cvaCapB",
                        cellClasses: "columnB",
                        row: 1,
                        col: 1,
                        cellClasses: "alignRight",
                        height: 22,
                        width: 280,
                        prec: 0,
                        bottomSmallMargin: true
                    }), new TextWidget({
                        name: "cvaUsageA",
                        cellClasses: "columnA",
                        row: 2,
                        col: 0,
                        text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
                    }), new TextWidget({
                        name: "cvaUsageB",
                        cellClasses: "columnB",
                        row: 2,
                        col: 1,
                        text: strings.createVirtualVolumes.poolDetails(0, 0, 0)
                    })]
                }), this.volumeContainer = new WidgetContainer({
                    name: "volumeContainer"
                }), new TableWidget({
                    name: "addRowButton",
                    classes: "width100pct",
                    widgets: [new ButtonContainer({
                        orientation: "horizontal",
                        alignment: "right",
                        widgets: [new ButtonWidget({
                            name: "cvaAddRowButton",
                            text: strings.createVirtualVolumes.addRowLabel,
                            callback: createObjectCallback(this, this.addRow),
                            topMargin: true
                        })]
                    })]
                }), new TextWidget({
                    name: "cvaSummary"
                })]
            }), new FormWidget({
                name: "map",
                widgets: [new TextWidget({
                    name: "hostInfo",
                    text: strings.storageSetup.hostText,
                    tip: strings.storageSetup.mapTip,
                    width: 500,
                    topMargin: true
                }), new TextWidget({
                    name: "noHostInfo",
                    text: strings.storageSetup.noInitiators,
                    topMargin: true,
                    width: 500
                }), new WidgetContainer({
                    name: "hostTableWidget",
                    classes: "width100pct tableDisplay",
                    widgets: [this.hostTable = new TableInator({
                        name: "hostTable",
                        topMargin: true,
                        type: "rawData",
                        rawBasetype: "initiator",
                        metadata: [{
                            bVisible: false,
                            bIsKey: true
                        }, {
                            sTitle: '<input id="selectAll" type="checkbox">'
                        }, {
                            sTitle: strings.storageSetup.nickname + '<div class="tipWidget datatableTip"></div>',
                            editable: {
                                rules: {
                                    utf8length: 32,
                                    dhHostName: true
                                }
                            }
                        }, {
                            sTitle: strings.storageSetup.hostId
                        }, {
                            sTitle: strings.storageSetup.hostType
                        }],
                        noFeatures: true,
                        editCallback: createObjectCallback(this, this.hostEdited)
                    })]
                }), new CheckboxContainer({
                    name: "mapAllInit",
                    label: strings.storageSetup.mapAll,
                    topMargin: true,
                    changeCallback: createObjectCallback(this, this.mapAllChanged),
                    widgets: [new TableWidget({
                        widgets: [new TextWidget({
                            row: 0,
                            col: 0,
                            name: "warning",
                            classes: "error",
                            text: strings.storageSetup.warning
                        }), new TextWidget({
                            row: 0,
                            col: 1,
                            leftMargin: true,
                            name: "mapAllWarning",
                            text: strings.storageSetup.mapWarn,
                            width: 400
                        })]
                    })]
                })]
            }), new WidgetContainer({
                name: "summary",
                widgets: [new TextWidget({
                    name: "summaryIntro",
                    topMargin: true
                }), new TableInator({
                    name: "summaryVolTable",
                    topMargin: true,
                    type: "rawData",
                    noFeatures: true,
                    metadata: [{
                        sTitle: "LUN"
                    }, {
                        sTitle: strings.storageSetup.volNameLabel
                    }, {
                        sTitle: strings.storageSetup.volSizeLabel
                    }, {
                        sTitle: strings.storageSetup.poolLabel
                    }]
                }), new TextWidget({
                    name: "summaryMid",
                    width: 400,
                    topMargin: true
                }), new TableInator({
                    name: "summaryInitsTable",
                    topMargin: true,
                    type: "rawData",
                    noFeatures: true,
                    metadata: [{
                        sTitle: strings.storageSetup.nickname
                    }, {
                        sTitle: strings.storageSetup.hostId
                    }]
                }), new TextWidget({
                    name: "summaryFooter",
                    width: 400,
                    topMargin: true
                })]
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "StorageSetup";
    this.setDatatableTips();
    $("#selectAll", this.elements).click(createObjectCallback(this, function(H) {
        var G = this.hostTable.getNumVisibleRows();
        if (H.currentTarget.checked) {
            var D = 0;
            var F = this.hostTable.dataTable[0].rows.length - 1;
            var J = 0;
            while (D < G) {
                for (var E = J; E < F; E++) {
                    var I = this.hostTable._selectRow(E);
                    D++
                }
                this.hostTable.dataTable.fnPageChange("next", true);
                J = F;
                F = F + this.hostTable.dataTable[0].rows.length - 1
            }
            this.hostTable.dataTable.fnPageChange("first", true);
            $(".rowSelectbox").prop("checked", true);
            this.okEnabled(true)
        } else {
            this.hostTable._clearSelectAll();
            $(".rowSelectbox").prop("checked", false);
            if (!this.mapAllSelected) {
                this.okEnabled(false)
            }
        }
    }));
    this.nameExcludes = [];
    this.currentLuns = [];
    this.selectedHosts = {};
    this.mapAllSelected = false
}
StorageSetup.prototype = new ActionPanel();
StorageSetup.prototype.constructor = StorageSetup;
StorageSetup.getMenuState = function() {
    if (RI.hasFeature("completesetup") || RI.hasFeature("easyStartFirmware")) {
        return false
    }
    if (session.hasConfigurationCapability() && RI.hasFeature("easyStart")) {
        if (EZStartManager.showEasyStart()) {
            if (EZStartManager.isConfigurationComplete()) {
                return []
            } else {
                return strings.easyStart.mustCompleteConfig
            }
        } else {
            return []
        }
    } else {
        return false
    }
};
StorageSetup.prototype.showing = function() {
    this.setCurrentState("pools")
};
StorageSetup.prototype.hiding = function() {
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.poolsSubscription);
        delete this.poolsSubscription
    }
};
StorageSetup.prototype.setDatatableTips = function() {
    this.tip$ = $(".datatableTip", this.elements);
    this.tip$.off("click").click(function(D) {
        if (panels.tipPanel.tipShowing) {
            panels.tipPanel.close()
        } else {
            var C = "";
            switch (D.currentTarget.parentElement.innerText) {
                case strings.storageSetup.volSizeLabel:
                    C = strings.storageSetup.volSizeTip;
                    break;
                case "LUN":
                    C = strings.storageSetup.lunTip;
                    break;
                case strings.storageSetup.nickname:
                    C = strings.storageSetup.nicknameTip;
                    break;
                default:
                    break
            }
            panels.tipPanel.open(C, $(D.currentTarget).offset())
        }
    })
};
StorageSetup.prototype.okCallback = function() {
    switch (this.currentStep) {
        case "pools":
            this.createDiskGroups();
            break;
        case "volumes":
            this.createVolumes();
            break;
        case "map":
            if (!$.isEmptyObject(DC.initiators) || this.mapAllSelected) {
                this.mapVolumes()
            } else {
                this.setCurrentState("summary")
            }
            break;
        default:
            break
    }
};
StorageSetup.prototype.cancelCallback = function() {
    if ($.isEmptyObject(DC.pools)) {
        return true
    }
    if ($.isEmptyObject(DC.volumes)) {
        ShowActiveDialog({
            type: "confirm",
            message: strings.storageSetup.confirmLeaveVolumes,
            ok: function() {
                panels.actionDialog.close(true)
            }
        });
        return false
    }
    if (MC.mapsSet.data.objects.length) {
        var D = MC.mapsSet.data.objects;
        mapFound = false;
        for (var F = 0; F < D.length; F++) {
            var G = D[F].objects;
            for (var E = 0; E < G.length; E++) {
                var C = G[E];
                if (C.getInt("access_numeric") != 0) {
                    mapFound = true;
                    break
                }
            }
        }
        if (mapFound) {
            return true
        } else {
            ShowActiveDialog({
                type: "confirm",
                message: strings.storageSetup.confirmLeaveMappings,
                ok: function() {
                    panels.actionDialog.close(true)
                }
            });
            return false
        }
    } else {
        ShowActiveDialog({
            type: "confirm",
            message: strings.storageSetup.confirmLeaveMappings,
            ok: function() {
                panels.actionDialog.close(true)
            }
        });
        return false
    }
};
StorageSetup.prototype.skipCallback = function() {
    switch (this.currentStep) {
        case "pools":
            this.setCurrentState("volumes");
            break;
        case "volumes":
            this.setCurrentState("map");
            break;
        default:
            break
    }
};
StorageSetup.prototype.removeRescanButton = function() {
    this.buttonContainer.remove(this.rescanButton);
    delete this.rescanButton
};
StorageSetup.prototype.addRescanButton = function() {
    this.buttonContainer.prepend(this.rescanButton = new ButtonWidget({
        name: "rescanButton",
        emphasized: true,
        text: strings.storageSetup.rescanButton,
        callback: createObjectCallback(this, this.setCurrentState, "pools", true)
    }))
};
StorageSetup.prototype.setCurrentState = function(D, C) {
    this.update({
        volumes: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        summary: {
            visibility: "collapse"
        }
    });
    this.currentStep = D;
    switch (D) {
        case "pools":
            MC.addStorage({
                preview: true
            }, {
                dialog: (C ? true : false),
                successMsg: strings.storageSetup.rescanSuccessful,
                callback: createObjectCallback(this, this.setPools)
            });
            break;
        case "volumes":
            this.setVolumeState();
            break;
        case "map":
            this.setMapState();
            break;
        case "summary":
            this.setSummaryState();
            break;
        default:
            break
    }
};
StorageSetup.prototype.setPools = function(D) {
    var C = ($.isEmptyObject(DC.pools) ? strings.storageSetup.createPoolLabel : strings.storageSetup.expandPoolLabel);
    this.poolWidget.setPoolState(D);
    this.update({
        StorageSetup_ok: {
            text: strings.menus.addDiskGroup
        },
        EZpoolWidget: {
            visibility: "visible"
        },
        volumes: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        summary: {
            visibility: "collapse"
        }
    });
    if (typeof this.rescanButton == "undefined") {
        this.addRescanButton()
    }
    if (this.poolWidget.isValid()) {
        this.okEnabled(true)
    }
    if (this.provideSkip) {
        this.applyEnabled(true)
    }
};
StorageSetup.prototype.setVolumeState = function() {
    this.navWidget.setPrimaryStepActive("volumes");
    this.navWidget.markPrimaryStepComplete("pools");
    this.removeRescanButton();
    var E = userBasePreferenceIsDecimal();
    var L = [];
    var C = getBaseLUN();
    this.overcommitEnabled = {
        A: (DC.pools.A ? DC.pools.A.getInt("overcommit_numeric") != 0 : false),
        B: (DC.pools.B ? DC.pools.B.getInt("overcommit_numeric") != 0 : false)
    };
    if (DC.pools.A && (this.overcommitEnabled.A || MC.poolsSet.virtUncommittedSize.A.getRawValue() > 1000000)) {
        L.push("A")
    }
    if (DC.pools.B && (this.overcommitEnabled.B || MC.poolsSet.virtUncommittedSize.B.getRawValue() > 1000000)) {
        L.push("B")
    }
    this.volumeTable = new TableInator({
        name: "volumeTable",
        selectable: false,
        topMargin: true,
        type: "rawData",
        metadata: [{
            sTitle: strings.storageSetup.volNameLabel,
            editable: {
                rules: {
                    required: true,
                    dhName: true,
                    utf8length: 32
                }
            }
        }, {
            sTitle: strings.storageSetup.volSizeLabel + '<div class="tipWidget datatableTip"></div>',
            editable: {
                rules: {
                    required: true,
                    decimalBaseSizeString: E,
                    binaryBaseSizeString: !E,
                    sizeRange: ["1MB", "128TiB"]
                }
            }
        }, {
            sTitle: strings.storageSetup.poolLabel,
            editable: L
        }, {
            sTitle: 'LUN<div class="tipWidget datatableTip"></div>',
            editable: {
                rules: {
                    required: true,
                    range: [C, system.maxLuns - 1]
                }
            }
        }, {
            sTitle: "",
            editable: {}
        }],
        editCallback: createObjectCallback(this, this._cellEdited),
        noFeatures: true
    });
    this.volumeContainer.add(this.volumeTable);
    var F = [];
    var I = [];
    var G = (userBasePreferenceIsDecimal() ? "100GB" : "100GiB");
    var H = {
        StorageSetup_ok: {
            text: strings.storageSetup.createVolumeLabel
        },
        volumeCapacityTable: {
            data: F
        },
        volumeTable: {
            data: I
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(2, 4) + "</span>" + strings.storageSetup.volumeStepLabel
        },
        volumes: {
            visibility: "visible"
        },
        map: {
            visibility: "collapse"
        },
        summary: {
            visibility: "collapse"
        }
    };
    this.lunCount = 0;
    this.nextPool = "A";
    if (typeof DC.pools.A != "undefined") {
        var D = G;
        if (MC.poolsSet.virtUncommittedSize.A.value < 100000000000 && !this.overcommitEnabled.A) {
            D = MC.poolsSet.virtUncommittedSize.A.format("scale")
        }
        var K = DC.getUnusedKey("volumes", this.nameExcludes);
        var M = this.generateLUNs(1)[0];
        this.currentLuns.push(parseInt(M));
        I.push([K, D, "A", M, '<div class="buttonLarge button deleteRow">X</div>'])
    } else {
        this.header.elements$.find(".columnA").hide()
    }
    if (typeof DC.pools.B != "undefined") {
        var D = G;
        if (MC.poolsSet.virtUncommittedSize.B.value < 100000000000 && !this.overcommitEnabled.B) {
            D = MC.poolsSet.virtUncommittedSize.B.format("scale")
        }
        var J = DC.getUnusedKey("volumes", this.nameExcludes);
        var M = this.generateLUNs(1)[0];
        this.currentLuns.push(parseInt(M));
        I.push([J, D, "B", M, '<div class="buttonLarge button deleteRow"">X</div>']);
        if (typeof DC.pools.A != "undefined") {
            this.nextPool = "B"
        }
    } else {
        this.header.elements$.find(".columnB").hide()
    }
    if (this.provideSkip) {
        $(".buttonLarge:contains('" + strings.skip + "')").remove()
    }
    this.update(H);
    this.poolWidget.setVisibility("collapse");
    this.bindRemoveButton();
    this._recalc();
    this.setBorder();
    this.setDatatableTips()
};
StorageSetup.prototype.setMapState = function() {
    this.navWidget.setPrimaryStepActive("mapAction");
    this.navWidget.markPrimaryStepComplete("pools");
    this.navWidget.markPrimaryStepComplete("volumes");
    var D = {
        StorageSetup_ok: {
            text: strings.storageSetup.mapLabel
        },
        volumes: {
            visibility: "collapse"
        },
        map: {
            visibility: "visible"
        },
        summary: {
            visibility: "collapse"
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(3, 4) + "</span>" + strings.storageSetup.mapStepLabel
        }
    };
    var C = [];
    if ($.isEmptyObject(DC.initiators)) {
        D.StorageSetup_ok = {
            text: strings.recoveryManager.continueLabel
        };
        D.hostTableWidget = {
            visibility: "collapse"
        };
        D.noHostInfo = {
            visibility: "visible"
        };
        D.hostInfo = {
            visibility: "collapse"
        };
        $(".buttonLarge:contains('" + strings.skip + "')").remove()
    } else {
        for (var E in DC.initiators) {
            C.push([DC.initiators[E].get("durable_id"), '<input class="rowSelectbox" type="checkbox">', DC.initiators[E].get("nickname"), E, DC.initiators[E].get("host_bus_type")])
        }
        D.noHostInfo = {
            visibility: "collapse"
        };
        D.hostTableWidget = {
            visibility: "visible"
        };
        D.hostTable = {
            data: C
        }
    }
    this.update(D);
    $(".rowSelectbox").click(createObjectCallback(this, function(F) {
        var G = $(F.currentTarget.parentElement.parentElement).index();
        if (F.currentTarget.checked) {
            this.hostTable._selectRow(G);
            this.okEnabled(true)
        } else {
            if ($("#selectAll").prop("checked") == true) {
                $("#selectAll").prop("checked", false)
            }
            this.hostTable._unselectRow(G);
            if (this.hostTable.selected.length === 0) {
                this.okEnabled(false)
            }
        }
    }));
    $("#selectAll").click();
    this.okEnabled(true);
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};
StorageSetup.prototype.setSummaryState = function() {
    this.navWidget.setPrimaryStepActive("summary");
    this.navWidget.markPrimaryStepComplete("pools");
    this.navWidget.markPrimaryStepComplete("volumes");
    this.navWidget.markPrimaryStepComplete("mapAction");
    var N = new Size();
    var L = [];
    var I = this.volumeTable.getData();
    for (var H = 0; H < I.length; H++) {
        var C = I[H][0];
        var F = I[H][3];
        var M = DC.volumes[C];
        var P = M.get("size");
        var J = M.get("storage_pool_name");
        L.push([F, C, P, J]);
        N.add(M.getInt("size_numeric"), "blocks")
    }
    var D = strings.storageSetup.summaryIntro(N.format("scale"));
    var K = {
        StorageSetup_ok: {
            visibility: "collapse"
        },
        StorageSetup_cancel: {
            text: strings.closeButtonText
        },
        volumes: {
            visibility: "collapse"
        },
        map: {
            visibility: "collapse"
        },
        summary: {
            visibility: "visible"
        },
        summaryIntro: {
            text: D
        },
        summaryVolTable: {
            data: L
        },
        stepNumText: {
            text: '<span class="activeText">' + strings.recoveryManager.stepLabel(4, 4) + "</span>" + strings.storageSetup.summaryLabel
        }
    };
    if (this.provideSkip) {
        K.StorageSetup_apply = {
            visibility: "collapse"
        }
    }
    if (this.mapAllSelected) {
        K.summaryMid = {
            text: strings.storageSetup.summaryMid1
        };
        K.summaryFooter = {
            text: strings.storageSetup.summaryFooter1 + strings.storageSetup.summaryFooter2 + strings.storageSetup.summaryFooter4
        };
        K.summaryInitsTable = {
            visibility: "collapse"
        }
    } else {
        if ($.isEmptyObject(DC.initiators)) {
            K.summaryInitsTable = {
                visibility: "collapse"
            };
            K.summaryMid = {
                text: strings.storageSetup.summaryMid2
            };
            K.summaryFooter = {
                text: strings.storageSetup.summaryFooter1 + strings.storageSetup.summaryFooter3 + strings.storageSetup.summaryFooter4
            }
        } else {
            var G = [];
            var E = this.hostTable.selected;
            for (var H = 0; H < E.length; H++) {
                var O = E[H].getObject();
                if (O) {
                    G.push([O.get("nickname"), O.get("id")])
                }
            }
            K.summaryInitsTable = {
                data: G,
                visibility: "visible"
            };
            K.summaryMid = {
                text: strings.storageSetup.summaryMid
            };
            K.summaryFooter = {
                text: strings.storageSetup.summaryFooter1 + strings.storageSetup.summaryFooter2 + strings.storageSetup.summaryFooter4
            }
        }
    }
    this.update(K);
    this.resetSize({
        shrink: true
    });
    this.setBorder()
};
StorageSetup.prototype.generateLUNs = HostSetup.prototype.generateLUNs = function(M, J) {
    var P = new Array();
    var N = system.maxLuns || 1024;
    for (var L = 0; L < N; L++) {
        P[L] = false
    }
    for (var L = 0; L < this.currentLuns.length; L++) {
        var H = this.currentLuns[L];
        P[H] = true
    }
    for (var F in DC.volGroupMapsId) {
        var D = DC.volGroupMapsId[F];
        if (D.get("mapped_id") != "AOI") {
            continue
        }
        for (var K = 0; K < D.objects.length; K++) {
            P[D.objects[K].get("lun")] = true
        }
    }
    for (var F in DC.volMapsId) {
        var D = DC.volMapsId[F];
        P[D.get("lun")] = true
    }
    if (J == undefined) {
        var E = this.baseLUN
    } else {
        var E = J
    }
    var L = parseInt(E, 10);
    var I = system.maxLuns || 1024;
    while (L < I) {
        if (P[L] === false) {
            var O = L + M;
            if (O >= N) {
                return "-"
            }
            var G = true;
            var C = [];
            C.push(L);
            for (var K = L + 1; K < O; K++) {
                if (P[K] !== false) {
                    G = false;
                    break
                } else {
                    C.push(K)
                }
            }
            if (G) {
                this.currentLuns = this.currentLuns.concat(C);
                return C
            }
        }
        L++;
        if (L == N && E != this.baseLUN) {
            L = this.baseLUN;
            I = E
        }
    }
    return "-"
};
StorageSetup.prototype.bindRemoveButton = HostSetup.prototype.bindRemoveButton = function() {
    $(".deleteRow").off("click").click(createObjectCallback(this, this.deleteRow))
};
StorageSetup.prototype.deleteRow = HostSetup.prototype.deleteRow = function(E) {
    var G = $($("td", E.currentTarget.parentElement.parentElement)[3]).html();
    for (var D = 0; D < this.currentLuns.length; D++) {
        if (this.currentLuns[D] == G) {
            this.currentLuns.splice(D, 1);
            break
        }
    }
    var C = $($("td", E.currentTarget.parentElement.parentElement)[0]).html();
    for (var D = 0; D < this.nameExcludes.length; D++) {
        if (this.nameExcludes[D] == C) {
            this.nameExcludes.splice(D, 1);
            break
        }
    }
    var F = E.currentTarget.parentElement.parentElement.rowIndex - 1;
    this.volumeTable.removeRow(F);
    this._recalc()
};
StorageSetup.prototype.addRow = HostSetup.prototype.addRow = function() {
    var C = DC.getUnusedKey("volumes", this.nameExcludes);
    if (this.nextPool == "A" && DC.pools.B) {
        this.nextPool = "B"
    } else {
        if (this.nextPool == "B" && DC.pools.A) {
            this.nextPool = "A"
        }
    }
    var D = (userBasePreferenceIsDecimal() ? "100GB" : "100GiB");
    var E = D;
    if (MC.poolsSet.virtUncommittedSize.B.value < 100000000000 && ((this.nextPool == "B" && !this.overcommitEnabled.B) || (this.nextPool == "A" && !this.overcommitEnabled.A))) {
        E = MC.poolsSet.virtUncommittedSize.B.format("scale")
    }
    var F = [];
    var G = this.generateLUNs(1)[0];
    this.currentLuns.push(parseInt(G));
    F[0] = C;
    F[1] = E;
    F[2] = this.nextPool;
    F[3] = G;
    F[4] = '<div class="buttonLarge button deleteRow">' + strings.removeButtonText + "</div>";
    this.volumeTable.addData(F);
    this.bindRemoveButton();
    this._recalc()
};
StorageSetup.prototype.createDiskGroups = function() {
    MC.addStorage({
        preview: false
    }, {
        dialog: true,
        processingMsg: strings.storageSetup.addStorageProcessing,
        successMsg: strings.storageSetup.addStorageSuccess,
        failureMsg: strings.storageSetup.addStorageFailure,
        callback: createObjectCallback(this, this.poolsComplete)
    })
};
StorageSetup.prototype.poolsComplete = function(C) {
    if (C.success) {
        this.poolsSubscription = MC.poolsSet.requestData({
            update: true,
            durable: "all",
            requestor: this.class_name,
            handler: createObjectCallback(this, this.poolSizeUpdated)
        })
    }
};
StorageSetup.prototype.createVolumes = function() {
    var G = this.volumeTable.getData();
    var C = [];
    var H = G.length;
    this.volumesCreated = [];
    for (var I = 0; I < H; I++) {
        var D = G[I][0];
        var F = G[I][1];
        var E = G[I][2];
        this.volumesCreated.push(D);
        C.push({
            name: "createVol" + I,
            command: MC.createVolume,
            data: {
                pool: E,
                name: D,
                size: F
            },
            options: {
                processingMsg: strings.createVirtualVolumes.creatingOneMsg(D),
                failureMsg: strings.createVirtualVolumes.createFailedOneMsg(D)
            }
        })
    }
    MC.execCommandList(C, {
        successMsg: strings.createVirtualVolumes.completedMsg,
        confirmMsg: (this.overcommitting ? strings.overcommitMsg : null),
        callback: createObjectCallback(this, this.volumesComplete)
    })
};
StorageSetup.prototype.volumesComplete = function(C) {
    if (C.success) {
        if (this.poolsSubscription) {
            MC.poolsSet.unregister(this.poolsSubscription);
            delete this.poolsSubscription
        }
        this.setCurrentState("map")
    }
};
StorageSetup.prototype.mapVolumes = function() {
    var F = this.volumeTable.getData();
    var S = this.hostTable.getData();
    var C = this.hostTable.selected;
    var M = false;
    var E = 0;
    var K = [];
    for (var Q = 0; Q < S.length; Q++) {
        var T = S[Q][0];
        var D = S[Q][2];
        for (var R in DC.initiators) {
            if (T == DC.initiators[R].getKeyValue() && D != DC.initiators[R].get("nickname")) {
                K.push({
                    name: "init" + T,
                    command: MC.setInitiator,
                    data: {
                        id: DC.initiators[R].get("id"),
                        nickname: D
                    },
                    options: {
                        processingMsg: strings.modifyInit.processingMsg(DC.initiators[R].get("nickname")),
                        failureMsg: strings.modifyInit.failureMsg(DC.initiators[R].get("nickname"))
                    }
                })
            }
        }
    }
    if (DC.controllers.A) {
        var I = APIPort.getPortCount("A")
    } else {
        if (DC.controllers.B) {
            var I = APIPort.getPortCount("B")
        } else {
            var I = 4
        }
    }
    for (var H in DC.ports) {
        if (E == 0) {
            E = DC.ports[H].get("port_type_numeric")
        } else {
            if (DC.ports[H].get("port_type_numeric") != E) {
                M = true;
                break
            }
        }
    }
    for (var Q = 0; Q < F.length; Q++) {
        var G = F[Q][0];
        var L = F[Q][3];
        if (this.mapAllSelected) {
            var J = [];
            for (var O = 0; O < I; O++) {
                J.push("A" + (O + system.physicalPositionOffset));
                J.push("B" + (O + system.physicalPositionOffset))
            }
            K.push({
                name: "mapCmd" + G,
                command: MC.mapVolume,
                data: {
                    volumeName: G,
                    host: null,
                    lun: L,
                    access: "read-write",
                    ports: J
                },
                options: {
                    processingMsg: strings.mapAction.mapProcessingMsg(strings.allOtherInits, G),
                    failureMsg: strings.mapAction.mapFailMsg(strings.allOtherInits, G)
                }
            })
        } else {
            for (var O = 0; O < C.length; O++) {
                var P = C[O].getObject();
                var R = P.get("id");
                var J = [];
                if (typeof P != "undefined") {
                    if (M) {
                        if (P.getInt("host_bus_type_numeric") == PORT_TYPES.FC) {
                            for (var N = 0; N < 2; N++) {
                                J.push("A" + (N + system.physicalPositionOffset));
                                J.push("B" + (N + system.physicalPositionOffset))
                            }
                        } else {
                            for (var N = 2; N < I; N++) {
                                J.push("A" + (N + system.physicalPositionOffset));
                                J.push("B" + (N + system.physicalPositionOffset))
                            }
                        }
                    } else {
                        for (var N = 0; N < I; N++) {
                            J.push("A" + (N + system.physicalPositionOffset));
                            J.push("B" + (N + system.physicalPositionOffset))
                        }
                    }
                }
                K.push({
                    name: "mapCmd" + G + ":" + R,
                    command: MC.mapVolume,
                    data: {
                        volumeName: G,
                        host: R,
                        lun: L,
                        access: "read-write",
                        ports: J
                    },
                    options: {
                        processingMsg: strings.mapAction.mapProcessingMsg(R, G),
                        failureMsg: strings.mapAction.mapFailMsg(R, G)
                    }
                })
            }
        }
    }
    MC.execCommandList(K, {
        successMsg: strings.mapAction.mappingSucceeded,
        callback: createObjectCallback(this, this.mapComplete)
    })
};
StorageSetup.prototype.mapComplete = function(C) {
    if (C.success) {
        this.setCurrentState("summary")
    }
};
StorageSetup.prototype.hostEdited = function(D, C) {
    console.log("host cell edited!")
};
StorageSetup.prototype._cellEdited = function(E, C) {
    if (C == 0) {
        var D = this.volumeTable.getData(E, C).trim();
        if (DC.volumes[D]) {
            newName = DC.getUnusedKey("volumes", D, this.nameExcludes);
            this.volumeTable.cellAdjusted(E, C, strings.createVirtualVolumes.nameChanged);
            this.volumeTable.updateData(newName, E, C)
        } else {
            this.volumeTable.updateData(D, E, C);
            this.volumeTable.cellAdjusted(E, C, "")
        }
    }
    if (C == 1) {
        this.volSizeEdited = true
    }
    this._recalc()
};
StorageSetup.prototype.mapAllChanged = function(C, D) {
    if (C[D.name].value) {
        this.mapAllSelected = true;
        if ($.isEmptyObject(DC.initiators)) {
            this.update({
                StorageSetup_ok: {
                    text: strings.storageSetup.mapLabel
                }
            })
        } else {
            $("#selectAll").prop("disabled", true);
            $(".rowSelectbox").prop("disabled", true)
        }
        this.okEnabled(true)
    } else {
        this.mapAllSelected = false;
        if ($.isEmptyObject(DC.initiators)) {
            this.update({
                StorageSetup_ok: {
                    text: strings.recoveryManager.continueLabel
                }
            })
        } else {
            $("#selectAll").prop("disabled", false);
            $(".rowSelectbox").prop("disabled", false)
        }
    }
};
StorageSetup.prototype.poolSizeUpdated = function() {
    if (this.currentStep == "pools") {
        this.setCurrentState("volumes")
    } else {
        this._recalc()
    }
};
StorageSetup.prototype._recalc = HostSetup.prototype._recalc = function() {
    var P = new Size();
    var N = new Size();
    var L = 0;
    var J = 0;
    var K = 0;
    var E = 1;
    var D = this.volumeTable.getData();
    var I = "";
    this.dataOK = true;
    this.overcommitting = false;
    this.overcommitEnabled = {
        A: (DC.pools.A ? DC.pools.A.getInt("overcommit_numeric") != 0 : false),
        B: (DC.pools.B ? DC.pools.B.getInt("overcommit_numeric") != 0 : false)
    };
    for (var Q = 0; Q < D.length; Q++) {
        var C = new Size(D[Q][1]);
        C.set(C.getPages(), "pages");
        if (D[Q][2] == "A") {
            L += 1;
            P.add(C)
        } else {
            J += 1;
            N.add(C)
        }
        K += 1
    }
    var O = false;
    if (DC.pools.A) {
        if (Size.compare(P, MC.poolsSet.virtUncommittedSize.A) > 0) {
            if (!this.overcommitEnabled.A) {
                O = "A"
            } else {
                if (MC.poolsSet.virtUncommittedSize.A.getRawValue() > 0) {
                    this.overcommitting = true
                }
            }
        }
        var G = {
            text: strings.createVirtualVolumes.poolDetails(MC.volumeGroupsSet.numVolsVirtual.A, this.overcommitEnabled.A ? MC.poolsSet.virtUncommittedSize.A.format("scale") : MC.poolsSet.virtPoolAvailSize.A.format("scale"), MC.poolsSet.virtPoolAvailSize.A.format("scale"))
        }
    }
    if (DC.pools.B) {
        if (Size.compare(N, MC.poolsSet.virtUncommittedSize.B) > 0) {
            if (!this.overcommitEnabled.B) {
                if (O) {
                    O += " " + strings.and + " B"
                } else {
                    O = "B"
                }
            } else {
                if (MC.poolsSet.virtUncommittedSize.B.getRawValue() > 0) {
                    this.overcommitting = true
                }
            }
        }
        var F = {
            text: strings.createVirtualVolumes.poolDetails(MC.volumeGroupsSet.numVolsVirtual.B, this.overcommitEnabled.B ? MC.poolsSet.virtUncommittedSize.B.format("scale") : MC.poolsSet.virtPoolAvailSize.B.format("scale"), MC.poolsSet.virtPoolAvailSize.B.format("scale"))
        }
    }
    if (O) {
        I += '<span class="inputInvalid">' + strings.createVirtualVolumes.overcommitted(O) + "</span><br />";
        this.dataOK = false
    }
    if ((MC.volumeGroupsSet.totalVols + K) > system.maxLuns) {
        I += '<span class="inputInvalid">' + strings.createVirtualVolumes.exceededMaxVols(system.maxLuns) + "</span><br />";
        this.dataOK = false
    }
    var M = this.volumeTable.getErrorCount();
    if (M > 0) {
        if (M == 1) {
            I += '<span class="inputInvalid">' + strings.createVirtualVolumes.valError1 + "</span><br />"
        } else {
            I += '<span class="inputInvalid">' + strings.createVirtualVolumes.valErrors(M) + "</span><br />"
        }
        this.dataOK = false
    }
    if (K == 0) {
        this.dataOK = false;
        I += strings.createVirtualVolumes.noVols
    }
    if (this.dataOK) {
        this.okEnabled(true);
        if (K > 1) {
            if (typeof DC.pools.A == "undefined" && typeof DC.pools.B == "undefined" && !$.isEmptyObject(DC.pools)) {
                I += strings.hostSetup.newLinearVols(K, N.format())
            } else {
                if (DC.pools.A && DC.pools.B) {
                    I += strings.createVirtualVolumes.newVolsCount2pools(K, L, P.format(), J, N.format())
                } else {
                    if (DC.pools.A) {
                        I += strings.createVirtualVolumes.newVolsCount1pool(K, "A", P.format())
                    } else {
                        I += strings.createVirtualVolumes.newVolsCount1pool(K, "B", N.format())
                    }
                }
            }
        } else {
            if (L > 0) {
                I += strings.createVirtualVolumes.newVolsCount1("A", P.format())
            } else {
                I += strings.createVirtualVolumes.newVolsCount1("B", N.format())
            }
        }
        if (E > 1) {
            I += strings.createVirtualVolumes.copiesMsg
        }
    } else {
        this.okEnabled(false)
    }
    var H = {
        cvaCapA: {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.A,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.A,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.A,
                label: strings.Unallocated
            }, {
                cssClass: "spaceNewVols",
                size: P,
                label: strings.createVirtualVolumes.newVols
            }]
        },
        cvaCapB: {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.B,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.B,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.B,
                label: strings.Unallocated
            }, {
                cssClass: "spaceNewVols",
                size: N,
                label: strings.createVirtualVolumes.newVols
            }]
        },
        cvaSummary: {
            text: I
        }
    };
    if (G) {
        H.cvaUsageA = G
    }
    if (F) {
        H.cvaUsageB = F
    }
    this.update(H);
    this.resetSize({
        shrink: true
    })
};
StorageSetup.prototype.setBorder = HostSetup.prototype.setBorder = function() {
    var C = $(".recoveryManagerWidgetContainer");
    var D = $(".leftSection");
    if (D.height() > C.height()) {
        C.removeClass("recoveryBorderLeft");
        D.addClass("recoveryBorderRight")
    } else {
        C.addClass("recoveryBorderLeft");
        D.removeClass("recoveryBorderRight")
    }
};

function StorageCompleteSetup(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "StorageCompleteSetup";
    C.okCallback = createObjectCallback(this, this.okCallback);
    C.cancelButtonText = strings.closeButtonText;
    C.cancelCallback = createObjectCallback(this, this.cancelCallback);
    this.storageType = "virtual";
    C.widgets = [new WidgetContainer({
        name: "wrapper",
        classes: "nowrap",
        widgets: [new TextWidget({
            name: "waitingWidget",
            visibility: "collapse",
            text: '<div class="processIndicator" style="display: inline-block; width: 200px"></div>'
        }), new FormWidget({
            name: "storageSelection",
            widgets: [new TextWidget({
                name: "storageTypeText",
                text: strings.storageSetup.storageType,
                classes: "stepNumText",
                topMargin: true,
                row: 0,
                col: 0,
                colSpan: 2
            }), new TextWidget({
                name: "choosingText",
                text: strings.storageSetup.choosingText,
                width: 570,
                topMargin: true,
                row: 1,
                col: 0,
                colSpan: 2
            }), new RadioButtonsInputWidget({
                name: "option",
                row: 2,
                col: 0,
                colSpan: 1,
                orientation: "vertical",
                setOrig: true,
                singleCell: true,
                bottomMargin: true,
                leftMargin: true,
                topMargin: true,
                values: [{
                    value: "virtual",
                    text: strings.Virtual,
                    description: strings.storageSetup.virtualDescription
                }, {
                    value: "linear",
                    text: strings.Linear,
                    description: strings.storageSetup.linearDescription
                }],
                value: "virtual",
                changeCallback: createObjectCallback(this, this.changeStorageCallback)
            })]
        }), new WidgetContainer({
            name: "pools",
            tableLayout: true,
            widgets: [new Widget({
                name: "advancedlink",
                htmlText: '<div style="display: inline-block;" class="advancedText"><div>' + strings.storageSetup.advancedLink + '<span id="advanced" class="inlink">' + strings.storageSetup.advancedSetup + "</span></div>",
                topMargin: true
            }), this.poolWidget = new EZPoolWidget({
                name: "poolWidget"
            })]
        }), new WidgetContainer({
            name: "addDiskGroup",
            tableLayout: true,
            widgets: [this.addDiskGroup = new AddDiskGroupWidget({
                name: "addDiskGroupWidget",
                changeCallback: createObjectCallback(this, this._selectionChange)
            })]
        }), new WidgetContainer({
            name: "advancedTable",
            width: 680,
            widgets: [new TextWidget({
                text: strings.storageSetup.createAdvPools,
                topMargin: true,
                classes: "stepNumText"
            }), new TextWidget({
                text: strings.storageSetup.poolTableString,
                topMargin: true,
                bottomMargin: true
            }), new TextWidget({
                name: "addnText",
                text: strings.storageSetup.poolTableAddnString,
                topMargin: true,
                classes: "textWidth"
            }), new Widget({
                name: "goBackLink",
                htmlText: '<div style="display: inline-block;" class="advancedText"><span id="goBack" class="inlink" >' + strings.storageSetup.poolTableGoBack + "</span></div>",
                bottomMargin: true
            }), new Widget({
                name: "addLink",
                htmlText: '<div  class="advancedText">' + strings.storageSetup.poolTableNext + '<span  class="hoverSectionLabel"> ' + strings.storageSetup.addDiskGroupLink + "</span>" + strings.storageSetup.below + "</div>",
                topMargin: true
            }), new WidgetContainer({
                name: "advancedPoolsTable",
                widgets: [new TextWidget({
                    text: strings.storageSetup.poolsCreated,
                    topMargin: true
                }), new TableInator({
                    name: "poolsTable",
                    classes: "equalColumnWidth",
                    topMargin: true,
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.storageSetup.poolLabel
                    }, {
                        sTitle: strings.DiskGroup
                    }, {
                        sTitle: strings.storageSetup.tierLabel
                    }, {
                        sTitle: strings.storageSetup.size
                    }, {
                        sTitle: strings.addDiskGroup.dataProtectionLabel
                    }, {
                        sTitle: strings.storageClass
                    }, {
                        sTitle: strings.storageSetup.numDisksLabel
                    }, {
                        sTitle: strings.spareCount,
                        bVisible: false
                    }, {
                        sTitle: "",
                        editable: {}
                    }],
                    noFeatures: true
                })]
            }), new WidgetContainer({
                name: "advancedSpareTable",
                visibility: "collapse",
                widgets: [new TextWidget({
                    text: strings.storageSetup.spareCreated,
                    topMargin: true
                }), new TableInator({
                    name: "spareTable",
                    classes: "equalColumnWidth",
                    topMargin: true,
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.addDiskGroup.typeLabel
                    }, {
                        sTitle: strings.addDiskGroup.location
                    }, {
                        sTitle: strings.storageSetup.size
                    }],
                    noFeatures: true
                })]
            })]
        }), new FormWidget({
            name: "changeSpareWidget",
            widgets: [this.changeSpares = new ChangeSpareWidget({
                name: "changeSpares",
                changeCallback: createObjectCallback(this, this._spareChange)
            }), this.addSpareButtonWidget = new ButtonWidget({
                name: "addSpareButton",
                primary: true,
                disable: true,
                classes: "removeButton",
                topMargin: true,
                bottomMargin: true,
                text: strings.changeSpares.buttonText,
                callback: createObjectCallback(this, this._addSpare)
            })]
        })]
    })];
    ActionPanel.call(this, C);
    this.class_name = "StorageCompleteSetup";
    this.advancedLink$ = $("#advanced", this.elements);
    this.goBackLink$ = $("#goBack", this.elements);
    this.advancedLink$.bind("click", createObjectCallback(this, this.advancedCallback));
    this.goBackLink$.bind("click", createObjectCallback(this, this.goBackAutoPools))
}
StorageCompleteSetup.prototype = new ActionPanel();
StorageCompleteSetup.prototype.constructor = StorageCompleteSetup;
StorageCompleteSetup.getMenuState = function() {
    if (session.hasConfigurationCapability() && RI.hasFeature("completesetup")) {
        if (EZStartManager.showEasyStart()) {
            if (EZStartManager.isConfigurationComplete()) {
                return []
            } else {
                return strings.easyStart.mustCompleteConfig
            }
        } else {
            return []
        }
    } else {
        return false
    }
};
StorageCompleteSetup.prototype.showing = function() {
    this.poolSubscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.updatePoolsData)
    });
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.updateGlobalSpare)
    });
    if ($.isEmptyObject(DC.pools)) {
        this.firstState = "storageSelection";
        this.setCurrentState("storageSelection");
        this.okEnabled(true)
    } else {
        for (var C in DC.pools) {
            var D = DC.pools[C];
            if (D.getInt("storage_type_numeric") == STORAGE_CLASS.VIRTUAL) {
                this.storageType = "virtual";
                this.firstState = "autoPoolSetup";
                this.setCurrentState("autoPoolSetup");
                break
            } else {
                this.storageType = "linear";
                this.firstState = "advancedDiskGroup";
                this.setCurrentState("advancedDiskGroup");
                break
            }
        }
    }
};
StorageCompleteSetup.prototype.hiding = function() {
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.poolsSubscription);
        delete this.poolsSubscription
    }
    if (this.disksSubscription) {
        MC.disksSet.unregister(this.disksSubscription);
        delete this.disksSubscription
    }
};
StorageCompleteSetup.prototype.cancelCallback = function() {
    if ($.isEmptyObject(DC.pools)) {
        var C = strings.storageSetup.confirmMessage;
        ShowActiveDialog({
            type: "confirm",
            message: C,
            ok: function() {
                panels.actionDialog.close(true)
            }
        });
        return false
    } else {
        return true
    }
};
StorageCompleteSetup.prototype.changeStorageCallback = function(E, C, D) {
    this.okEnabled(true);
    this.storageType = E.option.value
};
StorageCompleteSetup.prototype._selectionChange = function(C) {
    if (this.currentStep == "advancedSetUp") {
        if (C) {
            this.okEnabled(true)
        } else {
            this.okEnabled(false)
        }
    }
};
StorageCompleteSetup.prototype.setCurrentState = function(C) {
    this.update({
        storageSelection: {
            visibility: "collapse"
        },
        StorageCompleteSetup_cancel: {
            visibility: "visible"
        },
        pools: {
            visibility: "collapse"
        },
        waitingWidget: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "collapse"
        },
        advancedSpareTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        }
    });
    $(".panelError").empty();
    this.currentStep = C;
    switch (C) {
        case "storageSelection":
            this.setStorageSelection();
            break;
        case "autoPoolSetup":
            this.update({
                waitingWidget: {
                    visibility: "visible"
                }
            });
            this.resetSize({
                shrink: true
            });
            this.setAutoPool();
            break;
        case "advancedDiskGroupIntro":
            this.setAdvancedDiskGroupIntro();
            break;
        case "advancedDiskGroup":
            this.setAdvancedDiskGroup();
            break;
        case "advancedSetUp":
            this.setAdvancedSetUp();
            this.okEnabled(false);
            break;
        case "addSpare":
            this.setAddSpare();
            this.okEnabled(true);
            break;
        default:
            break
    }
};
StorageCompleteSetup.prototype.setStorageSelection = function() {
    var C = {
        StorageCompleteSetup_ok: {
            text: strings.recoveryManager.continueLabel
        },
        storageSelection: {
            visibility: "visible"
        },
        pools: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        }
    };
    if (this.backButton != undefined) {
        this.removeBackButton()
    }
    if (this.rescanButton != undefined) {
        this.removeRescanButton()
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    if (this.spareButton != undefined) {
        this.removeSpareButton()
    }
};
StorageCompleteSetup.prototype.setAutoPool = function() {
    MC.addStorage({
        preview: true
    }, {
        dialog: false,
        successMsg: strings.storageSetup.addStorageSuccess,
        callback: createObjectCallback(this, this.updatePoolWidget)
    })
};
StorageCompleteSetup.prototype.setAdvancedDiskGroupIntro = function() {
    var C = {
        StorageCompleteSetup_ok: {
            text: strings.menus.addDiskGroup
        },
        storageSelection: {
            visibility: "collapse"
        },
        pools: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "visible"
        },
        advancedPoolsTable: {
            visibility: "collapse"
        },
        advancedSpareTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        }
    };
    if (!$.isEmptyObject(DC.pools)) {
        C.advancedPoolsTable = {
            visibility: "visible"
        };
        if (this.spareInfo.length > 0) {
            C.advancedSpareTable = {
                visibility: "visible"
            }
        }
        var D = this.checkAdaptForSpare();
        if (this.spareButton == undefined) {
            this.addSpareButton(!D)
        }
    } else {
        if (this.spareButton != undefined) {
            this.removeSpareButton()
        }
    }
    if (this.storageType == "virtual") {
        C.type = {
            disable: true,
            value: this.storageType,
            values: [{
                value: this.storageType,
                text: strings.addDiskGroup.virtual
            }]
        }
    } else {
        C.type = {
            disable: true,
            value: this.storageType,
            values: [{
                value: this.storageType,
                text: strings.addDiskGroup.linear
            }]
        }
    }
    if (this.rescanButton != undefined) {
        this.removeRescanButton()
    }
    if (this.backButton != undefined) {
        this.removeBackButton()
    }
    if (this.spareButton != undefined && $.isEmptyObject(DC.pools)) {
        this.removeSpareButton()
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    this.okEnabled(true)
};
StorageCompleteSetup.prototype.setAdvancedDiskGroup = function() {
    var C = {
        StorageCompleteSetup_ok: {
            text: strings.menus.addDiskGroup
        },
        storageSelection: {
            visibility: "collapse"
        },
        pools: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "visible"
        },
        advancedPoolsTable: {
            visibility: "visible"
        },
        addnText: {
            visibility: "collapse"
        },
        goBackLink: {
            visibility: "collapse"
        },
        nextString: {
            visibility: "collapse"
        },
        addLink: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        }
    };
    if (this.spareInfo.length > 0) {
        C.advancedSpareTable = {
            visibility: "visible"
        }
    }
    if ($.isEmptyObject(DC.pools)) {
        C.advancedPoolsTable = {
            visibility: "collapse"
        }
    }
    this.update(C);
    this.resetSize({
        shrink: true
    });
    if (this.backButton != undefined) {
        this.removeBackButton()
    }
    if ($.isEmptyObject(DC.pools) && this.spareButton != undefined) {
        this.removeSpareButton()
    } else {
        if (!$.isEmptyObject(DC.pools)) {
            var D = this.checkAdaptForSpare();
            if (this.spareButton == undefined) {
                this.addSpareButton(!D)
            }
        }
    }
    this.okEnabled(true)
};
StorageCompleteSetup.prototype.setAdvancedSetUp = function() {
    var C = {
        StorageCompleteSetup_ok: {
            text: strings.menus.addDiskGroup
        },
        StorageCompleteSetup_cancel: {
            visibility: "collapse"
        },
        storageSelection: {
            visibility: "collapse"
        },
        pools: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "visible"
        },
        advancedTable: {
            visibility: "collapse"
        },
        advancedSpareTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        }
    };
    this.addDiskGroup.getWidgetInfo(this.storageType);
    if (this.storageType == "virtual") {
        C.type = {
            value: this.storageType,
            values: [{
                value: this.storageType,
                text: strings.addDiskGroup.virtual
            }]
        }
    } else {
        C.type = {
            value: this.storageType,
            values: [{
                value: this.storageType,
                text: strings.addDiskGroup.linear
            }]
        }
    }
    if (this.rescanButton != undefined) {
        this.removeRescanButton()
    }
    if (this.spareButton != undefined) {
        this.removeSpareButton()
    }
    if (this.backButton == undefined) {
        this.addBackButton()
    }
    this.update(C);
    this.resetSize({
        shrink: true
    })
};
StorageCompleteSetup.prototype.setAddSpare = function() {
    var C = {
        StorageCompleteSetup_ok: {
            text: strings.changeSpares.compleSetupText
        },
        StorageCompleteSetup_cancel: {
            visibility: "collapse"
        },
        storageSelection: {
            visibility: "collapse"
        },
        pools: {
            visibility: "collapse"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "collapse"
        },
        advancedSpareTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "visible"
        }
    };
    if (this.rescanButton != undefined) {
        this.removeRescanButton()
    }
    if (this.spareButton != undefined) {
        this.removeSpareButton()
    }
    if (this.backButton != undefined) {
        this.removeBackButton()
    }
    this.update(C);
    this.resetSize({
        shrink: true
    })
};
StorageCompleteSetup.prototype.advancedCallback = function() {
    this.setCurrentState("advancedDiskGroupIntro")
};
StorageCompleteSetup.prototype.goBackAutoPools = function() {
    this.setCurrentState("autoPoolSetup")
};
StorageCompleteSetup.prototype.checkAdaptForSpare = function() {
    var D = true;
    if (!$.isEmptyObject(DC.diskGroups)) {
        for (var C in DC.diskGroups) {
            if (DC.diskGroups[C].getInt("raidtype_numeric") == DATAPROTECTIONLEVEL.ADAPT) {
                D = false
            } else {
                D = true;
                break
            }
        }
    }
    return D
};
StorageCompleteSetup.prototype.okCallback = function() {
    switch (this.currentStep) {
        case "storageSelection":
            if (this.storageType == "virtual") {
                this.setCurrentState("autoPoolSetup")
            } else {
                this.setCurrentState("advancedDiskGroup")
            }
            break;
        case "advancedSetUp":
            if (this.backButton != undefined) {
                this.removeBackButton()
            }
            var C = {};
            C.closeAction = "none";
            C.noSuccessDialog = true;
            C.caller = this;
            C.callBack = this.manageCallBack;
            this.addDiskGroup._create(C);
            break;
        case "advancedDiskGroup":
            this.setCurrentState("advancedSetUp");
            break;
        case "advancedDiskGroupIntro":
            this.setCurrentState("advancedSetUp");
            break;
        case "autoPoolSetup":
            this.createDiskGroups();
            break;
        case "addSpare":
            this.setCurrentState("advancedDiskGroup");
            break;
        default:
            break
    }
};
StorageCompleteSetup.prototype.updatePoolWidget = function(D) {
    this.poolWidget.setPoolState(D);
    if (this.rescanButton == undefined) {
        this.addRescanButton()
    }
    if (this.backButton == undefined && this.firstState != "autoPoolSetup") {
        this.addBackButton()
    }
    var C = ($.isEmptyObject(DC.pools) ? strings.storageSetup.createPoolLabel : strings.storageSetup.expandPoolLabel);
    var E = {
        StorageCompleteSetup_ok: {
            text: C
        },
        storageSelection: {
            visibility: "collapse"
        },
        pools: {
            visibility: "visible"
        },
        addDiskGroup: {
            visibility: "collapse"
        },
        advancedTable: {
            visibility: "collapse"
        },
        advancedSpareTable: {
            visibility: "collapse"
        },
        changeSpareWidget: {
            visibility: "collapse"
        },
        waitingWidget: {
            visibility: "collapse"
        }
    };
    this.update(E);
    this.resetSize({
        shrink: true
    });
    if (this.spareButton != undefined) {
        this.removeSpareButton()
    }
    if (this.poolWidget.configNotFound != undefined && this.poolWidget.configNotFound) {
        this.configNotFound = true;
        var C = strings.storageSetup.createPoolLabel;
        this.update({
            StorageCompleteSetup_ok: {
                text: C
            }
        });
        this.okEnabled(false)
    } else {
        this.okEnabled(true)
    }
};
StorageCompleteSetup.prototype.createDiskGroups = function(C) {
    MC.addStorage({
        preview: false
    }, {
        dialog: true,
        noSuccessDialog: true,
        processingMsg: strings.storageSetup.addStorageProcessing,
        failureMsg: strings.storageSetup.addStorageFailure,
        callback: createObjectCallback(this, this.poolsComplete)
    })
};
StorageCompleteSetup.prototype.poolsComplete = function(C) {
    if (C.success) {
        ShowActiveDialog({
            type: "success",
            dialogOverride: true,
            message: strings.storageSetup.addStorageSuccess,
            ok: panels.actionDialog.close(true)
        })
    } else {
        ShowActiveDialog({
            type: "error",
            dialogOverride: true,
            message: strings.storageSetup.addStorageFailure,
            ok: panels.actionDialog.close(true)
        })
    }
};
StorageCompleteSetup.prototype.manageCallBack = function(C) {
    if (C.success) {
        this.okEnabled(false);
        HideActiveDialog();
        ShowActiveDialog({
            type: "success",
            dialogOverride: false,
            message: strings.addDiskGroup.success(this.addDiskGroup.diskGroupname),
            ok: createObjectCallback(this, this.setAdvancedPoolsTable)
        })
    }
};
StorageCompleteSetup.prototype.updatePoolsData = function() {
    var J = {};
    this.poolInfo = [];
    for (var G in DC.diskGroups) {
        var L = DC.diskGroups[G];
        var G = L.getPropertyValue("owner");
        var D = L.getPropertyValue("name");
        var E = L.getPropertyValue("storage_tier");
        var C = L.getPropertyValue("freespace");
        var M = L.getPropertyValue("raidtype");
        var F = L.getPropertyValue("storage_type");
        var I = L.getInt("diskcount");
        var H = L.getPropertyValue("sparecount");
        var K = '<div class="buttonLarge button deleteRow">' + strings.removeButtonText + "</div>";
        this.poolInfo.push([G, D, E, C, M, F, I, H, K])
    }
    J.poolsTable = {
        data: this.poolInfo
    };
    if (this.poolInfo.length == 0) {
        J.advancedPoolsTable = {
            visibility: "collapse"
        }
    }
    this.update(J);
    this.resetSize({
        shrink: true
    });
    this.bindDeleteButton()
};
StorageCompleteSetup.prototype.updateGlobalSpare = function() {
    var D = {};
    this.spareInfo = [];
    for (var H in DC.disks) {
        var I = DC.disks[H];
        var G = I.getInt("usage_numeric");
        if (G == DRIVE_USAGE.GLOBAL_SPARE) {
            var F = I.getPropertyValue("type");
            var C = I.getPropertyValue("location");
            var E = I.getPropertyValue("size");
            this.spareInfo.push([F, C, E])
        }
    }
    if (this.spareInfo.length > 0) {
        D.spareTable = {
            data: this.spareInfo
        }
    }
    this.update(D);
    this.resetSize({
        shrink: true
    })
};
StorageCompleteSetup.prototype.bindDeleteButton = function() {
    $(".deleteRow").off("click").click(createObjectCallback(this, this.deletePool))
};
StorageCompleteSetup.prototype.deletePool = function(I) {
    var E = $($("td", I.currentTarget.parentElement.parentElement)[1]).html();
    var D = DC.diskGroups[E].get("serial_number");
    var H = {
        diskGroups: D
    };
    var J = "";
    if (!$.isEmptyObject(DC.volumes)) {
        for (var F in DC.volumes) {
            var G = DC.volumes[F];
            var C = G.getPropertyValue("owner");
            if (C == DC.diskGroups[E].getPropertyValue("owner") && DC.pools[C].getNumDiskGroups() == 1) {
                J = strings.removeDiskGroups.warningWithPools(strings.pools);
                break
            }
        }
    }
    if (J == "") {
        J = strings.removeDiskGroups.standardWarning(strings.diskgroup)
    }
    MC.removeDiskGroups(H, {
        dialog: true,
        includeInfo: true,
        confirmMsg: J,
        noSuccessDialog: true,
        processingMsg: strings.removeDiskGroups.processing(E),
        failureMsg: strings.removeDiskGroups.failure(E),
        successMsg: strings.removeDiskGroups.success,
        okLabel: strings.Yes,
        cancelLabel: strings.cancelButtonText,
        closeActionOn: "none",
        callback: createObjectCallback(this, this.removeCallBack)
    })
};
StorageCompleteSetup.prototype.removeCallBack = function(C) {
    if (C.success) {
        HideActiveDialog();
        ShowActiveDialog({
            type: "success",
            dialogOverride: false,
            message: strings.removeDiskGroups.success,
            ok: createObjectCallback(this, this.setNavigationLink)
        })
    }
};
StorageCompleteSetup.prototype.setNavigationLink = function(C) {
    var D = {};
    if (this.currentStep == "advancedDiskGroup" && $.isEmptyObject(DC.pools)) {
        if (this.storageType == "virtual") {
            D.addnText = {
                visibility: "visible"
            };
            D.goBackLink = {
                visibility: "visible"
            }
        } else {
            if (this.backButton == undefined) {
                this.addBackButton()
            }
        }
        D.advancedPoolsTable = {
            visibility: "collapse"
        };
        if (this.spareInfo.length == 0) {
            D.advancedSpareTable = {
                visibility: "collapse"
            }
        }
    }
    this.update(D);
    this.resetSize({
        shrink: true
    })
};
StorageCompleteSetup.prototype.setAdvancedPoolsTable = function(D) {
    this.setCurrentState("advancedDiskGroup");
    var C = {};
    C.addnText = {
        visibility: "collapse"
    };
    C.goBackLink = {
        visibility: "collapse"
    };
    this.update(C);
    var E = $("#poolsTable").dataTable();
    if (this.storageType == "linear") {
        E.fnSetColumnVis(7, true)
    } else {
        E.fnSetColumnVis(7, false)
    }
};
StorageCompleteSetup.prototype.addRescanButton = function() {
    this.buttonContainer.prepend(this.rescanButton = new ButtonWidget({
        name: "rescanButton",
        emphasized: true,
        text: strings.storageSetup.rescanButton,
        callback: createObjectCallback(this, this.rescanPools)
    }))
};
StorageCompleteSetup.prototype.rescanPools = function() {
    MC.addStorage({
        preview: true
    }, {
        dialog: true,
        successMsg: strings.storageSetup.rescanSuccessful,
        callback: createObjectCallback(this, this.updatePoolWidget)
    })
};
StorageCompleteSetup.prototype.removeRescanButton = function() {
    this.buttonContainer.remove(this.rescanButton);
    delete this.rescanButton
};
StorageCompleteSetup.prototype.removeBackButton = function() {
    this.buttonContainer.remove(this.backButton);
    delete this.backButton
};
StorageCompleteSetup.prototype.addBackButton = function() {
    this.buttonContainer.prepend(this.backButton = new ButtonWidget({
        name: "backButton",
        emphasized: true,
        text: strings.Back,
        callback: createObjectCallback(this, this.navigatePreviousStep)
    }))
};
StorageCompleteSetup.prototype.addSpareButton = function(C) {
    this.buttonContainer.prepend(this.spareButton = new ButtonWidget({
        name: "spareButton",
        disable: C,
        emphasized: true,
        text: strings.changeSpares.compleSetupButtonText,
        callback: createObjectCallback(this, this.addSpare)
    }))
};
StorageCompleteSetup.prototype.removeSpareButton = function() {
    this.buttonContainer.remove(this.spareButton);
    delete this.spareButton
};
StorageCompleteSetup.prototype.addSpare = function() {
    this.setCurrentState("addSpare")
};
StorageCompleteSetup.prototype._spareChange = function(D, C) {
    this.update({
        addSpareButton: {
            disable: !C.isValid()
        }
    })
};
StorageCompleteSetup.prototype._addSpare = function() {
    this.changeSpares.addSpare()
};
StorageCompleteSetup.prototype.navigatePreviousStep = function() {
    switch (this.currentStep) {
        case "advancedSetUp":
            this.setCurrentState("advancedDiskGroup");
            this.okEnabled(true);
            break;
        case "autoPoolSetup":
            this.setCurrentState("storageSelection");
            break;
        case "advancedDiskGroup":
            this.setCurrentState("storageSelection");
            break;
        default:
            break
    }
};

function EZPoolWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "EZPoolWidget";
    this.valid = false;
    C.widgets = [new WidgetContainer({
        name: "pools",
        widgets: [new TextWidget({
            name: "configNotFound",
            text: strings.storageSetup.noProvisionFound,
            topMargin: true
        }), new WidgetContainer({
            name: "suggestions",
            widgets: [new TextWidget({
                name: "suggestionText",
                text: strings.storageSetup.suggestionText,
                topMargin: true
            }), new TextWidget({
                name: "suggestionList",
                width: 500,
                topMargin: true
            })]
        }), new ContentHorizontalRule({
            name: "horizontalLine"
        }), new TextWidget({
            name: "configFound",
            text: strings.storageSetup.configFound,
            topMargin: true
        }), new TextWidget({
            name: "configDetails",
            width: 500,
            topMargin: true
        }), new TableInator({
            name: "poolTable",
            classes: "equalColumnWidth",
            width: 500,
            selectable: false,
            topMargin: true,
            type: "rawData",
            metadata: [{
                sTitle: strings.storageSetup.poolLabel
            }, {
                sTitle: strings.storageSetup.tierLabel
            }, {
                sTitle: strings.storageSetup.capacityLabel
            }, {
                sTitle: strings.storageSetup.numDisksLabel
            }],
            noFeatures: true
        }), new WidgetContainer({
            name: "adaptExpansions",
            widgets: [new TextWidget({
                text: '<span style="font-size: 14px;">' + strings.storageSetup.adaptExpansionsLabel + "</span>",
                topMargin: true
            }), new TextWidget({
                text: strings.storageSetup.adaptExpansionsText,
                topMargin: true
            }), new TableInator({
                name: "adaptExpansionsTable",
                classes: "equalColumnWidth",
                width: 500,
                topMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: strings.storageSetup.poolLabel
                }, {
                    sTitle: strings.storageSetup.tierLabel
                }, {
                    sTitle: strings.storageSetup.size
                }, {
                    sTitle: strings.storageSetup.numDisksLabel
                }],
                noFeatures: true
            })]
        }), new WidgetContainer({
            name: "globalSpares",
            widgets: [new TextWidget({
                text: '<span style="font-size: 14px;">' + strings.storageSetup.globalSparesLabel + "</span>",
                topMargin: true
            }), new TextWidget({
                text: strings.storageSetup.globalSparesText,
                topMargin: true
            }), new TableInator({
                name: "globalSparesTable",
                classes: "equalColumnWidth",
                width: 500,
                topMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: strings.storageSetup.location
                }, {
                    sTitle: strings.storageSetup.tierLabel
                }, {
                    sTitle: strings.storageSetup.type
                }, {
                    sTitle: strings.storageSetup.size
                }],
                noFeatures: true
            })]
        }), new WidgetContainer({
            name: "unusedDisks",
            widgets: [new TextWidget({
                text: '<span style="font-size: 14px;">' + strings.storageSetup.unusedDisksLabel + "</span>",
                topMargin: true
            }), new TextWidget({
                text: strings.storageSetup.unusedDisksText,
                topMargin: true
            }), new TableInator({
                name: "unusedDisksTable",
                classes: "equalColumnWidth",
                width: 500,
                topMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: strings.storageSetup.location
                }, {
                    sTitle: strings.storageSetup.type
                }, {
                    sTitle: strings.storageSetup.size
                }, {
                    sTitle: strings.storageSetup.fdeState
                }],
                noFeatures: true
            })]
        })]
    })];
    WidgetContainer.call(this, C);
    this.class_name = "EZPoolWidget"
}
EZPoolWidget.prototype = new WidgetContainer();
EZPoolWidget.prototype.constructor = EZPoolWidget;
EZPoolWidget.prototype.setPoolState = function(R) {
    var E = {};
    if (R != null) {
        storagePreviewObj = R.json.objects[0]
    }
    var H = {
        A: {},
        B: {}
    };
    var K = [];
    var L = [];
    var D = [];
    var J = false;
    if (typeof storagePreviewObj != "undefined") {
        for (var V = 0; V < storagePreviewObj.objects.length; V++) {
            var S = storagePreviewObj.objects[V];
            if (S.name == "disk-groups-preview") {
                J = true;
                var F;
                switch (S.getInt("tier_numeric")) {
                    case TIERS.PERFORMANCE:
                        F = strings.storageSetup.tierPerf;
                        break;
                    case TIERS.STANDARD:
                        F = strings.storageSetup.tierStand;
                        break;
                    case TIERS.ARCHIVE:
                        F = strings.storageSetup.tierArch;
                        break;
                    case TIERS.READCACHE:
                        F = strings.storageSetup.tierReadCache;
                        break;
                    default:
                        break
                }
                if (S.get("pool") == "A") {
                    if (H.A[F]) {
                        var C = new Size(S.get("size_numeric"));
                        var Q = H.A[F].capacity;
                        H.A[F].capacity = Q.add(C);
                        H.A[F].disks += S.getInt("disk_count")
                    } else {
                        H.A[F] = {
                            capacity: new Size(S.get("size_numeric")),
                            disks: S.getInt("disk_count")
                        }
                    }
                } else {
                    if (H.B[F]) {
                        var C = new Size(S.get("size_numeric"));
                        var Q = H.B[F].capacity;
                        H.B[F].capacity = Q.add(C);
                        H.B[F].disks += S.getInt("disk_count")
                    } else {
                        H.B[F] = {
                            capacity: new Size(S.get("size_numeric")),
                            disks: S.getInt("disk_count")
                        }
                    }
                }
            } else {
                if (S.name == "unused-disks-preview") {
                    K.push([S.get("location"), S.get("type"), S.get("size"), S.get("fde_state")])
                } else {
                    if (S.name == "spares-preview") {
                        L.push([S.get("location"), S.get("tier"), S.get("type"), S.get("size")])
                    } else {
                        if (S.name == "adapt-expand-preview") {
                            if (!J) {
                                J = true
                            }
                            D.push([S.get("pool"), S.get("tier"), S.get("size"), S.get("disk_count")])
                        }
                    }
                }
            }
        }
        if (storagePreviewObj.get("suggestions")) {
            var T = "<ul>";
            var X = storagePreviewObj.get("suggestions").split("- ");
            for (var V = 0; V < X.length; V++) {
                var W = X[V];
                if (W != "  ") {
                    T += "<li>" + W + "</li>"
                }
            }
            T += "</ul>";
            E.suggestions = {
                visibility: "visible"
            };
            E.suggestionList = {
                text: T
            };
            if (J) {
                E.suggestionText = {
                    visibility: "visible"
                }
            } else {
                E.suggestionText = {
                    visibility: "collapse"
                }
            }
        } else {
            E.suggestions = {
                visibility: "collapse"
            };
            E.horizontalLine = {
                visibility: "collapse"
            }
        }
    } else {
        E.suggestionText = {
            visibility: "collapse"
        };
        E.suggestions = {
            visibility: "visible"
        };
        E.suggestionList = {
            text: R.message
        }
    }
    if (J) {
        E.configNotFound = {
            visibility: "collapse"
        };
        var I = [];
        var G = 0;
        var P = "";
        for (var O in H) {
            for (var F in H[O]) {
                if (P != "") {
                    if (F != P) {
                        G++
                    }
                } else {
                    G++;
                    P = F
                }
                var N = H[O][F];
                I.push([O, F, N.capacity.format(), N.disks])
            }
        }
        if (G > 0) {
            if (Object.keys(H.A).length && Object.keys(H.B).length) {
                var U = strings.storageSetup.configDetailsPlural((this.provideSkip ? strings.storageSetup.expandPoolLabel : strings.storageSetup.createPoolLabel), (this.provideSkip ? strings.storageSetup.expandPoolDetail : strings.storageSetup.createPoolDetail), G)
            } else {
                var M = (Object.keys(H.A).length ? "A" : "B");
                if (G > 1) {
                    var U = strings.storageSetup.configDetailsPlural((this.provideSkip ? strings.storageSetup.expandPoolLabel : strings.storageSetup.createPoolLabel), (this.provideSkip ? strings.storageSetup.expandPoolSingle(M) : strings.storageSetup.createPoolSingle(M)), G)
                } else {
                    var U = strings.storageSetup.configDetailsSingle((this.provideSkip ? strings.storageSetup.expandPoolLabel : strings.storageSetup.createPoolLabel), (this.provideSkip ? strings.storageSetup.expandPoolSingle(M) : strings.storageSetup.createPoolSingle(M)))
                }
            }
        } else {
            var U = strings.storageSetup.configDetailsAdapt
        }
        E.poolTable = {
            visibility: (I.length ? "visible" : "collapse"),
            data: I
        };
        E.configDetails = {
            text: U
        };
        this.valid = true
    } else {
        E.poolTable = {
            visibility: "collapse"
        };
        E.configFound = {
            visibility: "collapse"
        };
        if (!K.length) {
            E.horizontalLine = {
                visibility: "collapse"
            }
        }
        this.configNotFound = true
    }
    if (K.length) {
        E.unusedDisks = {
            visibility: "visible"
        };
        E.unusedDisksTable = {
            data: K
        }
    } else {
        E.unusedDisks = {
            visibility: "collapse"
        }
    }
    if (L.length) {
        E.globalSpares = {
            visibility: "visible"
        };
        E.globalSparesTable = {
            data: L
        }
    } else {
        E.globalSpares = {
            visibility: "collapse"
        }
    }
    if (D.length) {
        E.adaptExpansions = {
            visibility: "visible"
        };
        E.adaptExpansionsTable = {
            data: D
        }
    } else {
        E.adaptExpansions = {
            visibility: "collapse"
        }
    }
    this.update(E)
};
EZPoolWidget.prototype.isValid = function() {
    return this.valid
};
var activeDialogActive = false;

function ActiveDialogPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "ActiveDialogPanel"
    }
    C.widgets = new WidgetContainer({
        name: "container",
        classes: "ActiveDialogContainer dark",
        widgets: [new StatusWidget({
            name: "statusWidget",
            cssClass: "activeDialogStatus",
            status: "processing"
        }), new TextWidget({
            name: "headerWidget",
            cssClass: "activeDialogHeader"
        }), new TextWidget({
            name: "textWidget",
            cssClass: "activeDialogText",
            text: ""
        }), new ButtonContainer({
            name: "okCancelButtons",
            arrange: "RTL",
            alignment: "right",
            rightMargin: true,
            widgets: [new ButtonWidget({
                emphasized: true,
                id: "adp_ok",
                name: "okButton",
                text: strings.okButtonText,
                click: function() {
                    ActiveDialogOK()
                }
            }), new ButtonWidget({
                emphasized: false,
                id: "adp_cancel",
                name: "cancelButton",
                text: strings.cancelButtonText,
                click: function() {
                    ActiveDialogCancel()
                }
            })]
        })]
    });
    Panel.call(this, C);
    this.class_name = "ActiveDialogPanel";
    this.textWidget = $(".activeDialogText", this.elements);
    this.__setOptions({}, true)
}
ActiveDialogPanel.prototype = new Panel();
ActiveDialogPanel.prototype.attaching = function() {};
ActiveDialogPanel.prototype.showing = function() {};
ActiveDialogPanel.prototype.hiding = function() {};
ActiveDialogPanel.prototype.__setOptions = function(F, C) {
    if (!C) {
        var E = {
            type: "processing",
            title: strings.activeDialog.processingTitle,
            header: null,
            message: strings.activeDialog.processing,
            successMsg: strings.activeDialog.success,
            failureMsg: strings.activeDialog.failure,
            okState: "enabled",
            okLabel: strings.okButtonText,
            cancelState: "enabled",
            cancelLabel: strings.cancelButtonText,
            cancel: function() {},
            ok: function() {}
        };
        $.extend(this.options, E)
    }
    var D = F || {};
    if (D.processingMsg) {
        D.type = "processing";
        D.message = D.processingMsg;
        delete D.processingMsg
    }
    if (D.noButtons) {
        D.okState = "hidden";
        D.cancelState = "hidden"
    }
    $.extend(this.options, D);
    if (!C) {
        switch (this.options.type) {
            case "processing":
                this.options.title = D.title || strings.activeDialog.processingTitle;
                this.options.okState = D.okState || "hidden";
                this.options.cancelState = D.cancelState || "hidden";
                break;
            case "success":
                this.options.title = D.title || strings.activeDialog.successTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelState = D.cancelState || "hidden";
                break;
            case "failure":
                this.options.title = D.title || strings.activeDialog.failureTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelState = D.cancelState || "hidden";
                break;
            case "confirm":
                this.options.title = D.title || strings.activeDialog.confirmTitle;
                this.options.okLabel = D.okLabel || strings.Yes;
                this.options.cancelLabel = D.cancelLabel || strings.No;
                break;
            case "message":
                this.options.title = D.title || strings.activeDialog.messageTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelState = D.cancelState || "hidden";
                break;
            case "warning":
                this.options.title = D.title || strings.activeDialog.warningTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelState = D.cancelState || "hidden";
                break;
            case "error":
                this.options.title = D.title || strings.activeDialog.errorTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelState = D.cancelState || "hidden";
                break;
            default:
                this.options.title = D.title || strings.activeDialog.defaultTitle;
                this.options.okLabel = D.okLabel || strings.okButtonText;
                this.options.cancelLabel = D.cancelLabel || strings.cancelButtonText;
                break
        }
    }
    return this.options
};

function __ActiveDialogSetOptions(D, C) {
    return panels.activeDialogPanel.__setOptions(D, C)
}

function ShowActiveDialog(C) {
    if (!panels.activeDialogPanel) {
        return
    }
    if (activeDialogActive && !C.dialogOverride) {
        return
    }
    activeDialogActive = true;
    ActiveDialogUpdate(C, true);
    views.activeDialogView.dialog("open")
}

function HideActiveDialog() {
    if (activeDialogActive) {
        activeDialogActive = false;
        views.activeDialogView.dialog("close")
    }
}

function ActiveDialogOK() {
    MC.debugOutput("OK clicked");
    var C = panels.activeDialogPanel.options;
    if (C.type == "confirm" && C.confirmMsg) {
        var D = {
            message: C.confirmMsg
        };
        delete panels.activeDialogPanel.options.confirmMsg;
        ActiveDialogUpdate(D)
    } else {
        HideActiveDialog();
        C.ok()
    }
}

function ActiveDialogCancel() {
    MC.debugOutput("Cancel clicked");
    var C = panels.activeDialogPanel.options;
    var D = activeDialogActive;
    HideActiveDialog();
    if (D && C && C.cancel) {
        C.cancel()
    }
}

function ActiveDialogClosing() {
    if (activeDialogActive) {
        ActiveDialogCancel()
    }
}

function ActiveDialogUpdate(H, G) {
    if (!activeDialogActive) {
        return
    }
    var C = panels.activeDialogPanel;
    if (C.uiDialogTitle == undefined) {
        C.uiDialogTitle = $(".ui-dialog-title", views.activeDialogView.parent().parent())
    }
    var D = __ActiveDialogSetOptions(H, (G ? false : true));
    var F = {
        statusWidget: {
            status: D.type
        },
        headerWidget: {
            visbility: (D.header ? "visible" : "collapse"),
            text: (D.header || "")
        },
        textWidget: {
            text: D.message
        },
        okButton: {
            text: D.okLabel,
            disable: ((D.okState == "disabled") ? true : false),
            visibility: ((D.okState == "hidden") ? "collapse" : "visible")
        },
        cancelButton: {
            text: D.cancelLabel,
            disable: ((D.cancelState == "disabled") ? true : false),
            visibility: ((D.cancelState == "hidden") ? "collapse" : "visible")
        }
    };
    if (D.title && C.uiDialogTitle) {
        C.uiDialogTitle.html(D.title)
    }
    C.update(F);
    C.textWidget.scrollTop(C.textWidget.prop("scrollHeight"));
    var E = C.elements$.find("[tabindex=0]").not(":disabled").first();
    if (E) {
        setTimeout(function() {
            try {
                E.focus()
            } catch (I) {
                MC.errorOutput("Unable to set focus on element, %o, in ActiveDialog ", E)
            }
        }, 0)
    }
}

function EasyStartManager() {}
EasyStartManager.prototype.isConfigurationComplete = function() {
    this.getRequiredConfiguration();
    if (this.requiredSteps.length > 0) {
        return false
    } else {
        return true
    }
};
EasyStartManager.prototype.getUserInteractions = function() {
    this.userInteractionsSubscription = MC.userInteractionsSet.requestData({
        requestor: "EasyStartManager",
        update: true,
        durable: true,
        handler: createObjectCallback(this, function(D) {
            var C = D.getData();
            if (!C) {
                return
            }
            C = C.objects[0];
            this.bypassPortConfig = decodeBooleanFlag(C.get("bypass_port_config_numeric"));
            this.bypassSupportAssist = decodeBooleanFlag(C.get("bypass_support_assist_numeric"));
            this.bypassLicenseConfig = decodeBooleanFlag(C.get("bypass_license_config_numeric"));
            this.bypassFirmware = decodeBooleanFlag(C.get("bypass_firmware_numeric"));
            this.bypassNotifications = decodeBooleanFlag(C.get("bypass_notifications_numeric"));
            this.bypassEasyStart = decodeBooleanFlag(C.get("bypass_easy_start_numeric"));
            NAV.navTo("topics", "home", null);
            if (settings.memorex == "ctk") {
                NAV.navTo("topics", "ctk", null)
            }
        })
    })
};
EasyStartManager.prototype.showEasyStart = function() {
    if (RI.hasFeature("easyStart") && !this.bypassEasyStart) {
        return true
    } else {
        return false
    }
};
EasyStartManager.prototype.isStepRequired = function(D) {
    if (RI.hasFeature("easyStart")) {
        this.getRequiredConfiguration();
        for (var C = 0; C < this.requiredSteps.length; C++) {
            if (this.requiredSteps[C] == D) {
                return true
            }
        }
    }
    return false
};
EasyStartManager.prototype.getRequiredConfiguration = function() {
    this.requiredSteps = [];
    if (RI.hasFeature("easyStart") && !this.bypassEasyStart) {
        if (!this.bypassPortConfig && APIPort.hasPortType("iSCSI")) {
            var C = 0;
            var G = 0;
            for (var F in DC.ports) {
                var E = DC.ports[F];
                if (E.getInt("port_type_numeric") == PORT_TYPES.ISCSI) {
                    G += 1;
                    if (E.get("_ip_address") == "0.0.0.0") {
                        C += 1
                    }
                }
            }
            if (G == C) {
                this.requiredSteps.push("ports")
            }
        }
        for (var H in DC.users) {
            var D = DC.users[H];
            if (D) {
                if (!decodeBooleanFlag(D.get("default_password_changed_numeric"))) {
                    this.requiredSteps.push("manageUsers");
                    break
                }
            }
        }
    }
    this.updateRequiredConfiguration()
};
EasyStartManager.prototype.updateRequiredConfiguration = function() {
    if (!MC.systemInfoSet.data) {
        this.requiredSteps.push("notifications");
        this.requiredSteps.push("license");
        this.requiredSteps.push("supportAssist");
        return
    }
    if (!this.bypassNotifications) {
        var J;
        var D;
        var H;
        if (!MC.emailParametersSet.data) {
            J = false
        } else {
            J = decodeBooleanFlag(MC.emailParametersSet.data.objects[0].get("email_notification_numeric"))
        }
        if (!MC.snmpParametersSet.data) {
            D = false
        } else {
            D = decodeBooleanFlag(MC.snmpParametersSet.data.objects[0].get("snmp_enabled_numeric"))
        }
        if (!MC.syslogParametersSet.data) {
            H = false
        } else {
            H = MC.syslogParametersSet.data.objects[0].getInt("syslog_notification_level_numeric") != 5
        }
    }
    if (isVistaSystem() && !this.bypassLicenseConfig) {
        var K = 0;
        for (var I in DC.disks) {
            var C = DC.disks[I];
            var G = C.get("type_numeric");
            if (G == DISK_TYPES.SSD_SATA || G == DISK_TYPES.SSD_SAS || G == DISK_TYPES.SSD_SATA_SINGLE_PORT || G == DISK_TYPES.SSD_SAS_SATA_DLC || G == DISK_TYPES.SSD_SAS_SINGLE_PORT) {
                K += 1
            }
        }
        var E = licenseInfo.licenseData.getInt("performance_tier_numeric") == 1;
        if (K > 4 && !E) {
            this.requiredSteps.push("license")
        }
        if (!this.bypassNotifications && !J && !D && !H) {
            this.requiredSteps.push("notifications")
        }
    }
    if (isHPsystem()) {
        if (!this.bypassLicenseConfig && !licenseInfo.isLicensed("performance_tier")) {
            this.requiredSteps.push("license")
        }
        if (!this.bypassNotifications && !J && !D && !H) {
            this.requiredSteps.push("notifications")
        }
    }
    if (isDellBBSystem()) {
        if (!this.bypassNotifications && !J && !D && !H) {
            this.requiredSteps.push("notifications")
        }
    }
    if (RI.hasFeature("supportAssist") && !isDellBBSystem()) {
        if (!this.bypassSupportAssist) {
            var F = (MC.supportAssistSet.data.objects[0].getInt("support_assist_state_numeric") == SUPPORTASSIST_STATE.DISABLED);
            if (F) {
                this.requiredSteps.push("supportAssist")
            }
        }
    }
};
var EZStartManager = new EasyStartManager();

function cursorWait() {
    $("body").css("cursor", "wait !important")
}

function cursorAuto() {
    $("body").css("cursor", "auto")
}

function adjustLayout() {
    computeLayout()
}

function computeLayout() {
    var I = $(window).width();
    var J = $(window).height();
    var N = views.topicView;
    var G = N.dimsInstance();
    var D = views.footerView.dimsInstance();
    var M = D.Height + D.vSpace;
    var C = G.Offset.left;
    var H = G.Offset.top;
    var O = I - C;
    var E = J - H - M;
    if (!G.setPos) {
        $(N).css("top", 0).css("left", 0);
        G.setPos = true
    }
    var L = views.topicView;
    mDims = L.dimsInstance();
    var K = O - mDims.hSpace;
    var F = E - mDims.vSpace;
    if (K < 500) {
        K = 500
    }
    L.width(K);
    L.height(F);
    L.css("top", H);
    L.css("left", C);
    mDims.Offset.top = H + mDims.MarginTop;
    mDims.Offset.left = C + mDims.MarginLeft;
    views.topicView.resizing()
}

function setMenus() {
    if (!RI.pagedOnly() && RI.hasFeature("rsr")) {
        var C = replicationSetup();
        var D = DC.protocols.getInt("management_mode_numeric");
        if (C == "rsr" || (C == "none" && D == MANAGEMENT_MODE.LINEAR)) {
            MENUS.topics.replications.topic = "RsrTopic";
            MENUS.VolumesTopic = RSRVOLTOPIC;
            panels.TopicMenuPanel.topicList.RsrTopic = "replications";
            delete panels.TopicMenuPanel.topicList.RepsTopic
        }
    }
    if (!RI.hasFeature("oneButtonProvision")) {
        delete MENUS.HomeTopic.addStorage
    }
    if (isVistaSystem()) {
        delete MENUS.SystemTopic.advancedSettings
    }
    if (!RI.hasFeature("heatmap")) {
        delete MENUS.footerPanels.ssdActivity
    }
    if (RI.feature("storageModel") != "HYBRID") {
        delete MENUS.PoolsTopic.expandDiskGroups
    }
    if (!RI.hasFeature("completesetup")) {
        delete MENUS.HomeTopic.storageCompleteSetup;
        delete MENUS.PoolsTopic.storageCompleteSetup;
        delete MENUS.HomeTopic.hostSetup;
        delete MENUS.HostsTopic.hostSetup
    }
    if (RI.hasFeature("easyStartFirmware")) {
        delete MENUS.HomeTopic.storageSetup
    }
    if (isDellSystem()) {
        delete MENUS.HomeTopic.storageSetup
    }
}

function UnauthorizedAccessOk() {
    HideActiveDialog();
    location.reload()
}

function SessionWarningOk() {
    HideActiveDialog();
    applicationAccessed();
    session.inWarning = false
}

function SessionTimeoutOk() {
    HideActiveDialog();
    location.reload()
}

function LogoutRequestHandling() {
    ShowActiveDialog({
        title: strings.logoutRequest.title,
        type: "confirm",
        message: strings.logoutRequest.confirmMsg,
        okLabel: strings.logoutRequest.okLabel,
        cancelLabel: strings.wiz.cancelButtonText,
        dialogOverride: true,
        ok: LogoutRequestOk
    })
}

function LogoutRequestOk() {
    HideActiveDialog();
    session.logout(logoutComplete)
}

function ActionDialogPanel(D) {
    if (arguments.length == 0 || !D.name) {
        return
    }
    var C = {
        width: 1000,
        closing: function() {}
    };
    $.extend(C, D);
    this.name = D.name;
    this.initialized = false;
    C.htmlText = '<div id="' + this.name + '" class="actionDialog"></div>';
    C.viewElementNames = [this.name];
    Panel.call(this, C);
    this.class_name = "ActionDialogPanel";
    this.panel$ = $("#" + this.name, this.elements);
    this.view = views[this.name];
    this.view.bind("dialogclose", this.closing);
    this.currentOptions = $.extend({}, D)
}
ActionDialogPanel.prototype = new Panel();
ActionDialogPanel.prototype.constructor = ActionDialogPanel;
ActionDialogPanel.close = function() {
    if (panels.actionDialog) {
        panels.actionDialog.close(true)
    }
};
ActionDialogPanel.prototype.resizing = function() {
    this.computeDimensions($(this.elements))
};
ActionDialogPanel.prototype.open = function(C) {
    if (this.active) {
        return
    }
    if (arguments.length == 0) {
        return
    }
    if (!C.panel) {
        MC.errorOutput("ActionDialogPanel.open called without panel!");
        return
    }
    this.currentOptions = $.extend({}, this.options, C);
    if (!this.initialized) {
        this.view.dialog({
            autoOpen: false,
            width: this.currentOptions.width,
            height: this.currentOptions.height,
            position: "center",
            modal: true,
            draggable: true,
            resizable: false,
            decorations: false,
            title: strings.applicationTitleAbbrev + " " + strings.taskDialog.title,
            overlay: {
                opacity: "50%",
                filter: "alpha(opacity = 50)"
            },
            close: createObjectCallback(this, this.closing)
        });
        this.dialog$ = this.panel$.closest(".ui-dialog");
        this.title$ = $(".ui-dialog-title", this.dialog$)
    }
    this.title$.html(this.currentOptions.panel.options.title);
    this.view.dialog("open");
    currentAction = this.currentOptions.panel;
    currentAction.focusOnFirstField();
    this.view.viewAttach(currentAction);
    this.resetSize();
    this.active = true
};
ActionDialogPanel.prototype.resetSize = function(E) {
    if (E == undefined) {
        E = {}
    }
    if (!this.dialog$) {
        return
    }
    if (E.width != undefined) {
        this.currentOptions.width = E.width
    }
    if (E.height != undefined) {
        this.currentOptions.height = E.height
    }
    var H = this.currentOptions.width;
    var L = this.currentOptions.height;
    var O = $(".actionDialog", this.dialog$);
    var M = $(".ui-dialog-titlebar", this.dialog$);
    var K = O.children(".actionContainer");
    var I = K.children(".actionTray");
    var C = I.children(".actionPanel");
    if (E.shrink) {
        I.height(50)
    }
    var D = O.outerWidth(true);
    if (H) {
        D = H
    }
    this.dialog$.width(D);
    if (H == 1000) {
        var F = I.width();
        this.dialog$.width(F + 30)
    }
    var N = I.outerHeight(true) + 72;
    var J = C.outerHeight(true) + 72;
    if (J > N) {
        N = J
    }
    if (L) {
        N = L
    } else {
        if (E.extraHeight) {
            if ((typeof E.extraHeight) == "boolean") {
                E.extraHeight = 40
            }
            N += E.extraHeight
        }
    }
    var G = views.topicView.innerHeight();
    if (N > G) {
        N = G
    }
    K.height(N - 40);
    I.height(N - 72).css("overflow", "auto");
    if (J != C.outerHeight(true) + 72) {
        N = C.outerHeight(true) + 72;
        K.height(N - 40);
        I.height(N - 72).css("overflow", "auto")
    }
    this.dialog$.height(N);
    this.view.dialog("position");
    this.panel$.resizing()
};
ActionDialogPanel.prototype.close = function(C) {
    currentAction = null;
    if (this.active) {
        MC.debugOutput("ActionDialog being closed", "%s");
        this.active = false;
        this.view.viewDetach();
        if ($.isFunction(this.currentOptions.panel.closing)) {
            this.currentOptions.panel.closing()
        }
        if ($.isFunction(this.currentOptions.panel.cleanUp)) {
            this.currentOptions.panel.cleanUp()
        }
        delete panels[this.currentOptions.panel.options.name];
        delete this.currentOptions.panel;
        this.view.dialog("close");
        if (C) {
            this.currentOptions.closing()
        }
    }
};
ActionDialogPanel.prototype.closing = function() {
    if (this.active) {
        this.close(true)
    }
};

function HoverDialogPanel(D) {
    if (arguments.length == 0 || !D.name) {
        return
    }
    var C = {
        width: 200,
        closing: function() {}
    };
    $.extend(C, D);
    this.name = D.name;
    this.initialized = false;
    C.htmlText = '<div id="' + this.name + '" class="hoverDialog"></div>';
    C.viewElementNames = [this.name];
    Panel.call(this, C);
    this.class_name = "HoverDialogPanel";
    this.panel$ = $("#" + this.name, this.elements);
    this.view = views[this.name];
    this.currentOptions = $.extend({}, D)
}
HoverDialogPanel.prototype = new Panel();
HoverDialogPanel.prototype.constructor = HoverDialogPanel;
HoverDialogPanel.prototype.resizing = function() {
    this.computeDimensions($(this.elements))
};
HoverDialogPanel.prototype.open = function(L) {
    applicationAccessed();
    if (arguments.length == 0) {
        L = this.currentOptions
    }
    if (!L.panel) {
        MC.errorOutput("HoverDialogPanel.open called without panel!");
        return
    }
    var R = views.bannerView.outerHeight(true) + 4;
    var Q = $(window).height() - views.footerView.outerHeight(true) - 5;
    var T = views.topicMenuView.outerWidth(true) + 4;
    var S = $(window).width() - 10;
    var M = Q - R;
    var P = S - T;
    this.currentOptions = $.extend({}, this.options, L);
    if (!this.initialized) {
        this.view.dialog({
            autoOpen: false,
            width: this.currentOptions.width,
            height: this.currentOptions.height,
            position: "center",
            modal: false,
            draggable: false,
            resizable: false,
            decorations: false
        });
        this.dialog$ = this.panel$.closest(".ui-dialog");
        this.title$ = $(".ui-dialog-title", this.dialog$);
        this.initialized = true
    }
    this.currentOptions.panel.currentParent = L.parentObj;
    this.currentOptions.panel.eventObj = L.eventObj;
    this.title$.html(this.currentOptions.panel.options.title);
    this.view.viewAttach(this.currentOptions.panel);
    this.view.dialog("open");
    var D = $(".hoverDialog", this.dialog$);
    var C = $(".ui-dialog-titlebar", this.dialog$);
    var I = D.children(".hoverContainer").children();
    var N = D.outerWidth(true);
    var K = $(".tableWidget", I).width() + 19;
    if (this.currentOptions.panel.options.width) {
        N = this.currentOptions.panel.options.width
    }
    if (N < K) {
        N = K
    }
    if (N > P) {
        N = P
    }
    this.dialog$.width(N);
    var J = I.outerHeight(true) + 40;
    if (this.currentOptions.height) {
        J = this.currentOptions.height
    }
    if (J > M) {
        J = M
    }
    this.dialog$.height(J);
    this.panel$.resizing();
    var F = L.eventObj.clientX;
    var E = L.eventObj.clientY;
    var O = L.offsetElement$.offset();
    var G = O.top + L.offsetElement$.outerHeight(false) + 5;
    if ((G + J) > Q) {
        G = O.top - J - 5
    }
    if (G > R) {
        var H = parseInt(F - (N / 2), 10);
        if (H < T) {
            H = T
        } else {
            if ((H + N) > S) {
                H = S - N
            }
        }
    } else {
        var G = parseInt(E - (J / 2), 10);
        if ((G + J) > Q) {
            G = Q - J
        }
        if (G < R) {
            G = R
        }
        var H = O.left - N - 5;
        if (H < T) {
            H = O.left + L.offsetElement$.outerWidth(false) + 5
        }
        if ((H + N) > S) {
            if (F > (S - F)) {
                H = F - N - 5;
                if (H < T) {
                    H = T
                }
            } else {
                H = F + 5;
                if ((H + N) > S) {
                    H = S - N
                }
            }
        }
    }
    this.dialog$.offset({
        top: G,
        left: H
    });
    this.active = true
};
HoverDialogPanel.prototype.close = function() {
    if (this.active) {
        this.active = false;
        this.view.dialog("close")
    }
};

function logoutComplete() {
    var C = new Panel({
        name: "empty",
        htmlText: "<div></div>",
        attachTo: $("#rootView")
    });
    location.reload()
}

function applicationPreInit() {
    APIObject.setHover("system", new SystemHover({}));
    APIObject.setHover("drives", new DrivesHover({}));
    APIObject.setHover("enclosures", new EnclosuresHover({}));
    APIObject.setHover("controllers", new ControllersHover({}));
    APIObject.setHover("power-supplies", new PowerSuppliesHover({}));
    APIObject.setHover("io-modules", new IoModulesHover({}));
    APIObject.setHover("port", new PortHover({}));
    APIObject.setHover("network-parameters", new NetworkParametersHover({}));
    APIObject.setHover("fan", new FanHover({}));
    APIObject.setHover("expander-ports", new ExpanderPortsHover({}));
    APIObject.setHover("compact-flash", new CompactFlashHover({}));
    APIObject.setHover("drawers", new DrawersHover({}));
    new HealthHover({});
    new CapacityHover({});
    new StorageHover({});
    new TierHover({});
    new PoolHover({});
    new DiskGroupHover({});
    new ReplicationSetsHover({});
    new PeerConnectionsHover({});
    new VolumeHover({});
    new SnapshotHover({});
    new ScheduleHover({});
    new RemoteSystemHover({});
    new RsrReplicationSetHover({});
    new ReplicationImageHover({});
    new Panel({
        name: "applicationPanel",
        htmlText: '<div id="pageView" class="pageView">    <div id="bannerView" class="bannerView">        <div id="titleView"></div>        <div id="sysInfoView"></div>        <div id="connectView"></div>        <div id="dateTimeView"></div>        <div id="userView"></div>        <div id="helpLinkView"></div>    </div>    <div id="topicMenuView" class="topicMenuView"></div>    <div id="topicView" class="topicView"></div>    <div id="footerView" class="footerView">        <div id="healthView"></div>        <div id="eventView"></div>        <div id="capacityView"></div>        <div id="perfView"></div>        <div id="tierIoView"></div>        <div id="ssdActivityView"></div>        <div id="activityView"></div>    </div>    <div id="activeDialogContainer">        <div id="activeDialogView" class="dh activeDialog"></div>    </div>    <div id="actionDialogContainer">        <div id="actionDialogView" class="dh actionDialog dark"></div>    </div>    <div id="hoverDialogContainer">        <div id="hoverDialogView" class="dh hoverDialog"></div>    </div>    <div id="topicSubMenuView"></div>    <div id="actionMenuView"></div>    <div id="editMenuView"></div>    <div id="tipView"></div></div>',
        viewElementNames: ["bannerView", "titleView", "sysInfoView", "connectView", "dateTimeView", "userView", "helpLinkView", "topicMenuView", "topicView", "footerView", "healthView", "eventView", "capacityView", "perfView", "tierIoView", "ssdActivityView", "activityView", "activeDialogView", "actionDialogView", "hoverDialogView", "topicSubMenuView", "actionMenuView", "editMenuView", "tipView"],
        attachTo: $("#rootView"),
        success: function() {}
    });
    new TopicMenuPanel({
        menu: "topics",
        attachTo: views.topicMenuView
    });
    new TitleBarPanel({
        attachTo: views.titleView
    });
    new SysInfoBarPanel({
        attachTo: views.sysInfoView
    });
    new ConnectBarPanel({
        attachTo: views.connectView
    });
    new DateTimeBarPanel({
        attachTo: views.dateTimeView
    });
    new UserBarPanel({
        attachTo: views.userView
    });
    new HelpBarPanel({
        attachTo: views.helpLinkView
    });
    new HealthBarPanel({
        attachTo: views.healthView
    });
    new EventBarPanel({
        attachTo: views.eventView
    });
    new CapacityBarPanel({
        attachTo: views.capacityView
    });
    new PerfBarPanel({
        attachTo: views.perfView
    });
    new TierIoBarPanel({
        attachTo: views.tierIoView
    });
    new SSDActivityPanel({
        attachTo: views.ssdActivityView
    });
    new ActivityBarPanel({
        attachTo: views.activityView
    });
    new VMenuPanel({
        name: "actionMenu",
        attachTo: views.actionMenuView
    });
    new VMenuPanel({
        name: "editMenu",
        attachTo: views.editMenuView
    });
    new ActionDialogPanel({
        name: "actionDialog",
        attachTo: views.actionDialogView
    });
    new HoverDialogPanel({
        name: "hoverDialog",
        attachTo: views.hoverDialogView
    });
    new VMenuPanel({
        name: "contextMenu",
        attachTo: $("#contextmenu")
    });
    new TipPanel({
        name: "tipPanel",
        attachTo: views.tipView
    });
    connection.displayConnection();
    views.activeDialogView.dialog({
        width: 600,
        height: 300,
        position: "center",
        modal: true,
        draggable: true,
        resizable: false,
        shadow: false,
        hidden: true,
        decorations: false,
        overlay: {
            opacity: "50%",
            filter: "alpha(opacity = 50)"
        }
    });
    views.activeDialogView.bind("dialogclose", ActiveDialogClosing);
    new ActiveDialogPanel({
        name: "activeDialogPanel",
        attachTo: views.activeDialogView
    });
    ShowActiveDialog({
        title: strings.activeDialog.applicationTitle,
        processingMsg: strings.activeDialog.applicationTitle,
        dialogOverride: true,
        noButtons: true
    })
}

function BarPanel(G) {
    if (arguments.length == 0) {
        return
    }
    var C = "barPanel" + (G.classes ? " " + G.classes : "");
    var F = "";
    if (G.editable) {
        this.editType = "banner";
        var E = "bannerEditButton";
        var D = "";
        if (G.editable == "footer") {
            E = "footerEditButton";
            this.editType = "footer"
        } else {
            if (G.editable instanceof Object) {
                if (G.editable.type == "footer") {
                    E = "footerEditButton";
                    this.editType = "footer"
                }
                var D = ' style="' + G.editable.position + '"'
            }
        }
        F = '<div title="' + strings.ClickMenu + '" class="' + E + '"' + D + "></div>"
    }
    var H = '<div id="' + G.name + '" class=" dark ' + C + '">' + (G.htmlText || "") + F + "</div>";
    G.htmlText = H;
    G.widgetsParentID = G.name;
    Panel.call(this, G);
    this.class_name = "BarPanel";
    if (G.editable) {
        this.editButton$ = $("." + E, this.elements);
        this.elements$.bind("click", createObjectCallback(this, this._editClicked));
        this.menu = G.menu || G.name;
        this.editButton$.hover(createObjectCallback(this, this.disableHover), createObjectCallback(this, this.enableHover));
        this.editButton$.mouseleave(createObjectCallback(this, this._editButtonLeft));
        this.leftEditButtonTimeoutCallback = createObjectCallback(this, this._leftEditButtonTimeout)
    }
}
BarPanel.prototype = new Panel();
BarPanel.prototype.constructor = BarPanel;
BarPanel.prototype._editClicked = function() {
    if (panels.editMenu.visible) {
        panels.editMenu.close();
        this.enableHover()
    } else {
        var C = "right";
        var D = "below";
        if (this.editType == "footer") {
            D = "above"
        }
        this.editMenuEntered = false;
        this.disableHover();
        panels.editMenu.open({
            parentObj: this,
            menu: this.menu,
            position: {
                element$: this.editButton$,
                direction: D,
                edge: C
            }
        })
    }
};
BarPanel.prototype._leftEditButtonTimeout = function() {
    MC.debugOutput("TopicPanel.leftEditButtonTimeout()");
    if (panels.editMenu.visible && !this.editMenuEntered) {
        panels.editMenu.close()
    }
};
BarPanel.prototype._editButtonLeft = function() {
    MC.debugOutput("TopicPanel.editButtonLeft()");
    if (panels.editMenu.visible) {
        this.leavingEditButtonTimeout = setTimeout(this.leftEditButtonTimeoutCallback, 200);
        this.disableHover()
    }
    return false
};
BarPanel.prototype.enteringSubMenu = function() {
    MC.debugOutput("BarPanel edit menu entered.");
    this.editMenuEntered = true
};

function TitleBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "TitleBarPanel"
    }
    C.classes = "titleBarPanel";
    C.htmlText = "<span><h1>&nbsp;</h1><br /><h2>" + strings.applicationTitle + "</h2></span>";
    BarPanel.call(this, C);
    this.productStr$ = $("h1", this.elements);
    this.class_name = "TitleBarPanel"
}
TitleBarPanel.prototype = new BarPanel();
TitleBarPanel.prototype.constructor = TitleBarPanel;
TitleBarPanel.prototype.showing = function() {
    var C = this;
    this.sysInfoSubscription = MC.systemInfoSet.requestData({
        update: false,
        requestor: this.class_name,
        handler: function(D) {
            if (isVistaSystem()) {
                var E = "ThinkSystem " + DC.system.prop.product_id.text
            } else {
                var E = DC.system.prop.product_id.text
            }
            C.productStr$.text(E)
        }
    })
};

function SysInfoBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "SysInfoBarPanel"
    }
    C.editable = "banner";
    C.htmlText = '<span class="barLabel">' + strings.sysInfoBar.systemLabel + '</span><span id="sysInfoName"></span><br ><span class="barLabel">' + strings.sysInfoBar.versionLabel + '</span><span id="sysInfoVersion"></span>';
    C.hoverPanel = APIObject.getHover("system");
    BarPanel.call(this, C);
    this.class_name = "SysInfoBarPanel";
    this.sysName$ = $("#sysInfoName", this.elements);
    this.sysVersion$ = $("#sysInfoVersion", this.elements)
}
SysInfoBarPanel.prototype = new BarPanel();
SysInfoBarPanel.prototype.constructor = SysInfoBarPanel;
SysInfoBarPanel.prototype.showing = function() {
    var C = this;
    this.sysInfoSubscription = MC.systemInfoSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: function(D) {
            C.sysName$.text(DC.system.prop.system_name.text)
        }
    });
    this.versionsSubscription = MC.versionsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._handleVersions)
    })
};
SysInfoBarPanel.prototype._handleVersions = function(C) {
    var D = (session.controller == "B" ? 1 : 0);
    var E = C.getData();
    if (E.objects[D]) {
        this.sysVersion$.text(E.objects[D].prop.bundle_version.text)
    }
};
SysInfoBarPanel.prototype.hiding = function() {
    if (this.sysInfoSubscription) {
        MC.systemInfoSet.unregister(this.sysInfoSubscription);
        delete this.sysInfoSubscription
    }
    if (this.versionsSubscription) {
        MC.versionsSet.unregister(this.versionsSubscription);
        delete this.versionsSubscription
    }
};

function ConnectBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "ConnectBarPanel"
    }
    C.htmlText = '<div class="linkState"></div>';
    C.hoverPanel = new ConnectHover({});
    BarPanel.call(this, C);
    this.class_name = "ConnectBarPanel"
}
ConnectBarPanel.prototype = new BarPanel();
ConnectBarPanel.prototype.constructor = ConnectBarPanel;

function ConnectHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 200;
    C.name = "ConnectHover";
    C.widgets = new TableWidget({
        maxCols: 2,
        widgets: [new TextWidget({
            name: "connectState",
            label: strings.connectBar.connectLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "scState",
            label: strings.connectBar.scLabel,
            labelOptions: {
                rightMargin: true
            }
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "ConnectHover"
}
ConnectHover.prototype = new HoverPanel();
ConnectHover.prototype.constructor = ConnectHover;
ConnectHover.prototype.showing = function() {
    this.update({
        connectState: {
            text: strings.connection[connection.linkState]
        },
        scState: {
            text: strings.connection[connection.systemState]
        }
    })
};

function DateTimeBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "DateTimeBarPanel"
    }
    C.editable = "banner";
    C.htmlText = '<span id="barDate"></span><br ><span id="barTime"></span>';
    C.hoverPanel = new DateTimeHover({});
    BarPanel.call(this, C);
    this.class_name = "DateTimeBarPanel";
    this.date$ = $("#barDate", this.elements);
    this.time$ = $("#barTime", this.elements)
}
DateTimeBarPanel.prototype = new BarPanel();
DateTimeBarPanel.prototype.constructor = DateTimeBarPanel;
DateTimeBarPanel.prototype.showing = function() {
    this.timeSubscription = MC.timeSettingsSet.requestData({
        update: false,
        durable: false,
        requestor: this.class_name,
        handler: createObjectCallback(this, this._startInterval)
    })
};
DateTimeBarPanel.prototype.hiding = function() {
    if (this.timeSubscription) {
        MC.timeSettingsSet.unregister(this.timeSubscription);
        delete this.timeSubscription
    }
    if (this.timerInteval) {
        clearInterval(this.timerInterval)
    }
};
DateTimeBarPanel.prototype._startInterval = function(C) {
    if (!this.timerInterval) {
        this.timerInterval = setInterval(createObjectCallback(this, this._tickleTime), 1000)
    }
};
DateTimeBarPanel.prototype._tickleTime = function() {
    DateTimeBarPanel.arrayDate = new MCDate();
    this.date$.text(MCDate.toISODateString(DateTimeBarPanel.arrayDate));
    this.time$.text(MCDate.toISOTimeString(DateTimeBarPanel.arrayDate))
};

function DateTimeHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 250;
    C.name = "DateTimeHover";
    C.widgets = new TableWidget({
        maxCols: 2,
        widgets: [new TextWidget({
            name: "ntp",
            label: strings.dateTimeBar.ntpLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "ntpOffset",
            label: strings.dateTimeBar.ntpOffsetLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "ntpServer",
            label: strings.dateTimeBar.ntpServerLabel,
            labelOptions: {
                rightMargin: true
            }
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "DateTimeHover"
}
DateTimeHover.prototype = new HoverPanel();
DateTimeHover.prototype.constructor = DateTimeHover;
DateTimeHover.prototype.showing = function() {
    var D = MC.timeSettingsSet.data.objects[0];
    var C = decodeBooleanFlag(D.getPropertyValue("ntp_state"));
    this.update({
        ntp: {
            text: (C ? strings.enabled : strings.disabled)
        },
        ntpOffset: {
            text: (C ? D.getPropertyValue("time_zone_offset") : strings.na)
        },
        ntpServer: {
            text: (C ? D.getPropertyValue("ntp_address") : strings.na)
        }
    })
};

function UserBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "UserBarPanel"
    }
    C.editable = {
        type: "banner",
        position: "bottom: 1px; left: 115px;"
    };
    C.htmlText = '<div id="userBarText" class="widgetContainer">   <span class="barLabel">' + strings.userBar.userLabel + '</span>   <span id="userName"></span>   <div class="timeoutAnchor">       <span class="barLabel">' + strings.userBar.sessionLabel + '</span>       <span class="timeoutCounter"></span>   </div></div>';
    C.widgets = new WidgetContainer({
        widgets: [new ButtonWidget({
            id: "logoutButton",
            name: "logoutButton",
            classes: "signOutButton",
            primary: true,
            text: strings.userBar.logoutLabel,
            callback: createObjectCallback(this, this._logout)
        })]
    });
    C.hoverPanel = new UserHover({});
    BarPanel.call(this, C);
    this.class_name = "UserBarPanel";
    this.userName$ = $("#userName", this.elements);
    this.logoutButton$ = $("#logoutButton", this.elements);
    this.logoutButton$.hover(createObjectCallback(this, this.disableHover), createObjectCallback(this, this.enableHover));
    this.initialized = false
}
UserBarPanel.prototype = new BarPanel();
UserBarPanel.prototype.constructor = UserBarPanel;
UserBarPanel.prototype.showing = function() {
    setTimeout(createObjectCallback(this, this._initialize), 1000)
};
UserBarPanel.prototype._initialize = function() {
    var H = session.getPersistedValue("userName");
    var C = $(".widgetContainer").css("font-family");
    var D = $(".widgetContainer").css("font-size");
    var G = parseInt($(".widgetContainer").css("width"), 10);
    var I = getTextWidth((strings.userBar.userLabel + H), (D + " " + C));
    while (I >= G) {
        var E = Math.floor(H.length / 2);
        var F = H.substr(0, E);
        H = F + strings.dotNotation + strings.dotNotation + strings.dotNotation;
        I = getTextWidth((strings.userBar.userLabel + H), (D + " " + C))
    }
    this.userName$.text(H);
    this.initialized = true
};
UserBarPanel.prototype._logout = function() {
    LogoutRequestHandling()
};

function UserHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 350;
    C.name = "UserHover";
    C.widgets = new TableWidget({
        maxCols: 2,
        widgets: [new TextWidget({
            name: "userName",
            label: strings.userBar.userLabelHover,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "roles",
            label: strings.userBar.rolesLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "access",
            label: strings.userBar.accessLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "timeout",
            label: strings.userBar.timeoutLabel,
            labelOptions: {
                rightMargin: true,
                classes: "noWrap"
            }
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "UserHover"
}
UserHover.prototype = new HoverPanel();
UserHover.prototype.constructor = UserHover;
UserHover.prototype.showing = function() {
    var C = DC.users[session.userName.value];
    if (C == undefined) {
        var E = session.sessionPreferences.usergroupname;
        if (DC.usergroups[E] != undefined) {
            C = DC.usergroups[E]
        }
    }
    if (C) {
        var F = "";
        if (C.prop.interface_access_CLI.text == "x") {
            F += "CLI, "
        }
        if (C.prop.interface_access_WBI.text == "x") {
            F += "WBI, "
        }
        if (C.prop.interface_access_FTP.text == "x") {
            F += "FTP, "
        }
        if (C.prop.interface_access_SMIS !== undefined && C.prop.interface_access_SMIS.text == "x") {
            F += "SMI-S, "
        }
        if (F != "") {
            F = F.substr(0, F.length - 2)
        }
        var D = C.get("roles").split(/,/);
        var G = D.find("engineering");
        if (G != "-1") {
            D.splice(G, 1)
        }
        this.update({
            userName: {
                text: C.get("username") == undefined ? session.sessionPreferences.username : C.get("username")
            },
            roles: {
                text: D.toString()
            },
            access: {
                text: F
            },
            timeout: {
                text: this._calcTimeout()
            }
        })
    }
    this.displayInterval = setInterval(createObjectCallback(this, this._updateTimeout), 1000)
};
UserHover.prototype.hiding = function() {
    if (this.displayInterval) {
        clearInterval(this.displayInterval);
        delete this.displayInterval
    }
};
UserHover.prototype._updateTimeout = function() {
    this.update({
        timeout: {
            text: this._calcTimeout()
        }
    })
};
UserHover.prototype._calcTimeout = function() {
    var H = session.sessionPreferences.timeout;
    if ((typeof H) != "number") {
        return strings.na
    }
    var E = new Date();
    var D = (E.getTime() - session.lastAccess.getTime()) / 1000;
    var I = Math.floor(H - D);
    var J = "";
    if (I > 0) {
        var C = Math.floor(I / 3600);
        var G = Math.floor((I / 60) % 60);
        var F = Math.floor(I % 60);
        if (C > 0) {
            J += ((C <= 9) ? "0" + C : C) + ":";
            J += ((G <= 9) ? "0" + G : G) + ":"
        } else {
            J += G + ":"
        }
        J += (F <= 9) ? "0" + F : F
    }
    return J
};

function HelpBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "HelpBarPanel"
    }
    C.widgets = new WidgetContainer({
        widgets: [new ButtonWidget({
            id: "helpButton",
            name: "helpButton",
            text: "?",
            primary: true,
            callback: createObjectCallback(this, this._help)
        })]
    });
    BarPanel.call(this, C);
    this.class_name = "HelpBarPanel"
}
HelpBarPanel.prototype = new BarPanel();
HelpBarPanel.prototype.constructor = HelpBarPanel;
HelpBarPanel.prototype._help = function() {
    Help.show(currentPanel, true)
};

function HealthBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "HealthBarPanel"
    }
    C.editable = "footer";
    C.htmlText = '<table id="HealthBarPanel" cellspacing="0" cellpadding="0">  <tr>    <td rowspan="2" class="healthSystemIcon">&nbsp</td>    <td id="healthBarSystem" rowspan="2" class="healthOk" />    <td id="healthA">A</td>    <td id="healthBarA" class="healthOk"  />  </tr>  <tr>    <td id="healthB">B</td>    <td id="healthBarB" class="healthOk"  />  </tr></table>';
    C.hoverPanel = panels.HealthHover;
    BarPanel.call(this, C);
    this.class_name = "HealthBarPanel";
    this.healthSystem$ = $("#healthBarSystem", this.elements);
    this.healthSystem = "0";
    this.healthA$ = $("#healthBarA", this.elements);
    this.healthA = "0";
    this.healthB$ = $("#healthBarB", this.elements);
    this.healthB = "0"
}
HealthBarPanel.prototype = new BarPanel();
HealthBarPanel.prototype.constructor = HealthBarPanel;
HealthBarPanel.prototype.showing = function() {
    MC.enclosuresSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._handleData)
    });
    MC.systemInfoSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._handleData)
    });
    MC.advancedSettingsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._handleData)
    })
};
HealthBarPanel.prototype._handleData = function(D) {
    if (typeof DC.advSettings.getInt != "undefined") {
        if (DC.advSettings.getInt("single_controller_numeric") == 1) {
            if (system.local_controller_numeric == 0) {
                if (!($("#healthA").hasClass("healthInvisible"))) {
                    $("#healthA").addClass("healthInvisible")
                }
                if (!($("#healthBarA").hasClass("healthInvisible"))) {
                    $("#healthBarA").addClass("healthInvisible")
                }
                if ($("#healthB").hasClass("healthInvisible")) {
                    $("#healthB").removeClass("healthInvisible")
                }
                if ($("#healthBarB").hasClass("healthInvisible")) {
                    $("#healthBarB").removeClass("healthInvisible")
                }
            } else {
                if ($("#healthA").hasClass("healthInvisible")) {
                    $("#healthA").removeClass("healthInvisible")
                }
                if ($("#healthBarA").hasClass("healthInvisible")) {
                    $("#healthBarA").removeClass("healthInvisible")
                }
                if (!($("#healthB").hasClass("healthInvisible"))) {
                    $("#healthB").addClass("healthInvisible")
                }
                if (!($("#healthBarB").hasClass("healthInvisible"))) {
                    $("#healthBarB").addClass("healthInvisible")
                }
            }
        } else {
            if ($("#healthA").hasClass("healthInvisible")) {
                $("#healthA").removeClass("healthInvisible")
            }
            if ($("#healthBarA").hasClass("healthInvisible")) {
                $("#healthBarA").removeClass("healthInvisible")
            }
            if ($("#healthB").hasClass("healthInvisible")) {
                $("#healthB").removeClass("healthInvisible")
            }
            if ($("#healthBarB").hasClass("healthInvisible")) {
                $("#healthBarB").removeClass("healthInvisible")
            }
        }
    }
    if (!DC.controllers.A || !DC.controllers.B) {
        return
    }
    var C = DC.system.prop.health_numeric.text;
    var F = DC.controllers.A.prop.health_numeric.text;
    var E = DC.controllers.B.prop.health_numeric.text;
    if (C != this.healthSystem) {
        this.healthSystem$.removeClass(HEALTH_CLASS[this.healthSystem]).addClass(HEALTH_CLASS[C]);
        this.healthSystem = C
    }
    if (F != this.healthA) {
        this.healthA$.removeClass(HEALTH_CLASS[this.healthA]).addClass(HEALTH_CLASS[F]);
        this.healthA = F
    }
    if (E != this.healthB) {
        this.healthB$.removeClass(HEALTH_CLASS[this.healthB]).addClass(HEALTH_CLASS[E]);
        this.healthB = E
    }
};

function HealthHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 350;
    C.name = "HealthHover";
    C.widgets = new WidgetContainer({
        widgets: [new HealthWidget({
            name: "healthWidget"
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "HealthHover"
}
HealthHover.prototype = new HoverPanel();
HealthHover.prototype.constructor = HealthHover;
HealthHover.prototype.showing = function() {
    if (!DC.system) {
        return
    }
    this.update({
        healthWidget: {
            obj: DC.system
        }
    })
};

function EventBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "EventBarPanel"
    }
    C.editable = "footer";
    C.htmlText = '<table>  <tr>    <td class="ebpCritical" title=' + strings.critical + '/>    <td class="ebpError" title=' + strings.major + '/>    <td class="ebpWarning" title=' + strings.minor + '/>    <td class="ebpInfo" title=' + strings.informational + '/>  </tr>  <tr>    <td class="criticalNum" title=' + strings.critical + '>0</td>    <td class="errorNum" title=' + strings.major + '>0</td>    <td class="warningNum" title=' + strings.minor + '>0</td>    <td class="infoNum" title=' + strings.informational + ">0</td>  </tr></table>";
    C.classes = "eventBarPanel";
    C.hoverPanel = new EventBarHover({});
    BarPanel.call(this, C);
    this.class_name = "EventBarPanel";
    this.criticalNum$ = $(".criticalNum", this.elements);
    this.majorNum$ = $(".errorNum", this.elements);
    this.minorNum$ = $(".warningNum", this.elements);
    this.infoNum$ = $(".infoNum", this.elements);
    this.systemTime$ = $("#systemNum", this.elements)
}
EventBarPanel.prototype = new BarPanel();
EventBarPanel.prototype.constructor = EventBarPanel;
EventBarPanel.prototype.showing = function() {
    this.subscription = MC.eventsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._handleData)
    })
};
EventBarPanel.prototype.hiding = function() {
    if (this.subscription) {
        MC.eventsSet.unregister(this.subscription);
        delete this.subscription
    }
};
EventBarPanel.prototype._handleData = function(D) {
    var J = D.getData();
    var H = 0;
    var G = 0;
    var F = 0;
    var K = 0;
    for (var E = 0; E < J.objects.length; E++) {
        var C = J.objects[E];
        var I = C.getPropertyValue("severity_numeric");
        switch (I) {
            case "0":
                K++;
                break;
            case "1":
                F++;
                break;
            case "2":
                G++;
                break;
            case "3":
                H++;
                break;
            default:
                break
        }
    }
    this.criticalNum$.text(H);
    this.majorNum$.text(G);
    this.minorNum$.text(F);
    this.infoNum$.text(K)
};

function EventBarHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 300;
    C.name = "EventBarHover";
    C.widgets = new Arrangement({
        widgets: [new TableWidget({
            widgets: [new TextWidget({
                name: "last24",
                row: 0,
                col: 1,
                label: strings.eventBar.last24Label,
                bottomMargin: true,
                leftMargin: true
            }), new TextWidget({
                name: "lastError",
                row: 1,
                col: 1,
                label: strings.eventBar.lastErrorLabel,
                bottomSmallMargin: true,
                leftMargin: true
            })]
        }), new TextWidget({
            name: "errorMsg"
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "EventBarHover"
}
EventBarHover.prototype = new HoverPanel();
EventBarHover.prototype.constructor = EventBarHover;
EventBarHover.prototype.showing = function() {
    var J = 0;
    var I = null;
    var E = new MCDate();
    var D = E.getTime();
    var H;
    if (MC.eventsSet.data && MC.eventsSet.data.objects.length > 0) {
        var K = MC.eventsSet.data.objects;
        var C = K.length;
        for (var G = 0; G < C; G++) {
            if (parseInt(K[G].prop.severity_numeric.text, 10) >= 2) {
                if (I == null) {
                    I = K[G]
                }
                H = K[G].getInt("time_stamp_numeric") * 1000;
                if (D > H) {
                    if ((D - H) < 86400000) {
                        J++
                    }
                } else {
                    continue
                }
            }
        }
    }
    var F = {
        last24: {
            text: J
        },
        lastError: {
            text: ""
        },
        errorMsg: {
            text: ""
        }
    };
    if (I != null) {
        F.lastError = {
            text: I.prop.time_stamp.text
        };
        F.errorMsg = {
            text: I.prop.event_id.text + " (" + (I.prop.severity_numeric.text == "3" ? strings.critical : strings.error) + "): " + I.prop.message.text
        }
    }
    this.update(F)
};

function CapacityBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "CapacityBarPanel"
    }
    C.widgets = new WidgetContainer({
        widgets: [new SpaceMeter({
            name: "capacityBar",
            width: 70,
            height: 25,
            label: "",
            noText: true,
            prec: 0
        })]
    });
    C.hoverPanel = panels.CapacityHover;
    BarPanel.call(this, C);
    this.class_name = "CapacityBarPanel"
}
CapacityBarPanel.prototype = new BarPanel();
CapacityBarPanel.prototype.constructor = CapacityBarPanel;
CapacityBarPanel.prototype.showing = function() {
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    });
    this.poolSubscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    });
    this.volSubscription = MC.volumeGroupsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    })
};
CapacityBarPanel.prototype._updateData = function(D) {
    if (!MC.disksSet.data || !MC.volumeGroupsSet.data || !MC.poolsSet.data) {
        return
    }
    var C = {
        capacityBar: {
            lowerSegments: [{
                cssClass: "spaceUnused",
                size: MC.disksSet.sizeAvail,
                label: strings.capacityBar.unusedLabel
            }, {
                cssClass: "spaceLinearPools",
                size: MC.disksSet.sizeLinear,
                label: strings.capacityBar.linearDGLabel
            }, {
                cssClass: "spaceSpares",
                size: MC.disksSet.sizeSpares,
                label: strings.capacityBar.sparesLabel
            }, {
                cssClass: "spaceVirtualPools",
                size: MC.disksSet.sizeVirtual,
                label: strings.capacityBar.virtualDGLabel
            }],
            segments: [{
                cssClass: "spaceOffset",
                size: MC.disksSet.sizeAvail,
                label: ""
            }, {
                cssClass: "spaceLinearReserved",
                size: MC.poolsSet.linearTotalReserved,
                label: strings.capacityBar.linearReservedLabel
            }, {
                cssClass: "spaceLinearAlloc",
                size: MC.poolsSet.linearTotalSizeUsed,
                label: strings.capacityBar.linearAllocLabel
            }, {
                cssClass: "spaceLinearUnalloc",
                size: MC.poolsSet.linearTotalSizeFree,
                label: strings.capacityBar.linearUnallocLabel
            }, {
                cssClass: "spaceOffset",
                size: MC.disksSet.sizeSpares,
                label: ""
            }, {
                cssClass: "spaceVirtualReserved",
                size: MC.poolsSet.virtTotalReserved,
                label: strings.capacityBar.virtualReservedLabel
            }, {
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSizeTotal,
                label: strings.capacityBar.virtualAllocLabel
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSizeTotal,
                label: strings.capacityBar.virtualUnallocLabel
            }]
        }
    };
    this.update(C)
};

function CapacityHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 430;
    C.name = "CapacityHover";
    C.widgets = new TableWidget({
        name: "capHoverTable",
        maxCols: 5,
        classes: "capHoverTable",
        widgets: [new LabelWidget({
            row: 0,
            col: 2,
            value: "A",
            noTerminator: true,
            cellClasses: "alignCenter",
            bottomSmallMargin: true,
            rightMargin: true
        }), new LabelWidget({
            value: "B",
            noTerminator: true,
            cellClasses: "alignCenter",
            bottomSmallMargin: true,
            rightMargin: true
        }), new LabelWidget({
            value: strings.Total,
            noTerminator: true,
            cellClasses: "alignCenter",
            bottomSmallMargin: true
        }), new TextWidget({
            name: "physicalTotal",
            row: 1,
            col: 4,
            label: strings.capacityBar.diskCapacity,
            labelOptions: {
                row: 1,
                col: 1,
                rightMargin: true,
                classes: "hoverSectionLabel noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 2,
            col: 0,
            classes: "capHoverColor spaceUnused",
            rightSmallMargin: true
        }), new TextWidget({
            name: "physicalUnused",
            row: 2,
            col: 4,
            label: strings.capacityBar.unusedLabel,
            labelOptions: {
                row: 2,
                col: 1,
                rightMargin: true,
                classes: "hoverSectionLabel noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 3,
            col: 0,
            classes: "capHoverColor spaceSpares",
            rightSmallMargin: true
        }), new TextWidget({
            name: "globalSpares",
            row: 3,
            col: 4,
            label: strings.capacityBar.sparesLabel,
            labelOptions: {
                row: 3,
                col: 1,
                rightMargin: true,
                classes: "hoverSectionLabel noWrap"
            },
            cellClasses: "alignRight",
            bottomMargin: true
        }), new WidgetContainer({
            row: 4,
            col: 0,
            classes: "capHoverColor spaceVirtualPools",
            rightSmallMargin: true
        }), new TextWidget({
            name: "virtualDGA",
            row: 4,
            col: 2,
            label: strings.capacityBar.virtualDGLabel,
            labelOptions: {
                rightMargin: true,
                classes: "hoverSectionLabel noWrap"
            },
            cellClasses: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualDGB",
            cssClass: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualDGTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 5,
            col: 0,
            classes: "capHoverColor spaceVirtualReserved",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "virtualRaidA",
            label: strings.capacityBar.virtualReservedLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualRaidB",
            cssClass: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualRaidTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 6,
            col: 0,
            classes: "capHoverColor spaceVirtualAlloc",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "virtualAllocA",
            label: strings.capacityBar.virtualAllocLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualAllocB",
            cssClass: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualAllocTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 7,
            col: 0,
            classes: "capHoverColor spaceVirtualUnalloc",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "virtualUnallocA",
            label: strings.capacityBar.virtualUnallocLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualUnallocB",
            cssClass: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "virtualUnallocTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new TextWidget({
            name: "virtualUncommittedA",
            row: 8,
            col: 2,
            label: strings.capacityBar.uncommittedLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            rightMargin: true
        }), new TextWidget({
            name: "virtualUncommittedB",
            cssClass: "alignRight",
            rightMargin: true
        }), new TextWidget({
            name: "virtualUncommittedTotal",
            cssClass: "alignRight"
        }), new TextWidget({
            name: "provA",
            row: 9,
            col: 1,
            colSpan: 4,
            topSmallMargin: true
        }), new TextWidget({
            name: "provB",
            row: 10,
            col: 1,
            colSpan: 4,
            topSmallMargin: true
        }), new WidgetContainer({
            row: 11,
            col: 0,
            classes: "capHoverColor spaceLinearPools",
            topMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "linearDGA",
            label: strings.capacityBar.linearDGLabel,
            labelOptions: {
                rightMargin: true,
                classes: "hoverSectionLabel noWrap"
            },
            cellClasses: "alignRight",
            text: "",
            topMargin: true,
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearDGB",
            cssClass: "alignRight",
            text: "",
            topMargin: true,
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearDGTotal",
            cssClass: "alignRight",
            topMargin: true,
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 12,
            col: 0,
            classes: "capHoverColor spaceLinearReserved",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "linearRaidA",
            label: strings.capacityBar.linearReservedLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearRaidB",
            cssClass: "alignRight",
            text: "",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearRaidTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 13,
            col: 0,
            classes: "capHoverColor spaceLinearAlloc",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "linearAllocA",
            label: strings.capacityBar.linearAllocLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearAllocB",
            cssClass: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearAllocTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new WidgetContainer({
            row: 14,
            col: 0,
            classes: "capHoverColor spaceLinearUnalloc",
            leftSmallMargin: true,
            rightSmallMargin: true
        }), new TextWidget({
            name: "linearUnallocA",
            label: strings.capacityBar.linearUnallocLabel,
            labelOptions: {
                leftMargin: true,
                rightMargin: true,
                classes: "noWrap"
            },
            cellClasses: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearUnallocB",
            cssClass: "alignRight",
            bottomSmallMargin: true,
            rightMargin: true
        }), new TextWidget({
            name: "linearUnallocTotal",
            cssClass: "alignRight",
            bottomSmallMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "CapacityHover"
}
CapacityHover.prototype = new HoverPanel();
CapacityHover.prototype.constructor = CapacityHover;
CapacityHover.prototype.showing = function() {
    if (isUserPrecisionPrefHigher()) {
        panels.hoverDialog.currentOptions.width = 580
    }
    var G = "";
    var F = "";
    $("tr", this.elements).slice(9).hide();
    if ((MC.volumeGroupsSet.pages.A - MC.poolsSet.virtPages.A) > 0) {
        var D = new Size(MC.volumeGroupsSet.pages.A - MC.poolsSet.virtPages.A, "pages");
        G = "A " + strings.capacityBar.overProvisioned + D.format("scale");
        $("tr", this.elements).slice(9, 10).show()
    }
    if ((MC.volumeGroupsSet.pages.B - MC.poolsSet.virtPages.B) > 0) {
        var C = new Size(MC.volumeGroupsSet.pages.B - MC.poolsSet.virtPages.B, "pages");
        F = "B " + strings.capacityBar.overProvisioned + C.format("scale");
        $("tr", this.elements).slice(10, 11).show()
    }
    if (MC.disksSet.sizeLinear && MC.disksSet.sizeLinear.getRawValue() > 0) {
        $("tr", this.elements).slice(11).show()
    }
    var E = {
        physicalTotal: {
            text: MC.disksSet.size.format("scale")
        },
        physicalUnused: {
            text: MC.disksSet.sizeAvail.format("scale")
        },
        globalSpares: {
            text: MC.disksSet.sizeSpares.format("scale")
        },
        linearDGA: {
            text: MC.disksSet.sizeLinearOwner.A.format("scale")
        },
        linearDGB: {
            text: MC.disksSet.sizeLinearOwner.B.format("scale")
        },
        linearDGTotal: {
            text: MC.disksSet.sizeLinear.format("scale")
        },
        linearRaidA: {
            text: MC.poolsSet.linearSizeReserved.A.format("scale")
        },
        linearRaidB: {
            text: MC.poolsSet.linearSizeReserved.B.format("scale")
        },
        linearRaidTotal: {
            text: MC.poolsSet.linearTotalReserved.format("scale")
        },
        linearAllocA: {
            text: MC.poolsSet.linearSizeUsed.A.format("scale")
        },
        linearAllocB: {
            text: MC.poolsSet.linearSizeUsed.B.format("scale")
        },
        linearAllocTotal: {
            text: MC.poolsSet.linearTotalSizeUsed.format("scale")
        },
        linearUnallocA: {
            text: MC.poolsSet.linearSizeFree.A.format("scale")
        },
        linearUnallocB: {
            text: MC.poolsSet.linearSizeFree.B.format("scale")
        },
        linearUnallocTotal: {
            text: MC.poolsSet.linearTotalSizeFree.format("scale")
        },
        virtualDGA: {
            text: MC.disksSet.sizeVirtualOwner.A.format("scale")
        },
        virtualDGB: {
            text: MC.disksSet.sizeVirtualOwner.B.format("scale")
        },
        virtualDGTotal: {
            text: MC.disksSet.sizeVirtual.format("scale")
        },
        virtualRaidA: {
            text: MC.poolsSet.virtPoolReservedSize.A.format("scale")
        },
        virtualRaidB: {
            text: MC.poolsSet.virtPoolReservedSize.B.format("scale")
        },
        virtualRaidTotal: {
            text: MC.poolsSet.virtTotalReserved.format("scale")
        },
        virtualAllocA: {
            text: MC.poolsSet.virtPoolAllocSize.A.format("scale")
        },
        virtualAllocB: {
            text: MC.poolsSet.virtPoolAllocSize.B.format("scale")
        },
        virtualAllocTotal: {
            text: MC.poolsSet.virtPoolAllocSizeTotal.format("scale")
        },
        virtualUnallocA: {
            text: MC.volumeGroupsSet.virtUnallocSize.A.format("scale")
        },
        virtualUnallocB: {
            text: MC.volumeGroupsSet.virtUnallocSize.B.format("scale")
        },
        virtualUnallocTotal: {
            text: MC.volumeGroupsSet.virtUnallocSizeTotal.format("scale")
        },
        virtualUncommittedA: {
            text: MC.poolsSet.virtUncommittedSize.A.format("scale")
        },
        virtualUncommittedB: {
            text: MC.poolsSet.virtUncommittedSize.B.format("scale")
        },
        virtualUncommittedTotal: {
            text: MC.poolsSet.virtUncommittedSizeTotal.format("scale")
        },
        volsA: {
            text: MC.volumeGroupsSet.size.A.format("scale")
        },
        volsB: {
            text: MC.volumeGroupsSet.size.B.format("scale")
        },
        volsTotal: {
            text: MC.volumeGroupsSet.totalSize.format("scale")
        },
        provA: {
            text: G
        },
        provB: {
            text: F
        }
    };
    this.update(E)
};

function PerfBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "PerfBarPanel"
    }
    this.maxIops = 10;
    this.maxMbps = 1;
    C.widgets = new TableWidget({
        widgets: [new WidgetContainer({
            row: 0,
            col: 0,
            widgets: [new SpaceMeter({
                row: 0,
                col: 0,
                name: "iopsA",
                width: 50,
                height: 3,
                noText: true
            }), new SpaceMeter({
                row: 1,
                col: 0,
                name: "mbA",
                width: 50,
                height: 3,
                classes: "perfBarVertSep",
                noText: true
            }), new SpaceMeter({
                row: 2,
                col: 0,
                name: "iopsB",
                width: 50,
                height: 3,
                noText: true
            }), new SpaceMeter({
                row: 3,
                col: 0,
                name: "mbB",
                width: 50,
                height: 3,
                noText: true
            })]
        }), new TextWidget({
            row: 0,
            col: 1,
            text: '<span class="perfBarIOPS">IOPS</span><br /><span class="perfBarMBPS">MB/s</span>'
        })]
    });
    C.hoverPanel = new PerfHover({});
    BarPanel.call(this, C);
    this.class_name = "PerfBarPanel"
}
PerfBarPanel.prototype = new BarPanel();
PerfBarPanel.prototype.constructor = PerfBarPanel;
PerfBarPanel.prototype.showing = function() {
    this.statsSubscription = MC.hostPortStatsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    })
};
PerfBarPanel.prototype._updateData = function(D) {
    var C = {
        iopsA: {
            total: D.maxIops,
            segments: [{
                label: "IOPS:",
                cssClass: "spacePerfIops",
                size: D.iops.A
            }]
        },
        mbA: {
            total: D.maxMbps,
            segments: [{
                label: "MB/s:",
                cssClass: "spacePerfMbps",
                size: D.mbps.A.toFixed(1)
            }]
        },
        iopsB: {
            total: D.maxIops,
            segments: [{
                label: "IOPS:",
                cssClass: "spacePerfIops",
                size: D.iops.B
            }]
        },
        mbB: {
            total: D.maxMbps,
            segments: [{
                label: "MB/s:",
                cssClass: "spacePerfMbps",
                size: D.mbps.B.toFixed(1)
            }]
        }
    };
    this.update(C)
};

function PerfHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 155;
    C.name = "PerfHover";
    C.widgets = new TableWidget({
        widgets: [new LabelWidget({
            row: 0,
            col: 1,
            value: "A",
            cellClasses: "alignCenter",
            noTerminator: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 0,
            col: 2,
            value: "B",
            cellClasses: "alignCenter",
            noTerminator: true,
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 1,
            col: 1,
            name: "portIopsA",
            cssClass: "alignRight",
            label: strings.perfHover.portIopsLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            row: 1,
            col: 2,
            name: "portIopsB",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 1,
            name: "portMbpsA",
            cssClass: "alignRight",
            label: strings.perfHover.portMbpsLabel,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 2,
            name: "portMbpsB",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "PerfHover"
}
PerfHover.prototype = new HoverPanel();
PerfHover.prototype.constructor = PerfHover;
PerfHover.prototype.showing = function() {
    this.update({
        portIopsA: {
            text: MC.hostPortStatsSet.iops.A
        },
        portIopsB: {
            text: MC.hostPortStatsSet.iops.B
        },
        portMbpsA: {
            text: MC.hostPortStatsSet.mbps.A
        },
        portMbpsB: {
            text: MC.hostPortStatsSet.mbps.B
        }
    })
};

function TierIoBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "TierIoBarPanel"
    }
    this.maxIops = 10;
    C.widgets = new TableWidget({
        widgets: [new WidgetContainer({
            row: 0,
            col: 0,
            widgets: [new SpaceMeter({
                name: "tierIoA",
                width: 50,
                height: 10,
                classes: "perfBarVertSep",
                noText: true
            }), new SpaceMeter({
                name: "tierIoB",
                width: 50,
                height: 10,
                noText: true
            })]
        }), new TextWidget({
            row: 0,
            col: 1,
            text: strings.tierIoBar.tierIoLabel
        })]
    });
    C.hoverPanel = new TierIoHover({});
    BarPanel.call(this, C);
    this.class_name = "TierIoBarPanel"
}
TierIoBarPanel.prototype = new BarPanel();
TierIoBarPanel.prototype.constructor = TierIoBarPanel;
TierIoBarPanel.prototype.showing = function() {
    this.statsSubscription = MC.poolStatisticsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._updateData)
    })
};
TierIoBarPanel.prototype._updateData = function(F) {
    var K = {
        A: [],
        B: []
    };
    var J = {
        A: 0,
        B: 0
    };
    for (var I in K) {
        var D = DC.poolStats[I];
        if (D) {
            for (var G = 0; G < D.objects.length; G++) {
                if (!(D.objects[G] instanceof APITierStatistics)) {
                    continue
                }
                var H = D.objects[G].get("tier");
                var C = parseInt(D.objects[G].get("tier_numeric"), 10);
                var E = D.objects[G].resettableStats;
                var M = parseInt(E.get("iops"), 10);
                K[I].push({
                    label: H,
                    cssClass: "spaceTierIops" + C,
                    size: M
                });
                J[I] += M
            }
        }
    }
    if (J.A >= J.B) {
        var L = J.A
    } else {
        var L = J.B
    }
    this.update({
        tierIoA: {
            total: L,
            segments: K.A
        },
        tierIoB: {
            total: L,
            segments: K.B
        }
    })
};

function TierIoHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 355;
    C.name = "TierIoHover";
    C.widgets = new TableWidget({
        id: "tierIoTable",
        widgets: [new LabelWidget({
            row: 0,
            col: 1,
            colSpan: 2,
            cellClasses: "alignCenter",
            noTerminator: true,
            bottomSmallMargin: true,
            value: "A"
        }), new LabelWidget({
            row: 0,
            col: 2,
            colSpan: 2,
            cellClasses: "alignCenter",
            noTerminator: true,
            bottomSmallMargin: true,
            value: "B"
        }), new LabelWidget({
            row: 0,
            col: 3,
            colSpan: 2,
            cellClasses: "alignCenter",
            noTerminator: true,
            bottomSmallMargin: true,
            value: strings.Total
        }), new LabelWidget({
            row: 1,
            col: 0,
            value: strings.Tier,
            noTerminator: true,
            rightMargin: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 1,
            col: 1,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "IOPS",
            bottomSmallMargin: true,
            leftMargin: true
        }), new LabelWidget({
            row: 1,
            col: 2,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "MB/s",
            leftMargin: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 1,
            col: 3,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "IOPS",
            leftMargin: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 1,
            col: 4,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "MB/s",
            leftMargin: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 1,
            col: 5,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "%IOPS",
            leftMargin: true,
            bottomSmallMargin: true
        }), new LabelWidget({
            row: 1,
            col: 6,
            cellClasses: "alignRight",
            noTerminator: true,
            value: "%MB/s",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 0,
            name: "tierName1",
            rightMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 1,
            name: "tierIops1A",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 2,
            name: "tierMBps1A",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 3,
            name: "tierIops1B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 4,
            name: "tierMBps1B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 5,
            name: "tierIops1Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 2,
            col: 6,
            name: "tierMBps1Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 0,
            name: "tierName2",
            rightMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 1,
            name: "tierIops2A",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 2,
            name: "tierMBps2A",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 3,
            name: "tierIops2B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 4,
            name: "tierMBps2B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 5,
            name: "tierIops2Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 3,
            col: 6,
            name: "tierMBps2Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 0,
            name: "tierName4",
            rightMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 1,
            name: "tierIops4A",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 2,
            name: "tierMBps4A",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 3,
            name: "tierIops4B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 4,
            name: "tierMBps4B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 5,
            name: "tierIops4Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 4,
            col: 6,
            name: "tierMBps4Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 0,
            name: "tierName8",
            rightMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 1,
            name: "tierIops8A",
            cssClass: "alignRight",
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 2,
            name: "tierMBps8A",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 3,
            name: "tierIops8B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 4,
            name: "tierMBps8B",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 5,
            name: "tierIops8Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 5,
            col: 6,
            name: "tierMBps8Pct",
            cssClass: "alignRight",
            leftMargin: true,
            bottomSmallMargin: true
        }), new TextWidget({
            row: 6,
            col: 0,
            name: "tierTotal",
            cssClass: "textBold",
            text: strings.Total,
            rightMargin: true
        }), new TextWidget({
            row: 6,
            col: 1,
            name: "totalIopsA",
            cssClass: "alignRight textBold"
        }), new TextWidget({
            row: 6,
            col: 2,
            name: "totalMBpsA",
            cssClass: "alignRight textBold",
            leftMargin: true
        }), new TextWidget({
            row: 6,
            col: 3,
            name: "totalIopsB",
            cssClass: "alignRight textBold",
            leftMargin: true
        }), new TextWidget({
            row: 6,
            col: 4,
            name: "totalMBpsB",
            cssClass: "alignRight textBold",
            leftMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "TierIoHover"
}
TierIoHover.prototype = new HoverPanel();
TierIoHover.prototype.constructor = TierIoHover;
TierIoHover.prototype.showing = function() {
    var N = {
        "1": {
            exists: false,
            totalIops: 0,
            totalMBps: 0
        },
        "2": {
            exists: false,
            totalIops: 0,
            totalMBps: 0
        },
        "4": {
            exists: false,
            totalIops: 0,
            totalMBps: 0
        },
        "8": {
            exists: false,
            totalIops: 0,
            totalMBps: 0
        }
    };
    var I = {
        A: 0,
        B: 0
    };
    var M = {
        A: 0,
        B: 0
    };
    var F = {};
    var K = 0;
    var P = 0;
    for (var J in DC.poolStats) {
        if (J != "A" && J != "B" || !DC.poolStats[J].tierStatsSerial) {
            continue
        }
        for (var D in DC.poolStats[J].tierStatsSerial) {
            var E = DC.poolStats[J].tierStatsSerial[D];
            var C = parseInt(E.get("tier_numeric"), 10);
            var G = E.resettableStats;
            if (!G) {
                continue
            }
            var L = parseInt(G.get("iops"), 10);
            var O = Math.round(parseInt(G.get("bytes_per_second_numeric"), 10) / 1000000);
            F["tierName" + C] = {
                text: E.get("tier")
            };
            F["tierIops" + C + J] = {
                text: L
            };
            F["tierMBps" + C + J] = {
                text: O
            };
            var H = "" + C;
            if (!N[H]) {
                N[H] = {
                    totalIops: 0,
                    totalMBps: 0
                }
            }
            N[H].exists = true;
            N[H].totalIops += L;
            N[H].totalMBps += O;
            I[J] += L;
            M[J] += O;
            K += L;
            P += O
        }
    }
    F.totalIopsA = {
        text: I.A
    };
    F.totalMBpsA = {
        text: M.A
    };
    F.totalIopsB = {
        text: I.B
    };
    F.totalMBpsB = {
        text: M.B
    };
    if (N["1"].exists) {
        F.tierIops1Pct = {
            text: (K > 0 ? Math.round(N["1"].totalIops / K * 100) + "%" : "0%")
        };
        F.tierMBps1Pct = {
            text: (P > 0 ? Math.round(N["1"].totalMBps / P * 100) + "%" : "0%")
        };
        $("tr", this.elements).slice(2, 3).show()
    } else {
        $("tr", this.elements).slice(2, 3).hide()
    }
    if (N["2"].exists) {
        F.tierIops2Pct = {
            text: (K > 0 ? Math.round(N["2"].totalIops / K * 100) + "%" : "0%")
        };
        F.tierMBps2Pct = {
            text: (P > 0 ? Math.round(N["2"].totalMBps / P * 100) + "%" : "0%")
        };
        $("tr", this.elements).slice(3, 4).show()
    } else {
        $("tr", this.elements).slice(3, 4).hide()
    }
    if (N["4"].exists) {
        F.tierIops4Pct = {
            text: (K > 0 ? Math.round(N["4"].totalIops / K * 100) + "%" : "0%")
        };
        F.tierMBps4Pct = {
            text: (P > 0 ? Math.round(N["4"].totalMBps / P * 100) + "%" : "0%")
        };
        $("tr", this.elements).slice(4, 5).show()
    } else {
        $("tr", this.elements).slice(4, 5).hide()
    }
    if (N["8"].exists) {
        F.tierIops8Pct = {
            text: (K > 0 ? Math.round(N["8"].totalIops / K * 100) + "%" : "0%")
        };
        F.tierMBps8Pct = {
            text: (P > 0 ? Math.round(N["8"].totalMBps / P * 100) + "%" : "0%")
        };
        $("tr", this.elements).slice(5, 6).show()
    } else {
        $("tr", this.elements).slice(5, 6).hide()
    }
    this.update(F)
};

function SSDActivityPanel(C) {
    if (arguments.length == 0) {
        return
    }
    C.editable = "footer";
    if (!C.name) {
        C.name = "SSDActivityPanel"
    }
    C.htmlText = '<table id="ssdActivityPanel" cellspacing="0" cellpadding="0">  <tr>    <td id="ssdActivityPanel" rowspan="2" class="graphIcon" />    <td id="ssdLabel">' + strings.ssdIoWorkload.ioWorkload + "</td>  </tr></table>";
    BarPanel.call(this, C);
    this.class_name = "SSDActivityPanel"
}
SSDActivityPanel.prototype = new BarPanel();
SSDActivityPanel.prototype.constructor = SSDActivityPanel;
SSDActivityPanel.prototype.showing = function() {
    this.load = MC.systemInfoSet.requestData({
        update: true,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._load)
    })
};
SSDActivityPanel.prototype._load = function() {
    if (!RI.hasFeature("heatmap")) {
        $("#ssdActivityView").hide()
    }
};

function ActivityBarPanel(C) {
    if (arguments.length == 0) {
        return
    }
    if (!C.name) {
        C.name = "ActivityBarPanel"
    }
    C.editable = "footer";
    C.htmlText = '<div id="activityContainer"><div id="activityNote"></div></div>';
    BarPanel.call(this, C);
    this.class_name = "ActivityBarPanel";
    this.note$ = $("#activityNote", this.elements);
    this.notes = [];
    this.nextNote = 0;
    this._nextCallback = createObjectCallback(this, this._next);
    this._showNextCallback = createObjectCallback(this, this._showNext)
}
ActivityBarPanel.prototype = new BarPanel();
ActivityBarPanel.prototype.constructor = ActivityBarPanel;
ActivityBarPanel.MAX_NOTES = 100;
ActivityBarPanel.MIN_DISPLAY_SECS = 5;
ActivityBarPanel.MAX_DISPLAY_SECS = 30;
ActivityBarPanel.EVENT_NOTIFY_LEVEL = 2;
ActivityBarPanel.EVENT_CODES = {
    459: "",
    470: "",
    251: "",
    268: ""
};
ActivityBarPanel.prototype.display = function(H, G, I) {
    var C = '<div class="noteContent">';
    if (H != "none") {
        C += '<span class="noteType ' + H + '"></span>'
    }
    if (G instanceof Date || G instanceof MCDate) {
        C += '<span class="noteDate">' + MCDate.toISOTimeString(G) + ":</span>"
    } else {
        if (!I) {
            I = G
        }
    }
    C += I;
    C += "</div>";
    this.notes.push([C]);
    if (!this.timeout) {
        this._next()
    } else {
        if (this.displayDate) {
            var E = new Date();
            var F = Math.floor((E.getTime() - this.displayDate.getTime()) / 1000);
            if (F > ActivityBarPanel.MIN_DISPLAY_SECS) {
                this._next()
            } else {
                clearTimeout(this.timeout);
                this.timeout = null;
                var D = ActivityBarPanel.MIN_DISPLAY_SECS - F;
                this.timeout = setTimeout(this._nextCallback, D * 1000)
            }
        }
    }
};
ActivityBarPanel.prototype._next = function() {
    if (this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.note$.animate({
            top: "-30px"
        }, "slow", this._showNextCallback);
        this.displayDate = null
    } else {
        this._showNext()
    }
};
ActivityBarPanel.prototype._showNext = function() {
    if (this.nextNote >= this.notes.length) {
        return
    }
    this.note$.css({
        top: "30px"
    });
    this.note$.html(this.notes[this.nextNote][0]);
    this.note$.animate({
        top: "0px"
    }, "slow");
    if (this.notes.length > ActivityBarPanel.MAX_NOTES) {
        this.notes.shift()
    } else {
        this.nextNote++
    }
    this.displayDate = new Date();
    if (this.nextNote < this.notes.length) {
        this.timeout = setTimeout(this._nextCallback, ActivityBarPanel.MIN_DISPLAY_SECS * 1000)
    } else {
        this.timeout = setTimeout(this._nextCallback, ActivityBarPanel.MAX_DISPLAY_SECS * 1000)
    }
};
ActivityBarPanel.prototype.notifyEvent = function(D) {
    var C = parseInt(D.get("severity_numeric"), 10);
    var E = parseInt(D.get("event_code"), 10);
    if (C >= ActivityBarPanel.EVENT_NOTIFY_LEVEL || ActivityBarPanel.EVENT_CODES[E] != undefined) {
        var F = D.get("event_id");
        this.display(EVENT_TYPES[C], MCDate.fromArrayTimestamp(D.get("time_stamp_numeric")), ' <span class="noteEvent" onclick=\x27EventListAction.open([ new DCRef(\x22events\x22, \x22' + F + "\x22)]);\x27>" + strings.EVENT + " " + F + "</span>: " + (ActivityBarPanel.EVENT_CODES[E] || D.get("message")))
    }
};

function HomeTopic(C) {
    C.name = "HomeTopic";
    C.contentClass = "homeTopicContent";
    this.hostWidgets = {};
    this.ports = {};
    this.portWidgets = {};
    this.poolPerfWidget = {};
    this.healthSystem = "-1";
    this.hasPool = {
        A: false,
        B: false
    };
    this.hasPoolPrev = {
        A: false,
        B: false
    };
    this.hasVdisk = {
        A: false,
        B: false
    };
    this.hasVdiskPrev = {
        A: false,
        B: false
    };
    this.hasCache = {
        A: false,
        B: false
    };
    this.hasCachePrev = {
        A: false,
        B: false
    };
    C.widgets = new WidgetContainer({
        id: "HomeTopic",
        widgets: [this.hostsContainer = new WidgetContainer({
            classes: "homeRowContainer homeHosts",
            widgets: [new TextWidget({
                text: strings.Hosts,
                classes: "homeSectionLabel"
            }), new WidgetContainer({
                classes: "homeHostsContainer",
                widgets: [this.hosts = new WidgetContainer({
                    classes: "homeHostList",
                    widgets: [this.hostGroupsWidget = new HostWidget({
                        type: "hostGroups",
                        number: 0
                    }), this.hostsWidget = new HostWidget({
                        type: "hosts",
                        number: 0
                    }), this.initsWidget = new HostWidget({
                        type: "initiators",
                        number: 0
                    })]
                })]
            })]
        }), this.portsContainer = new WidgetContainer({
            classes: "homeRowContainer",
            widgets: [new TableWidget({
                classes: "homePortTable",
                widgets: [this.ports.A = new TableWidget({
                    row: 0,
                    col: 0,
                    name: "HomePortsA",
                    classes: "homePorts",
                    maxCols: 16,
                    widgets: [new TextWidget({
                        row: 0,
                        colSpan: 16,
                        text: strings.Ports + " A",
                        classes: "homeSectionLabel"
                    })]
                }), this.hostPerfWidget = new PerfSummaryWidget({
                    row: 0,
                    col: 1,
                    name: "systemPerf",
                    vertical: true
                }), this.ports.B = new TableWidget({
                    row: 0,
                    col: 2,
                    name: "HomePortsB",
                    classes: "homePorts",
                    maxCols: 16,
                    widgets: [new TextWidget({
                        row: 0,
                        colSpan: 16,
                        text: strings.Ports + " B",
                        classes: "homeSectionLabel"
                    })]
                })]
            })]
        }), this.capacityContainer = new WidgetContainer({
            classes: "homeCapacity",
            hoverPanel: panels.CapacityHover,
            widgets: [new TextWidget({
                text: strings.Capacity,
                classes: "homeSectionLabel"
            }), this.capacityTable = new TableWidget({
                widgets: [new TextWidget({
                    row: 0,
                    col: 0,
                    text: strings.homeTopic.logicalCapLabel,
                    rightMargin: true,
                    classes: "homeCapBarLabel"
                }), new TextWidget({
                    row: 1,
                    col: 0,
                    text: strings.homeTopic.physicalCapLabel,
                    rightMargin: true,
                    classes: "homeCapBarLabel"
                }), this.totalSpaceMeter = new SpaceMeter({
                    row: 0,
                    col: 1,
                    rowSpan: 2,
                    name: "capacityBarTotal",
                    width: 700,
                    height: 30,
                    prec: 0,
                    classes: "homeCapacityMeterTotal"
                })]
            })]
        }), this.sysHealthWidget = new WidgetContainer({
            name: "sysHealth",
            id: "sysHealth",
            hoverPanel: panels.HealthHover
        }), this.sparesWidget = new SparesWidget({
            name: "spares",
            classes: "homeSpares",
            hoverPanel: new SparesHover({})
        }), this.storageA = new WidgetContainer({
            cellClasses: "poolCell",
            name: "poolA",
            id: "poolA",
            pool: "A",
            classes: "poolContainer",
            hoverPanel: panels.StorageHover,
            widgets: [new TextWidget({
                text: strings.homeTopic.storageTitle + " A",
                classes: "homeSectionLabel"
            }), new TextWidget({
                name: "pagedTitleA",
                label: strings.homeTopic.pagedLabel,
                text: strings.homeTopic.noPool,
                labelClass: "storageTitleLabel",
                cssClass: "storageTitleText",
                classes: "storageTitle",
                bottomSmallMargin: true
            }), this.storagePoolA = new WidgetContainer({
                name: "poolAgraphs",
                widgets: [this.poolSpaceA = new SpaceMeter({
                    name: "poolCapA",
                    width: 355,
                    height: 20,
                    prec: 0,
                    classes: "poolMeter"
                }), new TableWidget({
                    name: "storageTableA",
                    widgets: [new TextWidget({
                        row: 0,
                        col: 0,
                        text: strings.homeTopic.cacheTitle,
                        classes: "homeStorageGraphLabel"
                    }), new TextWidget({
                        row: 0,
                        col: 1,
                        text: strings.homeTopic.diskGroupTitle,
                        classes: "homeStorageGraphLabel"
                    }), this.rcSegsA = new SegmentedGraphWidget({
                        row: 1,
                        col: 0,
                        name: "rcGraphA",
                        width: 40,
                        height: 50,
                        captionVert: strings.homeTopic.percentUsed,
                        captionHoriz: "",
                        bottomMargin: true,
                        rightMargin: true,
                        segments: []
                    }), this.tierSegsA = new SegmentedGraphWidget({
                        row: 1,
                        col: 1,
                        name: "tierGraphA",
                        width: 303,
                        height: 50,
                        captionVert: strings.homeTopic.percentUsed,
                        captionHoriz: strings.homeTopic.diskGroupSize,
                        bottomMargin: true,
                        segments: []
                    })]
                })]
            }), this.storageVdiskA = new WidgetContainer({
                name: "vdiskAgraphs",
                widgets: [new TextWidget({
                    name: "linearTitleA",
                    label: strings.homeTopic.linearLabel,
                    text: strings.homeTopic.noVdisk,
                    labelClass: "storageTitleLabel",
                    cssClass: "storageTitleText",
                    classes: "storageTitle",
                    bottomSmallMargin: true
                }), this.vdiskSpaceA = new SpaceMeter({
                    name: "vdiskCapA",
                    width: 355,
                    height: 20,
                    prec: 0,
                    classes: "poolMeter"
                }), new TextWidget({
                    text: strings.homeTopic.vdiskTitle,
                    classes: "homeStorageGraphLabel"
                }), this.vdiskSegsA = new SegmentedGraphWidget({
                    name: "vdiskGraphA",
                    width: 353,
                    height: 50,
                    captionVert: strings.homeTopic.percentUsed,
                    captionHoriz: strings.homeTopic.vdiskSize,
                    bottomMargin: true,
                    sizeClass: "vdiskSize",
                    usedClass: "vdiskUsed",
                    segments: []
                })]
            })]
        }), this.storageB = new WidgetContainer({
            cellClasses: "poolCell",
            name: "poolB",
            id: "poolB",
            pool: "B",
            classes: "poolContainer",
            hoverPanel: panels.StorageHover,
            widgets: [new TextWidget({
                text: strings.homeTopic.storageTitle + " B",
                classes: "homeSectionLabel"
            }), new TextWidget({
                name: "pagedTitleB",
                label: strings.homeTopic.pagedLabel,
                text: strings.homeTopic.noPool,
                labelClass: "storageTitleLabel",
                cssClass: "storageTitleText",
                classes: "storageTitle",
                bottomSmallMargin: true
            }), this.storagePoolB = new WidgetContainer({
                name: "poolBgraphs",
                widgets: [this.poolSpaceB = new SpaceMeter({
                    name: "poolCapB",
                    width: 355,
                    height: 20,
                    prec: 0,
                    classes: "poolMeter"
                }), new TableWidget({
                    name: "storageTableB",
                    widgets: [new TextWidget({
                        row: 0,
                        col: 0,
                        text: strings.homeTopic.cacheTitle,
                        classes: "homeStorageGraphLabel"
                    }), new TextWidget({
                        row: 0,
                        col: 1,
                        text: strings.homeTopic.diskGroupTitle,
                        classes: "homeStorageGraphLabel"
                    }), this.rcSegsB = new SegmentedGraphWidget({
                        row: 1,
                        col: 0,
                        name: "rcGraphB",
                        width: 40,
                        height: 50,
                        captionVert: strings.homeTopic.percentUsed,
                        captionHoriz: "",
                        bottomMargin: true,
                        rightMargin: true,
                        segments: []
                    }), this.tierSegsB = new SegmentedGraphWidget({
                        row: 1,
                        col: 1,
                        name: "tierGraphB",
                        width: 303,
                        height: 50,
                        captionVert: strings.homeTopic.percentUsed,
                        captionHoriz: strings.homeTopic.diskGroupSize,
                        bottomMargin: true,
                        segments: []
                    })]
                })]
            }), this.storageVdiskB = new WidgetContainer({
                name: "vdiskBgraphs",
                widgets: [new TextWidget({
                    name: "linearTitleB",
                    label: strings.homeTopic.linearLabel,
                    text: strings.homeTopic.noVdisk,
                    labelClass: "storageTitleLabel",
                    cssClass: "storageTitleText",
                    classes: "storageTitle",
                    bottomSmallMargin: true
                }), this.vdiskSpaceB = new SpaceMeter({
                    name: "vdiskCapB",
                    width: 355,
                    height: 20,
                    prec: 0,
                    classes: "poolMeter"
                }), new TextWidget({
                    text: strings.homeTopic.vdiskTitle,
                    classes: "homeStorageGraphLabel"
                }), this.vdiskSegsB = new SegmentedGraphWidget({
                    name: "vdiskGraphB",
                    width: 353,
                    height: 50,
                    captionVert: strings.homeTopic.percentUsed,
                    captionHoriz: strings.homeTopic.vdiskSize,
                    bottomMargin: true,
                    sizeClass: "vdiskSize",
                    usedClass: "vdiskUsed",
                    segments: []
                })]
            })]
        })]
    });
    this.portsInitialized = false;
    this.disksSparesUpdated = false;
    TopicPanel.call(this, C);
    this.class_name = "HomeTopic"
}
HomeTopic.prototype = new TopicPanel();
HomeTopic.prototype.constructor = HomeTopic;
HomeTopic.prototype.showing = function() {
    if (this.initialized) {
        return
    }
    var C = {};
    var D = (applicationLoading ? false : true);
    MC.systemInfoSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._systemUpdate)
    });
    MC.poolsSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._storageUpdate)
    });
    MC.disksSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._disksUpdate)
    });
    if (RI.supportsLinear) {
        C.linearTitleA = {
            visibility: "visible"
        };
        C.linearTitleB = {
            visibility: "visible"
        }
    }
    MC.hostGroupsSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._hostsUpdate)
    });
    MC.volumeGroupsSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._storageUpdate)
    });
    MC.enclosuresSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._enclosuresUpdate)
    });
    MC.hostPortStatsSet.requestData({
        update: D,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._hostPortStatsUpdate)
    });
    $(".homeHosts").on("click", createObjectCallback(this, function() {
        NAV.navTo("topics", "hosts", null)
    }));
    $("#sysHealth").on("click", createObjectCallback(this, function() {
        NAV.navTo("topics", "system", null, null, {
            topicOptions: {
                display: "table",
                tableSort: [
                    [2, "desc"]
                ]
            }
        })
    }));
    this.storagePoolA.elements$.find("td:nth-child(1)").hide();
    this.storagePoolA.elements$.hide();
    this.storageVdiskA.elements$.hide();
    this.storagePoolB.elements$.find("td:nth-child(1)").hide();
    this.storagePoolB.elements$.hide();
    this.storageVdiskB.elements$.hide();
    this.initialized = true;
    this.update(C)
};
HomeTopic.prototype.update = function(D) {
    if (!this.initialized) {
        return
    }
    if (!D) {
        var D = {}
    }
    this.reconfigured = false;
    for (var C in {
            A: true,
            B: true
        }) {
        if (this.hasCache[C] != this.hasCachePrev[C]) {
            if (this.hasCache[C]) {
                this["storagePool" + C].elements$.find("td:nth-child(1)").show()
            } else {
                this["storagePool" + C].elements$.find("td:nth-child(1)").hide()
            }
            this.hasCachePrev[C] = this.hasCache[C];
            this.reconfigured = true
        }
        if (this.hasPool[C] != this.hasPoolPrev[C]) {
            if (this.hasPool[C]) {
                this["storagePool" + C].elements$.show();
                this.hasPoolPrev[C] = true
            } else {
                this["storagePool" + C].elements$.hide();
                D["pagedTitle" + C] = {
                    text: strings.homeTopic.noPool
                };
                this.hasPoolPrev[C] = false
            }
            this.reconfigured = true
        }
        if (this.hasVdisk[C] != this.hasVdiskPrev[C]) {
            if (this.hasVdisk[C]) {
                this["storageVdisk" + C].elements$.show();
                this.hasVdiskPrev[C] = true
            } else {
                this["storageVdisk" + C].elements$.hide();
                this.hasVdiskPrev[C] = false
            }
            this.reconfigured = true
        }
    }
    if (this.reconfigured) {
        this.resizing();
        this.reconfigured = false
    }
    TopicPanel.prototype.update.call(this, D)
};
HomeTopic.prototype.resizing = function() {
    if (!this.content$) {
        return
    }
    this.computeDimensions(this.panel$, this.tray$);
    if (this.sparesHalfWidth == undefined) {
        this.poolTop = this.storageA.elements$.position().top;
        var Q = this.storageA.elements$.dimsInstance();
        this.poolsSpace = {};
        this.poolsSpace.horiz = Q.BorderLeft + Q.PaddingLeft + Q.BorderRight + Q.PaddingRight;
        this.poolsSpace.vert = Q.BorderTop + Q.PaddingTop + Q.BorderBottom + Q.PaddingBottom;
        this.healthHalfWidth = Math.floor(this.sysHealthWidget.elements$.outerWidth() / 2);
        this.sparesHalfWidth = Math.floor(this.sparesWidget.elements$.outerWidth() / 2);
        this.capLabelWidth = this.capacityTable.elements$.find("td").first().outerWidth()
    }
    var E = this.content$.height();
    var P = this.content$.width();
    var F = (P - 33 - this.capLabelWidth) + "px";
    var C = Math.floor(P / 2);
    var L = C - this.healthHalfWidth;
    var K = C - this.sparesHalfWidth;
    var M = (C + this.sparesHalfWidth + 10) + "px";
    var O = E - this.poolTop - this.poolsSpace.vert - 10;
    if (O < 268) {
        O = 268
    }
    var N = K - this.poolsSpace.horiz - 15;
    if (N < 382) {
        N = 382
    }
    if (this.hasPool.A && this.hasVdisk.A) {
        var J = Math.floor((O - 158) / 2) + "px"
    } else {
        if (this.hasPool.A) {
            var J = (O - 84) + "px"
        } else {
            var J = (O - 102) + "px"
        }
    }
    if (this.hasPool.B && this.hasVdisk.B) {
        var H = Math.floor((O - 158) / 2) + "px"
    } else {
        if (this.hasPool.B) {
            var H = (O - 84) + "px"
        } else {
            var H = (O - 102) + "px"
        }
    }
    if (this.hasCache.A) {
        var I = (N - 50) + "px"
    } else {
        var I = N + "px"
    }
    if (this.hasCache.B) {
        var G = (N - 50) + "px"
    } else {
        var G = N + "px"
    }
    var D = N + "px";
    this.sysHealthWidget.elements$.css("left", L + "px");
    this.sparesWidget.elements$.css("left", K + "px");
    O += "px";
    N += "px";
    this.storageA.elements$.css({
        left: "5px",
        height: O,
        width: N
    });
    this.storageB.elements$.css({
        left: M,
        height: O,
        width: N
    });
    this.totalSpaceMeter.elements$.css("width", F);
    this.poolSpaceA.elements$.css("width", D);
    this.poolSpaceB.elements$.css("width", D);
    this.vdiskSpaceA.elements$.css("width", D);
    this.vdiskSpaceB.elements$.css("width", D);
    this.rcSegsA.elements$.css("height", J);
    this.rcSegsB.elements$.css("height", H);
    this.tierSegsA.elements$.css({
        height: J,
        width: I
    });
    this.tierSegsB.elements$.css({
        height: H,
        width: G
    });
    this.vdiskSegsA.elements$.css({
        height: J,
        width: D
    });
    this.vdiskSegsB.elements$.css({
        height: H,
        width: D
    });
    this.totalSpaceMeter.redrawGraph();
    if (this.hasPool.A) {
        this.poolSpaceA.redrawGraph();
        this.rcSegsA.redrawGraph();
        this.tierSegsA.redrawGraph()
    }
    if (this.hasPool.B) {
        this.poolSpaceB.redrawGraph();
        this.rcSegsB.redrawGraph();
        this.tierSegsB.redrawGraph()
    }
    if (this.hasVdisk.A) {
        this.vdiskSpaceA.redrawGraph();
        this.vdiskSegsA.redrawGraph()
    }
    if (this.hasVdisk.B) {
        this.vdiskSpaceB.redrawGraph();
        this.vdiskSegsB.redrawGraph()
    }
};
HomeTopic.prototype._systemUpdate = function(D) {
    var C = DC.system.get("health_numeric");
    if (C != this.healthSystem) {
        this.sysHealthWidget.elements$.removeClass(HEALTH_CLASS[this.healthSystem] + "25").addClass(HEALTH_CLASS[C] + "25");
        this.healthSystem = C
    }
};
HomeTopic.prototype._hostsUpdate = function(C) {
    var K = 0;
    for (var E in DC.hostGroupsId) {
        if (E != "HGU") {
            K++
        }
    }
    var D = 0;
    for (var I in DC.hostsId) {
        if (I != "HU") {
            D++
        }
    }
    var H = 0;
    for (var L in DC.initiators) {
        H++
    }
    var G = 0;
    if (DC.hostsId.HU && DC.hostsId.HU.initiators) {
        for (var F in DC.hostsId.HU.initiators) {
            G++
        }
    }
    this.hostGroupsWidget.handleUpdate({
        number: K,
        postText: ""
    });
    this.hostsWidget.handleUpdate({
        number: D,
        postText: ""
    });
    var J = "";
    if (G > 0) {
        var J = " (" + G + " " + strings.ungrouped + ")"
    }
    this.initsWidget.handleUpdate({
        number: H,
        postText: J
    })
};
HomeTopic.prototype._storageUpdate = function(K) {
    if (!MC.volumeGroupsSet.data || !MC.poolsSet.data) {
        return
    }
    if (!this.disksSparesUpdated) {
        this._disksUpdate()
    }
    if (DC.pools.A) {
        this.hasPool.A = true
    } else {
        this.hasPool.A = false
    }
    if (DC.pools.B) {
        this.hasPool.B = true
    } else {
        this.hasPool.B = false
    }
    this.hasVdisk.A = false;
    this.hasVdisk.B = false;
    var I = {
        A: [],
        B: []
    };
    var J = {
        A: [],
        B: []
    };
    var G = {
        A: [],
        B: []
    };
    for (var E in DC.diskGroups) {
        var L = DC.diskGroups[E];
        var D = L.get("preferred_owner");
        if (parseInt(L.get("storage_type_numeric")) == STORAGE_CLASS.LINEAR) {
            this.hasVdisk[D] = true;
            var N = new Size(L);
            var M = new Size(parseInt(L.get("blocks")) - parseInt(L.get("freespace_numeric")), "blocks");
            G[D].push({
                name: E,
                size: N,
                used: M
            })
        } else {
            var H = parseInt(L.get("storage_tier_numeric"), 10);
            if (H == 8) {
                J[D].push({
                    name: L.get("name"),
                    size: new Size(L.get("total_pages"), "pages"),
                    used: new Size(L.get("allocated_pages"), "pages"),
                    sizeClass: "tierSize8",
                    usedClass: "tierUsed8"
                })
            } else {
                I[D].push({
                    name: L.get("name"),
                    size: new Size(L.get("total_pages"), "pages"),
                    used: new Size(L.get("allocated_pages"), "pages"),
                    sizeClass: "tierSize" + H,
                    usedClass: "tierUsed" + H
                })
            }
        }
    }
    var F = {
        capacityBarTotal: {
            lowerSegments: [{
                cssClass: "spaceUnused",
                size: MC.disksSet.sizeAvail,
                label: strings.capacityBar.unusedLabel
            }, {
                cssClass: "spaceLinearPools",
                size: MC.disksSet.sizeLinear,
                label: strings.capacityBar.linearDGLabel
            }, {
                cssClass: "spaceSpares",
                size: MC.disksSet.sizeSpares,
                label: strings.capacityBar.sparesLabel
            }, {
                cssClass: "spaceVirtualPools",
                size: MC.disksSet.sizeVirtual,
                label: strings.capacityBar.virtualDGLabel
            }],
            segments: [{
                cssClass: "spaceOffset",
                size: MC.disksSet.sizeAvail,
                label: ""
            }, {
                cssClass: "spaceLinearReserved",
                size: MC.poolsSet.linearTotalReserved,
                label: strings.capacityBar.linearReservedLabel
            }, {
                cssClass: "spaceLinearAlloc",
                size: MC.poolsSet.linearTotalSizeUsed,
                label: strings.capacityBar.linearAllocLabel
            }, {
                cssClass: "spaceLinearUnalloc",
                size: MC.poolsSet.linearTotalSizeFree,
                label: strings.capacityBar.linearUnallocLabel
            }, {
                cssClass: "spaceOffset",
                size: MC.disksSet.sizeSpares,
                label: ""
            }, {
                cssClass: "spaceVirtualReserved",
                size: MC.poolsSet.virtTotalReserved,
                label: strings.capacityBar.virtualReservedLabel
            }, {
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSizeTotal,
                label: strings.capacityBar.virtualAllocLabel
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSizeTotal,
                label: strings.capacityBar.virtualUnallocLabel
            }]
        }
    };
    for (var C in {
            A: true,
            B: true
        }) {
        I[C].sort(HomeTopic.compareTierSegs);
        if (J[C].length > 0) {
            this.hasCache[C] = true;
            F["rcGraph" + C] = {
                segments: J[C]
            }
        } else {
            this.hasCache[C] = false;
            F["rcGraph" + C] = {
                segments: []
            }
        }
        if (I[C].length > 0) {
            this.hasPool[C] = true;
            F["tierGraph" + C] = {
                segments: I[C]
            }
        }
    }
    if (this.hasPool.A) {
        F.poolCapA = {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.A,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.A,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.A,
                label: strings.Unallocated
            }]
        };
        F.pagedTitleA = {
            text: strings.homeTopic.pagedTitle(MC.volumeGroupsSet.numVolsVirtual.A, MC.volumeGroupsSet.numSnapsVirtual.A)
        }
    }
    if (this.hasPool.B) {
        F.poolCapB = {
            lowerSegments: [{
                cssClass: "spaceVirtPool",
                size: MC.poolsSet.virtPoolSize.B,
                label: strings.VirtualPool
            }],
            segments: [{
                cssClass: "spaceVirtualAlloc",
                size: MC.poolsSet.virtPoolAllocSize.B,
                label: strings.Allocated
            }, {
                cssClass: "spaceVirtualUnalloc",
                size: MC.volumeGroupsSet.virtUnallocSize.B,
                label: strings.Unallocated
            }]
        };
        F.pagedTitleB = {
            text: strings.homeTopic.pagedTitle(MC.volumeGroupsSet.numVolsVirtual.B, MC.volumeGroupsSet.numSnapsVirtual.B)
        }
    }
    if (this.hasVdisk.A) {
        F.linearTitleA = {
            text: strings.homeTopic.linearTitle(MC.volumeGroupsSet.numVolsLinear.A, MC.volumeGroupsSet.numSnapsLinear.A)
        };
        F.vdiskCapA = {
            segments: [{
                cssClass: "spaceLinearAlloc",
                size: MC.poolsSet.linearSizeUsed.A,
                label: strings.Allocated
            }, {
                cssClass: "spaceLinearUnalloc",
                size: MC.poolsSet.linearSizeFree.A,
                label: strings.Unallocated
            }]
        };
        G.A.sort(HomeTopic.compareVdiskSegs);
        F.vdiskGraphA = {
            segments: G.A
        }
    }
    if (this.hasVdisk.B) {
        F.linearTitleB = {
            text: strings.homeTopic.linearTitle(MC.volumeGroupsSet.numVolsLinear.B, MC.volumeGroupsSet.numSnapsLinear.B)
        };
        F.vdiskCapB = {
            segments: [{
                cssClass: "spaceLinearAlloc",
                size: MC.poolsSet.linearSizeUsed.B,
                label: strings.Allocated
            }, {
                cssClass: "spaceLinearUnalloc",
                size: MC.poolsSet.linearSizeFree.B,
                label: strings.Unallocated
            }]
        };
        G.B.sort(HomeTopic.compareVdiskSegs);
        F.vdiskGraphB = {
            segments: G.B
        }
    }
    this.update(F)
};
HomeTopic.compareTierSegs = function(D, C) {
    if (D.sizeClass < C.sizeClass) {
        return -1
    } else {
        if (D.sizeClass > C.sizeClass) {
            return 1
        } else {
            if (D.name < C.name) {
                return -1
            } else {
                if (D.name > C.name) {
                    return 1
                } else {
                    return 0
                }
            }
        }
    }
};
HomeTopic.compareVdiskSegs = function(D, C) {
    if (D.name < C.name) {
        return -1
    } else {
        if (D.name > C.name) {
            return 1
        } else {
            return 0
        }
    }
};
HomeTopic.prototype._enclosuresUpdate = function(D) {
    if (!this.portsInitialized) {
        this._initializePorts()
    }
    var G = {};
    for (var E in DC.ports) {
        var C = DC.ports[E];
        var F = this.portWidgets[E];
        if (!F) {
            continue
        }
        if (C.get("status_numeric") === "0") {
            F.portImgDiv$.addClass("connected")
        } else {
            F.portImgDiv$.removeClass("connected");
            F.portImgDiv$.removeClass("active")
        }
        G[E] = {
            health: C.get("health_numeric")
        }
    }
    if (propertyCount(G) > 0) {
        this.update(G)
    }
};
HomeTopic.prototype._hostPortStatsUpdate = function(I) {
    var F = I.getData();
    var E;
    var D;
    var H = {};
    var G;
    for (var C = 0; C < F.objects.length; C++) {
        E = F.objects[C];
        D = E.get("durable_id");
        if (!this.portWidgets[D]) {
            continue
        }
        G = this.portWidgets[D];
        if (parseInt(E.get("iops"), 10) > 0) {
            G.portImgDiv$.addClass("active")
        } else {
            G.portImgDiv$.removeClass("active")
        }
    }
    this.hostPerfWidget.handleUpdate({
        iops: I.iopsTotal,
        mbps: I.mbpsTotal
    })
};
HomeTopic.prototype._disksUpdate = function(C) {
    if (MC.disksSet.numSparesStandard == undefined || MC.disksSet.numSparesArchive == undefined) {
        return
    }
    this.sparesWidget.update({
        spares: {
            standard: MC.disksSet.numSparesStandard,
            archive: MC.disksSet.numSparesArchive,
            ssd: MC.disksSet.numSparesSSD
        }
    });
    this.disksSparesUpdated = true
};
HomeTopic.prototype._initializePorts = function() {
    if (!DC.ports) {
        return
    }
    var H = {
        A: 1,
        B: 1
    };
    for (var G in H) {
        for (var D = 0; D <= 16; D++) {
            var E = "hostport_" + G + D;
            var C = DC.ports[E];
            var I = (D - system.physicalPositionOffset);
            if (C) {
                var F = new HomePortWidget({
                    name: E,
                    portPos: I
                });
                this.portWidgets[E] = F;
                this.ports[G].add(F)
            }
        }
    }
    this.portsInitialized = true
};

function HostWidget(E) {
    if (!E || !E.type) {
        return
    }
    var C = "host_" + E.type;
    switch (E.type) {
        case "hostGroups":
            var D = strings.HostGroups;
            break;
        case "hosts":
            var D = strings.Hosts;
            break;
        case "initiators":
            var D = strings.Initiators;
            break;
        default:
            MC.errorOutput("Invalid type for HostWidget: %s", E.type);
            break
    }
    E.htmlText = '<div id="' + D + '" class="hostWidget"><div class="' + C + '"></div><div class="hostTitle"><span class="hostPreText"></span> ' + D + ' <span class="hostPostText"></span></div></div>';
    Widget.call(this, E);
    this.class_name = "HostWidget";
    this.number$ = $(".hostPreText", this.elements);
    this.postText$ = $(".hostPostText", this.elements);
    this.handleUpdate(E)
}
HostWidget.prototype = new Widget();
HostWidget.prototype.constructor = HostWidget;
HostWidget.prototype.handleUpdate = function(C) {
    if (C.number != undefined) {
        this.number$.html(C.number);
        if (C.postText != undefined) {
            this.postText$.html(C.postText)
        }
    }
};

function HomePortWidget(E) {
    if (!E || !E.name) {
        return
    }
    this.port = DC.ports[E.name];
    if (!this.port) {
        return
    }
    this.portType = this.port.get("port_type");
    var D = "port" + this.portType;
    var C = this.port.getInt("fan_out");
    E.htmlText = '<div id="' + E.name + '" class="portDisplay"><div class="' + D + '"></div><div class="portLabel">' + this.port.get("port") + " - " + this.portType + "</div></div>";
    E.healthSize = 25;
    E.healthPosition = "top: -8px; left: -8px";
    if (C > 1 && (E.portPos == 0 || E.portPos == 2)) {
        E.fanoutSize = 24;
        E.fanoutPosition = "top: 33px; left: 74px; z-index: 1"
    }
    E.hoverPanel = APIObject.getHover("port");
    Widget.call(this, E);
    this.class_name = "HomePortWidget";
    this.portImgDiv$ = $("." + D, this.elements)
}
HomePortWidget.prototype = new Widget();
HomePortWidget.prototype.constructor = HomePortWidget;
HomePortWidget.prototype.getApiObject = function() {
    return this.port
};

function PerfSummaryWidget(F) {
    if (!F || !F.name) {
        return
    }
    var H = "perfDisplay";
    if (F.vertical) {
        H += "Vert"
    }
    var D = "perfIops";
    var E = "perfMbps";
    var G = "<span>&nbsp;IOPS</span>";
    var C = "<span>&nbsp;MB/s</span>";
    if (F.noUnits) {
        H += "Small";
        D = "perfIopsSmall";
        E = "perfMbpsSmall";
        G = "";
        C = ""
    }
    F.htmlText = '<div class="' + H + '"><div class="' + D + '"><span class="iops">0</span>' + G + '</div><div class="' + E + '"><span class="mbps">0</span>' + C + "</div></div>";
    Widget.call(this, F);
    this.class_name = "PerfSummaryWidget";
    this.iops$ = $(".iops", this.elements);
    this.mbps$ = $(".mbps", this.elements)
}
PerfSummaryWidget.prototype = new Widget();
PerfSummaryWidget.prototype.constructor = PerfSummaryWidget;
PerfSummaryWidget.prototype.handleUpdate = function(C) {
    if (C.iops != undefined) {
        this.iops$.html(C.iops)
    }
    if (C.mbps != undefined) {
        this.mbps$.html(C.mbps)
    }
};

function SparesWidget(C) {
    if (!C) {
        return
    }
    if (!C.name) {
        C.name = "spares"
    }
    C.htmlText = '<div class="sparesWidget"><div class="sparesInfo"><div class="sparesLabel">' + strings.Spares + '</div><div class="sparesStandard">0</div><div class="sparesArchive">0</div><div class="sparesSSD">0</div></div></div>';
    Widget.call(this, C);
    this.class_name = "SparesWidget";
    this.sparesStandard$ = $(".sparesStandard", this.elements);
    this.sparesArchive$ = $(".sparesArchive", this.elements);
    this.sparesSSD$ = $(".sparesSSD", this.elements)
}
SparesWidget.prototype = new Widget();
SparesWidget.prototype.constructor = SparesWidget;
SparesWidget.prototype.handleUpdate = function(C) {
    if (C.standard != undefined) {
        this.sparesStandard$.html(C.standard)
    }
    if (C.archive != undefined) {
        this.sparesArchive$.html(C.archive)
    }
    if (C.ssd != undefined) {
        this.sparesSSD$.html(C.ssd)
    }
};

function StorageHover(D) {
    if (arguments.length == 0) {
        return
    }
    D.width = 550;
    D.name = "StorageHover";
    var C = 0;
    D.widgets = new WidgetContainer({
        widgets: [this.dataTable = new TableWidget({
            maxCols: 2,
            width: D.width,
            widgets: [new TextWidget({
                name: "owner",
                label: strings.Owner,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: this.ownerRow = C
            }), new TextWidget({
                colSpan: 2,
                text: strings.Virtual,
                cssClass: "hoverSectionLabel",
                bottomSmallMargin: true,
                row: this.virtualBeginRow = ++C
            }), new TextWidget({
                name: "virtualTotal",
                label: strings.storageHover.totalSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "virtualAlloc",
                label: strings.storageHover.usedSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "virtualSnapSize",
                label: strings.storageHover.snapSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: this.virtualSnapRow = ++C
            }), new TextWidget({
                name: "virtualUnalloc",
                label: strings.storageHover.availSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "allocRate",
                label: strings.storageHover.allocRate,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "deallocRate",
                label: strings.storageHover.deallocRate,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "tierData",
                colSpan: 2,
                bottomMargin: true,
                leftMargin: true,
                row: this.virtualEndRow = ++C
            }), new TextWidget({
                colSpan: 2,
                text: strings.Linear,
                cssClass: "hoverSectionLabel",
                bottomSmallMargin: true,
                row: this.linearBeginRow = ++C
            }), new TextWidget({
                name: "linearTotal",
                label: strings.storageHover.totalSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "linearAlloc",
                label: strings.storageHover.usedSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: ++C
            }), new TextWidget({
                name: "linearSnapSize",
                label: strings.storageHover.snapSize,
                labelOptions: {
                    rightMargin: true
                },
                bottomSmallMargin: true,
                row: this.linearSnapRow = ++C
            }), new TextWidget({
                name: "linearUnalloc",
                label: strings.storageHover.availSize,
                labelOptions: {
                    rightMargin: true
                },
                row: this.linearEndRow = ++C
            })]
        }), new HealthWidget({
            name: "poolHealth",
            topMargin: true
        })]
    });
    HoverPanel.call(this, D);
    this.class_name = "StorageHover"
}
StorageHover.prototype = new HoverPanel();
StorageHover.prototype.constructor = StorageHover;
StorageHover.prototype.showing = function() {
    var D = this.currentParent.options.pool;
    var H = (RI.hasFeature("dms") || RI.hasFeature("copyServices"));
    var G = {};
    if (DC.pools[D]) {
        this.dataTable.showRows(this.virtualBeginRow, this.virtualEndRow);
        if (H) {
            this.dataTable.showRows(this.virtualSnapRow, this.virtualSnapRow)
        } else {
            this.dataTable.hideRows(this.virtualSnapRow, this.virtualSnapRow)
        }
    } else {
        this.dataTable.hideRows(this.virtualBeginRow, this.virtualEndRow)
    }
    if (MC.disksSet.sizeLinearOwner[D].getRawValue() == 0) {
        this.dataTable.hideRows(this.linearBeginRow, this.linearEndRow)
    } else {
        this.dataTable.showRows(this.linearBeginRow, this.linearEndRow);
        if (H) {
            this.dataTable.showRows(this.linearSnapRow, this.linearSnapRow)
        } else {
            this.dataTable.hideRows(this.linearSnapRow, this.linearSnapRow)
        }
    }
    var F = DC.pools[D];
    var J = strings.storageHover.pagesPerMin("0");
    var K = strings.storageHover.pagesPerMin("0");
    if (F) {
        J = strings.storageHover.pagesPerMin(F.stats.get("pages_alloc_per_minute"));
        K = strings.storageHover.pagesPerMin(F.stats.get("pages_dealloc_per_minute"))
    }
    var I = '<table class="tierTable"><tr><th class="tiersLabel">' + strings.storageHover.tiersLabel + "</th><th>" + strings.storageHover.tierPoolPctLabel + "</th><th>" + strings.storageHover.tierDisksLabel + "</th><th>" + strings.storageHover.tierTotalLabel + "</th><th>" + strings.storageHover.tierAllocLabel + "</th><th>" + strings.storageHover.tierAvailLabel + "</th><th>" + strings.storageHover.tierAffinitySize + "</th><th>" + strings.storageHover.tierReclaimLabel + "</th></tr>";
    if (DC.tiersSerial) {
        for (var C in DC.tiersSerial) {
            var E = DC.tiersSerial[C];
            if (E.get("pool") != D) {
                continue
            }
            I += "<tr>";
            I += '<td class="tierName">' + E.get("tier") + "</td>";
            I += "<td>" + E.get("pool_percentage") + "</td>";
            I += "<td>" + E.get("diskcount") + "</td>";
            I += "<td>" + E.get("total_size") + "</td>";
            I += "<td>" + E.get("allocated_size") + "</td>";
            I += "<td>" + E.get("available_size") + "</td>";
            I += "<td>" + E.get("affinity_size") + "</td>";
            I += "<td>" + this.findZeroPages(C) + "</td>";
            I += "</tr>"
        }
        I += "</table>"
    }
    G = {
        owner: {
            text: D
        },
        virtualTotal: {
            text: MC.poolsSet.virtPoolSize[D].format("scale")
        },
        virtualAlloc: {
            text: MC.poolsSet.virtPoolAllocSize[D].format("scale")
        },
        virtualUnalloc: {
            text: MC.poolsSet.virtPoolAvailSize[D].format("scale")
        },
        allocRate: {
            text: J
        },
        deallocRate: {
            text: K
        },
        tierData: {
            text: I
        },
        linearTotal: {
            text: MC.poolsSet.linearSize[D].format("scale")
        },
        linearAlloc: {
            text: MC.poolsSet.linearSizeUsed[D].format("scale")
        },
        linearUnalloc: {
            text: MC.poolsSet.linearSizeFree[D].format("scale")
        },
        poolHealth: {
            obj: F
        }
    };
    if (F) {
        G.virtualSnapSize = {
            text: MC.poolsSet.virtPoolSnapSizeUsed[D].format("scale")
        };
        G.linearSnapSize = {
            text: MC.poolsSet.linearSnapSizeUsed[D].format("scale")
        }
    } else {
        G.linearSnapSize = {
            text: MC.poolsSet.linearSnapSizeUsed[D].format("scale")
        }
    }
    this.update(G)
};
StorageHover.prototype.findZeroPages = function(D) {
    var F = this.currentParent.options.pool;
    var C = DC.pools[F].stats;
    for (var E = 0; E < C.objects.length; E++) {
        if (C.objects[E].get("serial_number") == D && C.objects[E].get("pages_reclaimed")) {
            return C.objects[E].get("pages_reclaimed")
        }
    }
    return ""
};

function TierHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 250;
    C.name = "TierHover";
    C.widgets = new TableWidget({
        maxCols: 2,
        widgets: [new TextWidget({
            name: "tierName",
            label: strings.tierHover.tierName,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "totalSize",
            label: strings.tierHover.totalSize,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "percent",
            label: strings.tierHover.percent,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "usedSize",
            label: strings.tierHover.usedSize,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "availSize",
            label: strings.tierHover.availSize,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "allocRate",
            label: strings.tierHover.allocRate,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        }), new TextWidget({
            name: "deallocRate",
            label: strings.tierHover.deallocRate,
            labelOptions: {
                rightMargin: true
            },
            bottomSmallMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "TierHover"
}
TierHover.prototype = new HoverPanel();
TierHover.prototype.constructor = TierHover;
TierHover.prototype.showing = function() {
    var C = this.currentParent.tier;
    var D = (C.get("tier_numeric") == TIERS.READCACHE);
    var E = new Size(C.get("total_size_numeric"), "blocks");
    var F = {
        tierName: {
            text: C.get("pool") + " - " + C.get("tier")
        }
    };
    if (D) {
        $("tr", this.elements).slice(2, 7).hide()
    } else {
        $("tr", this.elements).slice(2, 7).show();
        var H = new Size(C.get("available_size_numeric"), "blocks");
        var G = new Size(E);
        G.subtract(H);
        F.percent = {
            text: strings.percentValue(C.get("pool_percentage"))
        };
        F.totalSize = {
            text: E.format("scale")
        };
        F.usedSize = {
            text: G.format("scale")
        };
        F.availSize = {
            text: H.format("scale")
        };
        F.allocRate = {
            text: strings.tierHover.pagesPerMin(C.get("pages_alloc_per_minute"))
        };
        F.deallocRate = {
            text: strings.tierHover.pagesPerMin(C.get("pages_dealloc_per_minute"))
        }
    }
    this.update(F)
};

function SparesHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "SparesHover";
    C.width = 250;
    C.widgets = new TableWidget({
        name: "sparesTable",
        maxCols: 2,
        widgets: [new TextWidget({
            name: "diskType",
            text: strings.sparesHover.usage,
            rightMargin: true,
            bottomMargin: true
        }), new TextWidget({
            name: "sparesAvailable",
            text: strings.sparesHover.sparesAvailable,
            cellClasses: "alignRight",
            bottomMargin: true
        })]
    });
    this.prefix = "DiskType";
    for (index = 0; index < 20; index++) {
        C.widgets.add(this.addWidget(index))
    }
    C.widgets.add(new TextWidget({
        colSpan: 2,
        text: strings.sparesHover.warningLabel,
        topMargin: true,
        cssClass: "error"
    }));
    HoverPanel.call(this, C);
    this.class_name = "SparesHover"
}
SparesHover.prototype = new HoverPanel();
SparesHover.prototype.constructor = SparesHover;
SparesHover.prototype.showing = function() {
    var K = MC.disksSet.data.objects;
    var I = {};
    var D = {};
    for (E = 0, len = K.length; E < len; E++) {
        var C = K[E].getInt("usage_numeric");
        var J = K[E].get("description") + " " + K[E].get("rpm") + "K " + K[E].get("size");
        if (I[J] == undefined) {
            I[J] = 0
        }
        if (C == DRIVE_USAGE.GLOBAL_SPARE) {
            I[J]++
        }
    }
    var E = 0;
    var H = false;
    for (var J in I) {
        var G = I[J];
        var F = this.prefix + E;
        D[F] = {
            label: J,
            text: G
        };
        E++;
        D[F].cssClass = "alignCenter"
    }
    D.sparesTable = {
        hide: {
            start: 1,
            end: 21
        },
        show: {
            start: 1,
            end: E
        }
    };
    this.update(D);
    if (H) {
        D = {
            sparesTable: {
                show: {
                    start: 21,
                    end: 21
                }
            }
        };
        this.update(D)
    }
};
SparesHover.prototype.addWidget = function(C) {
    var D = new TextWidget({
        name: this.prefix + C,
        label: "",
        text: "",
        noTerminator: true,
        bottomSmallMargin: true,
        leftMargin: true
    });
    return D
};

function EasyStartTopic(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "EasyStartTopic";
    C.title = strings.menus.home;
    C.widgets = new WidgetContainer({
        classes: "center10",
        widgets: [new WidgetContainer({
            classes: "homeRowContainer homeHosts",
            widgets: [new TextWidget({
                text: strings.easyStart.welcome,
                classes: "welcomeText"
            }), new TextWidget({
                text: strings.easyStart.intro,
                classes: "welcomeLeftMargin"
            }), new Widget({
                name: "checkFirmware",
                classes: "welcomeLeftMargin",
                topMargin: true,
                htmlText: '<div ><div id="firmware" class="welcomeAction buttonPrimary">' + strings.easyStart.upgradeFirmware + '</div><div class="welcomeActionStatus"><div class="welcomeActionStatusIcon"></div><div class="welcomeActionStatusText">' + strings.easyStart.required + "</div></div>"
            }), new Widget({
                classes: "welcomeLeftMargin",
                name: "sysSettings",
                topMargin: true,
                htmlText: '<div ><div id="settings" class="welcomeAction buttonPrimary">' + strings.easyStart.sysSettings + '</div><div class="welcomeActionStatus"><div class="welcomeActionStatusIcon"></div><div class="welcomeActionStatusText">' + strings.easyStart.required + "</div></div>"
            }), new Widget({
                name: "storageSetup",
                classes: "welcomeLeftMargin",
                topMargin: true,
                htmlText: '<div ><div id="storage" class="welcomeAction buttonPrimary">' + strings.easyStart.storageSetup + '</div><div class="welcomeActionStatus"><div class="welcomeActionStatusIcon"></div><div class="welcomeActionStatusText">' + strings.easyStart.required + "</div></div>"
            }), new Widget({
                name: "hostSetup",
                classes: "welcomeLeftMargin",
                topMargin: true,
                htmlText: '<div><div id="host" class="welcomeAction buttonPrimary">' + strings.easyStart.hostSetup + '</div><div class="welcomeActionStatus"><div class="welcomeActionStatusIcon"></div><div class="welcomeActionStatusText">' + strings.easyStart.required + "</div></div>"
            }), new TextWidget({
                name: "mustCompleteConfig",
                classes: "welcomeLeftMargin",
                topMargin: true,
                text: strings.easyStart.mustCompleteFirmware
            }), new WidgetContainer({
                name: "configComplete",
                widgets: [new TextWidget({
                    name: "configComplete",
                    classes: "welcomeLeftMargin",
                    topMargin: true,
                    text: strings.easyStart.configComplete
                }), new ButtonWidget({
                    name: "goToHome",
                    id: "goToHome",
                    classes: "welcomeSysInfo",
                    primary: true,
                    text: strings.easyStart.goToHome,
                    callback: function() {
                        MC.setUserInteraction({
                            bypassEasyStart: true
                        }, {
                            callback: BypassEasyStartComplete
                        })
                    }
                })]
            }), new Widget({
                name: "skipWelcome",
                htmlText: '<div class="textWidget">' + strings.easyStart.knowWhatDoing + '<span class="skipWelcomeText">' + strings.easyStart.skipWelcome + '</span><span style="margin-left:10px">' + strings.easyStart.returnLater + "</div>",
                topMargin: true,
                bottomMargin: true,
                classes: "welcomeLeftMargin"
            })]
        }), new WidgetContainer({
            htmlText: '<div style="margin-top: 10px"></div>',
            classes: "homeRowContainer homeHosts",
            widgets: [new WidgetContainer({
                name: "sysHealth",
                classes: "welcomeSysHealth",
                widgets: [new TextWidget({
                    text: '<span style="font-size: 15px; font-weight: bold;">' + strings.easyStart.sysHealth + "</span>"
                }), new Widget({
                    topMargin: true,
                    leftMargin: true,
                    htmlText: '<div><div class="welcomeSysHealthIcon"></div><div class="welcomeSysHealthText"></div></div>'
                }), new WidgetContainer({
                    name: "healthBad",
                    topMargin: true,
                    widgets: [new TextWidget({
                        name: "singleControllerText",
                        text: strings.easyStart.degradedSingleCtlr + ' <span class="setSingleCtlrText">' + strings.easyStart.setSingleCtlr + "</span><br><br>" + strings.easyStart.degradedSingleCtlrSysTopic
                    }), new TextWidget({
                        name: "healthBadText"
                    }), new ButtonWidget({
                        name: "sysInfo",
                        classes: "welcomeSysInfo",
                        primary: true,
                        text: strings.easyStart.sysInfo,
                        callback: function() {
                            NAV.navTo("topics", "system", null)
                        }
                    })]
                })]
            }), new WidgetContainer({
                htmlText: '<div style="display: inline-block;vertical-align: top; padding: 10px;"></div>',
                name: "sysCapacity",
                widgets: [new TextWidget({
                    text: '<span style="font-size: 15px; font-weight: bold;">' + strings.easyStart.availStorage + "</span>"
                }), new TextWidget({
                    name: "availableCapacity",
                    classes: "availCapacity",
                    leftMargin: true,
                    topMargin: true
                })]
            })]
        })]
    });
    TopicPanel.call(this, C);
    this.class_name = "EasyStartTopic";
    this.welcomeActionButtons = $(".welcomeAction", this.elements);
    $(".skipWelcomeText", this.elements).click(function() {
        MC.setUserInteraction({
            bypassEasyStart: true
        }, {
            dialog: true,
            confirmMsg: strings.systemSettings.bypassEasyStartConfirm,
            processingMsg: strings.systemSettings.bypassEasyStartProcessing,
            failureMsg: strings.systemSettings.bypassEasyStartFailure,
            successMsg: strings.systemSettings.bypassEasyStartSuccess,
            callback: BypassEasyStartComplete
        })
    });
    $(".setSingleCtlrText", this.elements).click(function() {
        var E = {
            single_controller: {
                value: true
            }
        };
        var D = {
            dialog: true,
            closeActionOn: "none",
            confirmMsg: strings.singleController.confirmMsg,
            processingMsg: strings.singleController.processingMsg,
            failureMsg: strings.singleController.failureMsg,
            successMsg: strings.singleController.successMsg
        };
        MC.setAdvancedSettings(E, D)
    });
    this.welcomeActionStatusIcons = $(".welcomeActionStatusIcon", this.elements);
    this.welcomeActionStatusTexts = $(".welcomeActionStatusText", this.elements);
    this.sysHealthIcon = $(".welcomeSysHealthIcon", this.elements);
    this.sysHealthText = $(".welcomeSysHealthText", this.elements)
}
EasyStartTopic.prototype = new TopicPanel();
EasyStartTopic.prototype.constructor = EasyStartTopic;
EasyStartTopic.prototype.showing = function() {
    var C = {
        skipWelcome: {
            visibility: "collapse"
        },
        configComplete: {
            visibility: "collapse"
        },
        mustCompleteConfig: {
            visibility: "collapse"
        }
    };
    if (RI.hasFeature("completesetup")) {
        C.hostSetup = {
            visibility: "visible"
        };
        C.storageSetup = {
            visibility: "visible"
        }
    } else {
        C.hostSetup = {
            visibility: "collapse"
        };
        C.storageSetup = {
            visibility: "collapse"
        }
    }
    if (RI.hasFeature("easyStartFirmware")) {
        C.checkFirmware = {
            visibility: "visible"
        };
        C.storageSetup = {
            visibility: "collapse"
        }
    } else {
        C.checkFirmware = {
            visibility: "collapse"
        }
    }
    this.update(C);
    if (RI.hasFeature("ldap")) {
        this.usersGroupSubscription = MC.usergroupssSet.requestData({
            update: false,
            durable: true,
            requestor: this.class_name,
            handler: createObjectCallback(this, function() {
                this.updateUserData()
            })
        })
    }
    this.usersSubscription = MC.usersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, function() {
            this.updateUserData()
        })
    });
    this.systemSubscription = MC.systemInfoSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.sysInfoUpdate)
    });
    this.diskSubscription = MC.disksSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.disksUpdate)
    });
    this.poolsSubscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.generalUpdate)
    });
    this.mapsSubscription = MC.mapsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.generalUpdate)
    });
    this.advSettingSubscription = MC.advancedSettingsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.sysInfoUpdate)
    });
    this.enclosuresSubscription = MC.enclosuresSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.sysInfoUpdate)
    });
    this.snmpSubscription = MC.snmpParametersSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.generalUpdate)
    });
    this.emailSubscription = MC.emailParametersSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this.generalUpdate)
    });
    this.syslogSubscription = MC.syslogParametersSet.requestData({
        update: false,
        durable: true,
        requestor: this.class_name,
        handler: createObjectCallback(this, this.generalUpdate)
    });
    var C = {
        singleControllerText: {
            visibility: "collapse"
        }
    };
    this.update(C)
};
EasyStartTopic.prototype.hiding = function() {
    if (this.systemSubscription) {
        MC.systemInfoSet.unregister(this.systemSubscription);
        delete this.systemSubscription
    }
    if (this.diskSubscription) {
        MC.disksSet.unregister(this.diskSubscription);
        delete this.diskSubscription
    }
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.generalUpdate);
        delete this.poolsSubscription
    }
    if (this.mapsSubscription) {
        MC.mapsSet.unregister(this.generalUpdate);
        delete this.mapsSubscription
    }
    if (this.advSettingSubscription) {
        MC.advancedSettingsSet.unregister(this.advSettingsSubscription);
        delete this.advSettingSubscription
    }
    if (this.enclosuresSubscription) {
        MC.enclosuresSet.unregister(this.enclosuresSubscription);
        delete this.enclosuresSubscription
    }
    if (this.emailSubscription) {
        MC.emailParametersSet.unregister(this.emailSubscription);
        delete this.emailSubscription
    }
    if (this.snmpSubscription) {
        MC.snmpParametersSet.unregister(this.snmpSubscription);
        delete this.snmpSubscription
    }
    if (this.syslogSubscription) {
        MC.syslogParametersSet.unregister(this.syslogSubscription);
        delete this.syslogSubscription
    }
    if (this.usersGroupSubscription) {
        MC.usergroupssSet.unregister(this.usersGroupSubscription);
        delete this.usersGroupSubscription
    }
    if (this.usersSubscription) {
        MC.usersSet.unregister(this.usersSubscription);
        delete this.usersSubscription
    }
};
EasyStartTopic.prototype.updateUserData = function() {
    this.welcomeActionButtons.off().click(function(C) {
        var D = C.currentTarget.id;
        if ($("#" + D).hasClass("welcomeButtonDisabled")) {
            return
        }
        if (session.hasConfigurationCapability()) {
            if (D == "firmware") {
                NAV.navTo("SysInfoBarPanel", "updateFirmware", null)
            } else {
                if (D == "settings") {
                    NAV.navTo("HomeTopic", "sysSettings", null)
                } else {
                    if (D == "storage" && RI.hasFeature("completesetup")) {
                        NAV.navTo("HomeTopic", "storageCompleteSetup", null)
                    } else {
                        if (D == "storage") {
                            NAV.navTo("HomeTopic", "storageSetup", null)
                        } else {
                            if (D == "host") {
                                NAV.navTo("HomeTopic", "hostSetup", null)
                            } else {
                                MC.warningOutput("Unrecognized Welcome action clicked")
                            }
                        }
                    }
                }
            }
        } else {
            if (session.hasMonitorRole()) {
                if (D == "settings") {
                    NAV.navTo("HomeTopic", "sysSettings", null)
                }
            }
        }
    })
};
EasyStartTopic.prototype.sysInfoUpdate = function() {
    var C = {
        healthBad: {
            visibility: "collapse"
        },
        healthBadText: {
            visibility: "collapse"
        },
        singleControllerText: {
            visibility: "collapse"
        }
    };
    var D = DC.system.getInt("health_numeric");
    if (D != HEALTH.OK) {
        if (D == HEALTH.FAULT) {
            $(this.welcomeActionButtons).addClass("welcomeButtonDisabled");
            $(this.welcomeActionStatusIcons).css("opacity", "0.25");
            $(this.welcomeActionStatusTexts).css("color", "#dadada");
            this.sysHealthIcon.addClass("welcomeSysBad");
            this.sysHealthText.html(strings.easyStart.faulty);
            C.healthBadText = {
                text: strings.easyStart.alert + " " + strings.easyStart.faultyStateText,
                visibility: "visible"
            };
            C.healthBad.visibility = "visible"
        } else {
            if (D == HEALTH.DEGRADED) {
                this.sysHealthIcon.addClass("welcomeSysDegraded");
                this.sysHealthText.html(strings.easyStart.degraded);
                C.healthBad.visibility = "visible";
                var F = false;
                if (DC.advSettings.attr != undefined && DC.advSettings.getInt("single_controller_numeric") == ADVANCED_SETTING.DISABLED) {
                    var G = (DC.controllers.A) ? (DC.controllers.A.getInt("status_numeric") === CONTROLLER_STATUS.NOT_INSTALLED) : true;
                    var E = (DC.controllers.B) ? (DC.controllers.B.getInt("status_numeric") === CONTROLLER_STATUS.NOT_INSTALLED) : true;
                    if (G || E) {
                        F = true
                    }
                }
                if (F) {
                    C.singleControllerText.visibility = "visible"
                } else {
                    C.healthBadText = {
                        text: strings.easyStart.alert + " " + strings.easyStart.faultyStateText,
                        visibility: "visible"
                    }
                }
            }
        }
    } else {
        this.sysHealthIcon.addClass("welcomeSysGood");
        this.sysHealthText.html(strings.easyStart.good)
    }
    this.update(C)
};
EasyStartTopic.prototype.generalUpdate = function() {
    if (!MC.poolsSet.data || !MC.mapsSet.data) {
        return
    }
    if (MC.mapsSet.data) {
        this.hostSetupComplete = false;
        if ((MC.mapsSet.data.objects.length > 0) || (propertyCount(DC.hostGroups) > 1) || (propertyCount(DC.hosts) > 1)) {
            this.hostSetupComplete = true
        }
    }
    this.updateWelcomeButtons()
};
EasyStartTopic.prototype.updateWelcomeButtons = function() {
    if (DC.pools == undefined || this.hostSetupComplete == undefined || !MC.systemInfoSet.data) {
        return
    }
    var C = false;
    var D = EZStartManager.bypassFirmware;
    var F = EZStartManager.isConfigurationComplete();
    var E = !$.isEmptyObject(DC.pools);
    if (F) {
        this.update({
            skipWelcome: {
                visibility: "visible"
            }
        })
    } else {
        this.update({
            skipWelcome: {
                visibility: "collapse"
            }
        })
    }
    if (RI.hasFeature("easyStartFirmware") && D && F) {
        C = true
    }
    if (RI.hasFeature("completesetup") && F && E && this.hostSetupComplete) {
        C = true
    }
    if (C) {
        $(this.welcomeActionStatusIcons).addClass("welcomeActionCompleted");
        $(this.welcomeActionStatusTexts).html(strings.easyStart.completed);
        $(this.welcomeActionButtons).removeClass("welcomeButtonDisabled");
        $(this.welcomeActionStatusIcons).css("opacity", "1");
        $(this.welcomeActionStatusTexts).css("opacity", "1");
        this.update({
            configComplete: {
                visibility: "visible"
            },
            skipWelcome: {
                visibility: "collapse"
            }
        })
    } else {
        this.update({
            configComplete: {
                visibility: "collapse"
            }
        });
        if (RI.hasFeature("easyStartFirmware")) {
            if (D) {
                $(this.welcomeActionStatusIcons[0]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[0]).html(strings.easyStart.completed);
                $(this.welcomeActionStatusIcons[1]).removeClass("welcomeActionCompleted welcomeButtonDisabled").addClass("welcomeActionRequired").css("opacity", "1");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.required).css("opacity", "1");
                $(this.welcomeActionButtons[1]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionButtons[0]).removeClass("welcomeButtonDisabled");
                this.update({
                    mustCompleteConfig: {
                        visibility: "collapse"
                    }
                })
            } else {
                $(this.welcomeActionStatusIcons[0]).addClass("welcomeActionRequired");
                $(this.welcomeActionStatusTexts[0]).html(strings.easyStart.required);
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionRequired");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.required);
                $(this.welcomeActionButtons[1]).addClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[1]).css("opacity", "0.25");
                $(this.welcomeActionStatusTexts[1]).css("opacity", "0.25");
                this.update({
                    mustCompleteConfig: {
                        visibility: "visible"
                    }
                })
            }
            if (F) {
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.completed);
                this.update({
                    mustCompleteConfig: {
                        visibility: "collapse"
                    }
                })
            } else {
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionRequired");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.required)
            }
        }
        if (RI.hasFeature("completesetup")) {
            $(this.welcomeActionStatusIcons[1]).removeClass("welcomeActionCompleted").addClass("welcomeActionRequired");
            $(this.welcomeActionButtons[1]).addClass("welcomeButtonDisabled");
            $(this.welcomeActionStatusIcons[1]).css("opacity", "0.25");
            $(this.welcomeActionStatusTexts[1]).css("opacity", "0.25");
            $(this.welcomeActionStatusIcons[2]).removeClass("welcomeActionCompleted").addClass("welcomeActionRequired");
            $(this.welcomeActionButtons[2]).addClass("welcomeButtonDisabled");
            $(this.welcomeActionStatusIcons[2]).css("opacity", "0.25");
            $(this.welcomeActionStatusTexts[2]).css("opacity", "0.25");
            $(this.welcomeActionStatusIcons[3]).removeClass("welcomeActionCompleted").addClass("welcomeActionRequired");
            $(this.welcomeActionButtons[3]).addClass("welcomeButtonDisabled");
            $(this.welcomeActionStatusIcons[3]).css("opacity", "0.25");
            $(this.welcomeActionStatusTexts[3]).css("opacity", "0.25");
            if (F) {
                $(this.welcomeActionButtons[1]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.completed);
                $(this.welcomeActionStatusIcons[1]).css("opacity", "1");
                $(this.welcomeActionStatusTexts[1]).css("opacity", "1");
                $(this.welcomeActionButtons[2]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[2]).css("opacity", "1");
                $(this.welcomeActionStatusTexts[2]).css("opacity", "1")
            } else {
                $(this.welcomeActionButtons[1]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[1]).css("opacity", "1");
                $(this.welcomeActionStatusTexts[1]).css("opacity", "1");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.required)
            }
            if (F && E) {
                $(this.welcomeActionButtons[2]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[2]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[2]).html(strings.easyStart.completed);
                $(this.welcomeActionButtons[3]).removeClass("welcomeButtonDisabled");
                $(this.welcomeActionStatusIcons[3]).css("opacity", "1");
                $(this.welcomeActionStatusTexts[3]).css("opacity", "1")
            } else {
                if (!F && E) {
                    $(this.welcomeActionButtons[2]).removeClass("welcomeButtonDisabled");
                    $(this.welcomeActionStatusIcons[2]).addClass("welcomeActionCompleted");
                    $(this.welcomeActionStatusTexts[2]).html(strings.easyStart.completed);
                    $(this.welcomeActionStatusIcons[2]).css("opacity", "1");
                    $(this.welcomeActionStatusTexts[2]).css("opacity", "1")
                }
            }
        } else {
            if (F) {
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.completed);
                this.update({
                    mustCompleteConfig: {
                        visibility: "collapse"
                    }
                })
            } else {
                $(this.welcomeActionStatusIcons[1]).addClass("welcomeActionRequired");
                $(this.welcomeActionStatusTexts[1]).html(strings.easyStart.required)
            }
            if (E) {
                $(this.welcomeActionStatusIcons[2]).addClass("welcomeActionCompleted");
                $(this.welcomeActionStatusTexts[2]).html(strings.easyStart.completed)
            } else {
                $(this.welcomeActionStatusIcons[2]).removeClass("welcomeActionCompleted").addClass("welcomeActionRequired");
                $(this.welcomeActionStatusTexts[2]).html(strings.easyStart.required);
                if (F) {
                    $(this.welcomeActionButtons[1]).removeClass("welcomeActionCompleted welcomeButtonDisabled");
                    $(this.welcomeActionStatusIcons[1]).css("opacity", "1");
                    $(this.welcomeActionStatusTexts[1]).css("opacity", "1")
                } else {
                    $(this.welcomeActionButtons[2]).addClass("welcomeButtonDisabled");
                    $(this.welcomeActionStatusIcons[2]).css("opacity", "0.25");
                    $(this.welcomeActionStatusTexts[2]).css("opacity", "0.25")
                }
            }
        }
    }
    if (session.hasOnlyMonitorRole()) {
        $(this.welcomeActionButtons[0]).addClass("welcomeButtonDisabled");
        $(this.welcomeActionButtons[2]).addClass("welcomeButtonDisabled");
        $(this.welcomeActionButtons[3]).addClass("welcomeButtonDisabled");
        $(this.welcomeActionStatusIcons[0]).addClass("welcomeButtonDisabled").css("opacity", "0.25");
        $(this.welcomeActionStatusIcons[2]).addClass("welcomeButtonDisabled").css("opacity", "0.25");
        $(this.welcomeActionStatusIcons[3]).addClass("welcomeButtonDisabled").css("opacity", "0.25");
        $(this.welcomeActionButtons[1]).removeClass("welcomeButtonDisabled");
        $(this.welcomeActionStatusIcons[1]).removeClass("welcomeButtonDisabled").css("opacity", "1");
        $(this.welcomeActionStatusTexts[1]).css("opacity", "1");
        $("#goToHome").addClass("welcomeButtonDisabled")
    }
};
EasyStartTopic.prototype.disksUpdate = function() {
    var D = new Size();
    for (var C in DC.disks) {
        var F = DC.disks[C];
        var E = F.getInt("usage_numeric");
        if (E == DRIVE_USAGE.AVAILABLE) {
            var G = F.getTotalBlocks();
            D.add(G, "blocks")
        }
    }
    this.update({
        availableCapacity: {
            text: D.format("scale")
        }
    })
};

function BypassEasyStartComplete(C) {
    if (C.success) {
        EZStartManager.bypassEasyStart = true;
        NAV.navTo("topics", "home", null)
    }
}

function SystemTopic(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "SystemTopic";
    C.widgets = [new TableWidget({
        classes: "systemTopicTable",
        widgets: [new TabWidget({
            name: "tSystemTabs",
            type: "Primary",
            classes: "systemTabWidget",
            changeCallback: createObjectCallback(this, this._tabSelected),
            tabs: [{
                name: "tSystemFront",
                label: strings.systemTopic.frontLabel
            }, {
                name: "tSystemRear",
                label: strings.systemTopic.rearLabel
            }, {
                name: "tSystemTabular",
                label: strings.systemTopic.tabularLabel
            }],
            widgets: [new WidgetContainer({
                classes: "clearFloats"
            }), new WidgetContainer({
                name: "tSystemContainer",
                classes: "systemContainer scrollingDiv",
                widgets: [this.rack = new RackEnclosureWidget({
                    name: "systemRack",
                    durable: "all",
                    selectable: (session.hasConfigurationCapability() ? true : false),
                    noLedControls: (session.hasConfigurationCapability() ? false : true),
                    modes: [{
                        front: true
                    }, {
                        rear: true
                    }, {
                        front: true,
                        rear: true,
                        tabular: true
                    }]
                })]
            })]
        })]
    })];
    TopicPanel.call(this, C);
    this.class_name = "SystemTopic";
    this.rackContainer$ = $(".systemContainer", this.elements)
}
SystemTopic.prototype = new TopicPanel();
SystemTopic.prototype.constructor = SystemTopic;
SystemTopic.prototype.showing = function() {
    if (!this.topicOptions) {
        return
    }
    var C = {};
    if (!this.prevIndex) {
        this.prevIndex = 0
    }
    if (this.topicOptions.display) {
        switch (this.topicOptions.display) {
            case "front":
                C.tSystemTabs = {
                    value: 0
                };
                break;
            case "rear":
                C.tSystemTabs = {
                    value: 1
                };
                break;
            case "table":
                C.tSystemTabs = {
                    value: 2
                };
                break;
            default:
                break
        }
    }
    if (propertyCount(C) > 0) {
        this.update(C)
    }
    if (this.topicOptions.tableSort) {
        this.rack.sortTable(this.topicOptions.tableSort)
    }
};
SystemTopic.prototype.resizing = function() {
    if (!this.panel$) {
        return
    }
    this.computeDimensions(this.panel$, this.tray$, this.rackContainer$)
};
SystemTopic.prototype._tabSelected = function(C) {
    applicationAccessed();
    if (C != null && C != this.prevIndex) {
        this.prevIndex = C;
        this.rack.modeSelect(C)
    }
};

function SelectionGroup(E) {
    var D = 10;
    if (arguments.length == 0) {
        return
    }
    this.name = E.name;
    this.overWidgets = new Array(D);
    for (var C = 0; C < D; C++) {
        this.overWidgets[C] = null
    }
    this.overTop = 0;
    this.widgets = {};
    this.itemCount = 0;
    this.class_name = "SelectionGroup"
}
SelectionGroup.prototype.getName = function() {
    return this.name
};
SelectionGroup.prototype.add = function(C) {
    if (!this.widgets[C.name]) {
        this.widgets[C.name] = C;
        this.itemCount++
    } else {
        this.widgets[C.name] = C
    }
};
SelectionGroup.prototype.remove = function(C) {
    if (this.widgets[C.name]) {
        if (C.overFlag) {
            this.out(C)
        }
        if (C.isSelected()) {
            C.setUnselectedState()
        }
        delete this.widgets[C.name];
        this.itemCount--
    }
};
SelectionGroup.prototype.unselectAllExcept = function(E) {
    for (var C in this.widgets) {
        var D = this.widgets[C];
        if ((D != E) && D.isSelected()) {
            D.unselect()
        }
    }
};
SelectionGroup.prototype.over = function(F) {
    var C = F.overPriority;
    var E = this.overWidgets[C];
    if (E) {
        E.overOff()
    }
    this.overWidgets[C] = F;
    if (C >= this.overTop) {
        this.overTop = C;
        for (var D = this.overTop - 1; D >= 0; D--) {
            if (this.overWidgets[D]) {
                this.overWidgets[D].overOff()
            }
        }
        F.overOn()
    }
};
SelectionGroup.prototype.out = function(F) {
    var C = F.overPriority;
    var E = this.overWidgets[C];
    if (E && E != F) {
        E.overOff()
    }
    F.overOff();
    this.overWidgets[C] = null;
    if (C >= this.overTop) {
        for (var D = C - 1; D >= 0; D--) {
            this.overTop = D;
            if (this.overWidgets[D]) {
                this.overWidgets[D].overOn();
                break
            }
        }
    }
};

function Selector() {}
Selector.prototype.isSelected = function() {
    return this.selected
};
Selector.prototype.selectChange = function(C) {};
Selector.prototype.setSelectedState = function() {
    this.selected = true;
    if (this.inputElements$ && this.inputElements$.length > 0) {
        this.inputElements$.prop("checked", true)
    }
    if (this.exclusive) {
        this.group.unselectAllExcept(this)
    }
    this.element$.removeClass(this.selectableClass);
    this.element$.addClass(this.selectedClass);
    this.selectChange(this.selected)
};
Selector.prototype.setUnselectedState = function() {
    this.selected = false;
    if (this.inputElements$ && this.inputElements$.length > 0) {
        this.inputElements$.prop("checked", false)
    }
    this.element$.removeClass(this.selectedClass);
    this.selectChange(this.selected)
};
Selector.prototype.select = function() {
    var D = true;
    if (!this.noLedControls) {
        D = (this.class_name == "ControllerWidget" || this.class_name == "DiskDriveWidget" || this.class_name == "EnclosureFrontWidget" || this.class_name == "IOMWidget")
    }
    if (D) {
        var C = this.selected;
        this.setSelectedState();
        if (C != this.selected) {
            this.fireChange(null)
        }
    }
};
Selector.prototype.unselect = function() {
    var C = this.selected;
    this.setUnselectedState();
    if (C != this.selected) {
        this.fireChange(null)
    }
};
Selector.prototype.selecting = function(C) {
    C.stopPropagation();
    if (this.selected) {
        if (this.exclusive) {} else {
            this.unselect()
        }
    } else {
        this.select()
    }
};
Selector.prototype.fireChange = function(D) {
    if ($.isFunction(this.changeCallback)) {
        var C = {};
        if (this.name) {
            this.handleRetrieve(C);
            if (C.drives) {
                C.drives = new APIData(C.drives)
            }
            if (C.enclosures) {
                C.enclosures = new APIData(C.enclosures)
            }
            if (C.components) {
                C.components = new APIData(C.components)
            }
        }
        this.changeCallback.call(this, C, this, D)
    }
};
Selector.prototype.over = function() {
    this.group.over(this)
};
Selector.prototype.out = function() {
    this.group.out(this)
};
Selector.prototype.overOn = function() {
    var C = true;
    if (!this.noLedControls) {
        C = (this.class_name == "ControllerWidget" || this.class_name == "DiskDriveWidget" || this.class_name == "EnclosureFrontWidget")
    }
    if (!this.overFlag && C && !this.element$.hasClass(this.selectedClass)) {
        this.element$.addClass(this.selectableClass);
        this.overFlag = true
    }
};
Selector.prototype.overOff = function() {
    if (this.overFlag) {
        this.element$.removeClass(this.selectableClass);
        this.overFlag = false
    }
};

function Filterer() {}
Filterer.prototype.applyFilters = function(I, E, P, N, Q) {
    if (!(E instanceof Array)) {
        return
    }
    for (var H = 0; H < E.length; H++) {
        var C = E[H];
        if (!(C instanceof Object)) {
            continue
        }
        if (!(C.options instanceof Object)) {
            continue
        }
        var D = null;
        if (C.filterAll) {
            for (var M in I) {
                var L = I[M];
                if (L) {
                    $.extend(L, C.options)
                }
            }
        } else {
            if (C.filterIndex != undefined) {
                var J = C.filterIndex;
                for (var M in I) {
                    if (J == 0) {
                        var L = I[M];
                        if (L) {
                            $.extend(L, C.options)
                        }
                        break
                    }
                    J--
                }
            } else {
                if (C.filterList) {
                    if (!(C.filterList instanceof Array)) {
                        continue
                    }
                    var K = C.filterList;
                    for (var G = 0; G < K.length; G++) {
                        var L = I[K[G]];
                        if (L) {
                            $.extend(L, C.options)
                        }
                    }
                } else {
                    if (C.filterSelect) {
                        if (!(C.filterSelect instanceof Object)) {
                            continue
                        }
                        var D = P.select(C.filterSelect).objects
                    } else {
                        if (C.filterJson) {
                            if ((!C.filterJson.objects) || (!(C.filterJson.objects instanceof Array))) {
                                continue
                            }
                            var D = C.filterJson.objects
                        }
                    }
                }
            }
        }
        if (D) {
            if (Q) {
                var O = D;
                for (var G = 0; G < O.length; G++) {
                    var F = O[G];
                    for (var M in I) {
                        var L = I[M];
                        if (L.json) {
                            if (L.json.get(N) == F.get(N)) {
                                $.extend(L, C.options)
                            }
                        }
                    }
                }
            } else {
                var O = D;
                for (var G = 0; G < O.length; G++) {
                    var M = O[G].get(N);
                    if (M) {
                        var L = I[M];
                        if (L) {
                            $.extend(L, C.options)
                        }
                    }
                }
            }
        }
    }
};

function EnclosureElement(E) {
    if (arguments.length == 0) {
        return
    }
    this.typeName = E.typeName || "element";
    this.overPriority = E.overPriority || 0;
    this.isEnclosureElement = true;
    this.group = E.group;
    this.style = E.style;
    this.rotation = E.rotation;
    this.json = E.json;
    this.top = E.top;
    this.lft = E.lft;
    this.parent = E.parent;
    var C = this;
    while (C && C.json && C.json.basetype != "enclosures") {
        C = C.parent
    }
    if (C) {
        this.enclosure = C.json.get("enclosure_id")
    } else {
        this.enclosure = "?"
    }
    this.elementText = "";
    this.captionText = "";
    this.size = "-";
    this.text = false;
    this.selected = false;
    this.selectable = false;
    this.noLedControls = true;
    this.exclusive = false;
    this.disabled = false;
    this.inactive = false;
    this.highlights = "";
    this.saveHighlights = "";
    this.clickBound = false;
    this.showStatus = true;
    if (E.sizeDisplay != undefined) {
        this.sizeDisplay = E.sizeDisplay
    }
    if (E.typeDisplay != undefined) {
        this.typeDisplay = E.typeDisplay
    }
    if (E.textVertical != undefined) {
        this.textVertical = E.textVertical
    }
    this.selectedClass = this.typeName + "Selected";
    this.selectableClass = this.typeName + "Selectable";
    this.captionClass = this.typeName + "Caption";
    this.sizeClass = this.typeName + "Size";
    this.typeClass = this.typeName + "Type";
    this.inputClass = this.typeName + "Check";
    this.widgetClass = this.typeName + "Widget";
    E.htmlText = '<div class="widgetContainer"><div class="enclosureStyles"></div></div>';
    WidgetContainer.call(this, E);
    this.element$ = $(this.elements);
    this.styles$ = $(".enclosureStyles", this.elements);
    this.class_name = E.class_name || "EnclosureElement";
    var D = {};
    D[this.name] = E;
    this.update(D)
}
EnclosureElement.prototype = new WidgetContainer();
EnclosureElement.renderCell = function(D) {
    if (D == undefined) {
        MC.errorOutput("EnclosureElement.renderCellFront: info object is undefined");
        return "&nbsp;"
    }
    var C = D.aData;
    switch (D.iDataColumn) {
        case 0:
            return C.json.basetype || "";
        case 1:
            return C.json.getKeyValue() || "";
        case 2:
            return C.interceptHealthHandler();
        case 3:
            return C.displayType;
        case 4:
            return C.enclosure;
        case 5:
            return (C.location ? C.location : (C.parent ? C.parent.location : "-"));
        case 6:
            return C.displayInfo;
        case 7:
            return C.status;
        default:
            return "&nbsp;"
    }
    return "&nbsp;"
};
EnclosureElement.prototype.handleUpdate = function(C) {
    if (C.tabular != undefined) {
        this.tabular = C.tabular
    }
    if (C.changeCallback != undefined) {
        this.changeCallback = C.changeCallback
    }
    if (C.json != undefined) {
        this.json = C.json
    }
    if (C.top != undefined) {
        this.top = C.top
    }
    if (C.lft != undefined) {
        this.lft = C.lft
    }
    if (C.text != undefined) {
        this.text = C.text
    }
    if (C.disabled != undefined) {
        this.disabled = C.disabled
    }
    if (C.highlights != undefined) {
        this.saveHighlights = this.highlights;
        this.highlights = C.highlights;
        this.newHighlights = true
    }
    if (C.showStatus != undefined) {
        this.showStatus = C.showStatus
    }
    if (C.selectable != undefined) {
        this.selectable = C.selectable
    }
    if (C.noLedControls != undefined) {
        this.noLedControls = C.noLedControls
    }
    if (C.exclusive != undefined) {
        this.exclusive = C.exclusive;
        if (this.exclusive) {
            this.group.add(this)
        } else {
            this.group.remove(this)
        }
    }
    if (C.inactive != undefined) {
        this.inactive = C.inactive
    }
    this.elementText = "";
    this.setProperties(C);
    this.setStatus(C);
    this.setFanoutStatus(C);
    this.setupComponents(C);
    if (C.selected != undefined) {
        if (this.selected != C.selected) {
            if (C.selected) {
                this.setSelectedState()
            } else {
                this.setUnselectedState()
            }
        }
    }
    if (this.text) {
        this.elementText = this.text
    }
    if (!C.noRender && !this.tabular) {
        this.render()
    }
};
EnclosureElement.prototype.handleRetrieve = function(D) {
    if (this.isSelected()) {
        if (!D.components) {
            D.components = new Array()
        }
        var C = D.components;
        C[C.length] = this.json
    }
};
EnclosureElement.prototype.render = function() {
    this.captionText = "";
    if (this.inactive) {
        var D = this.style + "Inactive"
    } else {
        var D = this.style + "Active"
    }
    if (this.rotation != null) {
        D = D + " " + this.rotation
    }
    if (this.fullStyle != D) {
        this.element$.removeClass(this.fullStyle).addClass(D)
    }
    this.fullStyle = D;
    this.element$.addClass(this.widgetClass);
    this.element$.css("top", this.top);
    this.element$.css("left", this.lft);
    if (this.json.class_name == "APIEnclosures" && (this.json.getInt("type_numeric") == ENCLOSURE_TYPE.XYRATEX12 || this.json.getInt("type_numeric") == ENCLOSURE_TYPE.XYRATEX24 || this.json.getInt("type_numeric") == ENCLOSURE_TYPE.TITAN)) {
        this.captionText = "0"
    }
    if (this.textVertical) {
        this.captionText += this.elementText.split("").join("<br />")
    } else {
        this.captionText += this.elementText
    }
    var C = this.addDecorations();
    if (this.locatorLedTarget) {
        var E = parseInt(this.json.get("locator_led_numeric"), 10);
        if (E) {
            if (this.class_name == "IOMWidget") {
                C += '<div class="LED iomWidgetledOn"></div>\n'
            } else {
                C += '<div class="LED ledOn"></div>\n'
            }
        } else {
            C += '<div class="LED ledOff"></div>\n'
        }
    }
    if (this.captionText) {
        C += '<div class="' + this.captionClass + '">' + this.captionText + "</div>\n"
    }
    if (this.statusClasses) {
        C += '<div class="' + this.statusClasses + '"></div>\n'
    }
    if (this.fanoutClass) {
        C += '<div class="' + this.fanoutClass + '"></div>\n'
    }
    if (this.sizeDisplay) {
        C += '<div class="' + this.sizeClass + '">' + this.elementSize + "</div>\n"
    }
    if (this.typeDisplay) {
        C += '<div class="' + this.typeClass + '">' + this.elementType + "</div>\n"
    }
    if (this.selectable && !this.exclusive) {
        C += '<input class="' + this.inputClass + '" name="' + this.group.getName() + '" type="' + (this.exclusive ? "radio" : "checkbox") + '" value="' + this.name + '" ' + (this.selected ? "checked " : "") + (this.disabled ? "disabled " : "") + (!this.noLedControls ? 'style="opacity: 0;" ' : "") + "</input>\n"
    }
    this.styles$.html(C);
    if (this.newHighlights) {
        $("." + this.captionClass, this.element$).removeClass(this.saveHighlights).addClass(this.highlights);
        this.newHighlights = false
    }
    this.inputElements$ = $("input", this.styles$);
    if (this.selectable && !this.disabled) {
        if (!this.clickBound) {
            if (!this.clickCallback) {
                this.clickCallback = createObjectCallback(this, this.selecting)
            }
            if (!this.mouseoverCallback) {
                this.mouseoverCallback = createObjectCallback(this, this.over)
            }
            if (!this.mouseoutCallback) {
                this.mouseoutCallback = createObjectCallback(this, this.out)
            }
            this.element$.bind("click", this.clickCallback).bind("mouseover", this.mouseoverCallback).bind("mouseout", this.mouseoutCallback);
            this.clickBound = true
        }
    } else {
        if (this.clickBound) {
            this.element$.unbind("click", this.clickCallback).unbind("mouseover", this.mouseoverCallback).unbind("mouseout", this.mouseoutCallback);
            this.clickBound = false
        }
    }
    if (this.selectable && this.selected) {
        this.element$.addClass(this.selectedClass)
    } else {
        this.element$.removeClass(this.selectedClass)
    }
    this.out()
};
EnclosureElement.prototype.setupComponents = function(C) {};
EnclosureElement.prototype.addDecorations = function(C) {
    return ""
};
EnclosureElement.prototype.selectChange = Selector.prototype.selectChange;
EnclosureElement.prototype.over = Selector.prototype.over;
EnclosureElement.prototype.out = Selector.prototype.out;
EnclosureElement.prototype.overOn = Selector.prototype.overOn;
EnclosureElement.prototype.overOff = Selector.prototype.overOff;
EnclosureElement.prototype.isSelected = Selector.prototype.isSelected;
EnclosureElement.prototype.setSelectedState = Selector.prototype.setSelectedState;
EnclosureElement.prototype.setUnselectedState = Selector.prototype.setUnselectedState;
EnclosureElement.prototype.select = Selector.prototype.select;
EnclosureElement.prototype.unselect = Selector.prototype.unselect;
EnclosureElement.prototype.selecting = Selector.prototype.selecting;
EnclosureElement.prototype.fireChange = Selector.prototype.fireChange;
EnclosureElement.prototype.applyFilters = Filterer.prototype.applyFilters;
EnclosureElement.prototype.destructor = function() {
    this.group.remove(this)
};
EnclosureElement.prototype.setHealthStatus = function(C) {
    this.healthStatus = this.json.get("health_numeric");
    this.healthText = this.json.get("health");
    this.status = this.json.get("status");
    if (this.status == undefined) {
        this.status = strings.na
    }
    this.statusClasses = (C ? "elementHealthSmall " : "elementHealth ");
    switch (this.healthStatus) {
        case "1":
            this.statusClasses += (C ? "smallHealthDegraded" : "healthDegraded");
            break;
        case "2":
            this.statusClasses += (C ? "smallHealthBad" : "healthBad");
            break;
        default:
            break
    }
};
EnclosureElement.prototype.setStatus = function(C) {
    if (this.showStatus) {
        this.elementType = C.caption;
        this.setHealthStatus(C.smallStatus)
    }
};
EnclosureElement.prototype.setFanoutStatus = function(C) {
    if (C.fanoutStatus) {
        this.fanoutClass = "portSASFanoutIconActive "
    }
};
EnclosureElement.prototype.setProperties = function(C) {
    this.displayType = strings.generic;
    this.displayInfo = strings.enclosureElement;
    this.ID = "-";
    this.location = "-"
};
EnclosureElement.prototype.getApiObject = function() {
    return this.json
};
EnclosureElement.prototype.addComponent = function(D) {
    D[D.length] = this;
    for (var C = 0; C < this.widgets.length; C++) {
        this.widgets[C].addComponent(D)
    }
};
EnclosureElement.prototype.interceptHealthHandler = function() {
    var D = this.healthStatus;
    var E = this.healthText;
    switch (parseInt(D)) {
        case 0:
            var C = "sortOrder1 healthOk";
            break;
        case 1:
            var C = "sortOrder3 healthDegraded";
            break;
        case 2:
            var C = "sortOrder4 healthBad";
            break;
        case 3:
        default:
            var C = "sortOrder2 healthUnknown";
            break
    }
    return '<div class="healthStyle ' + C + '"><span class="healthText">' + E + "</span></div>"
};
EnclosureElement.prototype.interceptStateHandler = function(D, C) {
    return D.highlights
};
EnclosureElement.prototype.updateComponent = function(D) {
    var C = this.findWidgetByName(D.name);
    if (C) {
        var E = {};
        E[D.name] = D;
        C.update(E);
        C.deleted = false;
        return true
    }
    return false
};

function AggregateEnclosureElement(C) {
    if (arguments.length == 0) {
        return
    }
    if (C.styleObject != undefined) {
        this.styleObject = C.styleObject
    }
    EnclosureElement.call(this, C)
}
AggregateEnclosureElement.prototype = new EnclosureElement();
AggregateEnclosureElement.prototype.doFiltering = function(C) {
    if (this.componentFilters) {
        this.applyFilters(C, this.componentFilters, this.componentJson, "durable_id", true)
    }
    if (this.selectedComponents) {
        this.applyFilters(C, [{
            filterJson: this.selectedComponents,
            options: {
                selectable: true,
                selected: true
            }
        }], this.selectableComponents, "durable_id", true)
    }
};
AggregateEnclosureElement.prototype.loadComponents = function(I, H) {
    var C = this.componentJson;
    for (var F = 0; F < C.objects.length; F++) {
        var D = C.objects[F];
        var E = {
            json: D
        };
        $.extend(E, H);
        var J = D.basetype;
        var G = null;
        switch (J) {
            case "drawers":
                G = DiskDrawerWidget;
                break;
            case "drives":
                G = DiskDriveWidget;
                break;
            case "power-supplies":
                G = PowerSupplyWidget;
                break;
            case "controllers":
                G = ControllerWidget;
                break;
            case "io-modules":
                G = IOMWidget;
                break;
            case "port":
                G = PortWidget;
                break;
            case "network-parameters":
                G = NetworkPortWidget;
                break;
            case "expander-ports":
                G = ExpPortWidget;
                break;
            case "fan-modules":
                G = FanWidget;
                break;
            case "fan":
                G = FanWidget;
                break;
            case "compact-flash":
                G = CompactFlashWidget;
                break;
            case "sideplanes":
                G = SidePlane;
                break;
            case "expanders":
                G = Expander;
                break;
            default:
                break
        }
        if (G) {
            E.constructor = G;
            G.prototype.setOptions(E);
            if (E.rotationProperty) {
                E.rotation = this.styleObject[E.rotationProperty]
            }
            if (E.styleProperty) {
                E.style = this.styleObject[E.styleProperty]
            }
            I[E.name] = E
        }
    }
};
AggregateEnclosureElement.prototype.setupComponents = function(G) {
    if (G.componentFilters != undefined) {
        this.componentFilters = G.componentFilters
    }
    if (G.selectedComponents != undefined) {
        this.selectedComponents = G.selectedComponents
    }
    var F = this;
    for (var E = 0; E < this.widgets.length; E++) {
        this.widgets[E].deleted = true
    }
    var D = {
        parent: this,
        tabular: this.tabular,
        noRender: G.noRender,
        group: this.group,
        selectable: this.selectable,
        noLedControls: this.noLedControls,
        exclusive: this.exclusive,
        componentFilters: this.componentFilters,
        selectedComponents: this.selectedComponents,
        styleObject: this.styleObject,
        changeCallback: this.changeCallback
    };
    this._components = {};
    this.loadComponents(this._components, D);
    this.doFiltering(this._components);
    for (var C in this._components) {
        var D = this._components[C];
        if (!this.updateComponent(D)) {
            this.add(new D.constructor(D))
        }
    }
    this.removeDeletedByProperty()
};

function DiskDrawerWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.class_name = "DiskDrawerWidget";
    C.typeName = "diskDrawer";
    this.locatorLedTarget = "drawer";
    C.hoverPanel = APIObject.getHover("drawers");
    C.overPriority = 1;
    EnclosureElement.call(this, C)
}
DiskDrawerWidget.prototype = new EnclosureElement();
DiskDrawerWidget.prototype.constructor = DiskDrawerWidget;
DiskDrawerWidget.prototype.setProperties = function(C) {
    this.durable_id = this.json.get("durable_id");
    this.displayType = strings.rack.type.drawer;
    this.displayInfo = strings.rack.drawerInfo(this.json.get("drawer_id"));
    this.ID = this.durable_id.substr(this.durable_id.lastIndexOf("_") + 1);
    this.location = this.json.get("drawer_id");
    this.serial = this.json.get("drawer_wwn");
    this.state = ""
};
DiskDrawerWidget.prototype.setOptions = function(E) {
    E.name = E.json.get("durable_id");
    var D = E.json.get("drawer_id");
    E.text = strings.rack.DRAWER + " " + D;
    if (E.styleObject.name == "SEAGATE5U84") {
        if (E.json.getInt("position_numeric") == 2) {
            E.text += " (" + strings.rack.drawerTop + ")"
        }
        if (E.json.getInt("position_numeric") == 3) {
            E.text += " (" + strings.rack.drawerBottom + ")"
        }
    }
    var C = D - system.physicalPositionOffset;
    E.top = 0;
    E.lft = (C < E.styleObject.drawer_settings.x.length) ? E.styleObject.drawer_settings.x[C] : 0;
    E.textVertical = E.styleObject.drawer_settings.vertical_label;
    switch (C) {
        case 0:
        case 1:
            E.styleProperty = "drawer_style_left";
            break;
        case 2:
            E.styleProperty = "drawer_style_right";
            break;
        default:
            MC.debugOutput("Invalid drawer position: %d", C);
            break
    }
};

function DiskDriveWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "disk";
    this.locatorLedTarget = "disk";
    C.hoverPanel = APIObject.getHover("drives");
    this.blink = false;
    C.overPriority = 1;
    EnclosureElement.call(this, C);
    this.class_name = "DiskDriveWidget"
}
DiskDriveWidget.prototype = new EnclosureElement();
DiskDriveWidget.prototype.setStatus = function(F) {
    var E = false;
    if (this.style.indexOf("disk2U48") == 0 || this.style.indexOf("disk4U56") == 0 || this.style.indexOf("disk5U84SEAGATE") == 0) {
        E = true
    }
    if (this.showStatus) {
        this.setHealthStatus(E);
        this.usageNum = this.json.getInt("usage_numeric");
        var D = new Size(this.json);
        this.elementSize = D.format("auto", 0);
        this.elementType = this.json.get("type");
        if (this.text) {
            this.elementText = this.text
        } else {
            this.elementText = "  " + DISK_TYPE_LABELS[parseInt(this.json.get("type_numeric"), 10)];
            switch (this.usageNum) {
                case DRIVE_USAGE.VIRTUAL_POOL:
                    var C = this.json.getInt("storage_tier_numeric");
                    switch (C) {
                        case TIERS.PERFORMANCE:
                            this.highlights = "diskPerfTier";
                            break;
                        case TIERS.STANDARD:
                            this.highlights = "diskStandardTier";
                            break;
                        case TIERS.ARCHIVE:
                            this.highlights = "diskArchiveTier";
                            break;
                        case TIERS.READCACHE:
                            this.highlights = "diskReadCache";
                            break;
                        default:
                            break
                    }
                    this.newHighlights = true;
                    break;
                case DRIVE_USAGE.LINEAR_POOL:
                    this.highlights = "diskLinear";
                    this.newHighlights = true;
                    break;
                case DRIVE_USAGE.DEDICATED_SPARE:
                case DRIVE_USAGE.GLOBAL_SPARE:
                    this.highlights = "diskSpare";
                    this.newHighlights = true;
                    break;
                default:
                    break
            }
        }
    }
};
DiskDriveWidget.prototype.setProperties = function(F) {
    var E = this.json;
    var C = new Size(E);
    var D = DISK_TYPE_LABELS[E.getInt("description_numeric")] + " " + C.format("auto", 0);
    this.usageNum = E.getInt("usage_numeric");
    if (this.usageNum == DRIVE_USAGE.VIRTUAL_POOL) {
        D += " (" + E.get("storage_pool_name") + ":" + E.get("storage_tier") + ")"
    } else {
        if (this.usageNum == DRIVE_USAGE.LINEAR_POOL) {
            D += " (" + E.get("storage_pool_name") + ":Linear)"
        } else {
            D += " (" + E.get("usage") + ")"
        }
    }
    this.displayType = strings.rack.type.disk;
    this.ID = E.get("location");
    this.displayInfo = D;
    this.location = this.ID;
    this.serial = E.get("serial_number");
    this.durable_id = E.get("durable_id");
    this.blink = E.get("blink");
    this.size = E.get("size");
    this.architectureNum = E.getInt("architecture_numeric");
    this.interfaceNum = E.getInt("interface_numeric")
};
DiskDriveWidget.prototype.handleRetrieve = function(D) {
    if (this.isSelected()) {
        if (!D.drives) {
            D.drives = new Array()
        }
        var C = D.drives;
        C[C.length] = this.json
    }
    EnclosureElement.prototype.handleRetrieve.call(this, D)
};
DiskDriveWidget.prototype.setOptions = function(C) {
    var E = C.json.get("durable_id");
    var D = C.json.get("slot");
    D -= system.physicalPositionOffset;
    C.name = E;
    C.styleProperty = "drv_style";
    C.lft = (D < C.styleObject.arrangement.disk_max) ? C.styleObject.arrangement.x[D] : 0;
    C.top = (D < C.styleObject.arrangement.disk_max) ? C.styleObject.arrangement.y[D] : 0;
    C.sizeDisplay = C.styleObject.arrangement.disk_size_display;
    C.typeDisplay = C.styleObject.arrangement.disk_type_display;
    C.textVertical = C.styleObject.arrangement.disk_text_vertical
};
DiskDriveWidget.prototype.addDecorations = function() {
    var D = "";
    if (this.usageNum == DRIVE_USAGE.VIRTUAL_POOL || this.usageNum == DRIVE_USAGE.LINEAR_POOL) {
        var C = this.json.get("storage_pool_name");
        D += '<div class="diskPool diskPool' + C + '"></div>\n'
    } else {
        if (this.usageNum == DRIVE_USAGE.GLOBAL_SPARE) {
            D += '<div class="diskPool diskPoolSpare"></div>\n'
        }
    }
    return D
};

function PowerSupplyWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "ps";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("power-supplies");
    EnclosureElement.call(this, C);
    this.class_name = "PowerSupplyWidget"
}
PowerSupplyWidget.prototype = new EnclosureElement();
PowerSupplyWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.powerSupply;
    this.ID = this.json.get("position");
    this.displayInfo = this.json.get("description");
    this.location = this.json.get("position");
    this.serial = this.json.get("serial_number")
};
PowerSupplyWidget.prototype.setHealthStatus = function(F) {
    var G = this.json;
    var C = this.json.dcParents[0].parent.objects;
    for (var D = 0; D < C.length; D++) {
        if (C[D] instanceof APIPowerSupplies && C[D].get("location") == this.json.get("location") && C[D].get("name") != this.json.get("name")) {
            var H = C[D];
            if (H.get("name").indexOf("Voltage Regulator") > -1) {
                var E = H
            } else {
                var E = this.json;
                G = H
            }
            break
        }
    }
    this.healthStatus = G.get("health_numeric");
    this.healthText = G.get("health");
    this.status = G.get("status");
    this.statusClasses = (F ? "elementHealthSmall " : "elementHealth ");
    if (E) {
        if (E.get("health_numeric") > this.healthStatus) {
            this.healthStatus = E.get("health_numeric");
            this.healthText = E.get("health");
            this.status = E.get("status")
        }
    }
    if (this.status == undefined) {
        this.status = strings.na
    }
    switch (this.healthStatus) {
        case "1":
            this.statusClasses += (F ? "smallHealthDegraded" : "healthDegraded");
            break;
        case "2":
            this.statusClasses += (F ? "smallHealthBad" : "healthBad");
            break;
        default:
            break
    }
};
PowerSupplyWidget.prototype.setOptions = function(C) {
    var D = parseInt(C.json.get("position_numeric"), 10);
    if (C.json.get("status_numeric") == "3") {
        D = -1
    }
    C.name = C.json.get("durable_id");
    switch (D) {
        case 0:
            C.styleProperty = "ps_style_Left";
            break;
        case 1:
            C.styleProperty = "ps_style_Right";
            break;
        case 2:
            C.styleProperty = "ps_style_Top";
            break;
        case 3:
            C.styleProperty = "ps_style_Bottom";
            break;
        default:
            C.style = "hidden";
            break
    }
};

function FanWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "fan";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("fan");
    EnclosureElement.call(this, C);
    this.class_name = "FanWidget"
}
FanWidget.prototype = new EnclosureElement();
FanWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.fan;
    this.ID = this.json.get("position");
    this.displayInfo = this.json.get("speed") + " r/min";
    this.location = (this.json.basetype == "fan-modules") ? this.json.get("location") : this.json.get("position");
    this.serial = this.json.get("serial_number")
};
FanWidget.prototype.setOptions = function(C) {
    var E = C.json.get("durable_id");
    if (C.json.basetype == "fan-modules") {
        var D = C.json.getInt("dom_id")
    } else {
        var D = parseInt(C.json.get("position_numeric"), 10)
    }
    C.name = E;
    switch (D) {
        case 0:
            C.styleProperty = "fan_style_Left";
            break;
        case 1:
            C.styleProperty = (C.json.basetype == "fan-modules") ? "fan_style_LeftMiddle" : "fan_style_Right";
            break;
        case 2:
            C.styleProperty = "fan_style_Middle";
            break;
        case 3:
            C.styleProperty = "fan_style_RightMiddle";
            break;
        case 4:
            C.styleProperty = "fan_style_Right";
            break;
        default:
            C.style = "hidden";
            break
    }
};

function SidePlane(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "side-plane";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("drawers");
    EnclosureElement.call(this, C);
    this.class_name = "SidePlane"
}
SidePlane.prototype = new EnclosureElement();
SidePlane.prototype.setProperties = function(C) {
    this.durable_id = this.json.get("durable_id");
    this.displayType = strings.rack.type.sidePlane;
    this.ID = this.durable_id.substr(this.durable_id.lastIndexOf("_") + 1);
    this.displayInfo = this.json.get("name");
    this.status = this.json.get("status");
    this.location = this.json.get("location")
};
SidePlane.prototype.setOptions = function(C) {
    var E = C.json.get("durable_id");
    if (C.json.basetype == "fan-modules") {
        var D = C.json.getInt("dom_id")
    } else {
        var D = parseInt(C.json.get("position_numeric"), 10)
    }
    C.name = E
};

function Expander(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "expander";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("drawers");
    EnclosureElement.call(this, C);
    this.class_name = "Expander"
}
Expander.prototype = new EnclosureElement();
Expander.prototype.setProperties = function(C) {
    this.durable_id = this.json.get("durable_id");
    this.displayType = strings.rack.type.expander;
    this.ID = this.durable_id.substr(this.durable_id.lastIndexOf("_") + 1);
    this.displayInfo = this.json.get("name");
    this.status = this.json.get("status");
    this.location = this.json.get("location")
};
Expander.prototype.setOptions = function(C) {
    var E = C.json.get("durable_id");
    if (C.json.basetype == "fan-modules") {
        var D = C.json.getInt("dom_id")
    } else {
        var D = parseInt(C.json.get("position_numeric"), 10)
    }
    C.name = E
};

function CompactFlashWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "compact-flash";
    C.overPriority = 1;
    EnclosureElement.call(this, C);
    this.class_name = "CompactFlashWidget"
}
CompactFlashWidget.prototype = new EnclosureElement();
CompactFlashWidget.prototype.setHealthStatus = function(C) {
    this.healthStatus = this.json.get("health_numeric");
    this.healthText = this.json.get("health")
};
CompactFlashWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.compactFlash;
    this.ID = this.json.get("durable_id");
    this.displayInfo = "";
    this.location = strings.Controller + "-" + this.json.get("controller_id");
    this.serial = "-";
    this.status = this.json.get("status")
};
CompactFlashWidget.prototype.setOptions = function(C) {
    var D = C.json.get("durable_id");
    C.name = D
};

function ControllerWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "cont";
    this.locatorLedTarget = "controller";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("controllers");
    AggregateEnclosureElement.call(this, C);
    this.class_name = "ControllerWidget"
}
ControllerWidget.prototype = new AggregateEnclosureElement();
ControllerWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.controller;
    this.ID = this.json.get("controller_id");
    this.displayInfo = strings.Controller + "-" + this.ID;
    this.location = this.json.get("position");
    this.serial = this.json.get("serial_number")
};
ControllerWidget.prototype.setOptions = function(D) {
    var F = D.json.getPropertyValue("durable_id");
    var G = D.json.getPropertyValue("controller_id");
    var E = parseInt(D.json.getPropertyValue("position_numeric"), 10);
    if (D.json.getPropertyValue("rotation_numeric")) {
        var C = parseInt(D.json.getPropertyValue("rotation_numeric"), 10)
    }
    D.name = F;
    D.caption = G;
    D.typeDisplay = true;
    switch (E) {
        case 0:
            D.styleProperty = "cont_style_Left";
            break;
        case 1:
            D.styleProperty = "cont_style_Right";
            break;
        case 2:
            D.styleProperty = "cont_style_Top";
            break;
        case 3:
            D.styleProperty = "cont_style_Bottom";
            break;
        default:
            D.style = "hidden";
            break
    }
    if (C == 2) {
        D.rotationProperty = "cont_style_Inverted"
    } else {
        if (C == 0) {
            D.rotationProperty = "cont_style_NotInverted"
        }
    }
};
ControllerWidget.prototype.setupComponents = function(C) {
    if (C.componentFilters != undefined) {
        this.componentFilters = C.componentFilters
    }
    this.componentJson = this.json;
    if (this.json.get("status_numeric") == "2") {
        return
    }
    AggregateEnclosureElement.prototype.setupComponents.call(this, C)
};

function IOMWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "iom";
    this.locatorLedTarget = "controller";
    C.overPriority = 1;
    C.hoverPanel = APIObject.getHover("io-modules");
    AggregateEnclosureElement.call(this, C);
    this.class_name = "IOMWidget"
}
IOMWidget.prototype = new AggregateEnclosureElement();
IOMWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.iom;
    this.ID = this.json.get("controller_id");
    this.displayInfo = strings.iomLabel + "-" + this.ID;
    this.location = this.json.get("position");
    this.serial = this.json.get("serial_number")
};
IOMWidget.prototype.setOptions = function(D) {
    var F = D.json.get("durable_id");
    var G = D.json.get("controller_id");
    var E = parseInt(D.json.get("position_numeric"), 10);
    if (D.json.getPropertyValue("rotation_numeric")) {
        var C = parseInt(D.json.getPropertyValue("rotation_numeric"), 10)
    }
    D.name = F;
    D.caption = G;
    D.typeDisplay = true;
    switch (E) {
        case 0:
            D.styleProperty = "cont_style_Left";
            break;
        case 1:
            D.styleProperty = "cont_style_Right";
            break;
        case 2:
            D.styleProperty = "cont_style_Top";
            break;
        case 3:
            D.styleProperty = "cont_style_Bottom";
            break;
        default:
            D.style = "hidden";
            break
    }
    if (C == 2) {
        D.rotationProperty = "cont_style_Inverted"
    } else {
        if (C == 0) {
            D.rotationProperty = "cont_style_NotInverted"
        }
    }
};
IOMWidget.prototype.setupComponents = function(C) {
    if (C.componentFilters != undefined) {
        this.componentFilters = C.componentFilters
    }
    this.componentJson = this.json;
    if (this.json.getInt("status_numeric") == CONTROLLER_STATUS.NOT_INSTALLED) {
        return
    }
    AggregateEnclosureElement.prototype.setupComponents.call(this, C)
};

function PortWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "port";
    C.hoverPanel = APIObject.getHover("port");
    C.overPriority = 2;
    EnclosureElement.call(this, C);
    this.class_name = "PortWidget"
}
PortWidget.prototype = new EnclosureElement();
PortWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.port;
    this.ID = this.json.get("port");
    this.displayInfo = this.json.get("media");
    this.location = this.ID;
    this.serial = this.json.get("target_id")
};
PortWidget.prototype.setOptions = function(C) {
    var N = C.json.get("durable_id");
    var M = C.json.get("port");
    var F = C.json.getInt("port_type_numeric");
    var D = C.json.getInt("fan_out");
    var E = parseInt(M.charAt(1)) - system.physicalPositionOffset;
    var I = C.json.get("media");
    var J = I.split("(")[0];
    var L = C.json.parentObject.parentObject.get("vendor");
    var H = C.json.parentObject.parentObject.getInt("type_numeric");
    if (H == 9 || H == 10) {
        if (C.json.parentObject.getInt("rotation_numeric") == 2) {
            var G = "port" + E + " port" + J + "OneStor portInverted"
        } else {
            if (C.json.parentObject.getInt("rotation_numeric") == 0) {
                var G = "port" + E + " port" + J + "OneStor portNotInverted"
            }
        }
    } else {
        var G = "port" + E + " port" + J
    }
    var K = J + "<br>" + M;
    if (F == PORT_TYPES.SAS && D > 1) {
        if (E % 2 == 0) {
            C.fanoutStatus = true
        }
    }
    C.name = N;
    C.style = G;
    C.caption = K;
    C.typeDisplay = true;
    C.smallStatus = true
};

function NetworkPortWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "netPort";
    C.overPriority = 2;
    C.hoverPanel = APIObject.getHover("network-parameters");
    EnclosureElement.call(this, C);
    this.class_name = "NetworkPortWidget"
}
NetworkPortWidget.prototype = new EnclosureElement();
NetworkPortWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.netPort;
    this.ID = this.json.get("ip_address");
    this.displayInfo = this.json.get("ip_address");
    this.location = this.parent.displayInfo;
    this.serial = this.json.get("mac_address")
};
NetworkPortWidget.prototype.setOptions = function(D) {
    var E = D.json.get("durable_id");
    var F = D.json.get("ip_address");
    var C = "netPortStyle";
    D.name = E;
    D.style = C;
    D.caption = F;
    D.typeDisplay = true;
    D.smallStatus = true
};

function ExpPortWidget(C) {
    if (arguments.length == 0) {
        return
    }
    C.typeName = "expPort";
    C.overPriority = 2;
    C.hoverPanel = APIObject.getHover("expander-ports");
    EnclosureElement.call(this, C);
    this.class_name = "ExpPortWidget"
}
ExpPortWidget.prototype = new EnclosureElement();
ExpPortWidget.prototype.setProperties = function(C) {
    this.displayType = strings.rack.type.expPort;
    this.ID = "-";
    this.displayInfo = this.json.get("name");
    this.location = this.parent.displayInfo;
    this.serial = "-"
};
ExpPortWidget.prototype.setOptions = function(F) {
    var E = F.json.getInt("sas_port_type_numeric");
    var D = F.json.getInt("sas_port_index");
    var C = "";
    var G = "";
    if (E == SAS_PORT_TYPES.EXP_EGRESS) {
        C = "expPortOut" + D;
        if (F.json.parentObject.parentObject.get("type") == "Hercules") {
            G = strings.out + D
        } else {
            G = strings.outPort
        }
    } else {
        if (E == SAS_PORT_TYPES.EXP_UNIVERSAL) {
            C = "expPortGeneric" + D;
            G = "I/O " + D
        } else {
            if (E != SAS_PORT_TYPES.DRAWER_EGRESS) {
                C = "expPortIn" + D;
                if (F.json.parentObject.parentObject.get("type") == "Hercules") {
                    G = strings.expPort.inLabel + D
                } else {
                    G = strings.inPort
                }
            }
        }
    }
    F.name = F.json.get("durable_id");
    F.style = C;
    F.caption = G;
    F.typeDisplay = true;
    F.smallStatus = true
};

function RackEnclosureWidget(D) {
    if (arguments.length == 0) {
        return
    }
    D.htmlText = '<div class="rackEnclosure"></div>';
    if (!D.noLedControls) {
        D.widgets = [this.ledButtonContainer = new WidgetContainer({
            classes: "tabbedPanel",
            widgets: [new ButtonContainer({
                orientation: "horizontal",
                classes: "rackLedButtons",
                bottomSmallMargin: true,
                widgets: [this.setLedButton = new ButtonWidget({
                    name: "setLEDbutton",
                    size: "small",
                    text: strings.rack.setLedLabel,
                    tooltip: strings.rack.setLedTip,
                    click: createObjectCallback(this, this.setLeds)
                }), this.resetLedButton = new ButtonWidget({
                    name: "resetLEDbutton",
                    size: "small",
                    text: strings.rack.resetLedLabel,
                    tooltip: strings.rack.resetLedTip,
                    click: createObjectCallback(this, this.resetLeds)
                })]
            })]
        })]
    }
    WidgetContainer.call(this, D);
    this.class_name = "RackEnclosureWidget";
    this.enclosuresSubscription = null;
    this.disksSubscription = null;
    this.enclosuresData = null;
    this.disksData = null;
    this.name = D.name;
    this.tableName = D.name + "RackTable";
    this.hidden = true;
    this._enclosureFilters = null;
    this._driveFilters = null;
    this._componentFilters = null;
    this._drives = null;
    this.components = null;
    this.enclosures = null;
    this.selectionGroup = new SelectionGroup({
        name: this.name
    });
    this.selectable = false;
    this.exclusive = false;
    this.front = true;
    this.rear = false;
    this.tabular = false;
    this.notifySelected = false;
    this.modes = false;
    this.durable = false;
    this.visibility = true;
    if (D.modes != undefined) {
        this.modes = D.modes
    }
    this.widgetContainer = this;
    this.table = new TableInator({
        row: 1,
        col: 2,
        name: this.tableName,
        width: 800 - Panel.getScrollbarWidth(),
        cellClasses: "verticalTop",
        type: "rawData",
        selectable: D.selectable,
        selectCallback: createObjectCallback(this, this._tableSelectCallback),
        displayLength: 20,
        hoverPanel: true,
        metadata: RackEnclosureWidget.getTableMeta(),
        dtOptions: {
            aaSorting: [
                [2, "desc"],
                [4, "asc"],
                [3, "asc"],
                [5, "asc"]
            ]
        }
    });
    var C = {};
    C[this.name] = D;
    this.update(C)
}
RackEnclosureWidget.prototype = new WidgetContainer();
RackEnclosureWidget.prototype.applyFilters = Filterer.prototype.applyFilters;
RackEnclosureWidget.prototype.handleUpdate = function(C) {
    if (C.durable != undefined) {
        this.durable = C.durable
    }
    this.setFilters(C);
    if (C.selectable != undefined) {
        this.selectable = C.selectable
    }
    if (C.noLedControls != undefined) {
        this.noLedControls = C.noLedControls
    }
    if (C.exclusive != undefined) {
        this.exclusive = C.exclusive
    }
    if (C.changeCallback != undefined) {
        this.changeCallback = C.changeCallback
    }
    if (C.notifySelected != undefined) {
        this.notifySelected = C.notifySelected
    }
    if (C.visibility != undefined) {
        this.visibility = (C.visibility != "collapse")
    }
    if (C.view != undefined) {
        this.setView(C.view)
    }
    if (C.format != undefined) {
        this.setFormat(C.format)
    }
    if (!this.hidden) {
        this.updateComponents(C)
    }
    if (!this.options.noLedControls) {}
};
RackEnclosureWidget.prototype._clearLedCommandList = function() {
    var G = false;
    var F = true;
    for (var D in DC.enclosures) {
        if (F) {
            var C = D.slice(-1);
            F = false
        }
        if (DC.enclosures[D].drawers) {
            G = true
        }
    }
    var E = [{
        name: "clearLedsEnc",
        command: MC.setLed,
        data: {
            target: "enclosure",
            id: "all",
            state: "off"
        },
        options: {
            processingMsg: strings.rack.clearLedsProcessing("enclosure"),
            failureMsg: strings.rack.clearLedsFailed("enclosure")
        }
    }, {
        name: "clearLedsContA",
        command: MC.setLed,
        data: {
            target: "controller",
            id: C + ".A",
            state: "off"
        },
        options: {
            processingMsg: strings.rack.clearLedsProcessing("controller A"),
            failureMsg: strings.rack.clearLedsFailed("controller A")
        }
    }, {
        name: "clearLedsContB",
        command: MC.setLed,
        data: {
            target: "controller",
            id: C + ".B",
            state: "off"
        },
        options: {
            processingMsg: strings.rack.clearLedsProcessing("controller B"),
            failureMsg: strings.rack.clearLedsFailed("controller B")
        }
    }, {
        name: "clearLedsDisk",
        command: MC.setLed,
        data: {
            target: "disk",
            id: "all",
            state: "off"
        },
        options: {
            processingMsg: strings.rack.clearLedsProcessing("disk"),
            failureMsg: strings.rack.clearLedsFailed("disk")
        }
    }];
    return E
};
RackEnclosureWidget.prototype.setLeds = function() {
    var H = this._getSelected();
    if (H.length) {
        var F = [];
        var G, I;
        var E = 0;
        for (var D = 0, C = H.length; D < C; D++) {
            if (H[D].locatorLedTarget) {
                G = H[D].locatorLedTarget;
                if (G == "controller") {
                    I = H[D].enclosure + "." + H[D].ID
                } else {
                    I = H[D].ID
                }
                F.push({
                    name: "setLed",
                    command: MC.setLed,
                    data: {
                        target: G,
                        id: I,
                        state: "on"
                    },
                    options: {
                        processingMsg: strings.rack.setLedProcessing(G, I),
                        failureMsg: strings.rack.setLedFailed(G, I)
                    }
                });
                E++
            }
        }
        MC.execCommandList(F, {
            successMsg: strings.rack.setLedSuccess(E)
        })
    }
};
RackEnclosureWidget.prototype.resetLeds = function() {
    var H = this._getSelected();
    if (H.length) {
        var D = strings.rack.clearLedsSuccessSelected;
        var F = [];
        var G, I;
        for (var E = 0, C = H.length; E < C; E++) {
            if (H[E].locatorLedTarget) {
                G = H[E].locatorLedTarget;
                if (G == "controller") {
                    I = H[E].enclosure + "." + H[E].ID
                } else {
                    I = H[E].ID
                }
                F.push({
                    name: "setLed",
                    command: MC.setLed,
                    data: {
                        target: G,
                        id: I,
                        state: "off"
                    },
                    options: {
                        processingMsg: strings.rack.clearLedsProcessing(G, I),
                        failureMsg: strings.rack.clearLedsFailed(G, I)
                    }
                })
            }
        }
    } else {
        var D = strings.rack.clearLedsSuccess;
        var F = this._clearLedCommandList()
    }
    MC.execCommandList(F, {
        successMsg: D
    })
};
RackEnclosureWidget.prototype._getSelected = function() {
    var E = [];
    var F = this.getComponents();
    for (var D = 0, C = F.length; D < C; D++) {
        if (F[D].selected) {
            E.push(F[D])
        }
    }
    return E
};
RackEnclosureWidget.prototype.sortTable = function(C) {
    this.table.sort(C)
};
RackEnclosureWidget.prototype.setFormat = function(C) {
    if (C == "graphic") {
        this.tabular = false
    } else {
        this.tabular = true
    }
};
RackEnclosureWidget.prototype.setFilters = function(C) {
    if (C.enclosureFilters != undefined) {
        this._enclosureFilters = C.enclosureFilters
    }
    if (C.driveFilters != undefined) {
        this._driveFilters = C.driveFilters
    }
    if (C.componentFilters != undefined) {
        this._componentFilters = C.componentFilters
    }
    if (C.drives != undefined) {
        this._drives = C.drives
    }
    if (C.components != undefined) {
        this.components = C.components
    }
    if (C.enclosures != undefined) {
        this.enclosures = C.enclosures
    }
};
RackEnclosureWidget.prototype.setView = function(E) {
    this.viewChanged = false;
    var C = this.front;
    var D = this.rear;
    this.front = false;
    this.rear = false;
    switch (E) {
        case "front":
            this.front = true;
            break;
        case "rear":
            this.rear = true;
            break;
        case "both":
            this.front = true;
            this.rear = true;
            break;
        default:
            break
    }
    if (C != this.front || D != this.rear) {
        this.viewChanged = true
    }
};
RackEnclosureWidget.prototype.showing = function(C) {
    this.hidden = false;
    this.getData()
};
RackEnclosureWidget.prototype.getData = function() {
    this.enclosuresData = null;
    this.disksData = null;
    this.enclosuresSubscription = MC.enclosuresSet.requestData({
        update: false,
        durable: this.durable,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.enclosuresData = C;
            this.updateComponents()
        })
    });
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: this.durable,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.disksData = C;
            this.updateComponents()
        })
    })
};
RackEnclosureWidget.prototype.hiding = function() {
    this.hidden = true;
    if (this.enclosuresSubscription) {
        MC.enclosuresSet.unregister(this.enclosuresSubscription);
        delete this.enclosuresSubscription
    }
    if (this.disksSubscription) {
        MC.disksSet.unregister(this.disksSubscription);
        delete this.disksSubscription
    }
};
RackEnclosureWidget.prototype.handleRetrieve = function(G) {
    var F = new APIData(G.drives);
    var D = new APIData(G.enclosures);
    var E = new APIData(G.components);
    var C = {
        enclosures: D,
        drives: F,
        value: F,
        components: E
    };
    G[this.name] = C;
    delete G.drives;
    delete G.enclosures;
    delete G.components;
    if (G.rack_table) {
        delete G.rack_table
    }
    if (G.rackTabs) {
        delete G.rackTabs
    }
};
RackEnclosureWidget.prototype.modeSelect = function(C) {
    if (C != null) {
        if (C < this.modes.length) {
            var D = this.modes[C];
            if (D.front && !D.rear) {
                this.setView("front")
            } else {
                if (!D.front && D.rear) {
                    this.setView("rear")
                } else {
                    this.setView("both")
                }
            }
            if (D.tabular) {
                this.setFormat("tabular")
            } else {
                this.setFormat("graphic")
            }
            if (this.viewChanged) {
                this.updateComponents()
            } else {
                this.renderRack()
            }
        }
    }
};
RackEnclosureWidget.prototype.updateComponents = function(C) {
    if (MC.enclosuresSet.pendingNotification(this.enclosuresSubscription) || !this.enclosuresData) {
        return
    }
    if (MC.disksSet.pendingNotification(this.disksSubscription) || !this.disksData) {
        return
    }
    if (!this.visibility) {
        for (var F = 0; F < this.widgetContainer.widgets.length; F++) {
            this.widgetContainer.widgets[F].setVisibility("collapse")
        }
        if (this.tabs) {
            this.tabs.setVisibility("collapse")
        }
        if (this.ledButtonContainer) {
            this.ledButtonContainer.setVisibility("collapse")
        }
        return
    } else {
        if (this.tabs) {
            this.tabs.setVisibility("visible")
        }
        if (this.ledButtonContainer) {
            this.ledButtonContainer.setVisibility("visible")
        }
    }
    var N = this;
    if (arguments.length == 0) {
        var D = true
    }
    var M = this.enclosuresData.getData();
    M.objects.sort(function(P, O) {
        return P.getInt("enclosure_id") - O.getInt("enclosure_id")
    });
    this.json = M;
    this._enclosures = {};
    var J = this.json.objects.length;
    if (!enclosuresBottomUp) {
        var L = 0
    } else {
        MC.debugOutput("RackEnclosureWidget::updateComponents bottoms up", "%s");
        var L = J - 1
    }
    var E = null;
    do {
        if (enclosuresBottomUp) {
            E = this.json.objects[L--]
        } else {
            E = this.json.objects[L++]
        }
        if (E == null) {
            break
        }
        var I = E;
        var H = E.get("enclosure_wwn");
        N._enclosures[H] = {
            tabular: N.tabular,
            noRender: true,
            serial: H,
            json: I,
            disksData: N.disksData,
            driveFilters: N._driveFilters,
            componentFilters: N._componentFilters,
            selectedDrives: N._drives,
            selectedComponents: N.components,
            group: N.selectionGroup,
            visibility: "visible",
            cellClasses: "encCell",
            selectable: N.selectable,
            noLedControls: N.noLedControls,
            exclusive: N.exclusive,
            changeCallback: createObjectCallback(N, RackEnclosureWidget.prototype.selectingComponent)
        }
    } while (E);
    if (this._enclosureFilters) {
        this.applyFilters(this._enclosures, this._enclosureFilters, this.json, "enclosure_wwn")
    }
    if (this.enclosures) {
        this.applyFilters(this._enclosures, [{
            filterJson: this.enclosures,
            options: {
                selectable: true,
                selected: true
            }
        }], this.enclosures, "enclosure_wwn")
    }
    for (var F = 0; F < N.widgetContainer.widgets.length; F++) {
        var G = N.widgetContainer.widgets[F];
        if (G != this.ledButtonContainer) {
            G.deleted = true
        }
    }
    for (enclosureName in N._enclosures) {
        var K = N._enclosures[enclosureName];
        if (K.notPresent) {
            continue
        }
        if (N.tabular) {
            if (!this.noLedControls) {
                this.ledButtonContainer.setVisibility("collapse")
            }
            K.visibility = "collapse"
        }
        if (N.front) {
            N.touchWidget("Front", K)
        }
        if (N.rear) {
            N.touchWidget("Rear", K)
        }
    }
    this.table.deleted = false;
    if (this.tabs) {
        this.tabs.deleted = false
    }
    this.widgetContainer.removeDeletedByProperty();
    this.renderRack(C);
    if (panels.actionDialog.active) {
        panels.actionDialog.resetSize()
    }
    if (!this.noLedControls) {
        this.selectingComponent()
    }
};
RackEnclosureWidget.prototype.renderRack = function(D) {
    if (this.rendering) {
        return
    }
    this.rendering = true;
    var J = this.getComponents();
    var E = J.length;
    for (var G = 0; G < E; G++) {
        J[G].tabular = this.tabular
    }
    var I = this.activeComponents(J);
    var L = this.selectableComponents(I);
    if (this.tabular) {
        for (var G = 0; G < J.length; G++) {
            var M = J[G];
            if (M.isEnclosure) {
                M.setVisibility("collapse")
            }
        }
        var K = {};
        for (var G = 0; G < I.length; G++) {
            var H = I[G];
            if (H.isEnclosure) {
                var F = I[G].json.getKeyValue();
                if (K[F]) {
                    I.splice(G, 1);
                    G--
                } else {
                    K[F] = true
                }
            }
        }
        if (this.tablesAdded == undefined) {
            this.widgetContainer.add(this.table);
            var C = {};
            C[this.tableName] = {
                visibility: "hidden"
            };
            this.table.update(C);
            this.tablesAdded = true
        }
        var C = {};
        C[this.tableName] = {
            visibility: "visible",
            data: I,
            select: this.getSelectedRefs(I)
        };
        this.table.update(C)
    } else {
        var C = {};
        C[this.tableName] = {
            visibility: "hidden"
        };
        this.table.update(C);
        for (var G = 0; G < J.length; G++) {
            var M = J[G];
            if (M.isEnclosure) {
                M.setVisibility("visible")
            }
            M.render()
        }
    }
    this.rendering = false
};
RackEnclosureWidget.prototype.touchWidget = function(C, E) {
    E.name = C + E.serial;
    var D = this.widgetContainer.findWidgetByName(E.name);
    if (D) {
        var F = {};
        F[E.name] = E;
        D.update(F);
        D.deleted = false
    } else {
        if (C == "Front") {
            this.widgetContainer.add(new EnclosureFrontWidget(E))
        } else {
            this.widgetContainer.add(new EnclosureRearWidget(E))
        }
    }
};
RackEnclosureWidget.getTableMeta = function() {
    if (!RackEnclosureWidget.METADATA) {
        RackEnclosureWidget.METADATA = [{
            sTitle: "basetype",
            bIsBasetype: true,
            bVisible: false,
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: "key",
            bIsKey: true,
            bVisible: false,
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.healthCol,
            sType: "string",
            bFilterMenu: {
                allowSingles: true
            },
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.typeCol,
            sType: "string",
            bFilterMenu: {
                allowSingles: true,
                numItems: 30
            },
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.enclosureCol,
            sType: "numeric",
            bFilterMenu: {
                numItems: 0
            },
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.locationCol,
            sType: "string",
            bFilterMenu: {
                numItems: 0
            },
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.infoCol,
            sType: "string",
            bFilterMenu: {
                numItems: 0
            },
            fnRender: EnclosureElement.renderCell
        }, {
            sTitle: strings.rack.statusCol,
            sType: "string",
            bFilterMenu: {
                allowSingles: true
            },
            fnRender: EnclosureElement.renderCell
        }]
    }
    return RackEnclosureWidget.METADATA
};
RackEnclosureWidget.prototype.getComponents = function() {
    var D = [];
    for (var C = 0; C < this.widgetContainer.widgets.length; C++) {
        var E = this.widgetContainer.widgets[C];
        if (E.isEnclosureElement) {
            E.addComponent(D)
        }
    }
    return D
};
RackEnclosureWidget.prototype.activeComponents = function(E) {
    var D = E.length;
    var F = new Array();
    for (var C = 0; C < D; C++) {
        if (!E[C].inactive) {
            F[F.length] = E[C]
        }
    }
    return F
};
RackEnclosureWidget.prototype.selectableComponents = function(F) {
    var E = F.length;
    var C = new Array(E);
    for (var D = 0; D < E; D++) {
        C[D] = (F[D].selectable && !F[D].disabled)
    }
    return C
};
RackEnclosureWidget.prototype.getSelectedRefs = function(G) {
    var F = [];
    for (var E = 0, C = G.length; E < C; E++) {
        var D = G[E];
        if (D.selected) {
            F.push(new DCRef(D.json));
            if (this.notifySelected) {
                D.fireChange(null)
            }
        }
    }
    return F
};
RackEnclosureWidget.prototype._tableSelectCallback = function(J) {
    var H = this.getComponents();
    for (var F = 0, I = H.length; F < I; F++) {
        var D = H[F].json;
        var E = false;
        for (var G = 0, K = J.length; G < K; G++) {
            var C = J[G];
            if (C.basetype == D.basetype && C.key == D.getKeyValue()) {
                E = true;
                break
            }
        }
        if (E) {
            H[F].select()
        } else {
            H[F].unselect()
        }
    }
};
RackEnclosureWidget.prototype.selectingComponent = function(D, F, H) {
    if (!this.noLedControls) {
        var J = this._getSelected();
        var C = "no-selection";
        if (J && J.length) {
            for (var E = 0, G = J.length; E < G; E++) {
                var I = J[E].json;
                if (I.getInt("locator_led_numeric") == 0) {
                    if (C == "on") {
                        C = "both";
                        break
                    } else {
                        C = "off"
                    }
                } else {
                    if (C == "off") {
                        C = "both";
                        break
                    } else {
                        C = "on"
                    }
                }
            }
        }
        if (C == "both" || C == "off") {
            this.resetLedButton.handleUpdate({
                disable: true,
                tooltip: strings.rack.alreadyOff
            })
        } else {
            if (this.selectedList && this.selectedList.length) {
                var K = strings.rack.resetLedTipSelected
            } else {
                var K = strings.rack.resetLedTip
            }
            this.resetLedButton.handleUpdate({
                disable: false,
                tooltip: K
            })
        }
        if (C == "both" || C == "on") {
            this.setLedButton.handleUpdate({
                disable: true,
                tooltip: strings.rack.alreadyOn
            })
        } else {
            this.setLedButton.handleUpdate({
                disable: false,
                tooltip: strings.rack.setLedTip
            })
        }
    }
    if ($.isFunction(this.changeCallback)) {
        this.changeCallback.call(F, D, F, H)
    }
};
RackEnclosureWidget.prototype.setVisibility = function(C) {};

function EnclosureCommon(C) {
    if (arguments.length == 0) {
        return
    }
    this.json = C.json;
    this.serial = C.serial || "";
    this.enclosureID = this.json.get("enclosure_id");
    this.ID = this.enclosureID;
    this._determineType();
    this._row = 0;
    this._col = 0;
    this.isEnclosure = true;
    C.style = this.style;
    C.typeName = "enclosure";
    C.text = this.enclosureID;
    AggregateEnclosureElement.call(this, C)
}
EnclosureCommon.prototype = new AggregateEnclosureElement();
EnclosureCommon.prototype.handleRetrieve = function(D) {
    if (this.isSelected()) {
        if (!D.enclosures) {
            D.enclosures = new Array()
        }
        var C = D.enclosures;
        C[C.length] = this.json
    }
    EnclosureElement.prototype.handleRetrieve.call(this, D)
};
EnclosureCommon.prototype._determineType = function() {
    var E = this.json;
    this.numberOfSlots = E.get("slots");
    this.vendor = E.get("vendor");
    this.model = E.get("model");
    this.health = E.get("health");
    this.rows = E.get("rows");
    this.columns = E.get("columns");
    this.type_numeric = E.getInt("type_numeric");
    if (this.numberOfSlots == "56") {
        var D = DC.controllers.A;
        var F = D.objects.filter(function(G) {
            if (G.constructor.name == "APIExpanderPorts") {
                return true
            } else {
                return false
            }
        });
        if (F.length > 1) {
            this.enclosureType = EnclosureTypes.herculesFX
        } else {
            this.enclosureType = EnclosureTypes.herculesLX
        }
    } else {
        if (this.numberOfSlots == "84") {
            this.enclosureType = EnclosureTypes.seagate5U84
        } else {
            if (this.type_numeric == 9 || this.type_numeric == 10) {
                var C = ((DC.controllers.A && DC.controllers.A.getInt("platform_type_numeric") == 7) || (DC.controllers.B && DC.controllers.B.getInt("platform_type_numeric") == 7));
                if (this.numberOfSlots == "24") {
                    if (C) {
                        this.enclosureType = EnclosureTypes.OneStor2u24EX
                    } else {
                        this.enclosureType = EnclosureTypes.OneStor2u24LX
                    }
                } else {
                    if (C) {
                        this.enclosureType = EnclosureTypes.OneStor2u12EX
                    } else {
                        this.enclosureType = EnclosureTypes.OneStor2u12LX
                    }
                }
            } else {
                if (this.vendor.indexOf("DotHill") != -1) {
                    if (this.numberOfSlots == "48") {
                        this.enclosureType = EnclosureTypes.atlas
                    } else {
                        if (this.numberOfSlots == "24") {
                            this.enclosureType = EnclosureTypes.dothill2u24
                        } else {
                            this.enclosureType = EnclosureTypes.dothill2u12
                        }
                    }
                } else {
                    if (this.vendor.indexOf("HP") != -1) {
                        if (this.model.indexOf("MSA70") != -1) {
                            this.enclosureType = EnclosureTypes.msa70
                        } else {
                            if ((this.model.indexOf("270 SAS AJ") != -1) || (this.model.indexOf("D270 SAS AJ") != -1) || (this.model.indexOf("D2700") != -1)) {
                                this.enclosureType = EnclosureTypes.d2x00
                            } else {
                                if (this.numberOfSlots == "24") {
                                    this.enclosureType = EnclosureTypes.hp2u24
                                } else {
                                    this.enclosureType = EnclosureTypes.hp2u12
                                }
                            }
                        }
                    } else {
                        if (this.numberOfSlots == "24") {
                            this.enclosureType = EnclosureTypes.dothill2u24
                        } else {
                            this.enclosureType = EnclosureTypes.def
                        }
                    }
                }
            }
        }
    }
    this.encSerial = E.get("enclosure_wwn");
    this.arrangement = this.enclosureType.arrangement;
    this.styleObject = {
        arrangement: this.arrangement
    };
    this.styleObject.drawer_settings = this.enclosureType.drawer_settings;
    $.extend(this.styleObject, this.enclosureType.front_style);
    $.extend(this.styleObject, this.enclosureType.rear_style);
    this.style = (this.view == "Front") ? this.enclosureType.front_style.enc_style : this.enclosureType.rear_style.enc_style
};
EnclosureCommon.prototype.setVisibility = function(C) {
    Widget.prototype.setVisibility.call(this, C);
    if (C == "collapse") {
        $(this.elements).height(0)
    } else {
        if (!this.tabular) {
            $(this.elements).height(this.enclosureType.enc_layout.height);
            $(this.elements).width(this.enclosureType.enc_layout.width)
        }
    }
};
EnclosureCommon.prototype.flashOn = function() {
    $(this.elements).addClass("enclosureHighlight");
    setTimeout(createObjectCallback(this, this.flashOff), 10)
};
EnclosureCommon.prototype.flashOff = function() {
    $(this.elements).removeClass("enclosureHighlight")
};
EnclosureCommon.prototype.setProperties = function(E) {
    var C = "";
    var D = this.json.get("location");
    if (D != "") {
        C += D + ", "
    }
    C += strings.Rack + " " + this.json.get("rack_number") + "." + this.json.get("rack_position");
    var F = this.json.get("vendor") + " " + this.json.get("model");
    F += " (" + this.json.get("number_of_disks") + " " + strings.disks + ")";
    this.displayType = strings.rack.type.enclosure;
    this.ID = this.enclosureID;
    this.displayInfo = F;
    this.location = C
};

function EnclosureFrontWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.view = "Front";
    this.driveFilters = null;
    this.selectedDrives = null;
    this.disksData = null;
    this.drivesJson = null;
    this.locatorLedTarget = "enclosure";
    C.hoverPanel = APIObject.getHover("enclosures");
    EnclosureCommon.call(this, C);
    this.class_name = "EnclosureFrontWidget"
}
EnclosureFrontWidget.prototype = new EnclosureCommon();
EnclosureFrontWidget.prototype.showCollection = function(E) {
    for (var C in E) {
        var D = E[C]
    }
};
EnclosureFrontWidget.prototype.doFiltering = function(C) {
    if (this.driveFilters) {
        this.applyFilters(C, this.driveFilters, this.drivesJson, "durable_id")
    }
    if (this.selectedDrives) {
        this.applyFilters(C, [{
            filterJson: this.selectedDrives,
            options: {
                selectable: true,
                selected: true
            }
        }], this.selecteDrives, "durable_id")
    }
};
EnclosureFrontWidget.prototype.setupComponents = function(I) {
    if (I.driveFilters != undefined) {
        this.driveFilters = I.driveFilters
    }
    if (I.selectedDrives != undefined) {
        this.selectedDrives = I.selectedDrives
    }
    if (I.disksData != undefined) {
        this.disksData = I.disksData;
        this.drivesJson = this.disksData.getData().select({
            type: "prop",
            name: "enclosure_wwn",
            value: this.serial
        })
    }
    this.componentJson = this.json.select({
        type: "attr",
        name: "basetype",
        value: "drawers"
    });
    if (this.componentJson.objects.length > 0) {
        var G;
        var F;
        for (var H = 0; H < this.componentJson.objects.length; H++) {
            var C = this.componentJson.objects[H];
            G = (C.select({
                type: "attr",
                name: "basetype",
                value: "sideplanes"
            }));
            if (G.length > 0) {
                for (var D = 0; D < G.length; D++) {
                    var E = G.objects[D];
                    F = (E.select({
                        type: "attr",
                        name: "basetype",
                        value: "expanders"
                    }));
                    this.componentJson.objects = this.componentJson.objects.concat(F.objects)
                }
            }
            this.componentJson.objects = this.componentJson.objects.concat(G.objects)
        }
    }
    this.componentJson.objects = this.componentJson.objects.concat(this.drivesJson.objects);
    AggregateEnclosureElement.prototype.setupComponents.call(this, I)
};

function EnclosureRearWidget(C) {
    if (arguments.length == 0) {
        return
    }
    this.componentFilters = null;
    this.selectedComponents = null;
    this.view = "Rear";
    C.hoverPanel = APIObject.getHover("enclosures");
    EnclosureCommon.call(this, C);
    this.class_name = "EnclosureRearWidget"
}
EnclosureRearWidget.prototype = new EnclosureCommon();
EnclosureRearWidget.prototype.setupComponents = function(C) {
    this.componentJson = this.json.select(function(D) {
        return (D.basetype != "drawers")
    });
    AggregateEnclosureElement.prototype.setupComponents.call(this, C)
};
var EnclosureSpecs = {
    drive_arrangement: {
        _HORIZONTAL_2U12: {
            col: 4,
            row: 3,
            disk_max: 12,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: false,
            disk_width: 162,
            disk_height: 42,
            x: [31, 195, 359, 523, 31, 195, 359, 523, 31, 195, 359, 523],
            y: [2, 2, 2, 2, 47, 47, 47, 47, 92, 92, 92, 92]
        },
        _HORIZONTAL_2U12_VERT_NUM: {
            col: 4,
            row: 3,
            disk_max: 12,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: false,
            disk_width: 162,
            disk_height: 42,
            x: [31, 31, 31, 195, 195, 195, 359, 359, 359, 523, 523, 523],
            y: [2, 47, 92, 2, 47, 92, 2, 47, 92, 2, 47, 92]
        },
        _VERTICAL_2U24: {
            col: 24,
            row: 1,
            disk_max: 24,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: true,
            disk_width: 25,
            disk_height: 136,
            x: [30, 57, 84, 111, 138, 165, 192, 219, 251, 278, 305, 332, 359, 386, 413, 440, 472, 499, 526, 553, 580, 607, 634, 661],
            y: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        },
        _HORIZONTAL_2U25: {
            col: 5,
            row: 5,
            disk_max: 25,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: false,
            disk_width: 130,
            disk_height: 26,
            x: [30, 30, 30, 30, 30, 162, 162, 162, 162, 162, 294, 294, 294, 294, 294, 426, 426, 426, 426, 426, 558, 558, 558, 558, 558],
            y: [0, 28, 56, 84, 112, 0, 28, 56, 84, 112, 0, 28, 56, 84, 112, 0, 28, 56, 84, 112, 0, 28, 56, 84, 112]
        },
        _ATLAS_2U48: {
            col: 12,
            row: 4,
            disk_max: 48,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: false,
            disk_width: 48,
            disk_height: 32,
            x: [46, 46, 46, 46, 96, 96, 96, 96, 146, 146, 146, 146, 196, 196, 196, 196, 266, 266, 266, 266, 316, 316, 316, 316, 366, 366, 366, 366, 416, 416, 416, 416, 472, 472, 472, 472, 522, 522, 522, 522, 572, 572, 572, 572, 622, 622, 622, 622],
            y: [2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101, 2, 35, 68, 101]
        },
        _DHS_4U56: {
            col: 14,
            row: 4,
            disk_max: 56,
            disk_size_display: true,
            disk_type_display: true,
            disk_text_vertical: false,
            disk_width: 43,
            disk_height: 61,
            x: [34, 80, 126, 172, 218, 264, 310, 34, 80, 126, 172, 218, 264, 310, 34, 80, 126, 172, 218, 264, 310, 34, 80, 126, 172, 218, 264, 310, 364, 410, 456, 502, 548, 594, 640, 364, 410, 456, 502, 548, 594, 640, 364, 410, 456, 502, 548, 594, 640, 364, 410, 456, 502, 548, 594, 640],
            y: [195, 195, 195, 195, 195, 195, 195, 131, 131, 131, 131, 131, 131, 131, 67, 67, 67, 67, 67, 67, 67, 3, 3, 3, 3, 3, 3, 3, 195, 195, 195, 195, 195, 195, 195, 131, 131, 131, 131, 131, 131, 131, 67, 67, 67, 67, 67, 67, 67, 3, 3, 3, 3, 3, 3, 3]
        },
        _SEAGATE_5U84: {
            col: 1,
            row: 3,
            disk_max: 84,
            disk_size_display: true,
            disk_type_display: false,
            disk_text_vertical: true,
            disk_width: 20,
            disk_height: 97,
            x: [32, 56, 80, 104, 128, 152, 176, 200, 224, 248, 272, 296, 320, 344, 32, 56, 80, 104, 128, 152, 176, 200, 224, 248, 272, 296, 320, 344, 32, 56, 80, 104, 128, 152, 176, 200, 224, 248, 272, 296, 320, 344, 382, 406, 430, 454, 478, 502, 526, 550, 574, 598, 622, 646, 670, 694, 382, 406, 430, 454, 478, 502, 526, 550, 574, 598, 622, 646, 670, 694, 382, 406, 430, 454, 478, 502, 526, 550, 574, 598, 622, 646, 670, 694],
            y: [204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
        },
        _ONESTOR_HORIZONTAL_2U12: {
            col: 4,
            row: 3,
            disk_max: 12,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: false,
            disk_width: 163,
            disk_height: 42,
            x: [38, 204, 388, 556, 38, 204, 388, 556, 38, 204, 388, 556],
            y: [4, 4, 4, 4, 47, 47, 47, 47, 92, 92, 92, 92]
        },
        _ONESTOR_VERTICAL_2U24: {
            col: 24,
            row: 1,
            disk_max: 24,
            disk_size_display: false,
            disk_type_display: false,
            disk_text_vertical: true,
            disk_width: 27,
            disk_height: 134,
            x: [36, 64, 92, 120, 148, 176, 204, 232, 260, 288, 316, 344, 385, 413, 441, 469, 497, 525, 553, 581, 609, 637, 665, 693],
            y: [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
        }
    },
    enclosure_layouts: {
        width: 724,
        height: 142,
        _DHS_4U56: {
            width: 724,
            height: 284
        },
        _ONESTOR_2U12: {
            width: 757,
            height: 142
        },
        _SEAGATE_5U84: {
            width: 757,
            height: 340
        }
    },
    drawer_settings: {
        _ATLAS_2U48: {
            x: [30, 250, 470],
            vertical_label: true
        },
        _DHS_4U56: {
            x: [30, 360],
            vertical_label: false
        },
        _SEAGATE_5U84: {
            x: [26, 376],
            vertical_label: false
        }
    },
    front_styles: {
        _HP_2U12: {
            name: "HP2U12",
            enc_style: "hp2U12",
            drv_style: "disk2U12HP"
        },
        _HP_2U24: {
            name: "HP2U24",
            enc_style: "hp2U24",
            drv_style: "disk2U24HP"
        },
        _DHS_2U12: {
            name: "DHS2U12",
            enc_style: "dhs2U12",
            drv_style: "disk2U12DHS"
        },
        _DHS_2U24: {
            name: "DHS2U24",
            enc_style: "dhs2U24",
            drv_style: "disk2U24DHS"
        },
        _MSA70_2U25: {
            name: "HPMSA70",
            enc_style: "hpMSA70",
            drv_style: "diskMSA70HP"
        },
        _D2x00_2U25: {
            name: "HPD2x00",
            enc_style: "hpD2x00",
            drv_style: "diskD2x00HP"
        },
        _DHS_2U48: {
            name: "DHS2U48",
            enc_style: "dhs2U48",
            drawer_style_left: "dhs2U48leftDrawer",
            drawer_style_right: "dhs2U48rightDrawer",
            drv_style: "disk2U48DHS"
        },
        _DHS_4U56: {
            name: "DHS4U56",
            enc_style: "dhs4U56",
            drawer_style_left: "dhs4U56Drawer",
            drv_style: "disk4U56DHS"
        },
        _SEAGATE_5U84: {
            name: "SEAGATE5U84",
            enc_style: "seagate5U84EnclosureFrontContainer",
            drawer_style_left: "seagate5U84Drawer",
            drv_style: "disk5U84SEAGATE"
        },
        _ONESTOR_2U12: {
            name: "ONESTOR2U12",
            enc_style: "OneStor2U12",
            drv_style: "disk2U12OneStor"
        },
        _ONESTOR_2U24: {
            name: "ONESTOR2U24",
            enc_style: "OneStor2U24",
            drv_style: "disk2U24OneStor"
        },
        _DEFAULT: {
            name: "DEFAULT",
            enc_style: "enclosureFrontContainer",
            drv_style: "horizontalDiskDrive"
        }
    },
    rear_styles: {
        _MSA70: {
            name: "HPMSA70rear",
            enc_style: "portArrangeAcross MSA70RearContainer",
            ps_style: "MSA70PSStyle",
            ps_style_Left: "MSA70PSLeft",
            ps_style_Right: "MSA70PSRight",
            fan_style_Left: "MSA70FanLeft",
            fan_style_Right: "MSA70FanRight",
            cont_style: "MSA70contStyle",
            cont_style_Left: "MSA70contLeft",
            cont_style_Right: "MSA70contRight"
        },
        _D2x00: {
            name: "HPD2x00rear",
            enc_style: "portArrangeAcross D2x00RearContainer",
            ps_style: "D2x00PSStyle",
            ps_style_Top: "D2x00PSTop",
            ps_style_Bottom: "D2x00PSBottom",
            fan_style_Left: "D2x00FanLeft",
            fan_style_Right: "D2x00FanRight",
            cont_style: "D2x00contStyle",
            cont_style_Top: "D2x00contTop",
            cont_style_Bottom: "D2x00contBottom"
        },
        _HP2U24: {
            name: "HP2U24rear",
            enc_style: "portArrangeAcross enclosureRearContainer",
            ps_style: "powerSupplyStyle",
            ps_style_Left: "powerSupplyLeft",
            ps_style_Right: "powerSupplyRight",
            fan_style_Left: "fanLeft",
            fan_style_Right: "fanRight",
            cont_style: "controllerStyle",
            cont_style_Top: "controllerTop",
            cont_style_Bottom: "controllerBottom"
        },
        _DHS_4U56: {
            name: "DHS4U56rear",
            enc_style: "portArrangeAcross dhs4U56RearContainer",
            ps_style: "dhs4U56PSStyle",
            ps_style_Left: "dhs4U56PSLeft",
            ps_style_Right: "dhs4U56PSRight",
            fan_style_Left: "dhs4U56FanLeft",
            fan_style_Right: "dhs4U56FanRight",
            cont_style: "dhs4U56ControllerStyle",
            cont_style_Left: "dhs4U56ControllerLeft",
            cont_style_Right: "dhs4U56ControllerRight"
        },
        _DHS_4U56LX: {
            name: "DHS4U56rear",
            enc_style: "portArrangeAcross dhs4U56RearContainer",
            ps_style: "dhs4U56PSStyle",
            ps_style_Left: "dhs4U56PSLeft",
            ps_style_Right: "dhs4U56PSRight",
            fan_style_Left: "dhs4U56FanLeft",
            fan_style_Right: "dhs4U56FanRight",
            cont_style: "dhs4U56ControllerStyle",
            cont_style_Left: "dhs4U56LXControllerLeft",
            cont_style_Right: "dhs4U56LXControllerRight"
        },
        _OneStor_LX: {
            name: "OneStor",
            enc_style: "portArrangeOneStor OneStorRearContainer",
            ps_style: "powerSupplyStyle",
            ps_style_Left: "OneStorpowerSupplyLeft",
            ps_style_Right: "OneStorpowerSupplyRight",
            cont_style_Top: "oneStorTopLx",
            cont_style_Bottom: "oneStorBottomLx",
            cont_style_Inverted: "oneStorInvertedLx",
            cont_style_NotInverted: "oneStorNotInvertedLx"
        },
        _OneStor_EX: {
            name: "OneStor",
            enc_style: "portArrangeOneStor OneStorRearContainer",
            ps_style: "powerSupplyStyle",
            ps_style_Left: "OneStorpowerSupplyLeft",
            ps_style_Right: "OneStorpowerSupplyRight",
            cont_style_Top: "oneStorTopEx",
            cont_style_Bottom: "oneStorBottomEx",
            cont_style_Inverted: "oneStorInvertedEx",
            cont_style_NotInverted: "oneStorNotInvertedEx"
        },
        _SEAGATE_5U84: {
            name: "SEAGATE5U84",
            enc_style: "portArrangeAcross5u84 seagate5U84EnclosureRearContainer",
            ps_style: "powerSupplyStyle",
            ps_style_Left: "seagate5U84powerSupplyLeft",
            ps_style_Right: "seagate5U84powerSupplyRight",
            cont_style: "seagate5U84ControllerStyle",
            cont_style_Left: "seagate5U84ControllerLeft",
            cont_style_Right: "seagate5U84ControllerRight",
            fan_style_Left: "seagate5U84FanLeft",
            fan_style_LeftMiddle: "seagate5U84FanLeftMiddle",
            fan_style_Middle: "seagate5U84FanMiddle",
            fan_style_RightMiddle: "seagate5U84FanRightMiddle",
            fan_style_Right: "seagate5U84FanRight"
        },
        _DEFAULT: {
            name: "Default",
            enc_style: "portArrangeAcross enclosureRearContainer",
            ps_style: "powerSupplyStyle",
            ps_style_Left: "powerSupplyLeft",
            ps_style_Right: "powerSupplyRight",
            fan_style_Left: "fanLeft",
            fan_style_Right: "fanRight",
            cont_style: "controllerStyle",
            cont_style_Top: "controllerTop",
            cont_style_Bottom: "controllerBottom"
        }
    }
};
var EnclosureTypes = {
    dothill2u12: {
        arrangement: EnclosureSpecs.drive_arrangement._HORIZONTAL_2U12,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._DHS_2U12,
        rear_style: EnclosureSpecs.rear_styles._DEFAULT
    },
    dothill2u24: {
        arrangement: EnclosureSpecs.drive_arrangement._VERTICAL_2U24,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._DHS_2U24,
        rear_style: EnclosureSpecs.rear_styles._DEFAULT
    },
    hp2u12: {
        arrangement: EnclosureSpecs.drive_arrangement._HORIZONTAL_2U12_VERT_NUM,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._HP_2U12,
        rear_style: EnclosureSpecs.rear_styles._DEFAULT
    },
    hp2u24: {
        arrangement: EnclosureSpecs.drive_arrangement._VERTICAL_2U24,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._HP_2U24,
        rear_style: EnclosureSpecs.rear_styles._HP2U24
    },
    msa70: {
        arrangement: EnclosureSpecs.drive_arrangement._HORIZONTAL_2U25,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._MSA70_2U25,
        rear_style: EnclosureSpecs.rear_styles._MSA70
    },
    d2x00: {
        arrangement: EnclosureSpecs.drive_arrangement._HORIZONTAL_2U25,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._D2x00_2U25,
        rear_style: EnclosureSpecs.rear_styles._D2x00
    },
    atlas: {
        arrangement: EnclosureSpecs.drive_arrangement._ATLAS_2U48,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        drawer_settings: EnclosureSpecs.drawer_settings._ATLAS_2U48,
        front_style: EnclosureSpecs.front_styles._DHS_2U48,
        rear_style: EnclosureSpecs.rear_styles._DEFAULT
    },
    herculesFX: {
        arrangement: EnclosureSpecs.drive_arrangement._DHS_4U56,
        enc_layout: EnclosureSpecs.enclosure_layouts._DHS_4U56,
        drawer_settings: EnclosureSpecs.drawer_settings._DHS_4U56,
        front_style: EnclosureSpecs.front_styles._DHS_4U56,
        rear_style: EnclosureSpecs.rear_styles._DHS_4U56
    },
    herculesLX: {
        arrangement: EnclosureSpecs.drive_arrangement._DHS_4U56,
        enc_layout: EnclosureSpecs.enclosure_layouts._DHS_4U56,
        drawer_settings: EnclosureSpecs.drawer_settings._DHS_4U56,
        front_style: EnclosureSpecs.front_styles._DHS_4U56,
        rear_style: EnclosureSpecs.rear_styles._DHS_4U56LX
    },
    OneStor2u24LX: {
        arrangement: EnclosureSpecs.drive_arrangement._ONESTOR_VERTICAL_2U24,
        enc_layout: EnclosureSpecs.enclosure_layouts._ONESTOR_2U12,
        front_style: EnclosureSpecs.front_styles._ONESTOR_2U24,
        rear_style: EnclosureSpecs.rear_styles._OneStor_LX
    },
    OneStor2u24EX: {
        arrangement: EnclosureSpecs.drive_arrangement._ONESTOR_VERTICAL_2U24,
        enc_layout: EnclosureSpecs.enclosure_layouts._ONESTOR_2U12,
        front_style: EnclosureSpecs.front_styles._ONESTOR_2U24,
        rear_style: EnclosureSpecs.rear_styles._OneStor_EX
    },
    OneStor2u12LX: {
        arrangement: EnclosureSpecs.drive_arrangement._ONESTOR_HORIZONTAL_2U12,
        enc_layout: EnclosureSpecs.enclosure_layouts._ONESTOR_2U12,
        front_style: EnclosureSpecs.front_styles._ONESTOR_2U12,
        rear_style: EnclosureSpecs.rear_styles._OneStor_LX
    },
    OneStor2u12EX: {
        arrangement: EnclosureSpecs.drive_arrangement._ONESTOR_HORIZONTAL_2U12,
        enc_layout: EnclosureSpecs.enclosure_layouts._ONESTOR_2U12,
        front_style: EnclosureSpecs.front_styles._ONESTOR_2U12,
        rear_style: EnclosureSpecs.rear_styles._OneStor_EX
    },
    seagate5U84: {
        arrangement: EnclosureSpecs.drive_arrangement._SEAGATE_5U84,
        enc_layout: EnclosureSpecs.enclosure_layouts._SEAGATE_5U84,
        drawer_settings: EnclosureSpecs.drawer_settings._SEAGATE_5U84,
        front_style: EnclosureSpecs.front_styles._SEAGATE_5U84,
        rear_style: EnclosureSpecs.rear_styles._SEAGATE_5U84
    },
    def: {
        arrangement: EnclosureSpecs.drive_arrangement._HORIZONTAL_2U12,
        enc_layout: EnclosureSpecs.enclosure_layouts,
        front_style: EnclosureSpecs.front_styles._DEFAULT,
        rear_style: EnclosureSpecs.rear_styles._DEFAULT
    }
};

function DriveSet(C) {
    this.selectable = C.selectable;
    this.name = C.name;
    this.type = C.type;
    this.diskType = C.diskType;
    this.piType = C.piType;
    this.storagetierType = C.storagetierType;
    this.min = C.min;
    this.max = C.max;
    this.cssClass = C.cssClass;
    this.displayTotal = 0;
    this.selectedTotal = 0;
    this.displaySize = new Size();
    this.selectedSize = new Size();
    this.valid = "invalid";
    this.selected = [];
    this.display = [];
    this.predictedRaidOver = new Size();
    this.predictedAvail = new Size();
    this.predictedMeta = new Size();
    this.predictedBackoff = new Size();
    this.predictedMismatchWaste = new Size();
    if (this.type == "SPARE") {
        this.originalSpares = []
    }
}
DriveSet.prototype.outputStatus = function() {};
DriveSet.prototype.setSelectable = function(C) {
    this.selectable = C
};
DriveSet.prototype.setMin = function(C) {
    this.min = C
};
DriveSet.prototype.setMax = function(C) {
    this.max = C
};
DriveSet.prototype.getMax = function() {
    return this.max
};
DriveSet.prototype.getMin = function() {
    return this.min
};
DriveSet.prototype.getSelectedLength = function() {
    return this.selected.length
};
DriveSet.prototype.getSelectedTotal = function() {
    return this.selectedTotal
};
DriveSet.prototype.getDisplayLength = function() {
    return this.display.length
};
DriveSet.prototype.getDisplayTotal = function() {
    return this.displayTotal
};
DriveSet.prototype.setDiskType = function(C) {
    this.diskType = C
};
DriveSet.prototype.setPiType = function(C) {
    this.piType = C
};
DriveSet.prototype.setStoragetierType = function(C) {
    this.storagetierType = C
};
DriveSet.prototype.meterSegment = function(C, D, E) {
    var F = (D - 1) * (E + 3);
    return '<div class="' + C + '" style="width:' + E + "px; left:" + F + 'px;"><div style="width:' + E + 'px;">' + D + "</div></div>"
};
DriveSet.prototype.meter = function() {
    var C = 16;
    var H = (C + 3) * 16;
    var E = "";
    var D = this.display.length;
    var J = 1;
    for (var F = 0; F < D; F++) {
        E += this.meterSegment("diskDisplay", J, C);
        J++
    }
    var G = this.selected.length;
    var I = Math.max(G, this.max);
    for (var F = 0; F < I; F++) {
        if (!this.selectable) {
            var K = "diskDisplay"
        } else {
            if (F < G) {
                if (G < this.min) {
                    var K = "diskPresent"
                } else {
                    var K = "diskPresentOk"
                }
            } else {
                if (F < this.min) {
                    var K = "diskRequired"
                } else {
                    var K = "diskOptional"
                }
            }
        }
        E += this.meterSegment(K, J, C);
        J++
    }
    if (E.length == 0) {
        E = "&nbsp;"
    }
    return '<div class="diskMeter" style="overflow:visible; width: ' + H + 'px;">' + E + "</div>"
};
DriveSet.prototype.getSelected = function() {
    return new APIData(this.selected)
};
DriveSet.prototype.getDisplay = function() {
    return new APIData(this.display)
};
DriveSet.prototype.remainingSelectable = function() {
    if (this.selectable) {
        return this.max - this.selected.length
    }
    return 0
};
DriveSet.prototype.validate = function() {
    this.predictSpace();
    if (!this.selectable) {
        this.valid = "valid";
        return
    }
    if ((this.selected.length >= this.min) && (this.selected.length <= this.max)) {
        this.valid = "valid"
    } else {
        this.valid = "invalid"
    }
};
DriveSet.prototype.predictSpace = function(N) {
    this.predictedRaidOver.set(0, "blocks");
    this.predictedAvail.set(0, "blocks");
    this.predictedMeta.set(0, "blocks");
    this.predictedBackoff.set(0, "blocks");
    this.predictedMismatchWaste.set(0, "blocks");
    if (this.type == "spares") {
        return
    }
    var L = this.selected.length;
    var G = this.getMinDriveSize();
    if (N != undefined) {
        var C = N.getBlocks();
        if (G > C) {
            var J = G - C;
            G -= J
        }
    }
    var K = this.getWastedSpace(G);
    var O = this.type.substr(0, 5);
    switch (O) {
        case "NRAID":
        case "RAID0":
            break;
        case "RAID1":
        case "RAID3":
        case "RAID5":
            L--;
            this.predictedRaidOver.add(G, "blocks");
            break;
        case "RAID6":
            L -= 2;
            this.predictedRaidOver.add(G * 2, "blocks");
            break;
        case "ADAPT":
            L -= 2;
            break;
        default:
            break
    }
    if (L < 0) {
        L = 0
    }
    var H = L * G;
    var M = (G / 1000 * (1000 - system.backoffPercentage)) + (G % 1000 * (1000 - (system.backoffPercentage + 500)) / 1000);
    M = parseInt(M / 127) * 127;
    var F = L * M;
    var I = (L * system.vdiskMetaBlocksPerDisk);
    this.predictedBackoff.set(H - F, "blocks");
    this.predictedMeta.set(I, "blocks");
    this.predictedRaidOver.add(this.predictedMeta);
    this.predictedRaidOver.add(this.predictedBackoff);
    var D = this.selectedSize.getBlocks() - this.predictedRaidOver.getBlocks();
    if (D > 0) {
        this.predictedAvail.set(D, "blocks")
    }
    if (O != "ADAPT") {
        this.predictedMismatchWaste.set(K, "blocks");
        this.predictedAvail.subtract(this.predictedMismatchWaste)
    } else {
        var E = this.getAdaptOverHead();
        this.predictedRaidOver.add(E, "blocks");
        this.predictedAvail.subtract(this.predictedRaidOver)
    }
};
DriveSet.prototype.outputSet = function(C) {
    if (!checkforconsole()) {
        return
    }
    console.log("DriveSet: %s --------- %s", this.name, C);
    console.log("---------------------- Seleted: ");
    $.each(this.selected, function() {
        console.log("drive: %o", this)
    });
    console.log("---------------------- Display: ");
    $.each(this.display, function() {
        console.log("drive: %o", this)
    })
};
DriveSet.prototype.addDisplayDriveObject = function(C) {
    this.display[this.display.length] = C;
    this.displayTotal += parseInt(C.getPropertyValue("size"));
    this.displaySize.add(C)
};
DriveSet.prototype.addSelectedDriveObject = function(D, F) {
    this.selected[this.selected.length] = D;
    var C;
    if (D instanceof APIDrives) {
        C = D
    } else {
        C = DC.disks[D.key]
    }
    this.selectedTotal += parseInt(C.getPropertyValue("size"));
    this.selectedSize.add(C);
    var E = C.getPropertyValue("type");
    if (this.type == "SPARE" && F) {
        this.originalSpares.push(D)
    }
    if (this.diskType == "none") {
        this.piType = C.getPropertyValue("pi_formatted_numeric");
        this.storagetierType = C.getPropertyValue("storage_tier_numeric");
        this.diskType = E
    }
};
DriveSet.prototype._addSelectedDrive = function(F) {
    var H = false;
    var G = this.selected.length;
    if (G < this.max) {
        var C = F.key;
        var E = DC.disks[F.key].getPropertyValue("serial_number");
        var D = DC.disks[F.key];
        if (!this._findSelectedDrive(D)) {
            this.addSelectedDriveObject(D);
            H = true
        }
    }
    return H
};
DriveSet.prototype._removeSelectedDrive = function(D) {
    if (D instanceof APIDrives) {
        driveObject = D
    } else {
        driveObject = DC.disks[D.key]
    }
    var C = driveObject.getPropertyValue("serial_number");
    var F = this.selected.length;
    for (var E = 0; E < F; E++) {
        var G = this.selected[E].getPropertyValue("serial_number");
        if (G == C) {
            this.selectedTotal -= parseInt(this.selected[E].getPropertyValue("size"));
            this.selectedSize.subtract(driveObject);
            this.selected.splice(E, 1);
            return true
        }
    }
    return false
};
DriveSet.prototype._findSelectedDrive = function(D) {
    var C = D.getPropertyValue("serial_number");
    var F = this.selected.length;
    for (var E = 0; E < F; E++) {
        var G = this.selected[E].getPropertyValue("serial_number");
        if (G == C) {
            return this.selected[E]
        }
    }
    return null
};
DriveSet.prototype.getMinDriveSize = function() {
    var E = 0;
    for (var D = 0; D < this.selected.length; D++) {
        if (this.selected[D] instanceof APIDrives) {
            driveObject = this.selected[D]
        } else {
            driveObject = DC.disks[this.selected[D].key]
        }
        var C = parseInt(driveObject.getPropertyValue("blocks"), 10);
        if (E == 0 || C < E) {
            E = C
        }
    }
    for (var D = 0; D < this.display.length; D++) {
        var C = parseInt(this.display[D].getPropertyValue("blocks"), 10);
        if (E == 0 || C < E) {
            E = C
        }
    }
    return E
};
DriveSet.prototype.getAdaptOverHead = function() {
    var G = 0;
    var E = 0;
    for (var D = 0; D < this.selected.length; D++) {
        if (this.selected[D] instanceof APIDrives) {
            driveObject = this.selected[D]
        } else {
            driveObject = DC.disks[this.selected[D].key]
        }
        var C = parseInt(driveObject.getPropertyValue("blocks"), 10);
        if (C > G) {
            E = G;
            G = C
        } else {
            if (C > E) {
                E = C
            }
        }
    }
    var F = (this.predictedAvail.getBlocks() - (G + E)) * 0.2;
    if (F >= 0) {
        return (F + G + E)
    } else {
        return (G + E)
    }
};
DriveSet.prototype.getWastedSpace = function(E) {
    var F = 0;
    for (var D = 0; D < this.selected.length; D++) {
        if (this.selected[D] instanceof APIDrives) {
            driveObject = this.selected[D]
        } else {
            driveObject = DC.disks[this.selected[D].key]
        }
        var C = parseInt(driveObject.getPropertyValue("blocks"), 10);
        if (C > E) {
            F += (C - E)
        }
    }
    for (var D = 0; D < this.display.length; D++) {
        var C = parseInt(this.display[D].getPropertyValue("blocks"), 10);
        if (C > E) {
            F += (C - E)
        }
    }
    return F
};
DriveSet.prototype.addSelectedDrive = function(C) {
    var E = this;
    var D = false;
    if (C instanceof Array) {
        D = this._addSelectedDrive(C[C.length - 1])
    } else {
        D = this._addSelectedDrive(C)
    }
    this.validate();
    return D
};
DriveSet.prototype.addDrives = function(D) {
    var E = false;
    var F = this;
    if (D instanceof Array) {
        for (var C = 0; C < D.length; C++) {
            E = this._addSelectedDrive(D[C])
        }
    } else {
        E = this._addSelectedDrive(D)
    }
    this.validate();
    return E
};
DriveSet.prototype.removeSelectedDrive = function(C) {
    var D = false;
    if (C instanceof Array) {
        C = C[C.length - 1]
    }
    D = this._removeSelectedDrive(C);
    this.validate();
    return D
};
DriveSet.prototype.handleRetrieve = function(C) {
    if (this.name && C) {
        C[this.name] = this.getSelected()
    }
};
DriveSet.prototype.getMeta = function() {
    if (!DriveSet.prototype.metadata) {
        DriveSet.prototype.metadata = new APIObject([new APIProp({
            name: "type",
            value: strings.rack.typeCol
        }), new APIProp({
            name: "diskType",
            value: strings.rack.diskType
        }), new APIProp({
            name: "min",
            value: strings.rack.minimum
        }), new APIProp({
            name: "max",
            value: strings.rack.maximum
        }), new APIProp({
            name: "display",
            value: strings.rack.display
        }), new APIProp({
            name: "selected",
            value: strings.rack.selected
        }), new APIProp({
            name: "meter",
            value: strings.rack.meter
        }), new APIProp({
            name: "totalSize",
            value: strings.rack.Size
        }), new APIProp({
            name: "complete",
            value: strings.rack.complete
        })])
    }
    return DriveSet.prototype.metadata
};
DriveSet.prototype.getCell = function(D, C) {
    switch (C) {
        case "type":
            return D.type;
        case "diskType":
            if (D.diskType == "none" || D.diskType == "mixed") {
                return strings.rack[D.diskType]
            } else {
                return D.diskType
            }
            break;
        case "min":
            return D.min;
        case "max":
            return D.max;
        case "display":
            return D.display.length;
        case "selected":
            return D.selected.length;
        case "meter":
            return D.meter();
        case "totalSize":
            return (D.selectedTotal + D.displayTotal).toLocaleString() + "GB";
        case "complete":
            return (D.valid == "valid") ? D.completeBadge("diskSetComplete") : D.completeBadge("diskSetNotComplete");
        default:
            return "&nbsp;"
    }
    return "&nbsp;"
};
DriveSet.prototype.getCSSClass = function(D, C) {
    return D.cssClass
};
DriveSet.prototype.completeBadge = function(C) {
    return '<div class="' + C + '"><span class="healthText"></div>'
};

function DriveSelectionWidget(E) {
    if (arguments.length == 0) {
        return
    }
    this.name = E.name;
    E.orientation = "vertical";
    E.autoHeight = true;
    E.autoWidth = true;
    this.mode = "create";
    if (E.mode != undefined) {
        this.mode = E.mode
    }
    this.durable = "all";
    if (E.diskGroup != undefined) {
        this.diskGroup = E.diskGroup
    }
    this.expand = false;
    this.spares = false;
    this.diskGroupSerial = "";
    this.subArrays = 0;
    this.expandArrays = 0;
    if (E.raidType != undefined) {
        this.raidType = "nraid"
    } else {
        this.raidType = E.raidType
    }
    this.diskType = "none";
    this.piType = "";
    this.storagetierType = "";
    this.sets = [];
    this.currentSet = 0;
    this.totalSize = new Size();
    this.predictedRaidOver = new Size();
    this.predictedAvail = new Size();
    this.predictedMeta = new Size();
    this.predictedBackoff = new Size();
    this.predictedMismatchWaste = new Size();
    this.predictedSpares = new Size();
    this.deselectedSpare = [];
    this.deselectedDgSpare = [];
    if (DriveSelectionWidget.DEFAULT_MODE == "graphic") {
        var D = [{
            tabular: false
        }, {
            tabular: true
        }]
    } else {
        var D = [{
            tabular: true
        }, {
            tabular: false
        }]
    }
    E.widgets = [this.spaceTable = new TableWidget({
        maxCols: 4,
        classes: "driveSelectionCaption",
        widgets: [this.captionText = new TextWidget({
            name: "spaceText",
            width: 335
        }), this.predictCaption = new SpaceMeter({
            name: "spaceMeter",
            width: 370,
            height: 16,
            classes: "driveSelectionGraph"
        })]
    }), this.setsTable = new DataTable({
        name: "selectionTable",
        caption: "&nbsp;",
        bottomMargin: true,
        selecting: createObjectCallback(this, this.selectionTableCallBack)
    }), new FormWidget({
        name: "inputTable",
        widgets: [new TextWidget({
            name: "instructions",
            row: 0,
            col: 0,
            text: strings.addDiskGroup.instructions,
            bottomMargin: true,
            rightMargin: true
        }), new TextInputWidget({
            name: "range",
            row: 1,
            col: 1,
            label: strings.addDiskGroup.range,
            setOrig: true,
            labelOptions: {
                row: 0,
                col: 0,
                bottomMargin: true
            },
            bottomMargin: true,
            rightMargin: true,
            changeCallback: createObjectCallback(this, this.selectRange),
            rules: {
                validRange: true
            },
            tip: strings.addDiskGroup.rangeTip
        }), this.selectAll = new CheckboxInputWidget({
            name: "all",
            row: 2,
            col: 0,
            label: strings.fde.selectAll,
            bottomMargin: true,
            leftSmallMargin: true,
            singleCell: true,
            disable: false,
            changeCallback: createObjectCallback(this, this._selectAll),
            tip: strings.addDiskGroup.disableSelectAll
        })]
    }), this.disksTable = new TableInator({
        name: "disks",
        row: 4,
        col: 0,
        selectable: "multiple",
        type: "apiData",
        metadata: "drives",
        criteria: createObjectCallback(this, this._disksSelectionCriteria),
        fields: ["type", "enclosure_id", "slot", "size", "health"],
        dtOptions: {
            iDisplayLength: 15,
            bFilter: "noInput",
            bLengthChange: false,
            bInfo: true,
            bPaginate: true,
            aaSorting: [
                [1, "asc"],
                [2, "asc"]
            ],
            bDeferRender: false,
            fnFilterCallback: createObjectCallback(this, this._filterCallBack)
        },
        intercepts: [{
            selector: "health",
            renderer: TableInator.healthIntercept
        }],
        selectCallback: createObjectCallback(this, this._diskSelect)
    })];
    Arrangement.call(this, E);
    this.class_name = "DriveSelectionWidget";
    this.disksData = null;
    this.poolsData = null;
    var C = {};
    C[this.name] = E;
    this.update(C)
}
DriveSelectionWidget.prototype = new Arrangement();
DriveSelectionWidget.DEFAULT_MODE = "tabular";
DriveSelectionWidget.prototype.showing = function(C) {
    this.getData()
};
DriveSelectionWidget.prototype.getData = function() {
    this.disksData = null;
    this.poolsData = null;
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: this.durable,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.disksData = C;
            this.updateData({})
        })
    });
    this.poolsSubscription = MC.poolsSet.requestData({
        update: false,
        durable: this.durable,
        requestor: this.class_name,
        handler: createObjectCallback(this, function(C) {
            this.poolsData = C;
            this.updateData({})
        })
    })
};
DriveSelectionWidget.prototype._disksSelectionCriteria = function(D) {
    var C = D.getInt("usage_numeric");
    if (this.mode == "create" || this.mode == "expand") {
        switch (C) {
            case DRIVE_USAGE.AVAILABLE:
                return true;
                break;
            default:
                return false;
                break
        }
    }
    return false
};
DriveSelectionWidget.prototype.hiding = function() {
    if (this.disksSubscription) {
        MC.disksSet.unregister(this.disksSubscription);
        delete this.disksSubscription
    }
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.poolsSubscription);
        delete this.poolsSubscription
    }
};
DriveSelectionWidget.prototype.handleUpdate = function(F) {
    if (F.mode != undefined) {
        this.reconfigured = true;
        this.mode = F.mode
    }
    if (this.mode) {
        this.selectedDrives = 0
    }
    if (F.diskGroupType != undefined) {
        this.diskGroupType = F.diskGroupType
    }
    if (F.diskType != undefined) {
        this.diskType = F.diskType
    }
    if (F.expand != undefined) {
        this.expand = F.expand
    }
    if (F.spares != undefined) {
        this.spares = F.spares
    }
    if (F.subArrays != undefined) {
        this.subArrays = F.subArrays
    }
    if (F.expandArrays != undefined) {
        this.expandArrays = F.expandArrays
    }
    if (F.raidType != undefined) {
        this.raidType = F.raidType
    }
    if (F.diskGroupSerial != undefined) {
        this.diskGroupSerial = F.diskGroupSerial
    }
    if (F.all != undefined) {
        this.allValue = F.all
    }
    var E = false;
    if (F.disks != undefined) {
        E = true;
        this.disks = F.disks
    }
    if (F.spares != undefined) {
        E = true;
        this.spares = F.spares
    }
    for (var D = 1; D < 12; D++) {
        var C = "sub" + D;
        if (F[C]) {
            E = true;
            this[C] = F[C]
        }
    }
    if ((F.raidType != undefined) && !E) {
        this.disks = null;
        this.spares = null;
        for (var D = 1; D < 12; D++) {
            var C = "sub" + D;
            this[C] = null
        }
    }
    this.updateData(F)
};
DriveSelectionWidget.prototype.updateData = function(F) {
    if (MC.disksSet.pendingNotification(this.disksSubscription) || !this.disksData) {
        return
    }
    if (MC.poolsSet.pendingNotification(this.poolsSubscription) || !this.poolsData) {
        return
    }
    this.currentSet = 0;
    this.selectable = false;
    this.exclusive = false;
    this.display = false;
    this.create = false;
    this.modify = false;
    if (this.mode == "create") {
        this.selectable = true;
        this.create = true
    } else {
        this.display = true;
        if (this.mode == "expand") {
            this.selectable = true;
            this.modify = true
        }
        if (this.diskGroupSerial == "") {
            var G = this.disksData.getData().select({
                type: "prop",
                name: "usage_numeric",
                value: DRIVE_USAGE.GLOBAL_SPARE
            });
            this.numDisks = G.objects.length;
            this.raidType = "global sp"
        } else {
            var C = DC.diskGroupsSerial[this.diskGroupSerial];
            if (C) {
                var D = this.disksData.getData().select({
                    type: "prop",
                    name: "virtual_disk_serial",
                    value: this.diskGroupSerial
                });
                var E = D.objects[0];
                this.diskGroupType = STORAGE_TYPES[parseInt(C.get("storage_type_numeric"))];
                this.raidType = C.getPropertyValue("raidtype").toLowerCase();
                this.diskType = C.getPropertyValue("array_drive_type");
                this.piType = E.getPropertyValue("pi_formatted_numeric");
                this.storagetierType = E.getPropertyValue("storage_tier_numeric");
                this.numDisks = parseInt(C.getPropertyValue("diskcount"));
                this.numDrivesPerSub = parseInt(C.getPropertyValue("num_drives_per_low_level_array"));
                this.subArrays = this.numDisks / this.numDrivesPerSub
            }
        }
    }
    this.reconfigureSets(F);
    if ((this.disksTable.selected.length > 0) && (F.raidChange != undefined && !F.raidChange)) {
        this.updateSets(true)
    } else {
        this.updateSets()
    }
};
DriveSelectionWidget.prototype.reconfigureSets = function(P) {
    this.type = this.raidType;
    if (this.sets.length > 0 && !P.raidChange) {
        for (var S = 0; S < this.sets.length; S++) {
            if (this.sets[S].selected.length > 0) {
                return
            }
        }
    }
    this.sets = [];
    this.total = 0;
    this.totalSize.set(0, "blocks");
    this.usable = 0;
    this.valid = "valid";
    if (DriveSelectionWidget.prototype.raidTable == undefined) {
        DriveSelectionWidget.prototype.raidTable = {
            nraid: {
                min: 1,
                max: 1
            },
            raid0: {
                min: 2,
                max: 16
            },
            raid1: {
                min: 2,
                max: 2
            },
            raid3: {
                min: 3,
                max: 16
            },
            raid5: {
                min: 3,
                max: 16
            },
            raid6: {
                min: 4,
                max: 16
            },
            adapt: {
                min: 12,
                max: 128
            }
        }
    }
    var L = (this.mode == "create");
    var D = DriveSelectionWidget.prototype.raidTable[this.type];
    if (this.diskGroupType == "read-cache") {
        this.type = "read-cache";
        this.addSet(new DriveSet({
            selectable: L,
            diskType: this.diskType,
            piType: this.piType,
            storagetierType: this.storagetierType,
            name: "disks",
            type: this.type.toUpperCase(),
            min: (this.display ? 0 : 1),
            max: (this.display ? 0 : 2),
            cssClass: "diskH0"
        }))
    } else {
        if (D) {
            var Q = (this.display) ? 0 : D.min;
            var U = (this.display) ? 0 : D.max;
            this.addSet(new DriveSet({
                selectable: L,
                diskType: this.diskType,
                piType: this.piType,
                storagetierType: this.storagetierType,
                name: "disks",
                type: this.type.toUpperCase(),
                min: Q,
                max: U,
                cssClass: "diskH0"
            }))
        } else {
            if (this.type == "raid10") {
                var Q = (this.display) ? 0 : 2;
                var U = (this.display) ? 0 : 2;
                var G = this.subArrays;
                for (var V = 1; V <= G; V++) {
                    this.addSet(new DriveSet({
                        selectable: L,
                        diskType: this.diskType,
                        storagetierType: this.storagetierType,
                        piType: this.piType,
                        name: "sub" + V,
                        type: "RAID1-" + V,
                        min: Q,
                        max: U,
                        cssClass: "diskH" + (V - 1)
                    }))
                }
            } else {
                if (this.type == "raid50") {
                    var Q = (this.display) ? 0 : 3;
                    var U = (this.display) ? 0 : Math.floor(32 / this.subArrays);
                    var G = this.subArrays;
                    for (var V = 1; V <= G; V++) {
                        this.addSet(new DriveSet({
                            selectable: L,
                            diskType: this.diskType,
                            piType: this.piType,
                            storagetierType: this.storagetierType,
                            name: "sub" + V,
                            type: "RAID5-" + V,
                            min: Q,
                            max: U,
                            cssClass: "diskH" + (V - 1)
                        }))
                    }
                } else {
                    if (this.type == "global sp") {
                        this.diskType = "mixed";
                        this.addSet(new DriveSet({
                            selectable: true,
                            diskType: this.diskType,
                            piType: this.piType,
                            name: "disks",
                            type: this.type.toUpperCase(),
                            min: 0,
                            max: 16,
                            cssClass: "diskH0"
                        }))
                    }
                }
            }
        }
    }
    if (this.diskGroupType == "linear" && this.type != "nraid" && this.type != "raid0" && this.type != "global sp" && this.type != "adapt") {
        var U = (this.display) ? 0 : 4;
        this.addSet(new DriveSet({
            selectable: L,
            diskType: this.diskType,
            piType: this.piType,
            name: "spares",
            type: "SPARE",
            min: 0,
            max: U,
            cssClass: "diskH10"
        }))
    }
    var Y = this.disksData.getData();
    var E = Y.objects.length;
    var Z = (this.raidType == "raid10" || this.raidType == "raid50");
    for (var V = 0; V < E; V++) {
        var W = Y.objects[V];
        var O = W.getInt("usage_numeric");
        var X = W.getPropertyValue("virtual_disk_serial");
        if (this.type != "global sp" && X != this.diskGroupSerial) {
            continue
        }
        if (this.type == "global sp" && O != DRIVE_USAGE.GLOBAL_SPARE) {
            continue
        }
        if (this.display) {
            var F = "disks";
            if (O == DRIVE_USAGE.DEDICATED_SPARE) {
                F = "spares"
            } else {
                if (Z) {
                    var C = W.getPropertyValue("member_index");
                    var H = Math.floor(C / this.numDrivesPerSub);
                    F = "sub" + (H + 1)
                }
            }
            var M = this.getSetByName(F);
            if (M) {
                if (this.type == "global sp") {
                    M.addSelectedDriveObject(W)
                } else {
                    if (F == "spares") {
                        if (this.modify && this.spares) {
                            M.addSelectedDriveObject(W, true)
                        } else {
                            M.addDisplayDriveObject(W)
                        }
                    } else {
                        M.addDisplayDriveObject(W)
                    }
                }
            }
        }
    }
    if (this.modify || this.expand) {
        if (this.expand) {
            switch (this.type) {
                case "nraid":
                case "raid1":
                    var M = this.getSetByName("disks");
                    break;
                case "raid0":
                case "raid3":
                case "raid5":
                case "raid6":
                    var M = this.getSetByName("disks");
                    if (M) {
                        var N = M.getDisplayLength();
                        M.setMin(0);
                        var U = Math.min(4, 16 - N);
                        M.setSelectable(U > 0);
                        M.setMax(U)
                    }
                    break;
                case "adapt":
                    var M = this.getSetByName("disks");
                    if (M) {
                        var N = M.getDisplayLength();
                        M.setMin(0);
                        var U = DC.systemParameters.getInt("max_adapt_drives_per_disk_group");
                        M.setSelectable(U > 0);
                        M.setMax(U)
                    }
                    break;
                case "raid10":
                    var K = Math.min(this.expandArrays, 8 - this.subArrays);
                    for (var V = 0; V < K; V++) {
                        var T = this.sets.length;
                        this.insertSet(new DriveSet({
                            selectable: true,
                            diskType: this.diskType,
                            name: "sub" + T,
                            type: "RAID1-" + T,
                            min: 2,
                            max: 2,
                            cssClass: "diskH" + (T - 1)
                        }), T - 1)
                    }
                    break;
                case "raid50":
                    var J = this.sets[0].getDisplayLength();
                    var K = ((J * (this.subArrays + 1)) <= 32) ? 1 : 0;
                    if (K) {
                        var T = this.sets.length;
                        this.insertSet(new DriveSet({
                            selectable: true,
                            diskType: this.diskType,
                            name: "sub" + T,
                            type: "RAID5-" + T,
                            min: J,
                            max: J,
                            cssClass: "diskH" + (T - 1)
                        }), T - 1)
                    }
                    break;
                default:
                    break
            }
        }
        if (this.spares) {
            var M = this.getSetByName("spares");
            if (M) {
                M.setMin(0);
                M.setMax(4);
                M.setSelectable(true)
            }
        }
    }
    if (this.selectable) {
        this.selectableSets = new Array(this.sets.length);
        for (var V = 0; V < this.sets.length; V++) {
            var M = this.sets[V];
            this.selectableSets[V] = M.selectable;
            if (M.selectable) {
                var I = this[M.name];
                if (I && I instanceof APIData) {
                    for (var R = 0; R < I.objects.length; R++) {
                        M._addSelectedDrive(I.objects[R])
                    }
                }
            }
        }
    }
    this.reconfigured = true
};
DriveSelectionWidget.prototype.updateSets = function(M) {
    this.validate();
    var C = (this.valid == "invalid") ? strings.rack.completeNo : ((this.valid == "valid") ? strings.rack.completeYes : strings.rack.completeUnbalanced);
    var J = this.total.toLocaleString() + "GB";
    var N = this.usable.toLocaleString() + "GB";
    if (this.create || (this.modify && !this.spares)) {
        var L = '<br /><span class="textBold" >' + strings.driveSelection.caption1(C, this.totalSize.format()) + "</span>";
        if ((this.diskType == "SATA-S") || (this.diskType == "SAS-S")) {
            L += '<br /><span class="textBold" style="color:yellow">' + strings.driveSelection.singlePorted + "</>"
        }
    } else {
        var L = strings.driveSelection.caption2(this.totalSize.format())
    }
    var I = this.findFirstNonMax();
    if (this.mode == "create") {
        var H = ["type", "diskType", "selected", "min", "max", "totalSize", "complete"]
    } else {
        var H = ["type", "diskType", "selected", "max", "totalSize", "complete"]
    }
    var E = {
        spaceText: {
            text: L
        },
        spaceMeter: {
            segments: ((this.type == "global sp") ? [{
                cssClass: "spacePredictSpares",
                size: this.totalSize,
                label: strings.driveSelection.meterSparesTip
            }] : [{
                cssClass: "spacePredictAvail",
                size: this.predictedAvail,
                label: strings.driveSelection.meterAvailTip
            }, {
                cssClass: "spacePredictOver",
                size: this.predictedRaidOver,
                label: strings.driveSelection.meterOverTip
            }, {
                cssClass: "spacePredictSpares",
                size: this.predictedSpares,
                label: strings.driveSelection.meterSparesTip
            }, {
                cssClass: "spacePredictWaste",
                size: this.predictedMismatchWaste,
                label: strings.driveSelection.meterWasteTip
            }])
        },
        selectionTable: {
            selected: (this.selectable ? this.currentSet : false),
            grid: new BasicDataGrid({
                data: this.sets,
                meta: DriveSet.prototype.getMeta(),
                intercept: [{
                    selector: "type",
                    classHandler: DriveSet.prototype.getCSSClass
                }, {
                    dataHandler: DriveSet.prototype.getCell
                }],
                selectable: this.selectableSets,
                sortable: false,
                exclusive: true,
                filter: {
                    fields: H
                }
            })
        }
    };
    if (!this.isNonMax(this.currentSet)) {
        var I = this.findFirstNonMax();
        if (I >= 0) {
            E.selectionTable.selected = I
        }
    }
    var K = this.genFilters();
    if (K) {
        var O = MC.disksSet.data.select(K)
    } else {
        O = MC.disksSet.data
    }
    E.disks = {
        data: O.objects,
        select: this.selectedDrives
    };
    E.range = {
        disable: false
    };
    this.checkSelectAll(O.objects);
    if (this.mode != "globalsp") {
        this.checkSelectedDisks()
    } else {
        this.disableSelectAll = false
    }
    if (O.objects.length == 0) {
        this.valid = "invalid"
    }
    if ((this.disableSelectAll != undefined) && (this.disableSelectAll)) {
        E.all = {
            disable: true,
            value: 0
        }
    } else {
        if ((this.disableSelectAll != undefined) && (!this.disableSelectAll)) {
            E.all = {
                disable: false,
                value: 0
            }
        } else {
            E.all = {
                disable: true,
                value: 0
            }
        }
    }
    if (M != undefined && M) {
        this.spaceTable.update(E);
        this.setsTable.update(E)
    } else {
        this.update(E)
    }
    this.fireChange();
    if (this.mode == "modify") {
        var E = $("#disks").dataTable().fnGetData();
        var D = 0;
        for (var F = 0; F < this.sets.length; F++) {
            if (this.sets[F].type == "SPARE") {
                D = F;
                break
            }
        }
        for (var Q = 0; Q < E.length; Q++) {
            var P = E[Q].prop.durable_id.text;
            var G = DC.disks[P];
            if (E[Q].prop.usage_numeric.text == DRIVE_USAGE.DEDICATED_SPARE) {
                if (this.sets[D].selected.find(G) != -1) {
                    if ($.inArray(P, this.deselectedDgSpare) != -1) {
                        var I = $.inArray(P, this.deselectedDgSpare);
                        this.deselectedDgSpare.splice(I, 1)
                    }
                    this.disksTable._selectRow(Q)
                } else {
                    if ($.inArray(P, this.deselectedDgSpare) == -1) {
                        this.deselectedDgSpare.push(P)
                    }
                }
            }
        }
    }
    if (this.sets.length == 1) {
        $(".objectAltSelector").remove();
        $(".objectSelectorTitle").remove()
    }
};
DriveSelectionWidget.prototype.getValid = function() {
    if (this.valid == "valid") {
        return true
    } else {
        return false
    }
};
DriveSelectionWidget.prototype.checkSelectAll = function(G) {
    if ((this.typeFilterApplied != undefined) && (this.typeFilterApplied)) {
        if (this.typeFilterApplied) {
            this.disableSelectAll = false
        } else {
            var E = "";
            for (var D = 0; D < G.length; D++) {
                var F = G[D];
                var C = F.getPropertyValue("storage_tier_numeric");
                if (E == "") {
                    E = C
                }
                if (E != C) {
                    this.disableSelectAll = true;
                    break
                }
            }
        }
    }
};
DriveSelectionWidget.prototype.checkDriveMismatch = function(L) {
    var H = [];
    var G = "";
    for (var F = 0; F < L.length; F++) {
        var M = L[F].getProperty("durable_id").text;
        H.push(M)
    }
    if (this.disksTable.selected.length == 0) {
        var J = "";
        for (var F = 0; F < L.length; F++) {
            if (J.length == 0) {
                J = L[F].getProperty("storage_tier_numeric").text
            }
        }
    } else {
        for (var C = 0; C < this.sets.length; C++) {
            var I = this.getSet(C);
            for (var D = 0; D < I.selected.length; D++) {
                var K = I.selected[D];
                var E = K.getPropertyValue("durable_id");
                if ($.inArray(E, H) == -1) {
                    G = "invalid";
                    break
                }
            }
        }
        if (this.diskGroupType == "read-cache" && G == "invalid") {
            if (I.selected.length == 2) {
                if (I.selected[0].getInt("type_numeric") != TIERS.READCACHE && I.selected[1].getInt("type_numeric") != TIERS.READCACHE) {
                    return "invalidSSD"
                }
                if (I.selected[0].getInt("type_numeric") != I.selected[1].getInt("type_numeric")) {
                    return "invalid"
                }
            } else {
                if (I.selected[0].getInt("type_numeric") != TIERS.READCACHE) {
                    return "invalidSSD"
                }
            }
        }
    }
    return G
};
DriveSelectionWidget.prototype.checkSelectedDisks = function() {
    var E = this.genFilters(true);
    if (E) {
        var D = MC.disksSet.data.select(E)
    }
    var C = "";
    this.disableSelectAll = false;
    if (this.disksTable.selected.length > 0) {
        if (D.objects.length > 0) {
            C = this.checkDriveMismatch(D.objects)
        } else {
            C = "invalid"
        }
        if (C != "") {
            this.valid = "invalid";
            this.disableSelectAll = true
        }
    } else {
        if (D.objects.length == 0) {
            this.valid = "invalid"
        } else {
            if (this.disksTable.selected.length == 0) {
                if (this.checkDriveMismatch(D.objects) != "") {
                    this.disableSelectAll = true
                }
            }
        }
    }
    if (C == "invalid") {
        $(".panelError").empty();
        $(".panelError").append('<p class="error">' + strings.addDiskGroup.mixedTypeWarning + "</p>")
    } else {
        if (C == "invalidSSD") {
            $(".panelError").empty();
            $(".panelError").append('<p class="error">' + strings.addDiskGroup.invalidReadCaheDrive + "</p>")
        } else {
            $(".panelError").empty()
        }
    }
};
DriveSelectionWidget.prototype.handleRetrieve = function(E) {
    if (this.name && E) {
        var F = {};
        var C = 0;
        F.maxLimit = false;
        for (var D = 0; D < this.sets.length; D++) {
            this.sets[D].handleRetrieve(F);
            C = C + this.sets[D].max
        }
        F.totalSize = this.totalSize;
        F.predictedAvail = this.predictedAvail;
        F.predictedMeta = this.predictedMeta;
        F.predictedBackoff = this.predictedBackoff;
        F.predictedMismatchWaste = this.predictedMismatchWaste;
        F.predictedSpares = this.predictedSpares;
        F.diskType = this.diskType;
        F.valid = this.valid;
        if (this.selectedDrives.length > C) {
            F.maxLimit = true
        }
        E[this.name] = F
    }
    if (E.selectionTable) {
        delete E.selectionTable
    }
};
DriveSelectionWidget.prototype.selectionTableCallBack = function(D, C) {
    this.selectSet(D)
};
DriveSelectionWidget.prototype.findRow = function(C, E) {
    var D = $("#disks").dataTable();
    var F = parseInt(C.substr(C.lastIndexOf("_") + 1));
    var G = parseInt(C.substr(C.lastIndexOf(".") + 1));
    for (index = 0; index < E.length; index++) {
        if (D.fnGetData(E[index], 1) == F) {
            return index
        }
    }
    return -1
};
DriveSelectionWidget.prototype._filterCallBack = function(D) {
    if (D.aoPreSearchCols[0].sSearch != "") {
        this.disableSelectAll = false;
        this.typeFilterApplied = true;
        var C = {};
        C.all = {
            disable: false,
            value: 0
        };
        this.selectAll.update(C)
    } else {
        if (this.typeFilterApplied) {
            this.disableSelectAll = true;
            this.typeFilterApplied = false;
            var C = {};
            C.all = {
                disable: true,
                value: 0
            };
            this.selectAll.update(C)
        }
    }
};
DriveSelectionWidget.prototype._diskSelect = function(X, L) {
    var E = {};
    var O = [];
    var W = [];
    this.selectedDrives = X;
    var M = 0;
    applicationAccessed();
    var J = this.getSet(this.currentSet);
    var K = J.name.indexOf("sub") != -1 || this.type == "raid10" || this.type == "raid50";
    var U = $("#disks").dataTable();
    if (K) {
        for (var S = 0; S < this.sets.length; S++) {
            M += this.getSet(S).selected.length
        }
    }
    if (L != undefined && L) {
        var Q = $(L.currentTarget).hasClass("row_selected");
        if ((onMac && L.metaKey) || (L.ctrlKey && !L.shiftKey)) {
            if (!Q) {
                W.push(this.disksTable._getSelectObjFromRow(L.currentTarget));
                X = W;
                if (K) {
                    this.removeSubgroupDrives()
                } else {
                    var G = J.removeSelectedDrive(X);
                    if (!G) {
                        var V = this.disksTable._getSelectObjFromRow(L.currentTarget);
                        var R = DC.disks[V.key];
                        if (J._findSelectedDrive(R) == null) {
                            this.removeDrive(R)
                        }
                    }
                }
            } else {
                if (K || this.sets.length > 1) {
                    this.addDrivesSubset(X)
                } else {
                    this.verifyAndAddDrives(X, J)
                }
            }
        } else {
            if (J) {
                if (J.type == "SPARE") {
                    this.addDedicatedSpare(X)
                } else {
                    if (J.name != undefined && (K || this.sets.length > 1)) {
                        this.removeSubgroupDrives(X, L);
                        if (X.length == 1) {
                            this.addDisktoSubGroup(X)
                        } else {
                            this.addDrivesSubset(X)
                        }
                    } else {
                        var U = $("#disks").dataTable();
                        var F = 0;
                        var N = true;
                        var C = [];
                        for (var I = 0; I < J.selected.length; I++) {
                            C[I] = J.selected[I]
                        }
                        while (F < C.length) {
                            var D = C[F];
                            var P = D.getProperty("durable_id").text;
                            var H = U.fnFindCellRowIndexes(parseInt(P.substr(P.lastIndexOf(".") + 1)), 2);
                            if (H.length > 1) {
                                var Y = this.findRow(P, H);
                                if (Y != -1) {
                                    N = U.fnGetData(H[Y]).DT_isSelected
                                }
                            } else {
                                N = U.fnGetData(H[0]).DT_isSelected
                            }
                            if (!N) {
                                G = J.removeSelectedDrive(D)
                            }
                            F++
                        }
                        this.verifyAndAddDrives(X, J)
                    }
                }
            }
        }
        if (this.selectAll.currentValue) {
            var T = {
                all: {
                    value: false
                }
            };
            this.selectAll.update(T)
        }
    } else {
        if (K) {
            this.addDrivesSubset(X)
        } else {
            G = J.addDrives(X)
        }
    }
    this.updateSets(true)
};
DriveSelectionWidget.prototype.verifyAndAddDrives = function(F, I) {
    var K = $("#disks").dataTable();
    for (var H = 0; H < F.length; H++) {
        var J = F[H].key;
        var G = 0;
        var D = DC.disks[J];
        var C = K.fnFindCellRowIndexes(parseInt(J.substr(J.lastIndexOf(".") + 1)), 2);
        if (C.length > 1) {
            var G = this.findRow(J, C)
        }
        if (I.selected.length == 0) {
            I._addSelectedDrive(F[H])
        } else {
            if (I._findSelectedDrive(D) == null) {
                var E = I._addSelectedDrive(F[H]);
                if (!E) {
                    this.disksTable._unselectRow(C[G])
                }
            }
        }
    }
};
DriveSelectionWidget.prototype.addDedicatedSpare = function(F) {
    var K = $("#disks").dataTable();
    var J = this.getSet(this.currentSet);
    var I = 0;
    var D = [];
    for (var E = 0; E < J.selected.length; E++) {
        D[E] = J.selected[E]
    }
    if (D.length == 0 && J.originalSpares.length > 0) {
        for (var E = 0; E < J.originalSpares.length; E++) {
            D[E] = J.originalSpares[E]
        }
    }
    while (I < D.length) {
        var L = D[I];
        var G = -1;
        var M = L.getProperty("durable_id").text;
        var H = parseInt(L.getProperty("usage_numeric").text);
        var C = K.fnFindCellRowIndexes(parseInt(M.substr(M.lastIndexOf(".") + 1)));
        if (C.length > 1) {
            G = this.findRow(M, C)
        } else {
            G = 0
        }
        if (G != -1) {
            isRowSelected = K.fnGetData(C[G]).DT_isSelected
        }
        if (H != DRIVE_USAGE.DEDICATED_SPARE) {
            J.removeSelectedDrive(L)
        } else {
            if (H == DRIVE_USAGE.DEDICATED_SPARE) {
                if (!isRowSelected && ($.inArray(M, this.deselectedDgSpare) == -1)) {
                    this.disksTable._selectRow(C[G])
                } else {
                    J.removeSelectedDrive(L)
                }
            }
        }
        I++
    }
    F = this.removeOtherSetDrives(F);
    this.addSelectedDrives(F, J);
    this.updateSets(true)
};
DriveSelectionWidget.prototype.removeOtherSetDrives = function(H) {
    var G = 0;
    var E = [];
    for (var F = 0; F < H.length; F++) {
        var D = DC.disks[H[F].key];
        G = 0;
        while (G < this.sets.length) {
            if (G != this.currentSet) {
                var I = this.getSet(G);
                if (I._findSelectedDrive(D) != null) {
                    E.push(F)
                }
            }
            G++
        }
    }
    for (var C = E.length - 1; C >= 0; C--) {
        H.splice(E[C], 1)
    }
    return H
};
DriveSelectionWidget.prototype.addDisktoSubGroup = function(G) {
    var H = 0;
    var F = false;
    for (var E = 0; E < this.setsTable.grid.selection.length; E++) {
        if (this.setsTable.grid.selection[E]) {
            H = E;
            break
        }
    }
    var D = this.getSet(H);
    var C = DC.disks[G[0].key];
    for (var E = 0; E < this.sets.length; E++) {
        var I = this.getSet(E);
        if (I._findSelectedDrive(C) != null) {
            F = true;
            break
        }
    }
    if (!F) {
        D.addSelectedDrive(G)
    }
};
DriveSelectionWidget.prototype.addDrivesSubset = function(H) {
    var D = 0;
    var L = 0;
    var O = false;
    for (var I = 0; I < this.sets.length; I++) {
        var P = this.getSet(I);
        D += P.max
    }
    var J = [];
    for (var I = 0; I < H.length; I++) {
        var F = DC.disks[H[I].key];
        for (var C = 0; C < this.sets.length; C++) {
            var P = this.getSet(C);
            if (P._findSelectedDrive(F) != null) {
                O = false;
                break
            } else {
                O = true
            }
        }
        if (O) {
            J.push(H[I])
        }
    }
    var N = this.getSet(this.currentSet);
    for (var M = 0; M < N.max; M++) {
        if (J[L] != null && N.selected.length < N.max) {
            N._addSelectedDrive(J[L]);
            L++
        } else {
            break
        }
    }
    for (var I = 0; I < this.sets.length; I++) {
        var P = this.getSet(I);
        for (var K = 0; K < P.max; K++) {
            if (J[L] != null && P.selected.length < P.max) {
                P._addSelectedDrive(J[L]);
                L++
            } else {
                break
            }
        }
    }
    while (L < J.length) {
        var Q = $("#disks").dataTable();
        var R = J[L].key;
        var E = Q.fnFindCellRowIndexes(parseInt(R.substr(R.lastIndexOf(".") + 1)));
        if (E.length > 1) {
            var G = this.findRow(R, E);
            if (G != -1) {
                this.disksTable._unselectRow(E[G])
            }
        } else {
            this.disksTable._unselectRow(E[0])
        }
        L++
    }
};
DriveSelectionWidget.prototype.addSelectedDrives = function(G, I) {
    for (var D = 0; D < G.length; D++) {
        success = I._addSelectedDrive(G[D]);
        if (!success) {
            var F = $("#disks").dataTable();
            var C = G[D].key;
            var H = F.fnFindCellRowIndexes(parseInt(C.substr(C.lastIndexOf(".") + 1)));
            if (H.length > 1) {
                var E = this.findRow(C, H);
                if (E != -1) {
                    this.disksTable._unselectRow(H[E])
                }
            } else {
                this.disksTable._unselectRow(H[0])
            }
        }
        this.selectedDrives = I.selected
    }
    I.validate()
};
DriveSelectionWidget.prototype.removeSubgroupDrives = function(H, L) {
    for (var I = 0; I < this.sets.length; I++) {
        var K = this.getSet(I);
        var N = $("#disks").dataTable();
        var J = 0;
        var C;
        var E = [];
        for (var F = 0; F < K.selected.length; F++) {
            E[F] = K.selected[F]
        }
        while (E[J] != null) {
            var M = E[J];
            var O = M.getProperty("durable_id").text;
            var D = N.fnFindCellRowIndexes(parseInt(O.substr(O.lastIndexOf(".") + 1)));
            if (D.length > 1) {
                var G = this.findRow(O, D);
                if (G != -1) {
                    C = N.fnGetData(D[G]).DT_isSelected
                }
            } else {
                C = N.fnGetData(D[0]).DT_isSelected
            }
            if (!C) {
                K.removeSelectedDrive(M)
            }
            J++
        }
    }
};
DriveSelectionWidget.prototype.removeDrive = function(D) {
    for (var C = 0; C < this.sets.length; C++) {
        if (!C == this.currentSet) {
            var E = this.getSet(C);
            if (E._findSelectedDrive(D) != null) {
                E.removeSelectedDrive(D);
                break
            }
        }
    }
};
DriveSelectionWidget.prototype._selectAll = function(N, J, K) {
    var P = $("#disks").dataTable();
    var L = this.disksTable.dataTable.fnGetFilteredNodes();
    var H = this.disksTable.dataTable.fnGetData();
    var D = this.disksTable.dataTable[0].rows.length - 1;
    var O = 0;
    if (L.length == H.length) {
        for (var G = O; G < L.length; G++) {
            var R = this.disksTable._selectRow(G)
        }
    }
    if (N.all.value) {
        for (var F = 0; F < L.length; F++) {
            var C = L[F].id;
            var Q = C.substr(C.lastIndexOf("_") + 1);
            var I = parseInt(Q.substr(0, 2));
            var M = parseInt(Q.substr(Q.lastIndexOf(".") + 1));
            var E = P.fnFindCellRowIndexes(M, 2);
            if (E.length > 1) {
                for (index = 0; index < E.length; index++) {
                    if (P.fnGetData(E[index], 1) == I) {
                        this.disksTable._selectRow(E[index]);
                        break
                    }
                }
            } else {
                this.disksTable._selectRow(E[0])
            }
        }
        this.disksTable.options.selectCallback(this.disksTable.selected)
    } else {
        this.clearDisks()
    }
};
DriveSelectionWidget.prototype.clearDisks = function() {
    this.disksTable._clearSelectAll();
    var F = [];
    for (var D = 0; D < this.sets.length; D++) {
        var H = this.getSet(D);
        if (this.mode != "create") {
            for (var G = 0; G < H.selected.length; G++) {
                F[G] = H.selected[G]
            }
            for (var C = 0; C < F.length; C++) {
                H.removeSelectedDrive(F[C])
            }
        } else {
            while (H.selected.length > 0) {
                H.removeSelectedDrive(H.selected[0])
            }
        }
    }
    this.updateSets(true);
    if (this.selectAll.currentValue) {
        var E = {
            all: {
                value: false
            }
        };
        this.selectAll.update(E)
    }
};
DriveSelectionWidget.prototype.selectSpares = function(D) {
    var F = $("#disks").dataTable();
    var C = D.get("durable_id");
    var E = 0;
    var G = F.fnFindCellRowIndexes(parseInt(C.substr(C.lastIndexOf(".") + 1)), 2);
    if (G.length > 1) {
        E = this.findRow(C, G);
        if (E != -1) {
            isRowSelected = F.fnGetData(G[E]).DT_isSelected
        }
    } else {
        isRowSelected = F.fnGetData(G[0]).DT_isSelected;
        E = 0
    }
    if (!isRowSelected) {
        this.disksTable._selectRow(G[E])
    }
};
DriveSelectionWidget.prototype.selectRange = function(O, H, I) {
    var Q = $("#disks").dataTable();
    if (I.type == "focusout" && O.range.value != "") {
        this.clearDisks();
        var J = O.range.value;
        var C = J.split(",");
        for (i = 0; i < C.length; i++) {
            var P = C[i].split("-");
            if (P.length == 1) {
                var K = P[0].trim().split(".");
                var G = K[0].trim();
                var N = K[1].trim();
                var E = Q.fnFindCellRowIndexes(parseInt(N), 2);
                if (E.length > 1) {
                    for (index = 0; index < E.length; index++) {
                        if (parseInt(Q.fnGetData(E[index], 1)) == parseInt(G)) {
                            this.disksTable._selectRow(E[index]);
                            break
                        }
                    }
                } else {
                    if (E.length == 1) {
                        this.disksTable._selectRow(E[0])
                    }
                }
                this.disksTable.options.selectCallback(this.disksTable.selected)
            } else {
                var M = P[0].trim();
                var F = M.split(".");
                var G = F[0].trim();
                var D = F[1].trim();
                var L = P[1].trim();
                this.selectDrives(G, D, L)
            }
        }
        this.updateSets(true)
    }
};
DriveSelectionWidget.prototype.selectDrives = function(E, C, G) {
    var I = MC.disksSet.select({
        type: "prop",
        name: "usage_numeric",
        value: DRIVE_USAGE.AVAILABLE
    });
    var H = $("#disks").dataTable();
    var D = $("#disks").dataTable().fnGetData();
    var K;
    if (I.objects.length > 0) {
        while (parseInt(C) <= parseInt(G)) {
            var F = E + "." + C;
            for (var J = 0; J < D.length; J++) {
                if (D[J].prop.location.text == F) {
                    this.disksTable._selectRow(J);
                    break
                }
            }
            C++
        }
        this.disksTable.options.selectCallback(this.disksTable.selected)
    }
};
DriveSelectionWidget.prototype.selectSet = function(C) {
    if (C >= 0 && C < this.length()) {
        this.currentSet = C
    }
};
DriveSelectionWidget.prototype.fireChange = function() {
    if ($.isFunction(this.options.changeCallback)) {
        var C = {};
        if (this.name) {
            this.handleRetrieve(C)
        }
        this.options.changeCallback.call(this, C, this)
    }
};
DriveSelectionWidget.prototype.genFilters = function(G) {
    var C = [{
        filterAll: true,
        options: {
            selectable: false,
            selected: false,
            highlights: "",
            text: false,
            inactive: true
        }
    }];
    var E = {};
    var D = licenseInfo.isLicensed("performance_tier");
    var I = RI.hasFeature("allFlashArray");
    var F = propertyCount(DC.diskGroups);
    var H = [];
    if (this.selectable) {
        if (this.mode == "modify") {
            H.push({
                type: "OR",
                conditions: [{
                    type: "prop",
                    name: "usage_numeric",
                    value: DRIVE_USAGE.AVAILABLE
                }, {
                    type: "prop",
                    name: "usage_numeric",
                    value: DRIVE_USAGE.DEDICATED_SPARE
                }]
            })
        } else {
            H.push({
                type: "prop",
                name: "usage_numeric",
                value: DRIVE_USAGE.AVAILABLE
            })
        }
        if ((G != undefined) && G) {
            if (this.storagetierType == TIERS.READCACHE || this.storagetierType == TIERS.PERFORMANCE || this.diskGroupType == "read-cache") {
                H.push({
                    type: "OR",
                    conditions: [{
                        type: "prop",
                        name: "storage_tier_numeric",
                        value: TIERS.PERFORMANCE
                    }, {
                        type: "prop",
                        name: "storage_tier_numeric",
                        value: TIERS.READCACHE
                    }]
                })
            } else {
                if (this.storagetierType != undefined && this.storagetierType != "") {
                    H.push({
                        type: "prop",
                        name: "storage_tier_numeric",
                        value: this.storagetierType
                    })
                }
            }
        }
        if (RI.hasFeature("e2ePi") && this.piType != "") {
            if (this.piType == PI_TYPES.T0 || this.piType == PI_TYPES.UNSUPPORTED) {
                H.push({
                    type: "OR",
                    conditions: [{
                        type: "prop",
                        name: "pi_formatted_numeric",
                        value: PI_TYPES.T0
                    }, {
                        type: "prop",
                        name: "pi_formatted_numeric",
                        value: PI_TYPES.UNSUPPORTED
                    }]
                })
            } else {
                H.push({
                    type: "prop",
                    name: "pi_formatted_numeric",
                    value: this.piType
                })
            }
        }
    }
    if (H != undefined && H.length > 0) {
        H = {
            type: "AND",
            conditions: H
        };
        return H
    }
    return false
};
DriveSelectionWidget.prototype.addSet = function(C) {
    this.sets[this.sets.length] = C
};
DriveSelectionWidget.prototype.insertSet = function(D, C) {
    this.sets.splice(C, 0, D)
};
DriveSelectionWidget.prototype.length = function() {
    return this.sets.length
};
DriveSelectionWidget.prototype.getSet = function(C) {
    if (C >= 0 && C < this.sets.length) {
        return this.sets[C]
    }
    return null
};
DriveSelectionWidget.prototype.getSetByName = function(C) {
    var E = this.sets.length;
    for (var D = 0; D < E; D++) {
        if (this.sets[D].name == C) {
            return this.sets[D]
        }
    }
    return null
};
DriveSelectionWidget.prototype.validate = function(K) {
    if (K != undefined) {
        var N = this.getSet(K);
        if (N) {
            N.validate()
        }
        return
    }
    this.totalDrives = 0;
    this.total = 0;
    this.totalSize.set(0, "blocks");
    this.usable = 0;
    this.valid = "valid";
    var D = "none";
    var G = "";
    var L = "";
    var M = 0;
    var H = 128;
    var E = this.sets.length;
    var F = this.anySelectable;
    var C = 0;
    for (var I = 0; I < this.sets.length; I++) {
        var N = this.sets[I];
        N.validate();
        this.totalDrives += N.getSelectedLength() + N.getDisplayLength();
        this.total += N.getSelectedTotal() + N.getDisplayTotal();
        this.totalSize.add(N.selectedSize);
        this.totalSize.add(N.displaySize);
        if (N.diskType != D && N.diskType != "none") {
            D = N.diskType
        }
        if (N.piType != G && N.piType != "") {
            G = N.piType
        }
        if ((N.storagetierType != L) && (N.storagetierType != "")) {
            L = N.storagetierType
        }
        if (N.name != "spares") {
            var J = Math.max(N.getSelectedLength(), N.getDisplayLength());
            M = Math.max(M, J);
            H = Math.min(H, J)
        }
        C += N.remainingSelectable();
        if (N.valid == "invalid") {
            this.valid = "invalid"
        }
    }
    this.predictSpace();
    if (!this.spares && this.valid == "valid" && M != H) {
        this.valid = "unbalanced"
    }
    this.anySelectable = (C > 0);
    if (F != this.anySelectable) {
        this.reconfigured = true
    }
    if (this.create) {
        if (this.totalDrives == 0) {
            if (this.diskType != "mixed" && this.diskGroupType != "read-cache") {
                D = "none";
                G = "";
                for (var I = 0; I < this.sets.length; I++) {
                    this.sets[I].setDiskType(D);
                    this.sets[I].setPiType(G);
                    this.sets[I].setStoragetierType(L)
                }
            }
        } else {
            if (this.totalDrives == 1) {
                var O = DC.disks[this.disksTable.selected[0].key];
                D = O.getPropertyValue("type");
                G = O.getPropertyValue("pi_formatted_numeric");
                L = O.getPropertyValue("storage_tier_numeric");
                for (var I = 0; I < this.sets.length; I++) {
                    this.sets[I].setDiskType(D);
                    this.sets[I].setPiType(G);
                    this.sets[I].setStoragetierType(L)
                }
            }
        }
        if (this.diskType != D) {
            this.reconfigured = true
        }
        this.diskType = D;
        this.piType = G;
        this.storagetierType = L
    }
};
DriveSelectionWidget.prototype.predictSpace = function() {
    this.predictedRaidOver.set(0, "blocks");
    this.predictedAvail.set(0, "blocks");
    this.predictedMeta.set(0, "blocks");
    this.predictedBackoff.set(0, "blocks");
    this.predictedMismatchWaste.set(0, "blocks");
    this.predictedSpares.set(0, "blocks");
    var E;
    if ((this.type == "raid10") || (this.type == "raid50")) {
        for (var D = 0; D < this.sets.length; D++) {
            if ((this.sets[D].name.substr(0, 3) == "sub") && (this.sets[D].predictedAvail.value > 0)) {
                if ((E == undefined) || (this.sets[D].predictedAvail.value < E.predictedAvail.value)) {
                    E = this.sets[D]
                }
            }
        }
    }
    for (var D = 0; D < this.sets.length; D++) {
        var F = this.sets[D];
        switch (F.name) {
            case "disks":
                this.predictedRaidOver.set(F.predictedRaidOver);
                this.predictedAvail.set(F.predictedAvail);
                this.predictedMeta.set(F.predictedMeta);
                this.predictedBackoff.set(F.predictedBackoff);
                this.predictedMismatchWaste.set(F.predictedMismatchWaste);
                break;
            case "spares":
                this.predictedSpares.set(F.displaySize);
                this.predictedSpares.add(F.selectedSize);
                break;
            default:
                if (F.name.substr(0, 3) == "sub") {
                    if (F.predictedAvail.value > 0) {
                        if (F.predictedAvail.value > E.predictedAvail.value) {
                            F.predictSpace(E.predictedRaidOver)
                        }
                    }
                    this.predictedRaidOver.add(F.predictedRaidOver);
                    this.predictedAvail.add(F.predictedAvail);
                    this.predictedMeta.add(F.predictedMeta);
                    this.predictedBackoff.add(F.predictedBackoff);
                    this.predictedMismatchWaste.add(F.predictedMismatchWaste)
                }
                break
        }
    }
    var C = new Size(system.vdiskMetaBlocks, "blocks");
    this.predictedMeta.add(C);
    this.predictedAvail.subtract(C);
    if (this.predictedAvail.value < 0) {
        this.predictedAvail.set(0, "blocks")
    }
};
DriveSelectionWidget.prototype.isNonMax = function(C) {
    if (C >= 0 && C < this.sets.length) {
        return (this.sets[C].getSelectedLength() < this.sets[C].getMax())
    }
    return false
};
DriveSelectionWidget.prototype.findFirstNonMax = function() {
    for (var C = 0; C < this.sets.length; C++) {
        if (this.sets[C].getSelectedLength() < this.sets[C].getMax()) {
            return C
        }
    }
    return -1
};

function HostsTopic(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "HostsTopic";
    this.selectedInits = [];
    this.selectedMaps = [];
    this.firstTime = true;
    var C = meta.initiator;
    D.widgets = new TableWidget({
        classes: "center10",
        widgets: [new TableInator({
            row: 0,
            col: 0,
            name: "tHostsInits",
            minWidth: 880,
            cellClasses: "verticalTop",
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this._initSelected),
            bottomMargin: true,
            type: "rawData",
            rawBasetype: "initiator",
            metadata: [{
                sTitle: "Durable ID",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.hostsTopic.groupCol,
                bFilterMenu: true
            }, {
                sTitle: strings.hostsTopic.hostCol,
                bFilterMenu: true
            }, {
                sTitle: strings.hostsTopic.nickname,
                bFilterMenu: {
                    numItems: 0
                }
            }, {
                sTitle: strings.ID,
                bFilterMenu: {
                    numItems: 0
                }
            }, {
                sTitle: strings.hostsTopic.profile
            }, {
                sTitle: strings.hostsTopic.discovered,
                bFilterMenu: {
                    allowSingles: true
                }
            }, {
                sTitle: strings.hostsTopic.mapped,
                bFilterMenu: {
                    allowSingles: true
                }
            }, {
                sTitle: strings.hostsTopic.hosttype,
                bFilterMenu: true
            }],
            dtOptions: {
                aaSorting: [
                    [1, "asc"],
                    [2, "asc"],
                    [3, "asc"]
                ]
            }
        }), new WidgetContainer({
            row: 1,
            col: 0,
            name: "mapsContainer",
            widgets: [new TextWidget({
                text: strings.hostsTopic.relatedMaps,
                classes: "topicSubtitle topicExtraTopMargin",
                bottomSmallMargin: true
            }), new TableInator({
                name: "tHostsMaps",
                minWidth: 650,
                cellClasses: "verticalTop",
                displayLength: 20,
                type: "rawData",
                metadata: [{
                    sTitle: "basetype",
                    bVisible: false,
                    bIsBasetype: true
                }, {
                    sTitle: "id",
                    bVisible: false,
                    bIsKey: true
                }, {
                    sTitle: strings.mappingTopic.hostCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.mappingTopic.volumeCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.mappingTopic.accessCol,
                    bFilterMenu: {
                        allowSingles: true
                    }
                }, {
                    sTitle: strings.mappingTopic.lunCol,
                    bFilterMenu: {
                        numItems: 0
                    }
                }, {
                    sTitle: strings.mappingTopic.portsCol,
                    bFilterMenu: {
                        list: ["0", "1", "2", "3"]
                    }
                }],
                selectable: "multiple",
                selectCallback: createObjectCallback(this, this._mapSelected),
                dtOptions: {
                    aaSorting: [
                        [2, "asc"],
                        [3, "asc"]
                    ]
                }
            })]
        })]
    });
    TopicPanel.call(this, D);
    this.class_name = "HostsTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }));
    $(".dataTables_length", this.elements).change(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
HostsTopic.prototype = new TopicPanel();
HostsTopic.prototype.constructor = HostsTopic;
HostsTopic.prototype.showing = function() {
    TopicPanel.selection.empty();
    this.mapsVisible = true;
    var C = {
        tHostsInits: {
            displayLength: (this.mapsVisible ? 10 : 20)
        },
        mapsContainer: {
            visibility: (this.mapsVisible ? "visible" : "hidden")
        }
    };
    this.update(C);
    this.hostGroupsSubscription = MC.hostGroupsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.mapsSubscription = MC.mapsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.bindContextMenu()
};
HostsTopic.prototype.hiding = function() {
    if (this.hostGroupsSubscription) {
        MC.hostGroupsSet.unregister(this.hostGroupsSubscription);
        delete this.hostGroupsSubscription
    }
    if (this.mapsSubscription) {
        MC.mapsSet.unregister(this.mapsSubscription);
        delete this.mapsSubscription
    }
    this.unBindContextMenu()
};
HostsTopic.prototype._refreshData = function() {
    var C = this._getInitData();
    var D = {
        tHostsInits: {
            data: C,
            select: this.selectedInits,
            redraw: (C.length ? keepCurrentPage : "")
        }
    };
    this.update(D);
    this._updateMaps();
    this.bindContextMenu();
    this._setTopicSelects()
};
HostsTopic.prototype._getInitData = function() {
    var G = [];
    var F, C, D;
    for (var E in DC.initiators) {
        F = DC.initiators[E];
        C = DC.hostsSerial[F.get("host_id")];
        groupID = C.get("host_group");
        D = DC.hostGroupsSerial[C.get("host_group")];
        G.push([F.get("durable_id"), D.get("name") == strings.hostUnGrouped ? "--" : D.get("name"), C.get("name") == strings.hostNotGrouped ? "--" : C.get("name"), F.get("nickname"), F.get("id"), F.get("profile"), F.get("discovered"), F.get("mapped"), F.get("host_bus_type")])
    }
    return G
};
HostsTopic.prototype._mapsCriteria = function(C) {
    return false
};
HostsTopic.prototype._setTopicSelects = function() {
    TopicPanel.selection.empty();
    $.merge(TopicPanel.selection, this.selectedInits);
    $.merge(TopicPanel.selection, this.selectedMaps)
};
HostsTopic.prototype._initSelected = function(C) {
    this.selectedInits = C;
    this.selectedMaps = [];
    if (this.mapsVisible) {
        this._updateMaps()
    }
    this._setTopicSelects()
};
HostsTopic.prototype._updateMaps = function() {
    var N = [];
    var M = {};
    for (var R = 0; R < this.selectedInits.length; R++) {
        var Q = this.selectedInits[R].getObject();
        this._addMaps(M, Q);
        var C = Q.get("host_id");
        if (C && C != "NOHOST") {
            var L = DC.hostsSerial[C];
            this._addMaps(M, L);
            var E = L.get("host_group");
            if (E && E != "UNGROUPEDHOSTS") {
                var I = DC.hostGroupsSerial[E];
                this._addMaps(M, I)
            }
        }
    }
    var L, S, K, G, P;
    for (var D in M) {
        var T = M[D];
        var S = "-";
        var J = T.get("parent_id");
        if (T instanceof APIVolumeGroupViewMappings) {
            S = DC.volGroupViewsId[J].get("group_name")
        } else {
            S = DC.volViewsId[J].get("volume_name")
        }
        var H = T.basetype;
        var O = T.getKeyValue();
        var L = T.getHostName();
        var F = T.get("access");
        var G = T.get("lun") || "*";
        var P = T.get("ports");
        N.push([H, O, L, S, F, G, P])
    }
    this.update({
        tHostsMaps: {
            data: N
        }
    })
};
HostsTopic.prototype._addMaps = function(H, G) {
    if (!H || !G) {
        return
    }
    var C = {
        groupMaps: true,
        maps: true
    };
    for (var E in C) {
        if (G[E]) {
            for (var D in G[E]) {
                var F = G[E][D];
                if (!H[D]) {
                    H[D] = F
                }
            }
        }
    }
};
HostsTopic.prototype._mapSelected = function(C) {
    this.selectedMaps = C;
    this._setTopicSelects()
};
HostsTopic.prototype.bindContextMenu = function() {
    $("tr", "#tHostsInits > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu))
};
HostsTopic.prototype.unBindContextMenu = function() {
    $("tr", "#tHostsInits > tbody").off("contextmenu");
    panels.contextMenu.close()
};
HostsTopic.prototype.openContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "HostsTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};

function PoolsTopic(G) {
    G.name = "PoolsTopic";
    this.selectedPools = [];
    this.selectedDiskGroups = [];
    var F = 3;
    var D = ["name", "health_numeric", "total_size", "total_avail", "volumes", "disk_groups"];
    var C = {
        name: {
            sTitle: strings.Name,
            bFilterMenu: {
                numItems: 0
            }
        },
        health_numeric: {
            sTitle: strings.poolsTopic.health,
            sType: "string",
            bFilterMenu: {
                allowSingles: true
            }
        },
        total_size: {
            sTitle: strings.Size,
            bFilterMenu: false
        },
        total_avail: {
            sTitle: strings.poolsTopic.avail,
            bFilterMenu: false
        },
        volumes: {
            sTitle: strings.Volumes,
            bFilterMenu: false
        },
        disk_groups: {
            sTitle: strings.DiskGroups,
            bFilterMenu: false
        }
    };
    var I = 4;
    var H = ["name", "health_numeric", "pool", "raidtype", "array_drive_type", "size", "freespace", "job_running", "status", "diskcount"];
    var E = {
        name: {
            sTitle: strings.Name,
            bFilterMenu: {
                numItems: 0
            }
        },
        health_numeric: {
            sTitle: strings.poolsTopic.health,
            sType: "string",
            bFilterMenu: {
                allowSingles: true
            }
        },
        pool: {
            sTitle: strings.Pool,
            bFilterMenu: {
                allowSingles: true
            }
        },
        size: {
            sTitle: strings.Size,
            bFilterMenu: false
        },
        freespace: {
            sTitle: strings.poolsTopic.free,
            bFilterMenu: false
        },
        job_running: {
            sTitle: strings.poolsTopic.currentjob,
            bFilterMenu: {
                allowSingles: true
            }
        },
        status: {
            sTitle: strings.poolsTopic.status
        },
        diskcount: {
            sTitle: strings.poolsTopic.disks,
            bFilterMenu: false
        }
    };
    if (RI.feature("storageModel") == "HYBRID") {
        D.splice(F, 0, "storage_type");
        H.splice(I, 0, "storage_type");
        C.storage_type = {
            sTitle: strings.poolsTopic.storagetype,
            bFilterMenu: {
                allowSingles: true
            }
        };
        E.storage_type = {
            sTitle: strings.poolsTopic.storagetype,
            bFilterMenu: {
                allowSingles: true
            }
        }
    }
    G.widgets = new TableWidget({
        name: "poolsTopicTable",
        maxCols: 1,
        classes: "center10",
        widgets: [new TableInator({
            name: "tPoolsPools",
            minWidth: 880,
            displayLength: -1,
            cellClasses: "verticalTop",
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this._poolSelected),
            bottomMargin: true,
            topSmallMargin: true,
            type: "dcCollection",
            metadata: "pools",
            data: DC.poolsSerial,
            fields: D,
            columnOverrides: C,
            emptyTableString: strings.poolsTopic.noPools,
            hoverPanel: panels.PoolHover
        }), new TextWidget({
            text: strings.poolsTopic.diskGroupsTitle,
            classes: "topicSubtitle topicExtraTopMargin",
            bottomSmallMargin: true
        }), new TableInator({
            name: "tPoolsDiskGroups",
            minWidth: 880,
            displayLength: -1,
            cellClasses: "alignTop",
            selectable: "multiple",
            criteria: createObjectCallback(this, this._diskGroupsCriteria),
            bottomMargin: true,
            type: "dcCollection",
            metadata: "disk-groups",
            data: DC.diskGroupsSerial,
            fields: H,
            columnOverrides: E,
            intercepts: [{
                selector: "job_running",
                renderer: this._dgJobIntercept
            }, {
                selector: "array_drive_type",
                renderer: this._driveTypeIntercept
            }],
            selectCallback: createObjectCallback(this, this._diskGroupSelected),
            hoverPanel: panels.DiskGroupHover
        }), new TextWidget({
            text: strings.poolsTopic.disksTitle,
            classes: "topicSubtitle topicExtraTopMargin",
            bottomSmallMargin: true
        }), new TableInator({
            name: "tPoolsDisks",
            minWidth: 880,
            displayLength: -1,
            cellClasses: "alignTop",
            selectable: false,
            criteria: createObjectCallback(this, this._disksCriteria),
            bottomMargin: true,
            type: "dcCollection",
            metadata: "drives",
            data: DC.disks,
            fields: ["location", "health_numeric", "description", "size", "usage", "index", "status"],
            columnOverrides: {
                location: {
                    sTitle: strings.poolsTopic.location,
                    bFilterMenu: {
                        numItems: 0
                    }
                },
                health_numeric: {
                    sTitle: strings.poolsTopic.health,
                    sType: "string",
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                description: {
                    sTitle: strings.Description
                },
                size: {
                    sTitle: strings.Size,
                    bFilterMenu: false
                },
                usage: {
                    sTitle: strings.poolsTopic.usage,
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                index: {
                    sTitle: strings.DiskGroup,
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                status: {
                    sTitle: strings.poolsTopic.status,
                    bFilterMenu: {
                        allowSingles: true
                    }
                }
            },
            intercepts: [{
                selector: 1,
                renderer: TableInator.healthIntercept
            }, {
                selector: "index",
                renderer: this._indexIntercept
            }],
            hoverPanel: APIObject.getHover("drives")
        })]
    });
    TopicPanel.call(this, G);
    this.class_name = "PoolsTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }));
    $(".dataTables_length", this.elements).change(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
PoolsTopic.prototype = new TopicPanel();
PoolsTopic.prototype.constructor = PoolsTopic;
PoolsTopic.prototype.showing = function() {
    this.poolsSubscription = MC.poolsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.disksSubscription = MC.disksSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.bindContextMenu()
};
PoolsTopic.prototype.hiding = function() {
    if (this.poolsSubscription) {
        MC.poolsSet.unregister(this.poolsSubscription);
        delete this.poolsSubscription
    }
    if (this.disksSubscription) {
        MC.disksSet.unregister(this.disksSubscription);
        delete this.disksSubscription
    }
    this.unBindContextMenu()
};
PoolsTopic.prototype._refreshData = function(D) {
    if (!MC.poolsSet.data) {
        return
    }
    var C = {
        tPoolsPools: {
            data: DC.poolsSerial,
            select: this.selectedPools,
            redraw: ($.isEmptyObject(DC.pools) ? "" : keepCurrentPage)
        },
        tPoolsDiskGroups: {
            data: DC.diskGroupsSerial,
            select: this.selectedDiskGroups
        },
        tPoolsDisks: {
            data: DC.disks
        }
    };
    this.update(C);
    this._setTopicSelects();
    this.bindContextMenu()
};
PoolsTopic.prototype._diskGroupsCriteria = function(H) {
    if (H.get("pool") == "") {
        return true
    } else {
        for (var F = 0, C = this.selectedPools.length; F < C; F++) {
            var E = this.selectedPools[F].getObject();
            if (!E) {
                continue
            }
            for (var D in E.diskGroups) {
                var G = E.diskGroups[D];
                if (G.get("serial_number") == H.get("serial_number")) {
                    return true
                }
            }
        }
        return false
    }
};
PoolsTopic.prototype._disksCriteria = function(G) {
    for (var E = 0, C = this.selectedDiskGroups.length; E < C; E++) {
        var F = this.selectedDiskGroups[E].getObject();
        if (!F) {
            continue
        }
        var D = F.get("serial_number");
        if (G.get("virtual_disk_serial") == D) {
            return true
        }
    }
    return false
};
PoolsTopic.prototype._dgJobIntercept = function(E) {
    var F = "";
    var D = DC.diskGroupsSerial[E.aData.prop.serial_number.text];
    if (D) {
        F = D.get("current_job");
        var C = D.get("current_job_completion");
        if (C) {
            F += " (" + C + ")"
        }
    }
    return F
};
PoolsTopic.prototype._indexIntercept = function(E) {
    var F = "";
    var D = DC.disks[E.aData.prop.durable_id.text];
    if (D) {
        var C = D.get("virtual_disk_serial");
        F = DC.diskGroupsSerial[C].get("name")
    }
    return F
};
PoolsTopic.prototype._driveTypeIntercept = function(D) {
    var E = "";
    var C = DC.diskGroupsSerial[D.aData.prop.serial_number.text];
    if (C) {
        E = C.get("array_drive_type");
        if (parseInt(C.get("storage_type_numeric")) == STORAGE_CLASS.VIRTUAL) {
            E += " (" + C.get("storage_tier") + ")"
        }
    }
    return E
};
PoolsTopic.prototype._poolSelected = function(C, D) {
    this.selectedPools = C;
    this.selectedDiskGroups = [];
    var E = {
        tPoolsDiskGroups: {
            data: DC.diskGroupsSerial
        },
        tPoolsDisks: {
            data: DC.disks
        }
    };
    this.update(E);
    this._setTopicSelects();
    this.bindContextMenu()
};
PoolsTopic.prototype._diskGroupSelected = function(C, D) {
    this.selectedDiskGroups = C;
    var E = {
        tPoolsDisks: {
            data: DC.disks
        }
    };
    this.update(E);
    this._setTopicSelects()
};
PoolsTopic.prototype._setTopicSelects = function() {
    TopicPanel.selection.empty();
    $.merge(TopicPanel.selection, this.selectedPools);
    $.merge(TopicPanel.selection, this.selectedDiskGroups)
};
PoolsTopic.prototype.bindContextMenu = function() {
    $("tr", "#tPoolsDiskGroups > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu));
    $("tr", "#tPoolsPools > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu))
};
PoolsTopic.prototype.unBindContextMenu = function() {
    $("tr", "#tPoolsDiskGroups > tbody").off("contextmenu");
    $("tr", "#tPoolsPools > tbody").off("contextmenu");
    panels.contextMenu.close()
};
PoolsTopic.prototype.openContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "PoolsTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};

function VolumesTopic(E) {
    if (arguments.length == 0) {
        return
    }
    var D = ["volume_group", "volume_name", "storage_pool_name", "volume_type", "size", "allocated_size"];
    E.name = "VolumesTopic";
    this.selectedVolumes = [];
    this.selectedSnaps = [];
    this.selectedMaps = [];
    this.selectedRepSets = [];
    this.selectedSchedules = [];
    this.firstTime = true;
    this.selectedTab = null;
    this.subTableTabs = [];
    if (RI.supportsSnaps()) {
        this.subTableTabs.push({
            name: "tVolumesSnaps",
            label: strings.volumesTopic.snaps,
            disabled: true,
            visibility: "hidden"
        })
    }
    this.subTableTabs.push({
        name: "tVolumesMaps",
        label: strings.volumesTopic.maps,
        disabled: true,
        visibility: "hidden"
    });
    if ((RI.hasFeature("asyncRep") && !EXPR.isSasPortType) || RI.hasFeature("rsr")) {
        if (replicationSetup() == "rsr") {
            var C = "tVolumesRsrRepSets"
        } else {
            var C = "tVolumesRepSets"
        }
        this.subTableTabs.push({
            name: C,
            label: strings.repSetsLabel,
            disabled: true,
            visibility: "hidden"
        })
    }
    if ((RI.hasFeature("asyncRep") && !EXPR.isSasPortType) || RI.hasFeature("rsr") || RI.supportsSnaps()) {
        this.subTableTabs.push({
            name: "tVolumesSchedules",
            label: strings.volumesTopic.schedules,
            disabled: true,
            visibility: "hidden"
        })
    }
    E.widgets = new TableWidget({
        maxCols: 1,
        classes: "center10",
        widgets: [new TableInator({
            name: "tVolumesVolumes",
            minWidth: 880,
            displayLength: 10,
            cellClasses: "alignTop",
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this._volumeSelected),
            criteria: createObjectCallback(this, this._volumesCriteria),
            bottomMargin: true,
            type: "dcCollection",
            metadata: "volumes",
            fields: D,
            columnOverrides: {
                volume_group: {
                    sTitle: strings.volumesTopic.groupCol,
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                volume_name: {
                    sTitle: strings.Name,
                    bFilterMenu: {
                        numItems: 0
                    }
                },
                storage_pool_name: {
                    sTitle: strings.volumesTopic.poolCol,
                    bFilterMenu: {
                        allowSingles: true
                    }
                },
                volume_type: {
                    sTitle: strings.volumesTopic.type,
                    bFilterMenu: false
                },
                size: {
                    sTitle: strings.volumesTopic.size,
                    stype: "size",
                    bFilterMenu: false
                },
                allocated_size: {
                    sTitle: strings.volumesTopic.allocSizeCol,
                    stype: "size",
                    bFilterMenu: false
                }
            },
            intercepts: [{
                selector: "volume_group",
                renderer: this._renderGroup
            }],
            hoverPanel: panels.VolumeHover
        }), this.tabWidget = new TabWidget({
            name: "tVolumeTabs",
            type: "Primary",
            classes: "volumesTabWidget",
            changeCallback: createObjectCallback(this, this._tabSelected),
            tabs: this.subTableTabs,
            widgets: [new WidgetContainer({
                classes: "clearFloats"
            }), new TableInator({
                name: "tVolumesSnaps",
                minWidth: 880,
                selectable: "multiple",
                selectCallback: createObjectCallback(this, this._snapSelected),
                criteria: createObjectCallback(this, this._snapsCriteria),
                topSmallMargin: true,
                displayLength: 10,
                type: "apiData",
                metadata: "snapshots",
                fields: ["name", "base_volume", "volume_parent", "creation_date_time", "status", "snap_data"],
                columnOverrides: {
                    name: {
                        sTitle: strings.Name,
                        bFilterMenu: {
                            numItems: 0
                        }
                    },
                    base_volume: {
                        sTitle: strings.snapHover.baseVolume
                    },
                    volume_parent: {
                        sTitle: strings.snapHover.parentVolume
                    },
                    creation_date_time: {
                        sTitle: strings.snapHover.creationDate,
                        sType: "string",
                        bFilterMenu: false
                    },
                    status: {
                        sTitle: strings.snapHover.statusLabel,
                        bFilterMenu: {
                            allowSingles: true
                        }
                    },
                    snap_data: {
                        sTitle: strings.snapHover.snapDataLabel,
                        sType: "size",
                        bFilterMenu: false
                    }
                },
                dtOptions: {
                    aaSorting: [
                        [3, "asc"],
                        [2, "asc"]
                    ]
                },
                emptyTableString: strings.volumesTopic.noData,
                hoverPanel: panels.SnapshotHover
            }), new TableInator({
                name: "tVolumesMaps",
                minWidth: 880,
                cellClasses: "verticalTop",
                displayLength: 10,
                topSmallMargin: true,
                type: "rawData",
                metadata: [{
                    sTitle: "basetype",
                    bVisible: false,
                    bIsBasetype: true
                }, {
                    sTitle: "id",
                    bVisible: false,
                    bIsKey: true
                }, {
                    sTitle: strings.mappingTopic.hostCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.mappingTopic.volumeCol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.mappingTopic.accessCol,
                    bFilterMenu: {
                        allowSingles: true
                    }
                }, {
                    sTitle: strings.mappingTopic.lunCol,
                    bFilterMenu: {
                        numItems: 0
                    }
                }, {
                    sTitle: strings.mappingTopic.portsCol,
                    bFilterMenu: {
                        list: ["0", "1", "2", "3"]
                    }
                }],
                emptyTableString: strings.volumesTopic.noData,
                selectable: "multiple",
                selectCallback: createObjectCallback(this, this._mapSelected),
                dtOptions: {
                    aaSorting: [
                        [2, "asc"],
                        [3, "asc"]
                    ]
                }
            }), new TableInator({
                name: "tVolumesRepSets",
                minWidth: 890,
                selectable: "single",
                selectCallback: createObjectCallback(this, this._repSetSelected),
                criteria: createObjectCallback(this, this._repSetsCriteria),
                type: "apiData",
                metadata: "cs-replication-set",
                fields: ["name", "primary_volume_name", "secondary_volume_name", "status", "last_success_time", "estimated_time_completion"],
                emptyTableString: strings.volumesTopic.noData,
                columnOverrides: {
                    name: {
                        sTitle: strings.Name
                    },
                    primary_volume_name: {
                        sTitle: strings.repsTopic.primaryVol
                    },
                    secondary_volume_name: {
                        sTitle: strings.repsTopic.secondaryVol
                    },
                    status: {
                        sTitle: strings.repsTopic.status
                    },
                    last_success_time: {
                        sTitle: strings.repsTopic.lastGoodUpdate
                    },
                    estimated_time_completion: {
                        sTitle: strings.repsTopic.estCompTime
                    }
                },
                intercepts: [{
                    selector: "primary_volume_name",
                    renderer: this._localPrimaryVolumeIntercept
                }, {
                    selector: "secondary_volume_name",
                    renderer: this._localSecondaryVolumeIntercept
                }],
                bottomMargin: true,
                hoverPanel: panels.ReplicationSetsHover
            }), new TableInator({
                name: "tVolumesRsrRepSets",
                minWidth: 890,
                selectable: "multiple",
                selectCallback: createObjectCallback(this, this._repSetSelected),
                type: "rawData",
                metadata: [{
                    sTitle: "basetype",
                    bVisible: false,
                    bIsBasetype: true
                }, {
                    sTitle: "id",
                    bVisible: false,
                    bIsKey: true
                }, {
                    sTitle: strings.repsTopic.primaryVol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.repsTopic.secondaryVol,
                    bFilterMenu: true
                }, {
                    sTitle: strings.repsTopic.peerConnHealth,
                    bFilterMenu: true
                }, {
                    sTitle: strings.repsTopic.status,
                    bFilterMenu: true
                }, {
                    sTitle: strings.repsTopic.linkType,
                    bFilterMenu: true
                }],
                intercepts: [{
                    selector: 2,
                    renderer: this._localPrimaryVolumeIntercept
                }, {
                    selector: 3,
                    renderer: this._localSecondaryVolumeIntercept
                }],
                bottomMargin: true,
                hoverPanel: panels.RsrReplicationSetHover
            }), new TableInator({
                name: "tVolumesSchedules",
                minWidth: 890,
                selectable: "single",
                selectCallback: createObjectCallback(this, this._scheduleSelected),
                criteria: createObjectCallback(this, this._schedulesCriteria),
                type: "apiData",
                metadata: "schedules",
                fields: ["name", "schedule_specification", "status", "task_type"],
                columnOverrides: {
                    name: {
                        sTitle: strings.Name
                    },
                    schedule_specification: {
                        sTitle: strings.scheduleHover.specification
                    },
                    status: {
                        sTitle: strings.scheduleHover.status
                    },
                    task_type: {
                        sTitle: strings.scheduleHover.taskType
                    }
                },
                emptyTableString: strings.volumesTopic.noData,
                bottomMargin: true,
                hoverPanel: panels.ScheduleHover
            })]
        })]
    });
    TopicPanel.call(this, E);
    this.class_name = "VolumesTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }));
    $(".dataTables_length", this.elements).change(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
VolumesTopic.prototype = new TopicPanel();
VolumesTopic.prototype.constructor = VolumesTopic;
VolumesTopic.prototype.showing = function() {
    this.volumeSubscription = MC.volumeGroupsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.snapshotsSubscription = MC.snapshotsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.schedulesSubscription = MC.schedulesSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.mapsSubscription = MC.mapsSet.requestData({
        update: false,
        durable: "all",
        requester: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    if (replicationSetup() == "rsr") {
        this.repSetSubscription = MC.replicationSetsSet.requestData({
            update: false,
            durable: "all",
            requestor: this.className,
            handler: createObjectCallback(this, this._refreshData)
        })
    } else {
        if (RI.hasFeature("asyncRep") && !EXPR.isSasPortType) {
            this.repSetSubscription = MC.virtualReplicationSets.requestData({
                update: false,
                durable: "all",
                requestor: this.className,
                handler: createObjectCallback(this, this._refreshData)
            })
        }
    }
    this.bindContextMenu()
};
VolumesTopic.prototype.hiding = function() {
    if (this.volumeSubscription) {
        MC.volumeGroupsSet.unregister(this.volumeSubscription);
        delete this.volumeSubscription
    }
    if (this.snapshotsSubscription) {
        MC.snapshotsSet.unregister(this.snapshotsSubscription);
        delete this.snapshotsSubscription
    }
    if (this.schedulesSubscription) {
        MC.schedulesSet.unregister(this.schedulesSubscription);
        delete this.schedulesSubscription
    }
    if (this.mapsSubscription) {
        MC.mapsSet.unregister(this.mapsSubscription);
        delete this.mapsSubscription
    }
    if (this.repSetSubscription) {
        MC.virtualReplicationSets.unregister(this.repSetSubscription);
        delete this.repSetSubscription
    }
    this.unBindContextMenu()
};
VolumesTopic.prototype._refreshData = function() {
    var C = this.subTableTabs.find(this.selectedTab);
    var D = {
        tVolumesVolumes: {
            data: DC.volumes,
            select: this.selectedVolumes,
            redraw: ($.isEmptyObject(DC.volumes) ? "" : keepCurrentPage)
        }
    };
    if (C == -1) {
        D.value = TabWidget.UNSELECT_ALL;
        D.tVolumesSnaps = {
            visibility: "hidden"
        };
        D.tVolumesMaps = {
            visibility: "hidden"
        };
        D.tVolumesRepSets = {
            visibility: "hidden"
        };
        D.tVolumesSchedules = {
            visibility: "hidden"
        };
        D.tVolumesRsrRepSets = {
            visibility: "hidden"
        }
    }
    this.update(D);
    this._setTopicSelects();
    this._volumeSelected(this.selectedVolumes, true);
    this.bindContextMenu()
};
VolumesTopic.prototype._tabSelected = function(C) {
    var E = {};
    var D = "";
    if (C == null) {
        return
    }
    E.tVolumeTabs = {};
    E.tVolumeTabs.tabs = this.subTableTabs;
    if (C >= 0) {
        this.selectedTab = this.subTableTabs[C];
        D = this.selectedTab.name
    } else {
        D = ""
    }
    switch (D) {
        case "tVolumesSnaps":
            E.tVolumesSnaps = {
                visibility: "visible"
            };
            E.tVolumesMaps = {
                visibility: "hidden"
            };
            E.tVolumesRepSets = {
                visibility: "hidden"
            };
            E.tVolumesRsrRepSets = {
                visibility: "hidden"
            };
            E.tVolumesSchedules = {
                visibility: "hidden"
            };
            break;
        case "tVolumesMaps":
            E.tVolumesSnaps = {
                visibility: "hidden"
            };
            E.tVolumesMaps = {
                visibility: "visible"
            };
            E.tVolumesRepSets = {
                visibility: "hidden"
            };
            E.tVolumesRsrRepSets = {
                visibility: "hidden"
            };
            E.tVolumesSchedules = {
                visibility: "hidden"
            };
            break;
        case "tVolumesRepSets":
            E.tVolumesSnaps = {
                visibility: "hidden"
            };
            E.tVolumesMaps = {
                visibility: "hidden"
            };
            E.tVolumesRepSets = {
                visibility: "visible"
            };
            E.tVolumesRsrRepSets = {
                visibility: "hidden"
            };
            E.tVolumesSchedules = {
                visibility: "hidden"
            };
            break;
        case "tVolumesRsrRepSets":
            E.tVolumesSnaps = {
                visibility: "hidden"
            };
            E.tVolumesMaps = {
                visibility: "hidden"
            };
            E.tVolumesRepSets = {
                visibility: "hidden"
            };
            E.tVolumesRsrRepSets = {
                visibility: "visible"
            };
            E.tVolumesSchedules = {
                visibility: "hidden"
            };
            break;
        case "tVolumesSchedules":
            E.tVolumesSnaps = {
                visibility: "hidden"
            };
            E.tVolumesMaps = {
                visibility: "hidden"
            };
            E.tVolumesRepSets = {
                visibility: "hidden"
            };
            E.tVolumesRsrRepSets = {
                visibility: "hidden"
            };
            E.tVolumesSchedules = {
                visibility: "visible"
            };
            break;
        default:
            E.tVolumesSnaps = {
                visibility: "hidden"
            };
            E.tVolumesMaps = {
                visibility: "hidden"
            };
            E.tVolumesRepSets = {
                visibility: "hidden"
            };
            E.tVolumesRsrRepSets = {
                visibility: "hidden"
            };
            E.tVolumesSchedules = {
                visibility: "hidden"
            };
            break
    }
    this.update(E)
};
VolumesTopic.prototype._volumesCriteria = function(D) {
    var C = D.getInt("volume_type_numeric");
    switch (C) {
        case VOLUME_TYPES.VOLUME:
        case VOLUME_TYPES.BACKING_STORE:
        case VOLUME_TYPES.MASTER_VOLUME:
        case VOLUME_TYPES.BASE:
        case VOLUME_TYPES.SNAPSHOT:
        case VOLUME_TYPES.ROLLOFF:
        case VOLUME_TYPES.RSR_SOURCE:
        case VOLUME_TYPES.PAGED_SNAPSHOT:
        case VOLUME_TYPES.VOLUME_COPY:
            break;
        default:
            return false;
            break
    }
    return true
};
VolumesTopic.prototype._renderGroup = function(D) {
    var C = D.aData.prop.volume_group.text;
    var E = DC.volumeGroupsSerial[C];
    if (E && C != "UNGROUPEDVOLUMES") {
        return E.get("group_name")
    } else {
        return "-"
    }
};
VolumesTopic.prototype._schedulesCriteria = function(H) {
    var I = this.selectedVolumes.length;
    var E = H.get("associated_volume_serial");
    var K = H.get("task_replication_set_serialnum");
    var J = H.get("task_type") != undefined;
    var L = {};
    var M = "";
    var C = "";
    var D = "";
    var F = "";
    if (J) {
        for (var G = 0; G < I; G++) {
            L = DC.base.volumes[this.selectedVolumes[G].key];
            M = L.get("serial_number");
            C = L.get("volume_group");
            if (E == M || C && (E == C)) {
                return true
            }
            if (K) {
                D = L.get("replication_set");
                F = DC.volumeGroupsSerial[C].get("replication_set_serial");
                if (K == D || K == F) {
                    return true
                }
            }
        }
    }
    return false
};
VolumesTopic.prototype._repSetsCriteria = function(I) {
    var F = 0;
    var C = this.selectedVolumes.length;
    var H = I.get("serial_number");
    for (F = 0; F < C; F++) {
        var D = DC.base.volumes[this.selectedVolumes[F].key];
        var G = D.get("replication_set");
        var E = D.get("volume_group");
        if (G == "" && E != "") {
            G = DC.volumeGroupsSerial[E].get("replication_set_serial")
        }
        if (H == G) {
            return true
        }
    }
    return false
};
VolumesTopic.prototype._snapsCriteria = function(J) {
    var C = {};
    C = MC.snapshotsSet.data.objects;
    for (var F = 0; F < this.selectedVolumes.length; F++) {
        var I = J.get("master_volume_name");
        var H = J.get("base_volume");
        var E = DC.base.volumes[this.selectedVolumes[F].key];
        var G = E.get("volume_name");
        if (E && (I == G || H == G)) {
            return true
        } else {
            var D = C.contains(I);
            while (D >= 0) {
                J = C[D];
                I = J.get("master_volume_name");
                H = J.get("base_volume");
                if (I == G || H == G) {
                    return true
                }
                D = C.contains(I)
            }
        }
        return false
    }
    return false
};
VolumesTopic.prototype._updateMaps = function() {
    var Q = [];
    var O = {};
    for (var J = 0; J < this.selectedVolumes.length; J++) {
        var K = this.selectedVolumes[J].getObject();
        var L = K.getMaps();
        for (var H = 0; H < L.length; H++) {
            var C = L[H];
            var G = "-";
            var N = C.get("durable_id");
            var I = C.parentObject;
            if (I instanceof APIVolumeGroupView) {
                G = I.get("group_name")
            } else {
                if (I instanceof APIVolumeView) {
                    G = I.get("volume_name")
                }
            }
            if (!O[N]) {
                var F = C.basetype;
                var D = C.getKeyValue();
                var P = C.getHostName();
                var E = C.get("access");
                var R = (C.prop.lun != undefined ? C.get("lun") : "*");
                var M = C.get("ports");
                Q.push([F, D, P, G, E, R, M]);
                O[N] = true
            }
        }
    }
    this.update({
        tVolumesMaps: {
            data: Q,
            select: this.selectedMaps
        }
    })
};
VolumesTopic.prototype._updateRsrRepSets = function() {
    var C = [];
    for (var K = 0; K < this.selectedVolumes.length; K++) {
        var L = this.selectedVolumes[K].getObject();
        if (L.get("replication_set")) {
            for (var F in DC.repSets) {
                var P = DC.repSets[F];
                if (P.get("serial_number") == L.get("replication_set")) {
                    var E = P.getKeyValue();
                    var H = P.basetype;
                    var N = P.objects[0].get("name");
                    var M = P.objects[1].get("name");
                    var G = P.objects[0].get("primary_volume_name");
                    if (N == G) {
                        var Q = N;
                        var D = M
                    } else {
                        var Q = M;
                        var D = N
                    }
                    var J = P.objects[0].get("monitor");
                    var I = P.objects[0].get("status");
                    var O = P.objects[0].get("link_type");
                    C.push([H, E, Q, D, J, I, O])
                }
            }
        }
    }
    this.update({
        tVolumesRsrRepSets: {
            data: C,
            select: this.selectedRepSets
        }
    })
};
VolumesTopic.prototype._setTopicSelects = function() {
    TopicPanel.selection.empty();
    $.merge(TopicPanel.selection, this.selectedVolumes);
    $.merge(TopicPanel.selection, this.selectedSnaps);
    $.merge(TopicPanel.selection, this.selectedMaps);
    $.merge(TopicPanel.selection, this.selectedRepSets)
};
VolumesTopic.prototype._volumeSelected = function(E, H) {
    var G = {};
    var D;
    var F;
    var C = 0;
    this.selectedVolumes = E;
    if (typeof H == "undefined") {
        this.selectedSnaps = [];
        this.selectedMaps = [];
        this.selectedRepSets = [];
        this.selectedSchedules = []
    }
    this._updateMaps();
    G.tVolumesSnaps = {
        data: MC.snapshotsSet.data.objects,
        select: this.selectedSnaps
    };
    if (replicationSetup() == "ar") {
        G.tVolumesRepSets = {
            data: MC.virtualReplicationSets.data.objects,
            select: this.selectedRepSets
        }
    } else {
        if (replicationSetup() == "rsr") {
            this._updateRsrRepSets()
        } else {
            G.tVolumesRepSets = {
                data: []
            }
        }
    }
    G.tVolumesSchedules = {
        data: MC.schedulesSet.data.objects,
        select: this.selectedSchedules
    };
    this.update(G);
    this._disableEmptyTabs();
    C = this.subTableTabs.find(this.selectedTab);
    D = this._findFirstEnabledTab();
    F = (this.selectedTab && D != -1) ? C : (D);
    this.update({
        tVolumeTabs: {
            value: (F == -1) ? TabWidget.UNSELECT_ALL : F
        }
    });
    this._setTopicSelects();
    this.bindContextMenu()
};
VolumesTopic.prototype._disableEmptyTabs = function() {
    var G = {};
    var E = 0;
    G.tVolumeTabs = {};
    G.tVolumeTabs.tabs = [{}, {}, {}, {}];
    var F = this.tabWidget.tabs.length;
    var H = 0;
    for (var D = 0; D < F; D++) {
        switch (this.tabWidget.tabs[D].name) {
            case "tVolumesSnaps":
                H = this.widgetContainer.findWidgetByNameDeep("tVolumesSnaps").getVisibleRows();
                break;
            case "tVolumesMaps":
                H = this.widgetContainer.findWidgetByNameDeep("tVolumesMaps").getVisibleRows();
                break;
            case "tVolumesRepSets":
                H = this.widgetContainer.findWidgetByNameDeep("tVolumesRepSets").getVisibleRows();
                break;
            case "tVolumesRsrRepSets":
                H = this.widgetContainer.findWidgetByNameDeep("tVolumesRsrRepSets").getVisibleRows();
                break;
            case "tVolumesSchedules":
                H = this.widgetContainer.findWidgetByNameDeep("tVolumesSchedules").getVisibleRows();
                break;
            default:
                break
        }
        if (H == 0) {
            G.tVolumeTabs.tabs[D].disabled = true;
            this.subTableTabs[D].disabled = true
        } else {
            E += H;
            G.tVolumeTabs.tabs[D].disabled = false;
            this.subTableTabs[D].disabled = false
        }
    }
    if (E == 0) {
        G.tVolumeTabs = {
            value: TabWidget.UNSELECT_ALL
        };
        G.tVolumeTabs.tabs = [{
            disabled: true
        }, {
            disabled: true
        }, {
            disabled: true
        }, {
            disabled: true
        }];
        for (var C = 0; C < F; C++) {
            this.subTableTabs[C].disabled = true
        }
    }
    this.update(G)
};
VolumesTopic.prototype._findFirstEnabledTab = function() {
    var D = this.tabWidget.tabs.length;
    for (var C = 0; C < D; C++) {
        if (this.subTableTabs[C].disabled == undefined || !this.subTableTabs[C].disabled) {
            return C
        }
    }
    return -1
};
VolumesTopic.prototype._snapSelected = function(C, D) {
    this.selectedSnaps = C;
    this._setTopicSelects()
};
VolumesTopic.prototype._mapSelected = function(C, D) {
    this.selectedMaps = C;
    this._setTopicSelects()
};
VolumesTopic.prototype._repSetSelected = function(C, D) {
    this.selectedRepSets = C;
    this._setTopicSelects()
};
VolumesTopic.prototype._scheduleSelected = function(C, D) {
    this.selectedSchedules = C;
    this._setTopicSelects()
};
VolumesTopic.prototype._localPrimaryVolumeIntercept = function(C) {
    if (replicationSetup() == "rsr") {
        return RsrTopic.localVolumeIntercept(C)
    } else {
        return RepsTopic.localVolumeIntercept(C, true)
    }
};
VolumesTopic.prototype._localSecondaryVolumeIntercept = function(C) {
    if (replicationSetup() == "rsr") {
        return RsrTopic.localVolumeIntercept(C)
    } else {
        return RepsTopic.localVolumeIntercept(C, false)
    }
};
VolumesTopic.prototype.bindContextMenu = function() {
    $("tr", "#tVolumesVolumes > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.createContextMenu));
    $("tr", "#tVolumesSnaps > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.createContextMenu));
    $("tr", "#tVolumesMaps > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.createContextMenu));
    $("tr", "#tVolumesRepSets > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.createContextMenu));
    $("tr", "#tVolumesSchedules > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.createContextMenu))
};
VolumesTopic.prototype.unBindContextMenu = function() {
    $("tr", "#tVolumesVolumes > tbody").off("contextmenu");
    $("tr", "#tVolumesSnaps > tbody").off("contextmenu");
    $("tr", "#tVolumesMaps > tbody").off("contextmenu");
    $("tr", "#tVolumesRepSets > tbody").off("contextmenu");
    $("tr", "#tVolumesSchedules > tbody").off("contextmenu");
    panels.contextMenu.close()
};
VolumesTopic.prototype.createContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "VolumesTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};

function VolumeHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 400;
    C.name = "VolumeHover";
    C.widgets = new WidgetContainer({
        widgets: [this.tableWidget = new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.volumeHover.nameLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "type",
                label: strings.volumeHover.typeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "pool",
                label: strings.volumeHover.poolLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "group",
                label: strings.volumeHover.groupLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "storageType",
                label: strings.volumeHover.classLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "size",
                label: strings.volumeHover.sizeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "allocSize",
                label: strings.volumeHover.allocSizeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "owner",
                label: strings.volumeHover.owner,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.volumeHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "volumeCopy",
                label: strings.volumeHover.volCopyJob,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "writePolicy",
                label: strings.volumeHover.writePolicyLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "optimization",
                label: strings.volumeHover.optimizationLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "readAheadSize",
                label: strings.volumeHover.readAheadSizeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "tierAffinity",
                label: strings.volumeHover.tierAffinity,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                text: strings.volumeHover.snapPoolInfo,
                colSpan: 2,
                cssClass: "hoverSectionLabel",
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "masterVolumes",
                label: strings.volumeHover.masterVolumesLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "free",
                label: strings.volumeHover.freeLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "freePercent",
                label: strings.volumeHover.freePercentLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.volumeHover.statusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                label: strings.volumeHover.thresholds,
                colSpan: 2,
                cssClass: "hoverSectionLabel",
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "lowThreshold",
                label: strings.volumeHover.lowThresholdLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "midThreshold",
                label: strings.volumeHover.midThresholdLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "highThreshold",
                label: strings.volumeHover.highThresholdLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "snapshots",
                label: strings.volumeHover.snapshot,
                leftMargin: true,
                bottomSmallMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "VolumeHover"
}
VolumeHover.prototype = new HoverPanel();
VolumeHover.prototype.constructor = VolumeHover;
VolumeHover.prototype.showing = function() {
    this.obj = this.currentParent;
    if (MC.volumeCopySet != undefined) {
        this.volCopySubscription = MC.volumeCopySet.requestData({
            update: false,
            durable: "all",
            requester: this.class_name,
            handler: createObjectCallback(this, this.volCopyUpdated)
        })
    }
    var O = "";
    var H = this.obj.get("volume_group");
    if (H && DC.volumeGroupsSerial[H]) {
        O = DC.volumeGroupsSerial[H].get("group_name") == strings.hostUnGrouped ? "--" : DC.volumeGroupsSerial[H].get("group_name")
    }
    var I = {
        name: {
            text: this.obj.get("volume_name")
        },
        pool: {
            text: this.obj.get("storage_pool_name")
        },
        group: {
            text: O
        },
        storageType: {
            text: this.obj.get("storage_type")
        },
        size: {
            text: this.obj.get("size")
        },
        allocSize: {
            text: this.obj.get("allocated_size")
        },
        owner: {
            text: strings.ownerCombined(this.obj.get("preferred_owner"), this.obj.get("owner"))
        },
        type: {
            text: this.obj.get("volume_type")
        },
        serial: {
            text: this.obj.get("serial_number")
        },
        writePolicy: {
            text: this.obj.get("write_policy")
        },
        optimization: {
            text: this.obj.get("cache_optimization")
        },
        readAheadSize: {
            text: this.obj.get("read_ahead_size")
        },
        health: {
            obj: this.obj
        }
    };
    var L = this.obj.getInt("volume_type_numeric");
    if (L == VOLUME_TYPES.BACKING_STORE) {
        var C = DC.snapPoolsSerial[this.obj.get("serial_number")];
        if (C) {
            for (var J = 0; J < C.objects.length; J++) {
                var E = C.objects[J];
                var D = E.get("threshold");
                var K = E.get("percent_usage");
                var F = E.get("policy");
                switch (D) {
                    case strings.volumeHover.lowThresholdLabel:
                        var M = K + strings.volumeHover.policyLabel + F;
                        break;
                    case strings.volumeHover.midThresholdLabel:
                        var N = K + strings.volumeHover.policyLabel + F;
                        break;
                    case strings.volumeHover.highThresholdLabel:
                        var G = K + strings.volumeHover.policyLabel + F;
                        break;
                    default:
                        MC.debugOutput("Got unexpected snap threshold level:  %s:", D);
                        break
                }
            }
            $.extend(true, I, {
                masterVolumes: {
                    text: C.get("master_volumes")
                },
                free: {
                    text: C.get("free")
                },
                freePercent: {
                    text: C.get("free_percent_size")
                },
                status: {
                    text: C.get("status")
                },
                lowThreshold: {
                    text: M
                },
                midThreshold: {
                    text: N
                },
                highThreshold: {
                    text: G
                },
                snapshots: {
                    text: C.get("snapshots")
                },
                dataTable: {
                    show: {
                        start: 0
                    }
                }
            })
        }
    } else {
        if (RI.hasFeature("volTierPreference") && this.obj.getInt("storage_type_numeric") == VOLUME_CLASS.VIRTUAL) {
            I.tierAffinity = {
                text: this.obj.get("tier_affinity")
            };
            I.dataTable = {
                show: {
                    start: 0,
                    end: 13
                },
                hide: {
                    start: 14
                }
            }
        } else {
            I.dataTable = {
                show: {
                    start: 0,
                    end: 12
                },
                hide: {
                    start: 13
                }
            }
        }
    }
    this.update(I);
    if (L == VOLUME_TYPES.BACKING_STORE) {
        this.tableWidget.hideRows(3, 4);
        this.tableWidget.hideRows(9, 9)
    }
};
VolumeHover.prototype.hiding = function() {
    if (this.volCopySubscription) {
        MC.volumeCopySet.unregister(this.volCopySubscription);
        delete this.volCopySubscription
    }
};
VolumeHover.prototype.volCopyUpdated = function() {
    var D = (MC.volumeCopySet.data.objects) ? MC.volumeCopySet.data.objects : 0;
    var E = 0;
    if (D) {
        for (var C = 0; C < D.length; C++) {
            if (D[C].get("source_volume_serial") == this.obj.get("serial_number")) {
                E = D[C].get("progress");
                break
            } else {
                if (D[C].get("destination_volume_serial") == this.obj.get("serial_number")) {
                    E = D[C].get("progress");
                    break
                }
            }
        }
        setTimeout(function() {
            MC.volumeCopySet._pollForData()
        }, 5000)
    }
    this.update({
        volumeCopy: {
            text: E
        }
    })
};

function SnapshotHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 300;
    C.name = "SnapshotHover";
    C.widgets = new WidgetContainer({
        widgets: [this.table = new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.snapHover.nameLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "serial",
                label: strings.snapHover.serialLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.snapHover.statusLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "statusReason",
                label: strings.snapHover.statusReasonLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "snapPoolName",
                label: strings.snapPoolLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "priorityValue",
                label: strings.snapHover.priorityLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "userPriorityValue",
                label: strings.snapHover.userPriorityLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "retentionPriority",
                label: strings.snapHover.retentionPriorityLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "snapData",
                label: strings.snapHover.snapDataLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "uniqueData",
                label: strings.snapHover.uniqueDataLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sharedData",
                label: strings.snapHover.sharedDataLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "storagePool",
                label: strings.snapHover.storagePool,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "storageType",
                label: strings.snapHover.classLabel,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "numberSnaps",
                label: strings.snapHover.numberSnaps,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "numberSnapshots",
                label: strings.snapHover.numberSnapshots,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sourceVolume",
                label: strings.snapHover.sourceVolume,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "totalSize",
                label: strings.snapHover.totalSize,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "creationDate",
                label: strings.snapHover.creationDate,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "type",
                label: strings.snapHover.type,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "parentVolume",
                label: strings.snapHover.parentVolume,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "baseVolume",
                label: strings.snapHover.baseVolume,
                leftMargin: true,
                bottomSmallMargin: true
            })]
        }), new HealthWidget({
            name: "health",
            topMargin: true
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "SnapshotHover"
}
SnapshotHover.prototype = new HoverPanel();
SnapshotHover.prototype.constructor = SnapshotHover;
SnapshotHover.prototype.showing = function() {
    var E = this.getApiObject();
    var F = DC.volumesSerial[E.get("serial_number")];
    var C = F.getInt("storage_type_numeric");
    var D = {
        name: {
            text: E.get("name")
        },
        serial: {
            text: E.get("serial_number")
        },
        status: {
            text: E.get("status")
        },
        statusReason: {
            text: E.get("status_reason")
        },
        snapData: {
            text: E.get("snap_data")
        },
        uniqueData: {
            text: E.get("uniquedata")
        },
        sharedData: {
            text: E.get("shareddata")
        },
        storagePool: {
            text: E.get("storage_pool_name")
        },
        storageType: {
            text: F.get("storage_type")
        },
        numberSnaps: {
            text: E.get("num_snaps_tree")
        },
        numberSnapshots: {
            text: E.get("num_children")
        },
        sourceVolume: {
            text: E.get("master_volume_name")
        },
        totalSize: {
            text: E.get("total_size")
        },
        creationDate: {
            text: E.get("creation_date_time")
        },
        type: {
            text: E.get("snapshot_type")
        },
        parentVolume: {
            text: E.get("volume_parent")
        },
        baseVolume: {
            text: E.get("base_volume")
        },
        health: {
            obj: F
        }
    };
    if (C == STORAGE_CLASS.VIRTUAL) {
        D.retentionPriority = {
            text: E.get("retention_priority")
        };
        this.table.showRows(0);
        this.table.hideRows(4, 6)
    } else {
        D.snapPoolName = {
            text: E.get("snap_pool_name")
        };
        D.priorityValue = {
            text: E.get("priority_value")
        };
        D.userPriorityValue = {
            text: E.get("user_priority_value")
        };
        this.table.showRows(0);
        this.table.hideRows(7, 7)
    }
    this.update(D)
};

function ScheduleHover(C) {
    if (arguments.length == 0) {
        return
    }
    C.width = 450;
    C.name = "ScheduleHover";
    C.widgets = new WidgetContainer({
        widgets: [this.table = new TableWidget({
            name: "dataTable",
            maxCols: 2,
            width: C.width,
            widgets: [new TextWidget({
                name: "name",
                label: strings.scheduleHover.name,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "specification",
                label: strings.scheduleHover.specification,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "status",
                label: strings.scheduleHover.status,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "nextTime",
                label: strings.scheduleHover.nextTime,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "taskName",
                label: strings.scheduleHover.taskName,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "taskType",
                label: strings.scheduleHover.taskType,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "taskStatus",
                label: strings.scheduleHover.taskStatus,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "taskState",
                label: strings.scheduleHover.taskState,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "ErrorMessage",
                label: strings.scheduleHover.errorMessage,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sourceVol",
                label: strings.scheduleHover.sourceVol,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "sourceVolSerial",
                label: strings.scheduleHover.sourceVolSerial,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "destDg",
                label: strings.scheduleHover.destDg,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "destDgSerial",
                label: strings.scheduleHover.destDgSerial,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "replicationMode",
                label: strings.scheduleHover.replicationMode,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "prefix",
                label: strings.scheduleHover.prefix,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "count",
                label: strings.scheduleHover.count,
                leftMargin: true,
                bottomSmallMargin: true
            }), new TextWidget({
                name: "lastCreated",
                label: strings.scheduleHover.lastCreated,
                leftMargin: true,
                bottomSmallMargin: true
            })]
        })]
    });
    HoverPanel.call(this, C);
    this.class_name = "ScheduleHover"
}
ScheduleHover.prototype = new HoverPanel();
ScheduleHover.prototype.constructor = ScheduleHover;
ScheduleHover.prototype.showing = function() {
    var F = this.getApiObject();
    var C = DC.tasks[F.get("task_to_run")];
    this.table.showRows(0);
    var E = {
        name: {
            text: F.get("name")
        },
        specification: {
            text: F.get("schedule_specification")
        },
        status: {
            text: F.get("status")
        },
        nextTime: {
            text: F.get("next_time")
        },
        taskName: {
            text: F.get("task_to_run")
        },
        taskType: {
            text: C.get("type")
        },
        taskStatus: {
            text: C.get("status")
        },
        taskState: {
            text: C.get("state")
        },
        ErrorMessage: {
            text: C.get("error_message")
        }
    };
    var D = C.objects[0];
    switch (C.get("type")) {
        case "TakeSnapshot":
            E.sourceVol = {
                label: strings.scheduleHover.sourceVol,
                text: D.get("master_volume_name")
            };
            E.sourceVolSerial = {
                label: strings.scheduleHover.sourceVolSerial,
                text: D.get("master_volume_serial")
            };
            E.prefix = {
                text: D.get("snapshot_prefix")
            };
            E.count = {
                text: D.get("retention_count")
            };
            E.lastCreated = {
                text: D.get("last_created")
            };
            this.table.hideRows(11, 13);
            break;
        case "ResetSnapshot":
            E.sourceVol = {
                label: strings.scheduleHover.snapName,
                text: D.get("snapshot_name")
            };
            E.sourceVolSerial = {
                label: strings.scheduleHover.snapSerial,
                text: D.get("snapshot_serial")
            };
            this.table.hideRows(11, 16);
            break;
        case "VolumeCopy":
            E.sourceVol = {
                label: strings.scheduleHover.sourceVol,
                text: D.get("source_volume_name")
            };
            E.sourceVolSerial = {
                label: strings.scheduleHover.sourceVolSerial,
                text: D.get("source_volume_serial")
            };
            E.destDg = {
                text: D.get("destination_vdisk_name")
            };
            E.destDgSerial = {
                text: D.get("destination_vdisk_serial")
            };
            E.prefix = {
                text: D.get("destination_volume_prefix")
            };
            E.lastCreated = {
                text: D.get("last_created")
            };
            this.table.hideRows(13, 13);
            this.table.hideRows(15, 15);
            break;
        case "ReplicateVolume":
            E.sourceVol = {
                label: strings.scheduleHover.primaryVolName,
                text: D.get("primary_volume_name")
            };
            E.sourceVolSerial = {
                label: strings.scheduleHover.primaryVolSerial,
                text: D.get("primary_volume_serial")
            };
            E.prefix = {
                text: D.get("snapshot_prefix")
            };
            E.replicationMode = {
                text: D.get("replication_mode")
            };
            E.count = {
                text: D.get("retention_count")
            };
            E.lastCreated = {
                text: D.get("last_created")
            };
            this.table.hideRows(11, 12);
            break;
        case "Replicate":
            var G = DC.virtualReplicationSets[F.get("task_replication_set_name")];
            E.sourceVol = {
                label: strings.scheduleHover.primaryVolName,
                text: G.get("primary_volume_name")
            };
            E.sourceVolSerial = {
                label: strings.scheduleHover.primaryVolSerial,
                text: G.get("primary_volume_serial")
            };
            this.table.hideRows(11, 16);
            break;
        default:
            break
    }
    this.update(E)
};

function MappingTopic(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "MappingTopic";
    this.selectedMaps = [];
    C.widgets = new TableWidget({
        maxCols: 1,
        classes: "center10",
        widgets: [new TableInator({
            name: "tMapsMaps",
            minWidth: 880,
            cellClasses: "verticalTop",
            displayLength: 20,
            selectable: "multiple",
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "id",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.mappingTopic.hostCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mappingTopic.volumeCol,
                bFilterMenu: true
            }, {
                sTitle: strings.mappingTopic.accessCol,
                bFilterMenu: {
                    allowSingles: true
                }
            }, {
                sTitle: strings.mappingTopic.lunCol,
                bFilterMenu: {
                    numItems: 0
                }
            }, {
                sTitle: strings.mappingTopic.portsCol,
                bFilterMenu: {
                    list: isHPsystem() ? ["1", "2", "3", "4"] : ["0", "1", "2", "3"]
                }
            }],
            selectCallback: createObjectCallback(this, this._mapSelected),
            dtOptions: {
                aaSorting: [
                    [2, "asc"],
                    [3, "asc"]
                ]
            }
        })]
    });
    TopicPanel.call(this, C);
    this.class_name = "MappingTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }));
    $(".dataTables_length", this.elements).change(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
MappingTopic.prototype = new TopicPanel();
MappingTopic.prototype.constructor = MappingTopic;
MappingTopic.prototype.showing = function() {
    this.volMapsSubscription = MC.mapsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.bindContextMenu()
};
MappingTopic.prototype.hiding = function() {
    if (this.volMapsSubscription) {
        MC.mapsSet.unregister(this.volMapsSubscription);
        delete this.volMapsSubscription
    }
    this.unBindContextMenu()
};
MappingTopic.prototype._refreshData = function() {
    var H = [];
    var F, E, G, J, I;
    var C = MC.mapsSet.data.objects;
    for (var D = 0; D < C.length; D++) {
        this._addViewMaps(H, C[D])
    }
    this.update({
        tMapsMaps: {
            data: H,
            select: this.selectedMaps,
            redraw: (H.length ? keepCurrentPage : "")
        }
    });
    this.bindContextMenu()
};
MappingTopic.prototype._addViewMaps = function(L, K) {
    var F = "-";
    if (K instanceof APIVolumeGroupView) {
        F = K.get("group_name")
    } else {
        if (K instanceof APIVolumeView) {
            F = K.get("volume_name")
        }
    }
    for (var H = 0; H < K.objects.length; H++) {
        var G = K.objects[H];
        if (G instanceof APIVolumeView) {
            this._addViewMaps(L, G)
        } else {
            if (G instanceof APIVolumeGroupViewMappings || G instanceof APIVolumeViewMappings) {
                if (G.get("mapped_id") == "AOI" && G.getInt("access_numeric") == 0) {
                    continue
                }
                var E = G.basetype;
                var C = G.getKeyValue();
                var M = G.getHostName();
                var D = G.get("access");
                var N = (G.prop.lun != undefined ? G.get("lun") : "*");
                var J = G.get("ports");
                var I = this.findNoAccessMappingByHost(L, M);
                if (I !== undefined && I.length != 0) {
                    L.pop(I)
                }
                L.push([E, C, M, F, D, N, J])
            }
        }
    }
};
MappingTopic.prototype._mapSelected = function(C, D) {
    this.selectedMaps = C;
    TopicPanel.selection.empty();
    $.merge(TopicPanel.selection, this.selectedMaps)
};
MappingTopic.prototype.bindContextMenu = function() {
    $("tr", "#tMapsMaps > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu))
};
MappingTopic.prototype.unBindContextMenu = function() {
    $("tr", "#tMapsMaps > tbody").off("contextmenu");
    panels.contextMenu.close()
};
MappingTopic.prototype.openContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "MappingTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};
MappingTopic.prototype.findNoAccessMappingByHost = function(D, C) {
    return $.grep(D, function(E) {
        return E[4] === "no-access" && E[2] === C
    })
};

function PerfTopic(J) {
    if (arguments.length == 0) {
        return
    }
    J.name = "PerfTopic";
    this.sets = {
        controllerStatSet: {
            valid: false,
            compTypes: ["controllers"]
        },
        diskStatSet: {
            valid: false,
            compTypes: ["drives", "diskGroups"]
        },
        hostPortStatsSet: {
            valid: false,
            compTypes: ["port"]
        },
        poolStatisticsSet: {
            valid: false,
            compTypes: ["tier-statistics", "pool-statistics"]
        },
        volumeStatSet: {
            valid: false,
            compTypes: ["volumes"]
        }
    };
    this.histMetrics = [{
        value: "total_iops",
        text: strings.perfTopic.totIOPS
    }, {
        value: "read_iops",
        text: strings.perfTopic.readIOPS
    }, {
        value: "write_iops",
        text: strings.perfTopic.writeIOPS
    }, {
        value: "total_bytes_per_sec_numeric",
        text: strings.perfTopic.dataRate
    }, {
        value: "read_bytes_per_sec_numeric",
        text: strings.perfTopic.dataReadRate
    }, {
        value: "write_bytes_per_sec_numeric",
        text: strings.perfTopic.dataWriteRate
    }, {
        value: "number_of_ios",
        text: strings.perfTopic.numOfIO
    }, {
        value: "number_of_reads",
        text: strings.perfTopic.numOfReads
    }, {
        value: "number_of_writes",
        text: strings.perfTopic.numOfWrites
    }, {
        value: "total_data_transferred_numeric",
        text: strings.perfTopic.dataTransfer
    }, {
        value: "data_read_numeric",
        text: strings.perfTopic.dataRead
    }, {
        value: "data_written_numeric",
        text: strings.perfTopic.dataWrite
    }];
    this.diskMetrics = [{
        value: "avg_rsp_time",
        text: strings.perfTopic.avgRespTime
    }, {
        value: "avg_read_rsp_time",
        text: strings.perfTopic.avgRdRespTime
    }, {
        value: "avg_write_rsp_time",
        text: strings.perfTopic.avgWrtRespTime
    }, {
        value: "avg_io_size_numeric",
        text: strings.perfTopic.avgIOSize
    }, {
        value: "avg_read_io_size_numeric",
        text: strings.perfTopic.avgRdIOSize
    }, {
        value: "avg_write_io_size_numeric",
        text: strings.perfTopic.avgWrtIOSize
    }, {
        value: "number_of_disk_errors",
        text: strings.perfTopic.numOfdiskErrs
    }, {
        value: "queue_depth",
        text: strings.perfTopic.qdepth
    }];
    this.poolMetrics = [{
        value: "number_of_allocated_pages",
        text: strings.perfTopic.numAllocPages
    }];
    this.tierMetrics = [{
        value: "number_of_page_moves_in",
        text: strings.perfTopic.numPageMovesIn
    }, {
        value: "number_of_page_moves_out",
        text: strings.perfTopic.numPageMovesOut
    }, {
        value: "number_of_page_rebalances",
        text: strings.perfTopic.numOfPageReb
    }, {
        value: "number_of_initial_allocations",
        text: strings.perfTopic.numOfInitAlloc
    }, {
        value: "number_of_unmaps",
        text: strings.perfTopic.numOfUnmaps
    }, {
        value: "number_of_rfc_copies",
        text: strings.perfTopic.numOfRFCCopies
    }, {
        value: "number_of_zero_pages_reclaimed",
        text: strings.perfTopic.numOfZeroPagesReclaimed
    }];
    this.rcTierMetrics = [{
        value: "number_of_pages_copied",
        text: strings.perfTopic.numOfPagesCopied
    }, {
        value: "number_of_pages_discarded",
        text: strings.perfTopic.numOfPagesDiscarded
    }];
    this.scaleUnits = {
        total_data_transferred_numeric: "B",
        data_read_numeric: "B",
        data_written_numeric: "B",
        total_bytes_per_sec_numeric: "B/s",
        read_bytes_per_sec_numeric: "B/s",
        write_bytes_per_sec_numeric: "B/s",
        number_of_ios: "",
        number_of_reads: "",
        number_of_writes: "",
        total_iops: "IO/s",
        read_iops: "IO/s",
        write_iops: "IO/s",
        avg_rsp_time: strings.microsec,
        avg_read_rsp_time: strings.microsec,
        avg_write_rsp_time: strings.microsec,
        avg_io_size_numeric: "B",
        avg_read_io_size_numeric: "B",
        avg_write_io_size_numeric: "B",
        number_of_disk_errors: "",
        queue_depth: "",
        number_of_allocated_pages: "",
        number_of_hot_pages: "",
        number_of_page_moves_in: "",
        number_of_page_moves_out: "",
        number_of_page_rebalances: "",
        number_of_initial_allocations: "",
        number_of_unmaps: "",
        number_of_rfc_copies: "",
        number_of_zero_pages_reclaimed: "",
        number_of_pages_copied: "",
        number_of_pages_discarded: ""
    };
    var G = {
        iDisplayLength: 17,
        bLengthChange: false,
        bInfo: false,
        bFilter: "noControls"
    };
    var I = {
        iDisplayLength: 17,
        bLengthChange: false,
        bFilter: "noControls"
    };
    var F = createObjectCallback(this, this.selectTable);
    var C = 706;
    var E = {
        iDisplayLength: 8,
        bLengthChange: false,
        bFilter: "noControls"
    };
    var H = ["volume_name", "volume_type"];
    var D = 1;
    if (RI.feature("storageModel") == "HYBRID") {
        H.splice(D, 0, "storage_type")
    }
    this.tablecontainer = new WidgetContainer({
        name: "tableContainer",
        rightMargin: true,
        row: 0,
        col: 0,
        widgets: [new TextWidget({
            name: "compTitle",
            text: strings.perfTopic.components,
            bottomMargin: true,
            classes: "topicSubtitle"
        }), new TextWidget({
            name: "compDescText",
            bottomSmallMargin: true,
            text: strings.perfTopic.selectCompText
        }), new FormWidget({
            name: "componentsForm",
            tableLayout: true,
            widgets: [new OptionInputWidget({
                name: "componentsOption",
                label: strings.perfTopic.showLabel,
                leftMargin: true,
                rightMargin: true,
                labelOptions: {
                    row: 0,
                    col: 0
                },
                row: 0,
                col: 1,
                values: [{
                    value: "drives",
                    text: strings.perfTopic.disks
                }, {
                    value: "diskGroups",
                    text: strings.perfTopic.diskGrps
                }, {
                    value: "pool-statistics",
                    text: strings.perfTopic.strgPoolLabel
                }, {
                    value: "tier-statistics",
                    text: strings.perfTopic.strgTierLabel
                }, {
                    value: "port",
                    text: strings.perfTopic.hostPorts
                }, {
                    value: "controllers",
                    text: strings.perfTopic.controllers
                }, {
                    value: "volumes",
                    text: strings.perfTopic.volumes
                }],
                changeCallback: createObjectCallback(this, this.selectComponentCallback)
            })]
        }), new TableInator({
            name: "perfDriveTable",
            bottomMargin: true,
            topMargin: true,
            selectable: "multiple",
            selectCallback: F,
            dtOptions: I,
            type: "apiData",
            metadata: "drives",
            fields: ["durable_id", "description"],
            columnOverrides: {
                durable_id: {
                    sTitle: strings.ID
                },
                description: {
                    sTitle: strings.Description
                }
            }
        }), new TableInator({
            name: "perfVolumeTable",
            bottomMargin: true,
            topMargin: true,
            selectable: "multiple",
            selectCallback: F,
            dtOptions: I,
            type: "dcCollection",
            metadata: "volumes",
            fields: H,
            columnOverrides: {
                volume_name: {
                    sTitle: strings.Name
                },
                storage_type: {
                    sTitle: strings.storageClass
                },
                volume_type: {
                    sTitle: strings.Type
                }
            },
            criteria: function(L) {
                var K = L.getInt("volume_type_numeric");
                switch (K) {
                    case VOLUME_TYPES.VOLUME:
                    case VOLUME_TYPES.MASTER_VOLUME:
                    case VOLUME_TYPES.BASE:
                    case VOLUME_TYPES.SNAPSHOT:
                    case VOLUME_TYPES.RSR_SOURCE:
                    case VOLUME_TYPES.PAGED_SNAPSHOT:
                    case VOLUME_TYPES.VOLUME_COPY:
                        break;
                    default:
                        return false;
                        break
                }
                return true
            }
        }), new TableInator({
            name: "perfCtrlrTable",
            bottomMargin: true,
            selectable: "multiple",
            selectCallback: F,
            dtOptions: G,
            type: "dcCollection",
            metadata: "controllers",
            fields: ["controller_id", "ip_address"],
            columnOverrides: {
                controller_id: {
                    sTitle: strings.ID
                },
                ip_address: {
                    sTitle: strings.IPAddress
                }
            }
        }), new TableInator({
            name: "perfPortTable",
            bottomMargin: true,
            selectable: "multiple",
            selectCallback: F,
            dtOptions: G,
            type: "dcCollection",
            metadata: "port",
            fields: ["durable_id", "port_type"],
            columnOverrides: {
                durable_id: {
                    sTitle: strings.ID
                },
                port_type: {
                    sTitle: strings.portType
                }
            }
        }), new TableInator({
            name: "diskGrpTable",
            selectable: "single",
            bottomMargin: true,
            topMargin: true,
            selectCallback: F,
            dtOptions: I,
            type: "rawData",
            rawBasetype: "diskGroups",
            metadata: [{
                sTitle: strings.Name,
                bIsKey: true
            }, {
                sTitle: strings.Description
            }, {
                sTitle: strings.perfTopic.NumOfDisks
            }]
        }), new TableInator({
            name: "perfPoolTable",
            selectable: "multiple",
            bottomMargin: true,
            selectCallback: F,
            dtOptions: G,
            type: "dcCollection",
            metadata: "pool-statistics",
            fields: ["pool"],
            columnOverrides: {
                pool: {
                    sTitle: strings.Pool
                }
            }
        }), new TableInator({
            name: "perfTierTable",
            selectable: "multiple",
            bottomMargin: true,
            selectCallback: F,
            dtOptions: $.extend({}, G, {
                aaSorting: [
                    [0, "asc"],
                    [1, "asc"]
                ]
            }),
            type: "dcCollection",
            metadata: "tier-statistics",
            fields: ["pool", "tier"],
            columnOverrides: {
                pool: {
                    sTitle: strings.Pool
                },
                tier: {
                    sTitle: strings.Tier
                }
            }
        }), this.applyBtn = new ButtonContainer({
            name: "applyBtnContainer",
            bottomMargin: true,
            leftMargin: true,
            alignment: "right",
            widgets: [new ButtonWidget({
                name: "applyBtn",
                text: strings.perfTopic.showData,
                classes: "buttonPrimary showDataWidth",
                click: createObjectCallback(this, this.applyCallback)
            })]
        })]
    });
    this.perfContainer = new WidgetContainer({
        name: "perfcontainer",
        leftMargin: true,
        classes: "perfWidth perfRelPos perfHeight perfScrollableContainer",
        widgets: [new WidgetContainer({
            name: "liveContainer",
            classes: "perfLiveContainer perfWidth",
            widgets: [new TextWidget({
                name: "liveTitle",
                text: strings.perfTopic.current,
                bottomMargin: true,
                classes: "topicSubtitle"
            }), new TextWidget({
                name: "perfDescText",
                bottomMargin: true,
                text: strings.perfTopic.livePerfDescr
            }), new TextWidget({
                name: "sampleTimeText",
                label: strings.perfTopic.sampleTime
            }), new TextWidget({
                name: "samplePeriodText",
                label: strings.perfTopic.samplePeriod,
                topSmallMargin: true
            }), new WidgetContainer({
                topMargin: true,
                bottomMargin: true,
                widgets: [new TableInator({
                    name: "driveStatTable",
                    width: C,
                    dtOptions: E,
                    type: "apiData",
                    metadata: "disk-statistics",
                    fields: ["durable_id", "iops", "bytes_per_second", "queue_depth"],
                    columnOverrides: {
                        durable_id: {
                            sTitle: strings.ID
                        },
                        iops: {
                            sTitle: strings.perfTopic.IOPSLabel
                        },
                        bytes_per_second: {
                            sTitle: "B/s",
                            sType: "size"
                        },
                        queue_depth: {
                            sTitle: strings.perfTopic.qdepth
                        }
                    }
                }), new TableInator({
                    name: "portStatTable",
                    width: C,
                    dtOptions: E,
                    type: "apiData",
                    metadata: "host-port-statistics",
                    fields: ["durable_id", "iops", "bytes_per_second", "avg_rsp_time", "avg_read_rsp_time", "avg_write_rsp_time", "queue_depth"],
                    columnOverrides: {
                        durable_id: {
                            sTitle: strings.ID
                        },
                        iops: {
                            sTitle: strings.perfTopic.IOPSLabel
                        },
                        bytes_per_second: {
                            sTitle: "B/s",
                            sType: "size"
                        },
                        avg_rsp_time: {
                            sTitle: strings.perfTopic.ioResp + "<br />(ms)",
                            sType: "numeric"
                        },
                        avg_read_rsp_time: {
                            sTitle: strings.perfTopic.readResp + "<br />(ms)",
                            sType: "numeric"
                        },
                        avg_write_rsp_time: {
                            sTitle: strings.perfTopic.writeResp + "<br />(ms)",
                            sType: "numeric"
                        },
                        queue_depth: {
                            sTitle: strings.perfTopic.qdepth
                        }
                    },
                    intercepts: [{
                        selector: "avg_rsp_time",
                        renderer: this._renderRespTime
                    }, {
                        selector: "avg_read_rsp_time",
                        renderer: this._renderRespTime
                    }, {
                        selector: "avg_write_rsp_time",
                        renderer: this._renderRespTime
                    }]
                }), new TableInator({
                    name: "ctrlrStatTable",
                    width: C,
                    dtOptions: E,
                    type: "apiData",
                    metadata: "controller-statistics",
                    fields: ["durable_id", "cpu_load", "bytes_per_second", "iops", "read_cache_hits", "write_cache_hits"],
                    columnOverrides: {
                        durable_id: {
                            sTitle: strings.ID
                        },
                        bytes_per_second: {
                            sTitle: "B/s",
                            sType: "size"
                        },
                        cpu_load: {
                            sTitle: strings.perfTopic.cpuLoad
                        },
                        iops: {
                            sTitle: strings.perfTopic.IOPSLabel
                        },
                        read_cache_hits: {
                            sTitle: strings.perfTopic.readCacheRatio
                        },
                        write_cache_hits: {
                            sTitle: strings.perfTopic.writeCacheRatio
                        }
                    },
                    intercepts: [{
                        selector: "read_cache_hits",
                        renderer: this.readCacheIntercept
                    }, {
                        selector: "write_cache_hits",
                        renderer: this.writeCacheIntercept
                    }]
                }), new TableInator({
                    name: "volStatTable",
                    width: C,
                    dtOptions: E,
                    classes: "equalColumnWidth",
                    type: "apiData",
                    metadata: "volume-statistics",
                    fields: ["volume_name", "iops", "bytes_per_second", "read_cache_hits", "write_cache_hits", "write_cache_space", "write_cache_percent", "read_ahead_operations", "small_destages", "full_stripe_write_destages"],
                    columnOverrides: {
                        volume_name: {
                            sTitle: strings.Name
                        },
                        iops: {
                            sTitle: strings.perfTopic.IOPSLabel
                        },
                        bytes_per_second: {
                            sTitle: "B/s",
                            sType: "size"
                        },
                        read_cache_hits: {
                            sTitle: strings.perfTopic.readCacheRatio
                        },
                        write_cache_hits: {
                            sTitle: strings.perfTopic.writeCacheRatio
                        }
                    },
                    intercepts: [{
                        selector: "read_cache_hits",
                        renderer: this.readCacheIntercept
                    }, {
                        selector: "write_cache_hits",
                        renderer: this.writeCacheIntercept
                    }],
                    dtOptions: {
                        bFilter: false,
                        iDisplayLength: 10,
                        bLengthChange: true
                    }
                }), new TableInator({
                    name: "poolStatTable",
                    width: C,
                    dtOptions: E,
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.perfTopic.perfPool
                    }, {
                        sTitle: strings.perfTopic.IOPSLabel
                    }, {
                        sTitle: "B/s",
                        sType: "size"
                    }, {
                        sTitle: strings.perfTopic.PagesAllocPerMin
                    }, {
                        sTitle: strings.perfTopic.PagesDeallocPerMin
                    }, {
                        sTitle: strings.perfTopic.PageUnmapsPerMin
                    }]
                }), new TableInator({
                    name: "tierStatTable",
                    width: C,
                    dtOptions: $.extend({}, E, {
                        aaSorting: [
                            [0, "asc"],
                            [1, "asc"]
                        ]
                    }),
                    type: "rawData",
                    metadata: [{
                        sTitle: strings.perfTopic.perfPool
                    }, {
                        sTitle: strings.perfTopic.perfTier
                    }, {
                        sTitle: strings.perfTopic.IOPSLabel
                    }, {
                        sTitle: "B/s",
                        sType: "size"
                    }, {
                        sTitle: strings.perfTopic.PagesAllocPerMin
                    }, {
                        sTitle: strings.perfTopic.PagesDeallocPerMin
                    }, {
                        sTitle: strings.perfTopic.PageUnmapsPerMin
                    }]
                })]
            })]
        }), new FormWidget({
            name: "historicalContainer",
            classes: "perfHistContainer perfWidth",
            rightMargin: true,
            widgets: [this.histOption = new CheckboxInputWidget({
                name: "histOption",
                classes: "topicSubtitle hist",
                labelClasses: "topicSubtitle",
                label: strings.perfTopic.historical,
                value: false,
                changeCallback: createObjectCallback(this, this.histOptionSelected)
            }), new TextWidget({
                name: "perfHistDesc",
                topMargin: true,
                text: strings.perfTopic.histPerfDesc
            }), new TableWidget({
                name: "histContainer",
                classes: "perfWidth",
                widgets: [new TableWidget({
                    row: 0,
                    col: 0,
                    rightMargin: true,
                    widgets: [new TableWidget({
                        row: 0,
                        col: 1,
                        bottomMargin: true,
                        topMargin: true,
                        rightMargin: true,
                        widgets: [new TextWidget({
                            name: "startDateText",
                            row: 0,
                            col: 1,
                            classes: "comboWrapper",
                            leftMargin: true,
                            bottomSmallMargin: true,
                            label: strings.perfTopic.startDate,
                            text: strings.na
                        }), new TextWidget({
                            name: "endDateText",
                            row: 1,
                            col: 1,
                            leftMargin: true,
                            classes: "comboWrapper",
                            label: strings.perfTopic.endDate,
                            text: strings.na
                        })]
                    }), new ButtonContainer({
                        name: "setTimerangeCont",
                        bottomMargin: true,
                        leftMargin: true,
                        topSmallMargin: true,
                        alignment: "left",
                        row: 0,
                        col: 2,
                        widgets: [new ButtonWidget({
                            name: "setTimeRangeBtn",
                            classes: "buttonPrimary",
                            text: strings.perfTopic.setTimeRange,
                            click: createObjectCallback(this, this.setTimeRangeCallback)
                        })]
                    })]
                }), new ProcessingWidget({
                    name: "processingWidget",
                    row: 0,
                    col: 1,
                    leftMargin: true,
                    bottomMargin: true,
                    topMargin: true
                }), new TextWidget({
                    name: "noteText",
                    row: 0,
                    col: 2,
                    bottomMargin: true,
                    topMargin: true,
                    text: strings.perfTopic.noteText
                }), new WidgetContainer({
                    row: 1,
                    col: 0,
                    rightMargin: true,
                    bottomMargin: true,
                    widgets: [new OptionInputWidget({
                        name: "statOptions",
                        rightMargin: true,
                        label: strings.perfTopic.statistics,
                        values: this.histMetrics,
                        changeCallback: createObjectCallback(this, this.selectStats)
                    })]
                }), new WidgetContainer({
                    row: 1,
                    col: 1,
                    classes: "indexPerfPos",
                    widgets: [new CheckboxInputWidget({
                        name: "showIndexOption",
                        label: strings.perfTopic.showIndexLbl,
                        rightMargin: true,
                        value: false,
                        changeCallback: createObjectCallback(this, this.showIndexSelected)
                    })]
                }), this.graphTitle = new TextWidget({
                    name: "graphTitle",
                    row: 2,
                    col: 0,
                    colSpan: 3,
                    topSmallMargin: true,
                    classes: "textCenter textBold"
                }), this.graphWidget = new GraphWidget({
                    name: "graphRate",
                    row: 3,
                    col: 0,
                    colSpan: 3,
                    width: 620,
                    height: 280,
                    graphOptions: {
                        xaxis: {
                            mode: "time",
                            timeformat: "%m/%d%<br />%h:%M"
                        },
                        yaxis: {
                            min: 0
                        }
                    }
                })]
            })]
        })]
    });
    J.widgets = new TableWidget({
        bodyClasses: "verticalTop",
        classes: "center10",
        autoWidth: true,
        widgets: [this.tablecontainer, this.perfContainer]
    });
    TopicPanel.call(this, J);
    this.class_name = "PerfTopic"
}
PerfTopic.prototype = new TopicPanel();
PerfTopic.prototype.constructor = PerfTopic;
PerfTopic.prototype.showing = function() {
    this.showIndexValue = true;
    this.curStatProp = "total_iops";
    this.curStatPropText = strings.perfTopic.totIOPS;
    this.selComponent = "drives";
    this.volSelected = [];
    this.driveSelected = [];
    this.diskGrpSelected = [];
    this.portSelected = [];
    this.ctrlrSelected = [];
    this.strgPoolSelected = [];
    this.strgTierSelected = [];
    this.histSelectedFlag = false;
    this.timeRange = false;
    this.curDiskHistData = [];
    this.curMetrics = [];
    this.curStorageHistData = [];
    var C = {
        processingWidget: {
            visibility: "collapse"
        },
        noteText: {
            visibility: "collapse"
        },
        histContainer: {
            visibility: "collapse"
        },
        perfHistDesc: {
            visibility: "collapse"
        },
        startDateText: {
            text: strings.na
        },
        endDateText: {
            text: strings.na
        },
        statOptions: {
            value: this.curStatProp
        },
        graphTitle: {
            text: this.curStatPropText
        },
        graphRate: {
            graphData: []
        },
        histOption: {
            value: false,
            visibility: "visible"
        },
        portStatTable: {
            visibility: "collapse"
        },
        ctrlrStatTable: {
            visibility: "collapse"
        },
        driveStatTable: {
            visibility: "visible",
            data: []
        },
        volStatTable: {
            visibility: "collapse"
        },
        poolStatTable: {
            visibility: "collapse"
        },
        tierStatTable: {
            visibility: "collapse"
        },
        applyBtn: {
            disable: true
        },
        sampleTimeText: {
            text: ""
        },
        samplePeriodText: {
            text: ""
        },
        showIndexOption: {
            value: true
        },
        componentsOption: {
            value: "drives"
        },
        perfDriveTable: {
            visibility: "visible",
            data: MC.disksSet.data.objects
        },
        perfPortTable: {
            visibility: "collapse",
            data: {}
        },
        perfCtrlrTable: {
            visibility: "collapse",
            data: {}
        },
        perfVolumeTable: {
            visibility: "collapse",
            data: {}
        },
        perfTierTable: {
            visibility: "collapse",
            data: {}
        },
        diskGrpTable: {
            visibility: "collapse",
            data: []
        },
        perfPoolTable: {
            visibility: "collapse",
            data: {}
        }
    };
    this.update(C);
    var D = createObjectCallback(this, this._handleSubscription);
    this.sets.controllerStatSet.valid = false;
    this.sets.diskStatSet.valid = false;
    this.sets.hostPortStatsSet.valid = false;
    this.sets.poolStatisticsSet.valid = false;
    this.sets.volumeStatSet.valid = false;
    this.diskStatSub = MC.diskStatSet.requestData({
        update: true,
        durable: "all",
        requestor: this.class_name,
        handler: D
    });
    this.poolStatSub = MC.poolStatisticsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: D
    });
    this.controllerStatSub = MC.controllerStatSet.requestData({
        update: true,
        durable: "all",
        requestor: this.class_name,
        handler: D
    });
    this.volumeStatSub = MC.volumeStatSet.requestData({
        update: true,
        durable: "all",
        requestor: this.class_name,
        handler: D
    });
    this.hostPortStatsSub = MC.hostPortStatsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: D
    });
    MC.diskStatSet.changeAccess(DataSet.METHOD.POLL, 30);
    MC.controllerStatSet.changeAccess(DataSet.METHOD.POLL, 30);
    MC.volumeStatSet.changeAccess(DataSet.METHOD.POLL, 30)
};
PerfTopic.prototype.hiding = function() {
    MC.diskStatSet.changeAccess(DataSet.METHOD.ONDEMAND);
    MC.controllerStatSet.changeAccess(DataSet.METHOD.ONDEMAND);
    MC.volumeStatSet.changeAccess(DataSet.METHOD.ONDEMAND);
    if (this.diskStatSub) {
        MC.diskStatSet.unregister(this.diskStatSub);
        delete this.diskStatSub
    }
    if (this.poolStatSub) {
        MC.poolStatisticsSet.unregister(this.poolStatSub);
        delete this.poolStatSub
    }
    if (this.controllerStatSub) {
        MC.controllerStatSet.unregister(this.controllerStatSub);
        delete this.controllerStatSub
    }
    if (this.volumeStatSub) {
        MC.volumeStatSet.unregister(this.volumeStatSub);
        delete this.volumeStatSub
    }
    if (this.hostPortStatsStatSub) {
        MC.hostPortStatsStatSet.unregister(this.hostPortStatsStatSub);
        delete this.hostPortStatsStatSub
    }
};
PerfTopic.prototype.selectComponentCallback = function(F) {
    var E = {
        perfDriveTable: {
            visibility: "collapse",
            data: []
        },
        perfPortTable: {
            visibility: "collapse",
            data: {}
        },
        perfCtrlrTable: {
            visibility: "collapse",
            data: {}
        },
        perfVolumeTable: {
            visibility: "collapse",
            data: {}
        },
        perfTierTable: {
            visibility: "collapse",
            data: {}
        },
        diskGrpTable: {
            visibility: "collapse",
            data: []
        },
        perfPoolTable: {
            visibility: "collapse",
            data: {}
        },
        startDateText: {
            text: strings.na
        },
        endDateText: {
            text: strings.na
        },
        portStatTable: {
            visibility: "collapse",
            data: []
        },
        ctrlrStatTable: {
            visibility: "collapse",
            data: []
        },
        driveStatTable: {
            visibility: "collapse",
            data: []
        },
        volStatTable: {
            visibility: "collapse",
            data: []
        },
        poolStatTable: {
            visibility: "collapse",
            data: []
        },
        tierStatTable: {
            visibility: "collapse",
            data: []
        },
        histOption: {
            visibility: "collapse"
        },
        histContainer: {
            visibility: "collapse"
        },
        perfHistDesc: {
            visibility: "collapse"
        },
        sampleTimeText: {
            text: ""
        },
        samplePeriodText: {
            text: ""
        }
    };
    TopicPanel.selection.empty();
    this.selComponent = F.componentsOption.value;
    switch (this.selComponent) {
        case "drives":
            E.perfDriveTable = {
                data: MC.disksSet.data.objects,
                visibility: "visible"
            };
            E.driveStatTable = {
                visibility: "visible",
                data: []
            };
            E.histOption = {
                visibility: "visible"
            };
            if (this.driveSelected.length > 0) {
                E.perfDriveTable.select = this.driveSelected
            }
            $.merge(TopicPanel.selection, this.driveSelected);
            break;
        case "diskGroups":
            var D = MC.enclosuresSet.data.objects;
            var C = this.getDiskGroups();
            E.diskGrpTable = {
                data: C,
                visibility: "visible"
            };
            E.driveStatTable = {
                visibility: "visible",
                data: []
            };
            E.histOption = {
                visibility: "visible"
            };
            if (this.diskGrpSelected.length > 0) {
                E.diskGrpTable.select = this.diskGrpSelected
            }
            $.merge(TopicPanel.selection, this.diskGrpSelected);
            break;
        case "port":
            E.perfPortTable = {
                data: DC.ports,
                visibility: "visible"
            };
            E.portStatTable = {
                visibility: "visible"
            };
            if (this.portSelected.length > 0) {
                E.perfPortTable.select = this.portSelected
            }
            break;
        case "volumes":
            E.perfVolumeTable = {
                data: DC.volumes,
                visibility: "visible"
            };
            E.volStatTable = {
                visibility: "visible"
            };
            if (this.volSelected.length > 0) {
                E.perfVolumeTable.select = this.volSelected
            }
            break;
        case "controllers":
            E.perfCtrlrTable = {
                data: DC.controllers,
                visibility: "visible"
            };
            E.ctrlrStatTable = {
                visibility: "visible"
            };
            if (this.ctrlrSelected.length > 0) {
                E.perfCtrlrTable.select = this.ctrlrSelected
            }
            break;
        case "pool-statistics":
            E.perfPoolTable = {
                data: DC.poolStats,
                visibility: "visible"
            };
            E.poolStatTable = {
                visibility: "visible"
            };
            E.histOption = {
                visibility: "visible"
            };
            if (this.strgPoolSelected.length > 0) {
                E.perfPoolTable.select = this.strgPoolSelected
            }
            $.merge(TopicPanel.selection, this.strgPoolSelected);
            break;
        case "tier-statistics":
            E.perfTierTable = {
                data: DC.tierStatsSerial,
                visibility: "visible"
            };
            E.tierStatTable = {
                visibility: "visible"
            };
            E.histOption = {
                visibility: "visible"
            };
            if (this.strgTierSelected.length > 0) {
                E.perfTierTable.select = this.strgTierSelected
            }
            $.merge(TopicPanel.selection, this.strgTierSelected);
            break;
        default:
            break
    }
    this.update(E);
    this.applyBtn.update({
        applyBtn: {
            disable: true
        }
    });
    $(".perfHeight", this.elements).height(600);
    this.populateLiveData();
    if (this.histSelectedFlag) {
        this.updateHistData()
    }
};
PerfTopic.prototype.getDiskGroups = function() {
    var E = [];
    for (var D in DC.diskGroups) {
        var G = DC.diskGroups[D];
        var F = G.get("storage_type");
        var C = G.get("storage_type_numeric");
        if (C == STORAGE_CLASS.VIRTUAL) {
            F += ": " + G.get("pool") + "-" + G.get("storage_tier")
        } else {
            F += ": " + G.get("preferred_owner")
        }
        E.push([D, F, propertyCount(G.disks)])
    }
    return E
};
PerfTopic.prototype.getDiskGroupDisks = function(E) {
    var C = [];
    var F = DC.diskGroups[E];
    if (F) {
        for (var D in F.disks) {
            C.push(F.disks[D].get("location"))
        }
    }
    return C
};
PerfTopic.prototype.applyCallback = function() {
    var C = this.selected[0].basetype;
    if (C == "drives") {
        this.driveSelected = this.selected;
        $.merge(TopicPanel.selection, this.driveSelected)
    }
    if (C == "diskGroups") {
        this.diskGrpSelected = this.selected;
        $.merge(TopicPanel.selection, this.diskGrpSelected)
    }
    if (C == "pool-statistics") {
        this.strgPoolSelected = this.selected;
        $.merge(TopicPanel.selection, this.strgPoolSelected)
    }
    if (C == "tier-statistics") {
        this.strgTierSelected = this.selected;
        $.merge(TopicPanel.selection, this.strgTierSelected)
    }
    if (C == "volumes") {
        this.volSelected = this.selected
    }
    if (C == "port") {
        this.portSelected = this.selected
    }
    if (C == "controllers") {
        this.ctrlrSelected = this.selected
    }
    this.selected = [];
    this.applyBtn.update({
        applyBtn: {
            disable: true
        }
    });
    this.populateLiveData();
    if (this.histSelectedFlag) {
        this.updateHistData()
    }
};
PerfTopic.prototype._handleSubscription = function(C) {
    if (C) {
        this.sets[C.name].valid = true;
        if (this.sets[C.name].compTypes.find(this.selComponent) != -1) {
            this.populateLiveData()
        }
    }
};
PerfTopic.prototype.setTimeRangeCallback = function() {
    NAV.navTo("PerfTopic", "updatePerf")
};
PerfTopic.prototype.populateLiveData = function() {
    var E = [];
    var C = {};
    var G = {};
    switch (this.selComponent) {
        case "volumes":
            if (this.volSelected.length == 0 || !this.sets.volumeStatSet.valid) {
                return
            }
            C = MC.volumeStatSet.data.objects;
            for (var H = 0; H < this.volSelected.length; H++) {
                for (var F = 0; F < C.length; F++) {
                    if (C[F].get("serial_number") == this.volSelected[H].key) {
                        E.push(C[F])
                    }
                }
            }
            G.volStatTable = {
                data: E
            };
            break;
        case "drives":
            if (this.driveSelected.length == 0 || !this.sets.diskStatSet.valid) {
                return
            }
            C = MC.diskStatSet.data.objects;
            for (var H = 0; H < this.driveSelected.length; H++) {
                for (var F = 0; F < C.length; F++) {
                    if (C[F].get("durable_id") == this.driveSelected[H].key) {
                        E.push(C[F])
                    }
                }
            }
            G.driveStatTable = {
                data: E
            };
            break;
        case "diskGroups":
            if (this.diskGrpSelected.length == 0 || !this.sets.diskStatSet.valid) {
                return
            }
            C = MC.diskStatSet.data.objects;
            var L = this.getDiskGroupDisks(this.diskGrpSelected[0].key);
            for (var H = 0; H < L.length; H++) {
                for (var F = 0; F < C.length; F++) {
                    var P = DC.disks[C[F].get("durable_id")];
                    if (P.get("location") == L[H]) {
                        E.push(C[F])
                    }
                }
            }
            G.driveStatTable = {
                data: E
            };
            break;
        case "port":
            if (this.portSelected.length == 0 || !this.sets.hostPortStatsSet.valid) {
                return
            }
            C = MC.hostPortStatsSet.data.objects;
            for (var H = 0; H < this.portSelected.length; H++) {
                for (var F = 0; F < C.length; F++) {
                    if (C[F].get("durable_id") == this.portSelected[H].key) {
                        E.push(C[F])
                    }
                }
            }
            G.portStatTable = {
                data: E
            };
            break;
        case "controllers":
            if (this.ctrlrSelected.length == 0 || !this.sets.controllerStatSet.valid) {
                return
            }
            C = MC.controllerStatSet.data.objects;
            for (var H = 0; H < this.ctrlrSelected.length; H++) {
                for (var F = 0; F < C.length; F++) {
                    var K = DC.controllersSerial[this.ctrlrSelected[H].key];
                    var J = C[F].get("durable_id");
                    if ((J.split("_"))[1] == K.get("controller_id")) {
                        E.push(C[F])
                    }
                }
            }
            G.ctrlrStatTable = {
                data: E
            };
            break;
        case "tier-statistics":
            if (this.strgTierSelected.length == 0 || !this.sets.poolStatisticsSet.valid) {
                return
            }
            C = DC.tierStatsSerial;
            for (var H = 0; H < this.strgTierSelected.length; H++) {
                var N = this.strgTierSelected[H].getObject();
                var O = N.resettableStats;
                var M = [];
                M.push(N.get("pool"));
                M.push(N.get("tier"));
                M.push(O.get("iops"));
                M.push(O.get("bytes_per_second"));
                M.push(N.get("pages_alloc_per_minute"));
                M.push(N.get("pages_dealloc_per_minute"));
                M.push(N.get("num_pages_unmap_per_minute"));
                E.push(M);
                var D = O.get("time_since_sample") + " " + strings.advSet.seconds
            }
            G.tierStatTable = {
                data: E
            };
            G.samplePeriodText = {
                text: D
            };
            break;
        case "pool-statistics":
            if (this.strgPoolSelected.length == 0 || !this.sets.poolStatisticsSet.valid) {
                return
            }
            C = DC.poolStats;
            for (var H = 0; H < this.strgPoolSelected.length; H++) {
                var N = this.strgPoolSelected[H].getObject();
                var O = N.resettableStats;
                var M = [];
                M.push(N.get("pool"));
                M.push(O.get("iops"));
                M.push(O.get("bytes_per_second"));
                M.push(N.get("pages_alloc_per_minute"));
                M.push(N.get("pages_dealloc_per_minute"));
                M.push(N.get("num_pages_unmap_per_minute"));
                E.push(M);
                var D = O.get("time_since_sample") + " " + strings.advSet.seconds
            }
            G.poolStatTable = {
                data: E
            };
            G.samplePeriodText = {
                text: D
            };
            break;
        default:
            break
    }
    if (E.length > 0) {
        if (E[0] instanceof APIObject) {
            var I = E[0].get("stop_sample_time")
        } else {
            var Q = MC.toISODate(MC.lastDate);
            var I = Q.date + " " + Q.time
        }
        G.sampleTimeText = {
            text: I
        };
        if (G.samplePeriodText == undefined) {
            var I = parseInt(E[0].get("stop_sample_time_numeric")) - parseInt(E[0].get("start_sample_time_numeric"));
            G.samplePeriodText = {
                text: I + " " + strings.advSet.seconds
            }
        }
    }
    this.perfContainer.update(G)
};
PerfTopic.prototype._renderRespTime = function(H) {
    var C = H.oSettings.aoColumns[H.iDataColumn].mDataProp;
    var F = C.split(".");
    var E = H.aData;
    for (var G = 0; G < F.length; G++) {
        E = E[F[G]]
    }
    var D = Math.round(parseInt(E, 10) / 10) / 100;
    return D + " ms"
};
PerfTopic.prototype.updateHistData = function(E) {
    var D = {
        historical: true
    };
    this.timeRange = false;
    switch (this.selComponent) {
        case "drives":
            if (this.driveSelected.length != 0) {
                var H = [];
                for (var F = 0; F < this.driveSelected.length; F++) {
                    var J = DC.disks[this.driveSelected[F].key];
                    disks = J.get("location");
                    H.push(J.get("location"))
                }
                var G = "showDiskStatistics";
                D.disk = H.toString()
            }
            break;
        case "diskGroups":
            if (this.diskGrpSelected.length != 0) {
                var H = [];
                var I = this.diskGrpSelected[0].key.split("_");
                H = this.getDiskGroupDisks(this.diskGrpSelected[0].key);
                var G = "showDiskStatistics";
                D.disk = H.toString()
            }
            break;
        case "tier-statistics":
            if (this.strgTierSelected.length != 0) {
                var G = "showPoolStatistics"
            }
            break;
        case "pool-statistics":
            if (this.strgPoolSelected.length != 0) {
                var G = "showPoolStatistics"
            }
            break;
        default:
            return
    }
    this.curStatProp = "total_iops";
    this.curStatPropText = strings.perfTopic.totIOPS;
    this.perfContainer.update({
        histContainer: {
            visibility: "visible"
        },
        setTimeRangeBtn: {
            disable: true
        },
        showIndexOption: {
            disable: true
        },
        perfHistDesc: {
            visibility: "visible"
        },
        graphRate: {
            graphData: []
        },
        statOptions: {
            values: this.histMetrics,
            value: this.curStatProp,
            disable: true
        }
    });
    if (G != undefined) {
        this.perfContainer.update({
            histOption: {
                value: true
            },
            processingWidget: {
                visibility: "visible"
            },
            noteText: {
                visibility: "collapse"
            },
            startDateText: {
                text: strings.na
            },
            endDateText: {
                text: strings.na
            }
        });
        if (E != undefined) {
            if (E.timeRange) {
                D.timeRange = E.timeRange;
                this.dateRef = E.dateRef;
                this.timeRange = true
            } else {
                if (E.count) {
                    D.count = E.count
                }
            }
            this.histSelectedFlag = true;
            $(".perfHeight", this.elements).height(800);
            var C = this.content$.offset();
            var K = this.histOption.elements$.offset();
            this.content$.scrollTop(K.top - C.top)
        }
        MC[G](D, {
            dialog: false,
            noSuccessDialog: true,
            callback: createObjectCallback(this, this.handleHistData)
        })
    }
};
PerfTopic.prototype.handleHistData = function(O) {
    this.legendCol = 1;
    this.curHistData = [];
    this.labels = [];
    var D;
    var J;
    if (O.success && O.json && O.json.objects.length > 0) {
        var K = O.json.objects;
        switch (this.selComponent) {
            case "drives":
            case "diskGroups":
                this.curMetrics = this.histMetrics.concat(this.diskMetrics);
                for (var G = 0; G < K.length; G++) {
                    if (K[G].objects.length > 0) {
                        this.curHistData.push(K[G].objects);
                        this.labels.push(K[G].getPropertyValue("durable_id"));
                        if (G > 5 && G <= 11) {
                            this.legendCol = 2
                        } else {
                            if (G > 11 && G <= 18) {
                                this.legendCol = 3
                            } else {
                                if (G > 18) {
                                    this.legendCol = 4
                                }
                            }
                        }
                    }
                }
                break;
            case "tier-statistics":
                this.curMetrics = this.histMetrics.concat(this.poolMetrics);
                var C = false;
                var I = false;
                for (var G = 0; G < this.strgTierSelected.length; G++) {
                    for (var E = 0; E < O.json.objects.length; E++) {
                        var F = O.json.objects[E];
                        if (F.basetype == "tier-summary" && F.get("serial_number") == this.strgTierSelected[G].key) {
                            this.curHistData.push(F.objects);
                            this.labels.push(F.get("tier") + "_" + F.get("pool"));
                            if (F.get("tier_numeric") == "8") {
                                C = true
                            } else {
                                I = true
                            }
                        }
                    }
                }
                if (C) {
                    $.merge(this.curMetrics, this.rcTierMetrics)
                }
                if (I) {
                    $.merge(this.curMetrics, this.tierMetrics)
                }
                break;
            case "pool-statistics":
                this.curMetrics = this.histMetrics.concat(this.poolMetrics);
                for (var G = 0; G < this.strgPoolSelected.length; G++) {
                    for (var E = 0; E < O.json.objects.length; E++) {
                        var F = O.json.objects[E];
                        if (F.basetype == "pool-summary" && F.get("serial_number") == this.strgPoolSelected[G].key) {
                            this.curHistData.push(F.objects);
                            this.labels.push(strings.perfTopic.perfPool + " " + F.get("pool"))
                        }
                    }
                }
                break;
            default:
                return
        }
        if (this.curHistData.length <= 0 || this.curHistData[0][0].get("sample_time_numeric") == 0) {
            this.perfContainer.update({
                processingWidget: {
                    visibility: "collapse"
                },
                startDateText: {
                    text: strings.na
                },
                endDateText: {
                    text: strings.na
                },
                setTimeRangeBtn: {
                    disable: false
                }
            });
            ShowActiveDialog({
                type: "error",
                dialogOverride: "true",
                message: strings.perfTopic.novalidData + O.message
            });
            return
        }
        var N = {
            data: this.curHistData,
            prop: this.curStatProp,
            baseUnit: this.scaleUnits[this.curStatProp]
        };
        if (this.showIndexValue) {
            N.labels = this.labels
        }
        var J = this.curHistData[0][0].get("sample_time");
        var D;
        for (var G = this.curHistData[0].length - 1; G >= 0; G--) {
            if (this.curHistData[0][G].get("sample_time_numeric") != 0) {
                if (this.curHistData[0][G].get("sample_time_numeric") > this.curHistData[0][0].get("sample_time_numeric")) {
                    J = this.curHistData[0][G].get("sample_time");
                    D = this.curHistData[0][0].get("sample_time")
                } else {
                    D = this.curHistData[0][G].get("sample_time")
                }
                break
            }
        }
        data = {
            startDateText: {
                text: D
            },
            endDateText: {
                text: J
            },
            processingWidget: {
                visibility: "collapse"
            },
            setTimeRangeBtn: {
                disable: false
            },
            showIndexOption: {
                disable: false
            },
            statOptions: {
                values: this.curMetrics,
                value: this.curStatProp,
                disable: false
            },
            graphRate: {
                graphOptions: {
                    legend: {
                        noColumns: this.legendCol
                    }
                },
                objectGraphData: N
            }
        };
        data.noteText = {
            visibility: "collapse"
        };
        if (this.timeRange) {
            var M = parseInt(this.curHistData[0][0].get("sample_time_numeric")) * 1000;
            var L = this.dateRef - M;
            if (L > 900000) {
                data.noteText = {
                    visibility: "visible"
                }
            }
        }
        this.perfContainer.update(data);
        this.graphTitleUpdate(this.curMetrics)
    } else {
        this.perfContainer.update({
            processingWidget: {
                visibility: "collapse"
            },
            noteText: {
                visibility: "collapse"
            },
            startDateText: {
                text: strings.na
            },
            endDateText: {
                text: strings.na
            },
            setTimeRangeBtn: {
                disable: false
            }
        });
        if (O.success && O.json && O.json.objects.length == 0) {
            var H = "message";
            O.message = strings.perfTopic.noDataFound
        } else {
            var H = "error";
            O.message = strings.perfTopic.failureMsg + O.message
        }
        ShowActiveDialog({
            type: H,
            dialogOverride: "true",
            message: O.message
        })
    }
};
PerfTopic.prototype.graphTitleUpdate = function() {
    var E = {};
    this.graphWidget.retrieve(E);
    var D = this.curStatPropText;
    var C = E.graphRate.scaleUnit;
    if (C != "") {
        D += " (" + C + ")"
    }
    this.graphTitle.update({
        graphTitle: {
            text: D
        }
    })
};
PerfTopic.prototype.histOptionSelected = function(F) {
    var D = {};
    if (F.histOption.value) {
        this.histSelectedFlag = true;
        $(".perfHeight", this.elements).height(800);
        var C = this.content$.offset();
        var E = this.histOption.elements$.offset();
        this.content$.scrollTop(E.top - C.top);
        this.updateHistData()
    } else {
        this.histSelectedFlag = false;
        $(".perfHeight", this.elements).height(600);
        D.histContainer = {
            visibility: "collapse"
        };
        D.perfHistDesc = {
            visibility: "collapse"
        };
        D.noteText = {
            visibility: "collapse"
        };
        this.perfContainer.update(D)
    }
};
PerfTopic.prototype.selectTable = function(C) {
    this.selected = C;
    this.applyBtn.update({
        applyBtn: {
            disable: false
        }
    })
};
PerfTopic.prototype.showIndexSelected = function(D) {
    if (this.curHistData.length == 0) {
        return
    }
    var C = {
        data: this.curHistData,
        prop: this.curStatProp,
        baseUnit: this.scaleUnits[this.curStatProp]
    };
    if (D.showIndexOption.value) {
        this.showIndexValue = true;
        C.labels = this.labels
    } else {
        this.showIndexValue = false
    }
    this.perfContainer.update({
        graphRate: {
            graphOptions: {
                legend: {
                    noColumns: this.legendCol
                }
            },
            objectGraphData: C
        }
    })
};
PerfTopic.prototype.selectStats = function(E) {
    this.curStatProp = E.statOptions.value;
    this.curStatPropText = E.statOptions.textValue;
    var C = {
        data: this.curHistData,
        prop: this.curStatProp,
        baseUnit: this.scaleUnits[this.curStatProp]
    };
    if (this.showIndexValue) {
        C.labels = this.labels
    }
    var D = {
        graphRate: {
            objectGraphData: C
        }
    };
    this.graphWidget.update(D);
    this.graphTitleUpdate(this.curMetrics)
};
PerfTopic.prototype.resetHistStats = function() {
    this.perfContainer.update({
        graphRate: {
            graphData: []
        }
    })
};
PerfTopic.prototype.readCacheIntercept = function(G) {
    var F = parseInt(G.aData.prop.read_cache_hits.text);
    var E = parseInt(G.aData.prop.read_cache_misses.text);
    var D = F + E;
    if (D == 0) {
        return strings.na
    } else {
        var C = (F / D) * 100;
        return C.toFixed(2) + "%"
    }
};
PerfTopic.prototype.writeCacheIntercept = function(G) {
    var D = parseInt(G.aData.prop.write_cache_hits.text);
    var F = parseInt(G.aData.prop.write_cache_misses.text);
    var E = D + F;
    if (E == 0) {
        return strings.na
    } else {
        var C = (D / E) * 100;
        return C.toFixed(2) + "%"
    }
};

function RepsTopic(D) {
    if (arguments.length == 0) {
        return
    }
    D.name = "RepsTopic";
    this.repSetSelected = [];
    this.peerConnectionsSelected = [];
    this.peerConnectionSubscription = {};
    this.repSetSubscription = {};
    var C = [{
        sTitle: "serial_number",
        bVisible: false,
        bIsKey: true
    }, {
        sTitle: strings.repsTopic.namestr
    }, {
        sTitle: strings.repsTopic.conStatus
    }, {
        sTitle: strings.repsTopic.peerConnHealth
    }, {
        sTitle: strings.repsTopic.mediaType
    }, {
        sTitle: strings.repsTopic.localPorts
    }, {
        sTitle: strings.repsTopic.remotePorts
    }];
    D.widgets = new TableWidget({
        maxCols: 1,
        classes: "center10",
        widgets: [new TextWidget({
            name: "peerTitle",
            text: strings.repsTopic.peerConnections,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "repsTopicPeerTable",
            minWidth: 890,
            selectable: "single",
            selectCallback: createObjectCallback(this, this.selectPeerCallback),
            type: "rawData",
            rawBasetype: "peer-connections",
            metadata: C,
            bottomMargin: true,
            hoverPanel: panels.PeerConnectionsHover
        }), new TextWidget({
            name: "repSetTitle",
            text: strings.repsTopic.repSets,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "repsTopicRepSetTable",
            minWidth: 890,
            selectable: "single",
            selectCallback: createObjectCallback(this, this.selectRepSetCallback),
            type: "dcCollection",
            metadata: "cs-replication-set",
            fields: ["name", "primary_volume_name", "secondary_volume_name", "status", "last_success_time", "estimated_time_completion"],
            columnOverrides: {
                name: {
                    sTitle: strings.repsTopic.namestr
                },
                primary_volume_name: {
                    sTitle: strings.repsTopic.primaryVol,
                    bFilterMenu: true
                },
                secondary_volume_name: {
                    sTitle: strings.repsTopic.secondaryVol,
                    bFilterMenu: true
                },
                status: {
                    sTitle: strings.repsTopic.status,
                    bFilterMenu: true
                },
                last_success_time: {
                    sTitle: strings.repsTopic.lastGoodUpdate,
                    bFilterMenu: true
                },
                estimated_time_completion: {
                    sTitle: strings.repsTopic.estCompTime,
                    bFilterMenu: true
                }
            },
            intercepts: [{
                selector: "primary_volume_name",
                renderer: this._localPrimaryVolumeIntercept
            }, {
                selector: "secondary_volume_name",
                renderer: this._localSecondaryVolumeIntercept
            }],
            bottomMargin: true,
            hoverPanel: panels.ReplicationSetsHover
        }), new TextWidget({
            name: "repSetTitle",
            text: strings.repsTopic.repSetSnapHistory,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "repsTopicSnapHistTable",
            minWidth: 890,
            selectable: "single",
            selectCallback: createObjectCallback(this, this.selectSnapCallback),
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "id",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.repsTopic.localSnapName,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.creatDateTime,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.snapData,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.uniqueData,
                bFilterMenu: true
            }],
            bottomMargin: true,
            hoverPanel: panels.SnapshotHover
        })]
    });
    TopicPanel.call(this, D);
    this.class_name = "RepsTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }));
    $(".dataTables_length", this.elements).change(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
RepsTopic.prototype = new TopicPanel();
RepsTopic.prototype.constructor = RepsTopic;
RepsTopic.prototype.showing = function() {
    TopicPanel.selection.empty();
    if (RI.hasFeature("asyncRep")) {
        this.peerConnectionSubscription = MC.peerConnectionsSet.requestData({
            update: false,
            durable: "all",
            requestor: this.className,
            handler: createObjectCallback(this, this._refreshData)
        });
        this.repSetSubscription = MC.virtualReplicationSets.requestData({
            update: false,
            durable: "all",
            requestor: this.className,
            handler: createObjectCallback(this, this._refreshData)
        })
    }
    this.bindContextMenu()
};
RepsTopic.prototype.hiding = function() {
    if (this.peerConnectionSubscription) {
        MC.peerConnectionsSet.unregister(this.peerConnectionsSubscription);
        delete this.peerConnectionSubscription
    }
    if (this.repSetSubscription) {
        MC.virtualReplicationSets.unregister(this.repSetSubscription);
        delete this.repSetSubscription
    }
    this.unBindContextMenu()
};
RepsTopic.prototype._refreshData = function() {
    var D = this.getPeerData();
    var C = {
        repsTopicPeerTable: {
            data: D,
            select: this.peerConnectionsSelected,
            redraw: (D.length ? keepCurrentPage : "")
        },
        repsTopicRepSetTable: {
            data: DC.virtualReplicationSets,
            select: this.repSetSelected,
            redraw: ($.isEmptyObject(DC.virtualReplicationSets) ? "" : keepCurrentPage)
        }
    };
    this.update(C);
    this.populateSnapHistory();
    this._setTopicSelects();
    this.bindContextMenu();
    if (RecoveryManager.waitingForFailover) {
        var E = DC.virtualReplicationSets[RecoveryManager.waitingForFailover];
        if (E.get("status_numeric") == REP_STATUS.FAILEDOVER) {
            RecoveryManager.waitingForFailover = false
        }
    }
};
RepsTopic.prototype.getPeerData = function() {
    var F = [];
    var J = {};
    for (var I in DC.peerConnections) {
        J = DC.peerConnections[I];
        var E = J.get("serial_number");
        var D = J.get("peer_connection_name");
        var G = J.get("connection_status");
        var H = J.get("health");
        var K = J.get("connection_type");
        var C = J.getPortLabelsAddrs(false, true, false);
        var L = J.getPortLabelsAddrs(true, true, false);
        F.push([E, D, G, H, K, C, L])
    }
    return F
};
RepsTopic.prototype.selectPeerCallback = function(C) {
    this.peerConnectionsSelected = C;
    this.repSetSelected = [];
    var D = {
        repsTopicRepSetTable: {
            data: DC.virtualReplicationSets
        }
    };
    this.update(D);
    this._setTopicSelects();
    this.bindContextMenu()
};
RepsTopic.prototype.selectRepSetCallback = function(C) {
    this.repSetSelected = C;
    this._setTopicSelects();
    this.populateSnapHistory()
};
RepsTopic.prototype._setTopicSelects = function() {
    TopicPanel.selection.empty();
    $.merge(TopicPanel.selection, this.peerConnectionsSelected);
    $.merge(TopicPanel.selection, this.repSetSelected)
};
RepsTopic.prototype.populateSnapHistory = function() {
    var F = [];
    for (var D = 0; D < this.repSetSelected.length; D++) {
        var G = this.repSetSelected[D].getObject();
        for (var C = 0; C < G.objects.length; C++) {
            if (G.objects[C] instanceof APICurrentReplicationSnapshots) {
                var E = G.objects[C];
                F.push(["snapshots", E.get("serial_number"), E.get("name"), E.get("creation_date_time"), E.get("snap_data"), E.get("uniquedata")])
            }
        }
    }
    this.update({
        repsTopicSnapHistTable: {
            data: F
        }
    })
};
RepsTopic.prototype.localVolumeIntercept = function(F, D) {
    var G = DC.virtualReplicationSetsSerial[F.aData.prop.serial_number.text];
    var E = G.get((D) ? "primary_volume_name" : "secondary_volume_name");
    if (D == undefined) {
        return E
    }
    if (F.aData && F.aData.prop && F.aData.prop.primary_location_numeric) {
        var C = parseInt(F.aData.prop.primary_location_numeric.text)
    } else {
        return "Bad Intercept"
    }
    if ((D && (C == PRI_VOL_LOCATION.LOCAL)) || (!D && (C == PRI_VOL_LOCATION.REMOTE))) {
        return '<div><span class="repSetLocationStyle repSetLocalVolume">' + E + "</span></div>"
    }
    return '<div><span class="repSetLocationStyle repSetNotLocalVolume">' + E + "</span></div>"
};
RepsTopic.localVolumeIntercept = RepsTopic.prototype.localVolumeIntercept;
RepsTopic.prototype._localPrimaryVolumeIntercept = function(C) {
    return RepsTopic.localVolumeIntercept(C, true)
};
RepsTopic.prototype._localSecondaryVolumeIntercept = function(C) {
    return RepsTopic.localVolumeIntercept(C, false)
};
RepsTopic.prototype._failbackInProgressIntercept = function(C) {
    if (decodeBooleanFlag(C.aData.prop.failback_in_progress_numeric.text)) {
        return strings.Yes
    } else {
        return strings.No
    }
};
RepsTopic.prototype.bindContextMenu = function() {
    $("tr", "#repsTopicPeerTable > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu));
    $("tr", "#repsTopicRepSetTable > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu))
};
RepsTopic.prototype.unBindContextMenu = function() {
    $("tr", "#repsTopicPeerTable > tbody").off("contextmenu");
    $("tr", "#repsTopicRepSetTable > tbody").off("contextmenu");
    panels.contextMenu.close()
};
RepsTopic.prototype.openContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "RepsTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};

function RsrTopic(C) {
    if (arguments.length == 0) {
        return
    }
    C.name = "RsrTopic";
    this.repSetSelected = [];
    this.peerConnectionsSelected = [];
    this.peerConnectionSubscription = {};
    this.repSetSubscription = {};
    C.widgets = new TableWidget({
        maxCols: 1,
        classes: "center10",
        widgets: [new TextWidget({
            name: "remoteSystemsTitle",
            text: strings.repsTopic.remoteSystems,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "remoteSystemsTable",
            minWidth: 890,
            selectable: "single",
            selectCallback: createObjectCallback(this, this.selectSystemCallback),
            type: "dcCollection",
            metadata: "remote-system",
            fields: ["system_name", "system_location", "ip_address_a", "ip_address_b", "status", "last_connected"],
            bottomMargin: true,
            hoverPanel: panels.RemoteSystemHover
        }), new TextWidget({
            name: "repSetTitle",
            text: strings.repsTopic.repSets,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "replicationSetsV2",
            minWidth: 890,
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this.selectRepSetCallback),
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "id",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.repsTopic.repSetName,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.primaryVol,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.secondaryVol,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.peerConnHealth,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.status,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.linkType,
                bFilterMenu: true
            }],
            intercepts: [{
                selector: 3,
                renderer: this._localPrimaryVolumeIntercept
            }, {
                selector: 4,
                renderer: this._localSecondaryVolumeIntercept
            }],
            bottomMargin: true,
            hoverPanel: panels.RsrReplicationSetHover
        }), new TextWidget({
            name: "repImagesTitle",
            text: strings.repsTopic.repImages,
            classes: "topicSubtitle",
            bottomSmallMargin: true
        }), new TableInator({
            name: "replicationImages",
            minWidth: 890,
            selectable: "multiple",
            selectCallback: createObjectCallback(this, this.selectRepImageCallback),
            type: "rawData",
            metadata: [{
                sTitle: "basetype",
                bVisible: false,
                bIsBasetype: true
            }, {
                sTitle: "id",
                bVisible: false,
                bIsKey: true
            }, {
                sTitle: strings.repsTopic.primaryVolSnap,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.secondaryVolSnap,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.status,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.snapshotSize,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.imgSerial,
                bFilterMenu: true
            }, {
                sTitle: strings.repsTopic.startDateTime,
                bFilterMenu: true
            }],
            hoverPanel: panels.ReplicationImageHover
        })]
    });
    TopicPanel.call(this, C);
    this.class_name = "RsrTopic";
    $(".dataTables_paginate", this.elements).click(createObjectCallback(this, function() {
        this.bindContextMenu()
    }))
}
RsrTopic.prototype = new TopicPanel();
RsrTopic.prototype.constructor = RsrTopic;
RsrTopic.prototype.showing = function() {
    TopicPanel.selection.empty();
    this.remoteSystemsSubscription = MC.remoteSystemsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    });
    this.repSetSubscription = MC.replicationSetsSet.requestData({
        update: false,
        durable: "all",
        requestor: this.class_name,
        handler: createObjectCallback(this, this._refreshData)
    })
};
RsrTopic.prototype._refreshData = function(D) {
    var C = {
        remoteSystemsTable: {
            data: DC.remoteSystems,
            select: this.remoteSystemSelected
        },
        replicationSetsV2: {
            data: this.getRepSetData(),
            select: this.repSetsSelected
        }
    };
    this.update(C);
    this._setTopicSelects();
    if (typeof this.repSetsSelected != "undefined" && this.repSetsSelected.length) {
        this.populateReplicationImages()
    }
    this.bindContextMenu()
};
RsrTopic.prototype.getRepSetData = function() {
    var C = [];
    for (var F in DC.repSets) {
        var O = DC.repSets[F];
        var Q = getRepSetInfo(O);
        var E = O.getKeyValue();
        var H = O.basetype;
        var P = O.get("name");
        var K = O.objects[0].get("primary_volume_name");
        var M = O.objects[0].get("name");
        var J = O.objects[0].get("monitor");
        var I = O.objects[0].get("status");
        var N = O.objects[0].get("link_type");
        if (typeof O.objects[1] != "undefined") {
            var L = O.objects[1].get("name");
            if (Q.vol.get("serial_number") == O.objects[1].get("serial_number")) {
                J = O.objects[1].get("monitor");
                I = O.objects[1].get("status");
                N = O.objects[1].get("link_type")
            }
        } else {
            var L = strings.repsTopic.repVolDeleted
        }
        if (K == M) {
            var G = M;
            var D = L
        } else {
            var G = L;
            var D = M
        }
        C.push([H, E, P, G, D, J, I, N])
    }
    return C
};
RsrTopic.prototype.selectRepSetCallback = function(C) {
    this.repSetsSelected = C;
    this._setTopicSelects();
    this.populateReplicationImages();
    this.bindContextMenu()
};
RsrTopic.prototype.selectSystemCallback = function(C) {
    this.remoteSystemSelected = C;
    this._setTopicSelects()
};
RsrTopic.prototype.selectRepImageCallback = function(C) {
    this.repImagesSelected = C;
    this._setTopicSelects()
};
RsrTopic.prototype._setTopicSelects = function() {
    TopicPanel.selection.empty();
    if (typeof this.remoteSystemSelected != "undefined") {
        $.merge(TopicPanel.selection, this.remoteSystemSelected)
    }
    if (typeof this.repSetsSelected != "undefined") {
        $.merge(TopicPanel.selection, this.repSetsSelected)
    }
    if (typeof this.repImagesSelected != "undefined") {
        $.merge(TopicPanel.selection, this.repImagesSelected)
    }
};
RsrTopic.prototype.populateReplicationImages = function() {
    var H = [];
    var I = {};
    var L = function(U) {
        for (var X in U) {
            if (!(X in I)) {
                var W = U[X];
                var R = W.getSourceImage();
                var P = W.getDestImage();
                var S = null;
                if (P != null && P.isLocal()) {
                    S = P
                }
                if (R != null && R.isLocal()) {
                    S = R
                }
                var Q = W.getKeyValue();
                var T = strings.noInfo;
                if (S != null) {
                    Q = S.getKeyValue();
                    T = DC.snapshotsSerial[S.get("snapshot_serial")].get("total_size")
                }
                var V = {
                    basetype: W.basetype,
                    id: Q,
                    status: (P != null ? P.objects[0].get("status") : strings.noInfo),
                    snapSize: T,
                    creationDate: (P != null ? P.objects[0].get("start_time") : strings.noInfo)
                };
                if (R != null) {
                    V.primarySnap = {
                        name: R.get("snapshot_name"),
                        local: R.isLocal()
                    }
                }
                if (P != null) {
                    V.secondarySnap = {
                        name: P.get("snapshot_name"),
                        local: P.isLocal()
                    }
                }
                I[X] = V
            }
        }
    };
    for (var G = 0; G < this.repSetsSelected.length; G++) {
        var M = this.repSetsSelected[G].getObject();
        for (var D = 0; D < M.objects.length; D++) {
            var N = M.objects[D].repImagesSerial;
            L(N)
        }
    }
    var O = jQuery.format('<div><span class="repSetLocationStyle repSetLocalVolume">{0}</span></div>');
    var J = jQuery.format('<div><span class="repSetLocationStyle repSetNotLocalVolume">{0}</span></div>');
    for (imageSerial in I) {
        var K = I[imageSerial];
        if (typeof K.primarySnap != "undefined") {
            if (K.primarySnap.local) {
                var C = O(K.primarySnap.name)
            } else {
                var C = J(K.primarySnap.name)
            }
        } else {
            var C = J(strings.noInfo)
        }
        if (typeof K.secondarySnap != "undefined") {
            if (K.secondarySnap.local) {
                var F = O(K.secondarySnap.name)
            } else {
                var F = J(K.secondarySnap.name)
            }
        } else {
            var F = J(strings.noInfo)
        }
        H.push([K.basetype, K.id, C, F, K.status, K.snapSize, imageSerial, K.creationDate])
    }
    var E = {
        replicationImages: {
            data: H,
            select: this.repImagesSelected
        }
    };
    this.update(E)
};
RsrTopic.localVolumeIntercept = function(G) {
    var H = G.aData[1];
    var E = G.aData[G.iDataColumn];
    var D = false;
    for (var F in DC.volumes) {
        var C = DC.volumes[F];
        if (C.get("volume_name") == E && C.get("replication_set") == H) {
            D = true;
            break
        }
    }
    if (D) {
        return '<div><span class="repSetLocationStyle repSetLocalVolume">' + E + "</span></div>"
    } else {
        return '<div><span class="repSetLocationStyle repSetNotLocalVolume">' + E + "</span></div>"
    }
};
RsrTopic.prototype._localPrimaryVolumeIntercept = function(C) {
    return RsrTopic.localVolumeIntercept(C)
};
RsrTopic.prototype._localSecondaryVolumeIntercept = function(C) {
    return RsrTopic.localVolumeIntercept(C)
};
RsrTopic.prototype.bindContextMenu = function() {
    $("tr", "#remoteSystemsTable > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu));
    $("tr", "#replicationSetsV2 > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu));
    $("tr", "#replicationImages > tbody").off("contextmenu").contextMenu("#contextmenu", createObjectCallback(this, this.openContextMenu))
};
RsrTopic.prototype.openContextMenu = function() {
    panels.contextMenu.open({
        parentObj: this,
        menu: "RsrTopic",
        position: {
            top: 0,
            left: 0
        }
    })
};

function CTKTopic(E) {
    if (arguments.length == 0) {
        return
    }
    var C = [{
        sTitle: "id",
        bIsVisible: false,
        bIsKey: true
    }, {
        sTitle: "Bibendum",
        bFilterMenu: true
    }, {
        sTitle: "Sem",
        editable: "text"
    }, {
        sTitle: "Fusce",
        bFilterMenu: true
    }, {
        sTitle: "Cursus",
        editable: ["Ullamcorpor", "Nibh", "Mattis"]
    }, {
        sTitle: "Epestas"
    }];
    var D = [
        ["one", "Euismod", "Risus", "Venenatis", "Nibh", "Fringilla"],
        ["two", "Tortor", "Euismod", "Consectetur", "Ullamcorpor", "Commodo"],
        ["three", "Elit", "Pellentesque", "Justo", "Mattis", "Ultricies"],
        ["four", "Tortor", "Malesuada", "Justo", "Nibh", "Cras"],
        ["five", "Mattis", "Vehicula", "Condimentum", "Nibh", "Ultricies"],
        ["six", "Dapibus", "Nullam", "Fusce", "Bibendum", "Cursus"]
    ];
    if (!E.name) {
        E.name = "CTKTopic"
    }
    E.title = "Customization Samples";
    E.widgets = [new TextWidget({
        text: "Tabs",
        classes: "topicSubtitle",
        bottomMargin: true
    }), new TabWidget({
        name: "primaryTabs",
        type: "Primary",
        tabs: [{
            name: "tab0",
            label: "Alpha"
        }, {
            name: "tab1",
            label: "Beta"
        }, {
            name: "tab2",
            label: "Gamma"
        }, {
            name: "tab3",
            label: "Disabled",
            disabled: true
        }]
    }), new TextWidget({
        text: "Table",
        classes: "topicSubtitle",
        bottomMargin: true
    }), new TableInator({
        name: "topicSampleTable",
        width: 700,
        editCallback: function() {
            return 1
        },
        type: "rawData",
        dtOptions: {
            aLengthMenu: [
                [3, 10, -1],
                [3, 10, strings.All]
            ]
        },
        displayLength: 3,
        metadata: C,
        data: D,
        bottomMargin: true
    }), new TextWidget({
        text: "Buttons",
        classes: "topicSubtitle",
        bottomMargin: true
    }), new TableWidget({
        name: "buttonTable",
        widgets: [new LabeledWidgetContainer({
            name: "smallButtons",
            row: 0,
            col: 0,
            label: "Small",
            bottomMargin: true,
            rightMargin: true,
            widgets: [new ButtonContainer({
                name: "Buttons",
                size: "large",
                orientation: "horizontal",
                alignment: "left",
                bottomMargin: true,
                widgets: [new ButtonWidget({
                    size: "small",
                    primary: false,
                    text: "Normal",
                    click: function() {
                        MC.debugOutput("smallButton clicked")
                    }
                }), new ButtonWidget({
                    size: "small",
                    primary: true,
                    text: "Primary",
                    click: function() {
                        MC.debugOutput("smallButton clicked")
                    }
                }), new ButtonWidget({
                    disable: true,
                    size: "small",
                    primary: true,
                    text: "Disabled",
                    click: function() {
                        MC.debugOutput("smallButton clicked")
                    }
                })]
            }), new WidgetContainer({
                classes: "clearFloats"
            })]
        }), new LabeledWidgetContainer({
            name: "mediumButtons",
            row: 0,
            col: 1,
            label: "Medium",
            bottomMargin: true,
            rightMargin: true,
            widgets: [new ButtonContainer({
                name: "MrtlButtons",
                size: "medium",
                orientation: "horizontal",
                alignment: "left",
                bottomMargin: true,
                leftMargin: true,
                widgets: [new ButtonWidget({
                    size: "medium",
                    primary: false,
                    text: "Normal",
                    click: function() {
                        MC.debugOutput("mediumButton clicked")
                    }
                }), new ButtonWidget({
                    size: "medium",
                    primary: true,
                    text: "Primary",
                    click: function() {
                        MC.debugOutput("mediumButton clicked")
                    }
                }), new ButtonWidget({
                    disable: true,
                    size: "medium",
                    primary: true,
                    text: "Disabled",
                    click: function() {
                        MC.debugOutput("mediumButton clicked")
                    }
                })]
            }), new WidgetContainer({
                classes: "clearFloats"
            })]
        }), new LabeledWidgetContainer({
            name: "largeButtons",
            row: 0,
            col: 2,
            label: "Large/Standard",
            bottomMargin: true,
            widgets: [new ButtonContainer({
                name: "LrtlButtons",
                size: "large",
                orientation: "horizontal",
                alignment: "left",
                bottomMargin: true,
                leftMargin: true,
                widgets: [new ButtonWidget({
                    size: "large",
                    primary: false,
                    text: "Normal",
                    click: function() {
                        MC.debugOutput("largeButton clicked")
                    }
                }), new ButtonWidget({
                    size: "large",
                    primary: true,
                    text: "Primary",
                    click: function() {
                        MC.debugOutput("largeButton clicked")
                    }
                }), new ButtonWidget({
                    disable: true,
                    size: "large",
                    primary: true,
                    text: "Disabled",
                    click: function() {
                        MC.debugOutput("largeButton clicked")
                    }
                })]
            }), new WidgetContainer({
                classes: "clearFloats"
            })]
        })]
    }), new TextWidget({
        text: "Tip Widgets",
        tip: "This is an example of a tip that would show."
    })];
    TopicPanel.call(this, E);
    this.class_name = "CTKTopic"
}
CTKTopic.prototype = new TopicPanel();
CTKTopic.prototype.constructor = CTKTopic;

function CTKAction(E) {
    if (arguments.length == 0) {
        return
    }
    E.width = 925;
    var C = [{
        sTitle: "id",
        bIsVisible: false,
        bIsKey: true
    }, {
        sTitle: "Bibendum",
        bFilterMenu: true
    }, {
        sTitle: "Sem",
        editable: "text"
    }, {
        sTitle: "Fusce",
        bFilterMenu: true
    }, {
        sTitle: "Cursus",
        editable: ["Ullamcorpor", "Nibh", "Mattis"]
    }, {
        sTitle: "Epestas"
    }];
    var D = [
        ["one", "Euismod", "Risus", "Venenatis", "Nibh", "Fringilla"],
        ["two", "Tortor", "Euismod", "Consectetur", "Ullamcorpor", "Commodo"],
        ["three", "Elit", "Pellentesque", "Justo", "Mattis", "Ultricies"],
        ["four", "Tortor", "Malesuada", "Justo", "Nibh", "Cras"],
        ["five", "Mattis", "Vehicula", "Condimentum", "Nibh", "Ultricies"],
        ["six", "Dapibus", "Nullam", "Fusce", "Bibendum", "Cursus"]
    ];
    if (!E.name) {
        E.name = "CTKAction"
    }
    E.title = "Customization Samples";
    E.widgets = [new WidgetContainer({
        name: "wrapper",
        classes: "nowrap",
        widgets: [new WidgetContainer({
            name: "leftSection",
            classes: "leftSection",
            widgets: [this.navWidget = new VerticalNavigationWidget({
                name: "nav",
                steps: [{
                    name: "completed",
                    label: "Completed Step"
                }, {
                    name: "active",
                    label: "Active Step"
                }, {
                    name: "inactive",
                    label: "Inactive Step"
                }]
            })]
        }), new WidgetContainer({
            name: "widgetSection",
            classes: "recoveryManagerWidgetContainer",
            widgets: [new TextWidget({
                text: "Tabs",
                classes: "actionSubtitle",
                bottomMargin: true
            }), new TabWidget({
                name: "primaryTabs",
                type: "Primary",
                tabs: [{
                    name: "tab0",
                    label: "Alpha"
                }, {
                    name: "tab1",
                    label: "Beta"
                }, {
                    name: "tab2",
                    label: "Gamma"
                }, {
                    name: "tab3",
                    label: "Disabled",
                    disabled: true
                }]
            }), new ContentHorizontalRule({}), new TextWidget({
                text: "Table",
                classes: "actionSubtitle",
                bottomMargin: true
            }), new TableInator({
                name: "actionSampleTable",
                width: 700,
                editCallback: function() {
                    return 1
                },
                type: "rawData",
                dtOptions: {
                    aLengthMenu: [
                        [3, 10, -1],
                        [3, 10, strings.All]
                    ]
                },
                displayLength: 3,
                metadata: C,
                data: D,
                bottomMargin: true
            }), new TextWidget({
                text: "Buttons",
                classes: "actionSubtitle",
                bottomMargin: true
            }), new TableWidget({
                name: "buttonTable",
                widgets: [new LabeledWidgetContainer({
                    name: "smallButtons",
                    row: 0,
                    col: 0,
                    label: "Small",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new ButtonContainer({
                        name: "Buttons",
                        size: "large",
                        orientation: "horizontal",
                        alignment: "left",
                        bottomMargin: true,
                        widgets: [new ButtonWidget({
                            size: "small",
                            primary: false,
                            text: "Normal",
                            click: function() {
                                MC.debugOutput("smallButton clicked")
                            }
                        }), new ButtonWidget({
                            size: "small",
                            primary: true,
                            text: "Primary",
                            click: function() {
                                MC.debugOutput("smallButton clicked")
                            }
                        }), new ButtonWidget({
                            disable: true,
                            size: "small",
                            primary: true,
                            text: "Disabled",
                            click: function() {
                                MC.debugOutput("smallButton clicked")
                            }
                        })]
                    }), new WidgetContainer({
                        classes: "clearFloats"
                    })]
                }), new LabeledWidgetContainer({
                    name: "mediumButtons",
                    row: 0,
                    col: 1,
                    label: "Medium",
                    bottomMargin: true,
                    rightMargin: true,
                    widgets: [new ButtonContainer({
                        name: "MrtlButtons",
                        size: "medium",
                        orientation: "horizontal",
                        alignment: "left",
                        bottomMargin: true,
                        leftMargin: true,
                        widgets: [new ButtonWidget({
                            size: "medium",
                            primary: false,
                            text: "Normal",
                            click: function() {
                                MC.debugOutput("mediumButton clicked")
                            }
                        }), new ButtonWidget({
                            size: "medium",
                            primary: true,
                            text: "Primary",
                            click: function() {
                                MC.debugOutput("mediumButton clicked")
                            }
                        }), new ButtonWidget({
                            disable: true,
                            size: "medium",
                            primary: true,
                            text: "Disabled",
                            click: function() {
                                MC.debugOutput("mediumButton clicked")
                            }
                        })]
                    }), new WidgetContainer({
                        classes: "clearFloats"
                    })]
                }), new LabeledWidgetContainer({
                    name: "largeButtons",
                    row: 0,
                    col: 2,
                    label: "Large/Standard",
                    bottomMargin: true,
                    widgets: [new ButtonContainer({
                        name: "LrtlButtons",
                        size: "large",
                        orientation: "horizontal",
                        alignment: "left",
                        bottomMargin: true,
                        leftMargin: true,
                        widgets: [new ButtonWidget({
                            size: "large",
                            primary: false,
                            text: "Normal",
                            click: function() {
                                MC.debugOutput("largeButton clicked")
                            }
                        }), new ButtonWidget({
                            size: "large",
                            primary: true,
                            text: "Primary",
                            click: function() {
                                MC.debugOutput("largeButton clicked")
                            }
                        }), new ButtonWidget({
                            disable: true,
                            size: "large",
                            primary: true,
                            text: "Disabled",
                            click: function() {
                                MC.debugOutput("largeButton clicked")
                            }
                        })]
                    }), new WidgetContainer({
                        classes: "clearFloats"
                    })]
                })]
            }), new TextWidget({
                text: "Inputs",
                classes: "actionSubtitle",
                bottomMargin: true
            }), new FormWidget({
                name: "TestForm",
                data: {},
                widgets: [new CheckboxContainer({
                    name: "checkboxContainerTest",
                    label: "Checkbox Container",
                    leftMargin: true,
                    value: true,
                    width: "300px",
                    widgets: [new TableWidget({
                        widgets: [new TextWidget({
                            name: "testTextLabel",
                            row: 0,
                            col: 0,
                            colSpan: 4,
                            text: "Uncheck the container to see disabled controls.",
                            singleCell: true,
                            topMargin: true,
                            bottomMargin: true
                        }), new TextInputWidget({
                            name: "testInput",
                            row: 1,
                            col: 1,
                            size: 20,
                            maxLength: 40,
                            label: "Input",
                            bottomMargin: true,
                            leftMargin: true,
                            rightMargin: true
                        }), new ComboBoxWidget({
                            col: 0,
                            row: 2,
                            col: 1,
                            name: "comboBox",
                            label: "Combo",
                            width: 150,
                            bottomMargin: true,
                            leftMargin: true,
                            rightMargin: true,
                            values: [{
                                value: "red",
                                text: "red"
                            }, {
                                value: "white",
                                text: "white"
                            }, {
                                value: "blue",
                                text: "blue"
                            }],
                            value: "white"
                        }), new CheckboxInputWidget({
                            name: "checkBox",
                            row: 1,
                            col: 3,
                            label: "Checkbox",
                            bottomMargin: true,
                            leftMargin: true,
                            value: false
                        }), new RadioButtonsInputWidget({
                            name: "testRadio",
                            row: 2,
                            col: 3,
                            orientation: "horizontal",
                            label: "Radio Buttons",
                            bottomMargin: true,
                            leftMargin: true,
                            value: "Fringilla",
                            values: [{
                                value: "Fringilla",
                                text: "Fringilla"
                            }, {
                                value: "Cras",
                                text: "Cras"
                            }, {
                                value: "Adipiscing",
                                text: "Adipiscing"
                            }]
                        }), new DateInputWidget({
                            name: "dateInput",
                            row: 3,
                            col: 1,
                            label: "Date",
                            bottomMargin: true,
                            leftMargin: true,
                            value: new Date("October 8, 2011 03:45:00"),
                            picker: {
                                minDate: new Date("January 1, 2010 01:01:01")
                            }
                        }), new TimeInputWidget({
                            name: "timeInput",
                            row: 3,
                            col: 3,
                            label: "Time",
                            bottomMargin: true,
                            leftMargin: true,
                            value: new Date("October 8, 2011 03:45:00")
                        })]
                    })]
                })]
            })]
        })]
    })];
    ActionPanel.call(this, E);
    this.class_name = "CTKAction"
}
CTKAction.prototype = new ActionPanel();
CTKAction.prototype.constructor = CTKAction;
CTKAction.prototype.showing = function() {
    this.navWidget.setPrimaryStepActive("active");
    this.navWidget.markPrimaryStepComplete("completed")
};
appLoaded = true;